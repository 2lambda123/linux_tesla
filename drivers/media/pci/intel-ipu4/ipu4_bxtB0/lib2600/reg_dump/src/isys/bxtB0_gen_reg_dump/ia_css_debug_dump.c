/*
* Support for Intel Camera Imaging ISP subsystem.
* Copyright (c) 2010 - 2015, Intel Corporation.
* 
* This program is free software; you can redistribute it and/or modify it
* under the terms and conditions of the GNU General Public License,
* version 2, as published by the Free Software Foundation.
* 
* This program is distributed in the hope it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
* more details.
*/
/* This file is generated, do not edit. */

#include "ia_css_debug_dump.h"

/* generating register dump code */

#define FIELD_VALUE(val, start, end) \
	(((end) == 31 && (start) == 0) ? \
	(val) : (((val) >> (start)) & ((1U << ((end)-(start) + 1)) - 1)))


void ia_css_debug_dump(void) {
	ia_css_debug_dump_mmu_at_system_gpc_mmu_at();
	ia_css_debug_dump_mmu_at_system_mmu1();
	ia_css_debug_dump_mmu_at_system_mmu0();
	ia_css_debug_dump_ctrl_bus_ab_mt_mmu();
	ia_css_debug_dump_ctrl_bus_ab_mt_mipibuf();
	ia_css_debug_dump_ctrl_bus_ab_mt_bus2();
	ia_css_debug_dump_ctrl_bus_ab_mt_dma_ext1();
	ia_css_debug_dump_ctrl_bus_ab_mt_dma_ext0();
	ia_css_debug_dump_ctrl_bus_ab_mt_sp();
	ia_css_debug_dump_ctrl_bus_ab_mt_fw_dma();
	ia_css_debug_dump_ctrl_bus_ab_mt_is_a();
	ia_css_debug_dump_soc_isapf();
	ia_css_debug_dump_socpf();
	ia_css_debug_dump_soc_cio2str();
	ia_css_debug_dump_gp_counter();
	ia_css_debug_dump_pf();
	ia_css_debug_dump_soc_pixel_s2m1();
	ia_css_debug_dump_soc_pixel_s2m0();
	ia_css_debug_dump_str2vec_ack_conv_bayer_1();
	ia_css_debug_dump_str2vec_ack_conv_bayer_0();
	ia_css_debug_dump_str_to_vec_v2_2_isl_bayer_yuv420_4ppc();
	ia_css_debug_dump_str_to_vec_v2_2_isl_bayer_4ppc();
	ia_css_debug_dump_dma();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_StrmScalPifPixOutConv();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_StrmPifPixOutConv();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Acc_Irq_Ctrl();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_isa_gp_reg();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AckConv();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_FF_AF_AWB_FR_GRD_RF();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Stat_AWB_AckConv();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_ff_3a_awb_rgbs_sat_rf();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_ff_3a_awb_rgbs_col_rf();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Stat_AE_AckConv();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_lut();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Bayer_Scaler_AckConv();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_INL();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_INL_ff_inl_evenodd_lut();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_AckConv();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id15();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id14();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id13();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id12();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id11();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id10();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id9();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id8();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id7();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id6();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id5();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id4();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id3();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id2();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id1();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id0();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_GBL();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch3();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch2();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch1();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch0();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Bayer_Lsc_AckConv();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch3();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch2();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch1();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch0();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_ff_gddpc_afpix();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_ff_gddpc_dplut_set1();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_ff_gddpc_dplut_set0();
	ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Bayer_Dpc_AckConv();
	ia_css_debug_dump_trace_unit();
	ia_css_debug_dump_c_gpio();
	ia_css_debug_dump_gpreg_srst();
	ia_css_debug_dump_irq_ctrl();
	ia_css_debug_dump_master_gate_ciogate_mt2();
	ia_css_debug_dump_master_gate_ciogate_mt1();
	ia_css_debug_dump_master_gate_ciogate_mt0();
	ia_css_debug_dump_pma_if();
	ia_css_debug_dump_gda();
	ia_css_debug_dump_fw_dma_eqc();
	ia_css_debug_dump_fw_dma_dma();
	ia_css_debug_dump_gpr_3();
	ia_css_debug_dump_irq_ctrl0_3();
	ia_css_debug_dump_irq_ctrl_3();
	ia_css_debug_dump_cphy_rx_3();
	ia_css_debug_dump_gpr_2();
	ia_css_debug_dump_irq_ctrl0_2();
	ia_css_debug_dump_irq_ctrl_2();
	ia_css_debug_dump_cphy_rx_2();
	ia_css_debug_dump_gpr_1();
	ia_css_debug_dump_irq_ctrl0_1();
	ia_css_debug_dump_irq_ctrl_1();
	ia_css_debug_dump_cphy_rx_1();
	ia_css_debug_dump_gpr_0();
	ia_css_debug_dump_irq_ctrl0_0();
	ia_css_debug_dump_irq_ctrl_0();
	ia_css_debug_dump_cphy_rx_0();
	ia_css_debug_dump_tm();
	ia_css_debug_dump_eqc();
	ia_css_debug_dump_gpreg();
	ia_css_debug_dump_gpr_d();
	ia_css_debug_dump_irq_ctrl1_d();
	ia_css_debug_dump_irq_ctrl0_d();
	ia_css_debug_dump_irq_ctrl_d();
	ia_css_debug_dump_csi_rx_d();
	ia_css_debug_dump_gpr_c();
	ia_css_debug_dump_irq_ctrl1_c();
	ia_css_debug_dump_irq_ctrl0_c();
	ia_css_debug_dump_irq_ctrl_c();
	ia_css_debug_dump_csi_rx_c();
	ia_css_debug_dump_gpr_b();
	ia_css_debug_dump_irq_ctrl1_b();
	ia_css_debug_dump_irq_ctrl0_b();
	ia_css_debug_dump_irq_ctrl_b();
	ia_css_debug_dump_csi_rx_b();
	ia_css_debug_dump_mipi_pkt_gen0();
	ia_css_debug_dump_gpr_a();
	ia_css_debug_dump_irq_ctrl1_a();
	ia_css_debug_dump_irq_ctrl0_a();
	ia_css_debug_dump_irq_ctrl_a();
	ia_css_debug_dump_csi_rx_a();
	ia_css_debug_dump_ibuf_ctrl();
	ia_css_debug_dump_sp_control_tile_evq();
	ia_css_debug_dump_sp_control_tile_gpc();
	ia_css_debug_dump_sp_control_tile_sp();
} /* end ia_css_debug_dump(void) */

/* Generated Debug Code: Device mmu_at_system_gpc_mmu_at */
void ia_css_debug_dump_mmu_at_system_gpc_mmu_at(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xe0bbc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_irq_enable_reg_3              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_irq_enable_reg_3_type */
	/* skip, unused field unused_gpc_irq_enable_reg_3 (gpc_irq_enable_reg_3) */
	REG_DUMP_PRINT_1("   -gpc_irq_enable_reg_3.gpc_irq_enable_reg_3                |         0x%01X  |  [RW][00:00]""Enable trigger 3 and sticky bits""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xe0bb8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_irq_enable_reg_2              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_irq_enable_reg_2_type */
	/* skip, unused field unused_gpc_irq_enable_reg_2 (gpc_irq_enable_reg_2) */
	REG_DUMP_PRINT_1("   -gpc_irq_enable_reg_2.gpc_irq_enable_reg_2                |         0x%01X  |  [RW][00:00]""Enable trigger 2 and sticky bits""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xe0bb4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_irq_enable_reg_1              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_irq_enable_reg_1_type */
	/* skip, unused field unused_gpc_irq_enable_reg_1 (gpc_irq_enable_reg_1) */
	REG_DUMP_PRINT_1("   -gpc_irq_enable_reg_1.gpc_irq_enable_reg_1                |         0x%01X  |  [RW][00:00]""Enable trigger 1 and sticky bits""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xe0bb0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_irq_enable_reg_0              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_irq_enable_reg_0_type */
	/* skip, unused field unused_gpc_irq_enable_reg_0 (gpc_irq_enable_reg_0) */
	REG_DUMP_PRINT_1("   -gpc_irq_enable_reg_0.gpc_irq_enable_reg_0                |         0x%01X  |  [RW][00:00]""Enable trigger 0 and sticky bits""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xe0bac);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_irq_timer_sel_reg_3           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_irq_timer_sel_reg_3_type */
	/* skip, unused field unused_gpc_irq_timer_sel_reg_3 (gpc_irq_timer_sel_reg_3) */
	REG_DUMP_PRINT_1("   -gpc_irq_timer_sel_reg_3.gpc_irq_timer_sel_reg_3          |         0x%01X  |  [RW][01:00]""Selects which counter to be used for matching for trigger 3""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xe0ba8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_irq_timer_sel_reg_2           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_irq_timer_sel_reg_2_type */
	/* skip, unused field unused_gpc_irq_timer_sel_reg_2 (gpc_irq_timer_sel_reg_2) */
	REG_DUMP_PRINT_1("   -gpc_irq_timer_sel_reg_2.gpc_irq_timer_sel_reg_2          |         0x%01X  |  [RW][01:00]""Selects which counter to be used for matching for trigger 2""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xe0ba4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_irq_timer_sel_reg_1           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_irq_timer_sel_reg_1_type */
	/* skip, unused field unused_gpc_irq_timer_sel_reg_1 (gpc_irq_timer_sel_reg_1) */
	REG_DUMP_PRINT_1("   -gpc_irq_timer_sel_reg_1.gpc_irq_timer_sel_reg_1          |         0x%01X  |  [RW][01:00]""Selects which counter to be used for matching for trigger 1""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xe0ba0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_irq_timer_sel_reg_0           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_irq_timer_sel_reg_0_type */
	/* skip, unused field unused_gpc_irq_timer_sel_reg_0 (gpc_irq_timer_sel_reg_0) */
	REG_DUMP_PRINT_1("   -gpc_irq_timer_sel_reg_0.gpc_irq_timer_sel_reg_0          |         0x%01X  |  [RW][01:00]""Selects which counter to be used for matching for trigger 0""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xe0b9c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_irq_trigger_value_reg_3       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_irq_trigger_value_reg_3_type */
	REG_DUMP_PRINT_1("   -gpc_irq_trigger_value_reg_3.gpc_irq_trigger_value_reg_3  |  0x%08X  |  [RW][31:00]""The reference value that is used for comparisson and trigger 3 generation""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xe0b98);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_irq_trigger_value_reg_2       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_irq_trigger_value_reg_2_type */
	REG_DUMP_PRINT_1("   -gpc_irq_trigger_value_reg_2.gpc_irq_trigger_value_reg_2  |  0x%08X  |  [RW][31:00]""The reference value that is used for comparisson and trigger 2 generation""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xe0b94);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_irq_trigger_value_reg_1       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_irq_trigger_value_reg_1_type */
	REG_DUMP_PRINT_1("   -gpc_irq_trigger_value_reg_1.gpc_irq_trigger_value_reg_1  |  0x%08X  |  [RW][31:00]""The reference value that is used for comparisson and trigger 1 generation""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xe0b90);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_irq_trigger_value_reg_0       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_irq_trigger_value_reg_0_type */
	REG_DUMP_PRINT_1("   -gpc_irq_trigger_value_reg_0.gpc_irq_trigger_value_reg_0  |  0x%08X  |  [RW][31:00]""The reference value that is used for comparisson and trigger 0 generation""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xe0b8c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_trace_pload_sel_reg_3         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_trace_pload_sel_reg_3_type */
	/* skip, unused field unused_gpc_trace_pload_sel_reg_3 (gpc_trace_pload_sel_reg_3) */
	REG_DUMP_PRINT_1("   -gpc_trace_pload_sel_reg_3.gpc_trace_pload_sel_reg_3      |         0x%01X  |  [RW][01:00]""GPC payload selection for counter 3""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xe0b88);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_trace_pload_sel_reg_2         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_trace_pload_sel_reg_2_type */
	/* skip, unused field unused_gpc_trace_pload_sel_reg_2 (gpc_trace_pload_sel_reg_2) */
	REG_DUMP_PRINT_1("   -gpc_trace_pload_sel_reg_2.gpc_trace_pload_sel_reg_2      |         0x%01X  |  [RW][01:00]""GPC payload selection for counter 2""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xe0b84);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_trace_pload_sel_reg_1         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_trace_pload_sel_reg_1_type */
	/* skip, unused field unused_gpc_trace_pload_sel_reg_1 (gpc_trace_pload_sel_reg_1) */
	REG_DUMP_PRINT_1("   -gpc_trace_pload_sel_reg_1.gpc_trace_pload_sel_reg_1      |         0x%01X  |  [RW][01:00]""GPC payload selection for counter 1""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xe0b80);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_trace_pload_sel_reg_0         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_trace_pload_sel_reg_0_type */
	/* skip, unused field unused_gpc_trace_pload_sel_reg_0 (gpc_trace_pload_sel_reg_0) */
	REG_DUMP_PRINT_1("   -gpc_trace_pload_sel_reg_0.gpc_trace_pload_sel_reg_0      |         0x%01X  |  [RW][01:00]""GPC payload selection for counter 0""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xe0b7c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_trace_msg_sel_reg_3           |  0x%08X  |  ""GPC message selection for counter 3""\n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_trace_msg_sel_reg_3_type */
	/* skip, unused field unused_gpc_trace_msg_sel_reg_3 (gpc_trace_msg_sel_reg_3) */
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_3.SrcSel                           |         0x%01X  |  [RW][03:00]""Select input / output""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_3.RoutSel                          |         0x%01X  |  [RW][05:04]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_3.SensSel                          |         0x%01X  |  [RW][07:06]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 6, 7));
	val = REG_DUMP_READ_REGISTER(0xe0b78);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_trace_msg_sel_reg_2           |  0x%08X  |  ""GPC message selection for counter 2""\n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_trace_msg_sel_reg_2_type */
	/* skip, unused field unused_gpc_trace_msg_sel_reg_2 (gpc_trace_msg_sel_reg_2) */
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_2.SrcSel                           |         0x%01X  |  [RW][03:00]""Select input / output""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_2.RoutSel                          |         0x%01X  |  [RW][05:04]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_2.SensSel                          |         0x%01X  |  [RW][07:06]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 6, 7));
	val = REG_DUMP_READ_REGISTER(0xe0b74);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_trace_msg_sel_reg_1           |  0x%08X  |  ""GPC message selection for counter 1""\n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_trace_msg_sel_reg_1_type */
	/* skip, unused field unused_gpc_trace_msg_sel_reg_1 (gpc_trace_msg_sel_reg_1) */
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_1.SrcSel                           |         0x%01X  |  [RW][03:00]""Select input / output""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_1.RoutSel                          |         0x%01X  |  [RW][05:04]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_1.SensSel                          |         0x%01X  |  [RW][07:06]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 6, 7));
	val = REG_DUMP_READ_REGISTER(0xe0b70);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_trace_msg_sel_reg_0           |  0x%08X  |  ""GPC message selection for counter 0""\n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_trace_msg_sel_reg_0_type */
	/* skip, unused field unused_gpc_trace_msg_sel_reg_0 (gpc_trace_msg_sel_reg_0) */
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_0.SrcSel                           |         0x%01X  |  [RW][03:00]""Select input / output""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_0.RoutSel                          |         0x%01X  |  [RW][05:04]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_0.SensSel                          |         0x%01X  |  [RW][07:06]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 6, 7));
	val = REG_DUMP_READ_REGISTER(0xe0b6c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_trace_stop_sel_reg_3          |  0x%08X  |  ""GPC stop selection for counter 3""\n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_trace_stop_sel_reg_3_type */
	/* skip, unused field unused_gpc_trace_stop_sel_reg_3 (gpc_trace_stop_sel_reg_3) */
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_3.SrcSel                          |         0x%01X  |  [RW][03:00]""Select input / output""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_3.RoutSel                         |         0x%01X  |  [RW][05:04]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_3.SensSel                         |         0x%01X  |  [RW][07:06]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 6, 7));
	val = REG_DUMP_READ_REGISTER(0xe0b68);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_trace_stop_sel_reg_2          |  0x%08X  |  ""GPC stop selection for counter 2""\n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_trace_stop_sel_reg_2_type */
	/* skip, unused field unused_gpc_trace_stop_sel_reg_2 (gpc_trace_stop_sel_reg_2) */
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_2.SrcSel                          |         0x%01X  |  [RW][03:00]""Select input / output""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_2.RoutSel                         |         0x%01X  |  [RW][05:04]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_2.SensSel                         |         0x%01X  |  [RW][07:06]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 6, 7));
	val = REG_DUMP_READ_REGISTER(0xe0b64);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_trace_stop_sel_reg_1          |  0x%08X  |  ""GPC stop selection for counter 1""\n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_trace_stop_sel_reg_1_type */
	/* skip, unused field unused_gpc_trace_stop_sel_reg_1 (gpc_trace_stop_sel_reg_1) */
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_1.SrcSel                          |         0x%01X  |  [RW][03:00]""Select input / output""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_1.RoutSel                         |         0x%01X  |  [RW][05:04]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_1.SensSel                         |         0x%01X  |  [RW][07:06]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 6, 7));
	val = REG_DUMP_READ_REGISTER(0xe0b60);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_trace_stop_sel_reg_0          |  0x%08X  |  ""GPC stop selection for counter 0""\n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_trace_stop_sel_reg_0_type */
	/* skip, unused field unused_gpc_trace_stop_sel_reg_0 (gpc_trace_stop_sel_reg_0) */
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_0.SrcSel                          |         0x%01X  |  [RW][03:00]""Select input / output""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_0.RoutSel                         |         0x%01X  |  [RW][05:04]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_0.SensSel                         |         0x%01X  |  [RW][07:06]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 6, 7));
	val = REG_DUMP_READ_REGISTER(0xe0b5c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_trace_start_sel_reg_3         |  0x%08X  |  ""GPC start selection for counter 3""\n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_trace_start_sel_reg_3_type */
	/* skip, unused field unused_gpc_trace_start_sel_reg_3 (gpc_trace_start_sel_reg_3) */
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_3.SrcSel                         |         0x%01X  |  [RW][03:00]""Select input / output""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_3.RoutSel                        |         0x%01X  |  [RW][05:04]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_3.SensSel                        |         0x%01X  |  [RW][07:06]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 6, 7));
	val = REG_DUMP_READ_REGISTER(0xe0b58);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_trace_start_sel_reg_2         |  0x%08X  |  ""GPC start selection for counter 2""\n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_trace_start_sel_reg_2_type */
	/* skip, unused field unused_gpc_trace_start_sel_reg_2 (gpc_trace_start_sel_reg_2) */
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_2.SrcSel                         |         0x%01X  |  [RW][03:00]""Select input / output""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_2.RoutSel                        |         0x%01X  |  [RW][05:04]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_2.SensSel                        |         0x%01X  |  [RW][07:06]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 6, 7));
	val = REG_DUMP_READ_REGISTER(0xe0b54);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_trace_start_sel_reg_1         |  0x%08X  |  ""GPC start selection for counter 1""\n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_trace_start_sel_reg_1_type */
	/* skip, unused field unused_gpc_trace_start_sel_reg_1 (gpc_trace_start_sel_reg_1) */
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_1.SrcSel                         |         0x%01X  |  [RW][03:00]""Select input / output""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_1.RoutSel                        |         0x%01X  |  [RW][05:04]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_1.SensSel                        |         0x%01X  |  [RW][07:06]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 6, 7));
	val = REG_DUMP_READ_REGISTER(0xe0b50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_trace_start_sel_reg_0         |  0x%08X  |  ""GPC start selection for counter 0""\n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_trace_start_sel_reg_0_type */
	/* skip, unused field unused_gpc_trace_start_sel_reg_0 (gpc_trace_start_sel_reg_0) */
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_0.SrcSel                         |         0x%01X  |  [RW][03:00]""Select input / output""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_0.RoutSel                        |         0x%01X  |  [RW][05:04]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_0.SensSel                        |         0x%01X  |  [RW][07:06]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 6, 7));
	val = REG_DUMP_READ_REGISTER(0xe0b4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_trace_input_sel_reg_3         |  0x%08X  |  ""GPC input selection for counter 3""\n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_trace_input_sel_reg_3_type */
	/* skip, unused field unused_gpc_trace_input_sel_reg_3 (gpc_trace_input_sel_reg_3) */
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_3.SrcSel                         |         0x%01X  |  [RW][03:00]""Select input / output""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_3.RoutSel                        |         0x%01X  |  [RW][05:04]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_3.SensSel                        |         0x%01X  |  [RW][07:06]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 6, 7));
	val = REG_DUMP_READ_REGISTER(0xe0b48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_trace_input_sel_reg_2         |  0x%08X  |  ""GPC input selection for counter 2""\n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_trace_input_sel_reg_2_type */
	/* skip, unused field unused_gpc_trace_input_sel_reg_2 (gpc_trace_input_sel_reg_2) */
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_2.SrcSel                         |         0x%01X  |  [RW][03:00]""Select input / output""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_2.RoutSel                        |         0x%01X  |  [RW][05:04]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_2.SensSel                        |         0x%01X  |  [RW][07:06]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 6, 7));
	val = REG_DUMP_READ_REGISTER(0xe0b44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_trace_input_sel_reg_1         |  0x%08X  |  ""GPC input selection for counter 1""\n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_trace_input_sel_reg_1_type */
	/* skip, unused field unused_gpc_trace_input_sel_reg_1 (gpc_trace_input_sel_reg_1) */
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_1.SrcSel                         |         0x%01X  |  [RW][03:00]""Select input / output""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_1.RoutSel                        |         0x%01X  |  [RW][05:04]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_1.SensSel                        |         0x%01X  |  [RW][07:06]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 6, 7));
	val = REG_DUMP_READ_REGISTER(0xe0b40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_trace_input_sel_reg_0         |  0x%08X  |  ""GPC input selection for counter 0""\n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_trace_input_sel_reg_0_type */
	/* skip, unused field unused_gpc_trace_input_sel_reg_0 (gpc_trace_input_sel_reg_0) */
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_0.SrcSel                         |         0x%01X  |  [RW][03:00]""Select input / output""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_0.RoutSel                        |         0x%01X  |  [RW][05:04]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_0.SensSel                        |         0x%01X  |  [RW][07:06]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 6, 7));
	val = REG_DUMP_READ_REGISTER(0xe0b3c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_value_reg_3                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_value_reg_3_type */
	REG_DUMP_PRINT_1("   -gpc_value_reg_3.gpc_value_reg_3                          |  0x%08X  |  [RO][31:00]""GPC current value of counter 3""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xe0b38);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_value_reg_2                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_value_reg_2_type */
	REG_DUMP_PRINT_1("   -gpc_value_reg_2.gpc_value_reg_2                          |  0x%08X  |  [RO][31:00]""GPC current value of counter 2""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xe0b34);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_value_reg_1                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_value_reg_1_type */
	REG_DUMP_PRINT_1("   -gpc_value_reg_1.gpc_value_reg_1                          |  0x%08X  |  [RO][31:00]""GPC current value of counter 1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xe0b30);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_value_reg_0                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_value_reg_0_type */
	REG_DUMP_PRINT_1("   -gpc_value_reg_0.gpc_value_reg_0                          |  0x%08X  |  [RO][31:00]""GPC current value of counter 0""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xe0b2c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_enable_reg_3                  |  0x%08X  |  ""GPC counter 3 enable""\n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_enable_reg_3_type */
	/* skip, unused field unused_gpc_enable_reg_3 (gpc_enable_reg_3) */
	REG_DUMP_PRINT_1("   -gpc_enable_reg_3.Enable                                  |         0x%01X  |  [RW][00:00]""When 0 counter is enabled, when 1 counter is enabled""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -gpc_enable_reg_3.Halt                                    |         0x%01X  |  [RW][01:01]""When 0 counter will wrap around, when 1 counter will halt""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -gpc_enable_reg_3.Reset_on_match                          |         0x%01X  |  [RW][02:02]""When 0 counter is not modified, when 1 counter reset on match""\n", FIELD_VALUE(val, 2, 2));
	val = REG_DUMP_READ_REGISTER(0xe0b28);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_enable_reg_2                  |  0x%08X  |  ""GPC counter 2 enable""\n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_enable_reg_2_type */
	/* skip, unused field unused_gpc_enable_reg_2 (gpc_enable_reg_2) */
	REG_DUMP_PRINT_1("   -gpc_enable_reg_2.Enable                                  |         0x%01X  |  [RW][00:00]""When 0 counter is enabled, when 1 counter is enabled""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -gpc_enable_reg_2.Halt                                    |         0x%01X  |  [RW][01:01]""When 0 counter will wrap around, when 1 counter will halt""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -gpc_enable_reg_2.Reset_on_match                          |         0x%01X  |  [RW][02:02]""When 0 counter is not modified, when 1 counter reset on match""\n", FIELD_VALUE(val, 2, 2));
	val = REG_DUMP_READ_REGISTER(0xe0b24);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_enable_reg_1                  |  0x%08X  |  ""GPC counter 1 enable""\n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_enable_reg_1_type */
	/* skip, unused field unused_gpc_enable_reg_1 (gpc_enable_reg_1) */
	REG_DUMP_PRINT_1("   -gpc_enable_reg_1.Enable                                  |         0x%01X  |  [RW][00:00]""When 0 counter is enabled, when 1 counter is enabled""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -gpc_enable_reg_1.Halt                                    |         0x%01X  |  [RW][01:01]""When 0 counter will wrap around, when 1 counter will halt""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -gpc_enable_reg_1.Reset_on_match                          |         0x%01X  |  [RW][02:02]""When 0 counter is not modified, when 1 counter reset on match""\n", FIELD_VALUE(val, 2, 2));
	val = REG_DUMP_READ_REGISTER(0xe0b20);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_enable_reg_0                  |  0x%08X  |  ""GPC counter 0 enable""\n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_enable_reg_0_type */
	/* skip, unused field unused_gpc_enable_reg_0 (gpc_enable_reg_0) */
	REG_DUMP_PRINT_1("   -gpc_enable_reg_0.Enable                                  |         0x%01X  |  [RW][00:00]""When 0 counter is enabled, when 1 counter is enabled""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -gpc_enable_reg_0.Halt                                    |         0x%01X  |  [RW][01:01]""When 0 counter will wrap around, when 1 counter will halt""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -gpc_enable_reg_0.Reset_on_match                          |         0x%01X  |  [RW][02:02]""When 0 counter is not modified, when 1 counter reset on match""\n", FIELD_VALUE(val, 2, 2));
	val = REG_DUMP_READ_REGISTER(0xe0b1c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_lost_packets_reg              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_lost_packets_reg_type */
	/* skip, unused field unused_gpc_lost_packets_reg (gpc_lost_packets_reg) */
	REG_DUMP_PRINT_1("   -gpc_lost_packets_reg.gpc_lost_packets_reg                |      0x%04X  |  [RO][15:00]""Tracks number of lost packets in acase of lossy tracing.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xe0b14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_trace_enable_ddr_reg          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_trace_enable_ddr_reg_type */
	/* skip, unused field unused_gpc_trace_enable_ddr_reg (gpc_trace_enable_ddr_reg) */
	REG_DUMP_PRINT_1("   -gpc_trace_enable_ddr_reg.gpc_trace_enable_ddr_reg        |         0x%01X  |  [RW][03:00]""Individual trace enable for tracing to DDR""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xe0b10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_trace_enable_npk_reg          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_trace_enable_npk_reg_type */
	/* skip, unused field unused_gpc_trace_enable_npk_reg (gpc_trace_enable_npk_reg) */
	REG_DUMP_PRINT_1("   -gpc_trace_enable_npk_reg.gpc_trace_enable_npk_reg        |         0x%01X  |  [RW][03:00]""Individual trace enable for tracing to NPK.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xe0b0c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_trace_addr_reg                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_trace_addr_reg_type */
	REG_DUMP_PRINT_1("   -gpc_trace_addr_reg.gpc_trace_addr_reg                    |  0x%08X  |  [RW][31:00]""Address to which all trace packet are sent.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xe0b08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_trace_header_reg              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_trace_header_reg_type */
	/* skip, unused field unused_gpc_trace_header_reg (gpc_trace_header_reg) */
	REG_DUMP_PRINT_1("   -gpc_trace_header_reg.gpc_trace_header_reg                |        0x%02X  |  [RW][07:00]""SVEN header""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xe0b04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_gpc_mmu_at.gpc_overall_enable_reg            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_gpc_mmu_at_gpc_overall_enable_reg_type */
	/* skip, unused field unused_gpc_overall_enable_reg (gpc_overall_enable_reg) */
	REG_DUMP_PRINT_1("   -gpc_overall_enable_reg.gpc_overall_enable_reg            |         0x%01X  |  [RW][00:00]""Overall enable all the counters""\n", FIELD_VALUE(val, 0, 0));
} /* end mmu_at_system_gpc_mmu_at */

/* Generated Debug Code: Device mmu_at_system_mmu1 */
void ia_css_debug_dump_mmu_at_system_mmu1(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xe0188);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_stream_id_reg_idx_L2_15             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_stream_id_reg_idx_L2_15_type */
	/* skip, unused field unused_mmu_stream_id_reg_idx_L2_15 (mmu_stream_id_reg_idx_L2_15) */
	REG_DUMP_PRINT_1("   -mmu_stream_id_reg_idx_L2_15.mmu_stream_id_reg_idx_L2_15  |        0x%02X  |  [RW][04:00]""Nr. of first block in L2 Cache belonging to StreamID=15""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0xe0184);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_stream_id_reg_idx_L2_14             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_stream_id_reg_idx_L2_14_type */
	/* skip, unused field unused_mmu_stream_id_reg_idx_L2_14 (mmu_stream_id_reg_idx_L2_14) */
	REG_DUMP_PRINT_1("   -mmu_stream_id_reg_idx_L2_14.mmu_stream_id_reg_idx_L2_14  |        0x%02X  |  [RW][04:00]""Nr. of first block in L2 Cache belonging to StreamID=14""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0xe0180);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_stream_id_reg_idx_L2_13             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_stream_id_reg_idx_L2_13_type */
	/* skip, unused field unused_mmu_stream_id_reg_idx_L2_13 (mmu_stream_id_reg_idx_L2_13) */
	REG_DUMP_PRINT_1("   -mmu_stream_id_reg_idx_L2_13.mmu_stream_id_reg_idx_L2_13  |        0x%02X  |  [RW][04:00]""Nr. of first block in L2 Cache belonging to StreamID=13""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0xe017c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_stream_id_reg_idx_L2_12             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_stream_id_reg_idx_L2_12_type */
	/* skip, unused field unused_mmu_stream_id_reg_idx_L2_12 (mmu_stream_id_reg_idx_L2_12) */
	REG_DUMP_PRINT_1("   -mmu_stream_id_reg_idx_L2_12.mmu_stream_id_reg_idx_L2_12  |        0x%02X  |  [RW][04:00]""Nr. of first block in L2 Cache belonging to StreamID=12""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0xe0178);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_stream_id_reg_idx_L2_11             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_stream_id_reg_idx_L2_11_type */
	/* skip, unused field unused_mmu_stream_id_reg_idx_L2_11 (mmu_stream_id_reg_idx_L2_11) */
	REG_DUMP_PRINT_1("   -mmu_stream_id_reg_idx_L2_11.mmu_stream_id_reg_idx_L2_11  |        0x%02X  |  [RW][04:00]""Nr. of first block in L2 Cache belonging to StreamID=11""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0xe0174);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_stream_id_reg_idx_L2_10             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_stream_id_reg_idx_L2_10_type */
	/* skip, unused field unused_mmu_stream_id_reg_idx_L2_10 (mmu_stream_id_reg_idx_L2_10) */
	REG_DUMP_PRINT_1("   -mmu_stream_id_reg_idx_L2_10.mmu_stream_id_reg_idx_L2_10  |        0x%02X  |  [RW][04:00]""Nr. of first block in L2 Cache belonging to StreamID=10""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0xe0170);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_stream_id_reg_idx_L2_9              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_stream_id_reg_idx_L2_9_type */
	/* skip, unused field unused_mmu_stream_id_reg_idx_L2_9 (mmu_stream_id_reg_idx_L2_9) */
	REG_DUMP_PRINT_1("   -mmu_stream_id_reg_idx_L2_9.mmu_stream_id_reg_idx_L2_9    |        0x%02X  |  [RW][04:00]""Nr. of first block in L2 Cache belonging to StreamID=9""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0xe016c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_stream_id_reg_idx_L2_8              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_stream_id_reg_idx_L2_8_type */
	/* skip, unused field unused_mmu_stream_id_reg_idx_L2_8 (mmu_stream_id_reg_idx_L2_8) */
	REG_DUMP_PRINT_1("   -mmu_stream_id_reg_idx_L2_8.mmu_stream_id_reg_idx_L2_8    |        0x%02X  |  [RW][04:00]""Nr. of first block in L2 Cache belonging to StreamID=8""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0xe0168);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_stream_id_reg_idx_L2_7              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_stream_id_reg_idx_L2_7_type */
	/* skip, unused field unused_mmu_stream_id_reg_idx_L2_7 (mmu_stream_id_reg_idx_L2_7) */
	REG_DUMP_PRINT_1("   -mmu_stream_id_reg_idx_L2_7.mmu_stream_id_reg_idx_L2_7    |        0x%02X  |  [RW][04:00]""Nr. of first block in L2 Cache belonging to StreamID=7""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0xe0164);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_stream_id_reg_idx_L2_6              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_stream_id_reg_idx_L2_6_type */
	/* skip, unused field unused_mmu_stream_id_reg_idx_L2_6 (mmu_stream_id_reg_idx_L2_6) */
	REG_DUMP_PRINT_1("   -mmu_stream_id_reg_idx_L2_6.mmu_stream_id_reg_idx_L2_6    |        0x%02X  |  [RW][04:00]""Nr. of first block in L2 Cache belonging to StreamID=6""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0xe0160);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_stream_id_reg_idx_L2_5              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_stream_id_reg_idx_L2_5_type */
	/* skip, unused field unused_mmu_stream_id_reg_idx_L2_5 (mmu_stream_id_reg_idx_L2_5) */
	REG_DUMP_PRINT_1("   -mmu_stream_id_reg_idx_L2_5.mmu_stream_id_reg_idx_L2_5    |        0x%02X  |  [RW][04:00]""Nr. of first block in L2 Cache belonging to StreamID=5""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0xe015c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_stream_id_reg_idx_L2_4              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_stream_id_reg_idx_L2_4_type */
	/* skip, unused field unused_mmu_stream_id_reg_idx_L2_4 (mmu_stream_id_reg_idx_L2_4) */
	REG_DUMP_PRINT_1("   -mmu_stream_id_reg_idx_L2_4.mmu_stream_id_reg_idx_L2_4    |        0x%02X  |  [RW][04:00]""Nr. of first block in L2 Cache belonging to StreamID=4""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0xe0158);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_stream_id_reg_idx_L2_3              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_stream_id_reg_idx_L2_3_type */
	/* skip, unused field unused_mmu_stream_id_reg_idx_L2_3 (mmu_stream_id_reg_idx_L2_3) */
	REG_DUMP_PRINT_1("   -mmu_stream_id_reg_idx_L2_3.mmu_stream_id_reg_idx_L2_3    |        0x%02X  |  [RW][04:00]""Nr. of first block in L2 Cache belonging to StreamID=3""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0xe0154);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_stream_id_reg_idx_L2_2              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_stream_id_reg_idx_L2_2_type */
	/* skip, unused field unused_mmu_stream_id_reg_idx_L2_2 (mmu_stream_id_reg_idx_L2_2) */
	REG_DUMP_PRINT_1("   -mmu_stream_id_reg_idx_L2_2.mmu_stream_id_reg_idx_L2_2    |        0x%02X  |  [RW][04:00]""Nr. of first block in L2 Cache belonging to StreamID=2""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0xe0150);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_stream_id_reg_idx_L2_1              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_stream_id_reg_idx_L2_1_type */
	/* skip, unused field unused_mmu_stream_id_reg_idx_L2_1 (mmu_stream_id_reg_idx_L2_1) */
	REG_DUMP_PRINT_1("   -mmu_stream_id_reg_idx_L2_1.mmu_stream_id_reg_idx_L2_1    |        0x%02X  |  [RW][04:00]""Nr. of first block in L2 Cache belonging to StreamID=1""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0xe014c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_stream_id_reg_idx_L2_0              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_stream_id_reg_idx_L2_0_type */
	/* skip, unused field unused_mmu_stream_id_reg_idx_L2_0 (mmu_stream_id_reg_idx_L2_0) */
	REG_DUMP_PRINT_1("   -mmu_stream_id_reg_idx_L2_0.mmu_stream_id_reg_idx_L2_0    |        0x%02X  |  [RW][04:00]""Nr. of first block in L2 Cache belonging to StreamID=0""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0xe0148);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_stream_id_reg_idx_L1_15             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_stream_id_reg_idx_L1_15_type */
	/* skip, unused field unused_mmu_stream_id_reg_idx_L1_15 (mmu_stream_id_reg_idx_L1_15) */
	REG_DUMP_PRINT_1("   -mmu_stream_id_reg_idx_L1_15.mmu_stream_id_reg_idx_L1_15  |        0x%02X  |  [RW][05:00]""Nr. of first block in L1 Cache belonging to StreamID=15""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0xe0144);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_stream_id_reg_idx_L1_14             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_stream_id_reg_idx_L1_14_type */
	/* skip, unused field unused_mmu_stream_id_reg_idx_L1_14 (mmu_stream_id_reg_idx_L1_14) */
	REG_DUMP_PRINT_1("   -mmu_stream_id_reg_idx_L1_14.mmu_stream_id_reg_idx_L1_14  |        0x%02X  |  [RW][05:00]""Nr. of first block in L1 Cache belonging to StreamID=14""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0xe0140);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_stream_id_reg_idx_L1_13             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_stream_id_reg_idx_L1_13_type */
	/* skip, unused field unused_mmu_stream_id_reg_idx_L1_13 (mmu_stream_id_reg_idx_L1_13) */
	REG_DUMP_PRINT_1("   -mmu_stream_id_reg_idx_L1_13.mmu_stream_id_reg_idx_L1_13  |        0x%02X  |  [RW][05:00]""Nr. of first block in L1 Cache belonging to StreamID=13""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0xe013c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_stream_id_reg_idx_L1_12             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_stream_id_reg_idx_L1_12_type */
	/* skip, unused field unused_mmu_stream_id_reg_idx_L1_12 (mmu_stream_id_reg_idx_L1_12) */
	REG_DUMP_PRINT_1("   -mmu_stream_id_reg_idx_L1_12.mmu_stream_id_reg_idx_L1_12  |        0x%02X  |  [RW][05:00]""Nr. of first block in L1 Cache belonging to StreamID=12""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0xe0138);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_stream_id_reg_idx_L1_11             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_stream_id_reg_idx_L1_11_type */
	/* skip, unused field unused_mmu_stream_id_reg_idx_L1_11 (mmu_stream_id_reg_idx_L1_11) */
	REG_DUMP_PRINT_1("   -mmu_stream_id_reg_idx_L1_11.mmu_stream_id_reg_idx_L1_11  |        0x%02X  |  [RW][05:00]""Nr. of first block in L1 Cache belonging to StreamID=11""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0xe0134);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_stream_id_reg_idx_L1_10             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_stream_id_reg_idx_L1_10_type */
	/* skip, unused field unused_mmu_stream_id_reg_idx_L1_10 (mmu_stream_id_reg_idx_L1_10) */
	REG_DUMP_PRINT_1("   -mmu_stream_id_reg_idx_L1_10.mmu_stream_id_reg_idx_L1_10  |        0x%02X  |  [RW][05:00]""Nr. of first block in L1 Cache belonging to StreamID=10""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0xe0130);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_stream_id_reg_idx_L1_9              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_stream_id_reg_idx_L1_9_type */
	/* skip, unused field unused_mmu_stream_id_reg_idx_L1_9 (mmu_stream_id_reg_idx_L1_9) */
	REG_DUMP_PRINT_1("   -mmu_stream_id_reg_idx_L1_9.mmu_stream_id_reg_idx_L1_9    |        0x%02X  |  [RW][05:00]""Nr. of first block in L1 Cache belonging to StreamID=9""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0xe012c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_stream_id_reg_idx_L1_8              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_stream_id_reg_idx_L1_8_type */
	/* skip, unused field unused_mmu_stream_id_reg_idx_L1_8 (mmu_stream_id_reg_idx_L1_8) */
	REG_DUMP_PRINT_1("   -mmu_stream_id_reg_idx_L1_8.mmu_stream_id_reg_idx_L1_8    |        0x%02X  |  [RW][05:00]""Nr. of first block in L1 Cache belonging to StreamID=8""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0xe0128);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_stream_id_reg_idx_L1_7              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_stream_id_reg_idx_L1_7_type */
	/* skip, unused field unused_mmu_stream_id_reg_idx_L1_7 (mmu_stream_id_reg_idx_L1_7) */
	REG_DUMP_PRINT_1("   -mmu_stream_id_reg_idx_L1_7.mmu_stream_id_reg_idx_L1_7    |        0x%02X  |  [RW][05:00]""Nr. of first block in L1 Cache belonging to StreamID=7""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0xe0124);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_stream_id_reg_idx_L1_6              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_stream_id_reg_idx_L1_6_type */
	/* skip, unused field unused_mmu_stream_id_reg_idx_L1_6 (mmu_stream_id_reg_idx_L1_6) */
	REG_DUMP_PRINT_1("   -mmu_stream_id_reg_idx_L1_6.mmu_stream_id_reg_idx_L1_6    |        0x%02X  |  [RW][05:00]""Nr. of first block in L1 Cache belonging to StreamID=6""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0xe0120);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_stream_id_reg_idx_L1_5              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_stream_id_reg_idx_L1_5_type */
	/* skip, unused field unused_mmu_stream_id_reg_idx_L1_5 (mmu_stream_id_reg_idx_L1_5) */
	REG_DUMP_PRINT_1("   -mmu_stream_id_reg_idx_L1_5.mmu_stream_id_reg_idx_L1_5    |        0x%02X  |  [RW][05:00]""Nr. of first block in L1 Cache belonging to StreamID=5""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0xe011c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_stream_id_reg_idx_L1_4              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_stream_id_reg_idx_L1_4_type */
	/* skip, unused field unused_mmu_stream_id_reg_idx_L1_4 (mmu_stream_id_reg_idx_L1_4) */
	REG_DUMP_PRINT_1("   -mmu_stream_id_reg_idx_L1_4.mmu_stream_id_reg_idx_L1_4    |        0x%02X  |  [RW][05:00]""Nr. of first block in L1 Cache belonging to StreamID=4""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0xe0118);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_stream_id_reg_idx_L1_3              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_stream_id_reg_idx_L1_3_type */
	/* skip, unused field unused_mmu_stream_id_reg_idx_L1_3 (mmu_stream_id_reg_idx_L1_3) */
	REG_DUMP_PRINT_1("   -mmu_stream_id_reg_idx_L1_3.mmu_stream_id_reg_idx_L1_3    |        0x%02X  |  [RW][05:00]""Nr. of first block in L1 Cache belonging to StreamID=3""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0xe0114);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_stream_id_reg_idx_L1_2              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_stream_id_reg_idx_L1_2_type */
	/* skip, unused field unused_mmu_stream_id_reg_idx_L1_2 (mmu_stream_id_reg_idx_L1_2) */
	REG_DUMP_PRINT_1("   -mmu_stream_id_reg_idx_L1_2.mmu_stream_id_reg_idx_L1_2    |        0x%02X  |  [RW][05:00]""Nr. of first block in L1 Cache belonging to StreamID=2""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0xe0110);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_stream_id_reg_idx_L1_1              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_stream_id_reg_idx_L1_1_type */
	/* skip, unused field unused_mmu_stream_id_reg_idx_L1_1 (mmu_stream_id_reg_idx_L1_1) */
	REG_DUMP_PRINT_1("   -mmu_stream_id_reg_idx_L1_1.mmu_stream_id_reg_idx_L1_1    |        0x%02X  |  [RW][05:00]""Nr. of first block in L1 Cache belonging to StreamID=1""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0xe010c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_stream_id_reg_idx_L1_0              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_stream_id_reg_idx_L1_0_type */
	/* skip, unused field unused_mmu_stream_id_reg_idx_L1_0 (mmu_stream_id_reg_idx_L1_0) */
	REG_DUMP_PRINT_1("   -mmu_stream_id_reg_idx_L1_0.mmu_stream_id_reg_idx_L1_0    |        0x%02X  |  [RW][05:00]""Nr. of first block in L1 Cache belonging to StreamID=0""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0xe0108);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_info                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_info_type */
	/* skip, unused field unused_mmu_info (mmu_info) */
	REG_DUMP_PRINT_1("   -mmu_info.mmu_info                                        |       0x%03X  |  [RW][09:00]""Information that goes with every page request (CIO protocol).""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xe0104);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu1.mmu_page_table_base_address             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu1_mmu_page_table_base_address_type */
	/* skip, unused field unused_mmu_page_table_base_address (mmu_page_table_base_address) */
	REG_DUMP_PRINT_1("   -mmu_page_table_base_address.mmu_page_table_base_address  |   0x%07X  |  [RW][26:00]""Physical base address of the Level-2 page table.""\n", FIELD_VALUE(val, 0, 26));
} /* end mmu_at_system_mmu1 */

/* Generated Debug Code: Device mmu_at_system_mmu0 */
void ia_css_debug_dump_mmu_at_system_mmu0(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xe0008);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu0.info                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu0_info_type */
	/* skip, unused field unused_info (info) */
	REG_DUMP_PRINT_1("   -info.info                                        |       0x%03X  |  [RW][09:00]""Information that goes with every page request (CIO protocol).""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xe0004);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mmu_at_system_mmu0.page_table_base_address         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_mmu_at_system_mmu0_page_table_base_address_type */
	/* skip, unused field unused_page_table_base_address (page_table_base_address) */
	REG_DUMP_PRINT_1("   -page_table_base_address.page_table_base_address  |   0x%07X  |  [RW][26:00]""Physical base address of the level-1 page table.""\n", FIELD_VALUE(val, 0, 26));
} /* end mmu_at_system_mmu0 */

/* Generated Debug Code: Device ctrl_bus_ab_mt_mmu */
void ia_css_debug_dump_ctrl_bus_ab_mt_mmu(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xc0930);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_mmu.addr_rng_access3  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_mmu_addr_rng_access3_type */
	/* skip, unused field unused_addr_rng_access3 (addr_rng_access3) */
	REG_DUMP_PRINT_1("   -addr_rng_access3.addr_rng_access3  |         0x%01X  |  [RW][01:00]""Range's access type""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xc092c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_mmu.addr_rng_max3     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_mmu_addr_rng_max3_type */
	/* skip, unused field unused_addr_rng_max3 (addr_rng_max3) */
	REG_DUMP_PRINT_1("   -addr_rng_max3.addr_rng_max3        |       0x%03X  |  [RW][11:00]""Range's high address register""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xc0928);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_mmu.addr_rng_min3     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_mmu_addr_rng_min3_type */
	/* skip, unused field unused_addr_rng_min3 (addr_rng_min3) */
	REG_DUMP_PRINT_1("   -addr_rng_min3.addr_rng_min3        |       0x%03X  |  [RW][11:00]""Range's low address register""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xc0924);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_mmu.addr_rng_access2  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_mmu_addr_rng_access2_type */
	/* skip, unused field unused_addr_rng_access2 (addr_rng_access2) */
	REG_DUMP_PRINT_1("   -addr_rng_access2.addr_rng_access2  |         0x%01X  |  [RW][01:00]""Range's access type""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xc0920);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_mmu.addr_rng_max2     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_mmu_addr_rng_max2_type */
	/* skip, unused field unused_addr_rng_max2 (addr_rng_max2) */
	REG_DUMP_PRINT_1("   -addr_rng_max2.addr_rng_max2        |       0x%03X  |  [RW][11:00]""Range's high address register""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xc091c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_mmu.addr_rng_min2     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_mmu_addr_rng_min2_type */
	/* skip, unused field unused_addr_rng_min2 (addr_rng_min2) */
	REG_DUMP_PRINT_1("   -addr_rng_min2.addr_rng_min2        |       0x%03X  |  [RW][11:00]""Range's low address register""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xc0918);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_mmu.addr_rng_access1  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_mmu_addr_rng_access1_type */
	/* skip, unused field unused_addr_rng_access1 (addr_rng_access1) */
	REG_DUMP_PRINT_1("   -addr_rng_access1.addr_rng_access1  |         0x%01X  |  [RW][01:00]""Range's access type""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xc0914);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_mmu.addr_rng_max1     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_mmu_addr_rng_max1_type */
	/* skip, unused field unused_addr_rng_max1 (addr_rng_max1) */
	REG_DUMP_PRINT_1("   -addr_rng_max1.addr_rng_max1        |       0x%03X  |  [RW][11:00]""Range's high address register""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xc0910);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_mmu.addr_rng_min1     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_mmu_addr_rng_min1_type */
	/* skip, unused field unused_addr_rng_min1 (addr_rng_min1) */
	REG_DUMP_PRINT_1("   -addr_rng_min1.addr_rng_min1        |       0x%03X  |  [RW][11:00]""Range's low address register""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xc090c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_mmu.addr_rng_access0  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_mmu_addr_rng_access0_type */
	/* skip, unused field unused_addr_rng_access0 (addr_rng_access0) */
	REG_DUMP_PRINT_1("   -addr_rng_access0.addr_rng_access0  |         0x%01X  |  [RW][01:00]""Range's access type""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xc0908);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_mmu.addr_rng_max0     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_mmu_addr_rng_max0_type */
	/* skip, unused field unused_addr_rng_max0 (addr_rng_max0) */
	REG_DUMP_PRINT_1("   -addr_rng_max0.addr_rng_max0        |       0x%03X  |  [RW][11:00]""Range's high address register""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xc0904);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_mmu.addr_rng_min0     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_mmu_addr_rng_min0_type */
	/* skip, unused field unused_addr_rng_min0 (addr_rng_min0) */
	REG_DUMP_PRINT_1("   -addr_rng_min0.addr_rng_min0        |       0x%03X  |  [RW][11:00]""Range's low address register""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xc0900);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_mmu.rd_back_value     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_mmu_rd_back_value_type */
	REG_DUMP_PRINT_1("   -rd_back_value.rd_back_value        |  0x%08X  |  [RW][31:00]""The return data in case of a blocked read.""\n", FIELD_VALUE(val, 0, 31));
} /* end ctrl_bus_ab_mt_mmu */

/* Generated Debug Code: Device ctrl_bus_ab_mt_mipibuf */
void ia_css_debug_dump_ctrl_bus_ab_mt_mipibuf(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xc070c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_mipibuf.addr_rng_access0  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_mipibuf_addr_rng_access0_type */
	/* skip, unused field unused_addr_rng_access0 (addr_rng_access0) */
	REG_DUMP_PRINT_1("   -addr_rng_access0.addr_rng_access0      |         0x%01X  |  [RW][01:00]""Range's access type""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xc0708);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_mipibuf.addr_rng_max0     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_mipibuf_addr_rng_max0_type */
	/* skip, unused field unused_addr_rng_max0 (addr_rng_max0) */
	REG_DUMP_PRINT_1("   -addr_rng_max0.addr_rng_max0            |     0x%05X  |  [RW][16:00]""Range's high address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0704);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_mipibuf.addr_rng_min0     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_mipibuf_addr_rng_min0_type */
	/* skip, unused field unused_addr_rng_min0 (addr_rng_min0) */
	REG_DUMP_PRINT_1("   -addr_rng_min0.addr_rng_min0            |     0x%05X  |  [RW][16:00]""Range's low address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0700);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_mipibuf.rd_back_value     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_mipibuf_rd_back_value_type */
	REG_DUMP_PRINT_1("   -rd_back_value.rd_back_value            |  0x%08X  |  [RW][31:00]""The return data in case of a blocked read.""\n", FIELD_VALUE(val, 0, 31));
} /* end ctrl_bus_ab_mt_mipibuf */

/* Generated Debug Code: Device ctrl_bus_ab_mt_bus2 */
void ia_css_debug_dump_ctrl_bus_ab_mt_bus2(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xc0630);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_bus2.addr_rng_access3  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_bus2_addr_rng_access3_type */
	/* skip, unused field unused_addr_rng_access3 (addr_rng_access3) */
	REG_DUMP_PRINT_1("   -addr_rng_access3.addr_rng_access3   |         0x%01X  |  [RW][01:00]""Range's access type""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xc062c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_bus2.addr_rng_max3     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_bus2_addr_rng_max3_type */
	/* skip, unused field unused_addr_rng_max3 (addr_rng_max3) */
	REG_DUMP_PRINT_1("   -addr_rng_max3.addr_rng_max3         |     0x%05X  |  [RW][16:00]""Range's high address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0628);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_bus2.addr_rng_min3     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_bus2_addr_rng_min3_type */
	/* skip, unused field unused_addr_rng_min3 (addr_rng_min3) */
	REG_DUMP_PRINT_1("   -addr_rng_min3.addr_rng_min3         |     0x%05X  |  [RW][16:00]""Range's low address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0624);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_bus2.addr_rng_access2  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_bus2_addr_rng_access2_type */
	/* skip, unused field unused_addr_rng_access2 (addr_rng_access2) */
	REG_DUMP_PRINT_1("   -addr_rng_access2.addr_rng_access2   |         0x%01X  |  [RW][01:00]""Range's access type""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xc0620);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_bus2.addr_rng_max2     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_bus2_addr_rng_max2_type */
	/* skip, unused field unused_addr_rng_max2 (addr_rng_max2) */
	REG_DUMP_PRINT_1("   -addr_rng_max2.addr_rng_max2         |     0x%05X  |  [RW][16:00]""Range's high address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc061c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_bus2.addr_rng_min2     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_bus2_addr_rng_min2_type */
	/* skip, unused field unused_addr_rng_min2 (addr_rng_min2) */
	REG_DUMP_PRINT_1("   -addr_rng_min2.addr_rng_min2         |     0x%05X  |  [RW][16:00]""Range's low address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0618);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_bus2.addr_rng_access1  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_bus2_addr_rng_access1_type */
	/* skip, unused field unused_addr_rng_access1 (addr_rng_access1) */
	REG_DUMP_PRINT_1("   -addr_rng_access1.addr_rng_access1   |         0x%01X  |  [RW][01:00]""Range's access type""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xc0614);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_bus2.addr_rng_max1     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_bus2_addr_rng_max1_type */
	/* skip, unused field unused_addr_rng_max1 (addr_rng_max1) */
	REG_DUMP_PRINT_1("   -addr_rng_max1.addr_rng_max1         |     0x%05X  |  [RW][16:00]""Range's high address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0610);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_bus2.addr_rng_min1     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_bus2_addr_rng_min1_type */
	/* skip, unused field unused_addr_rng_min1 (addr_rng_min1) */
	REG_DUMP_PRINT_1("   -addr_rng_min1.addr_rng_min1         |     0x%05X  |  [RW][16:00]""Range's low address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc060c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_bus2.addr_rng_access0  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_bus2_addr_rng_access0_type */
	/* skip, unused field unused_addr_rng_access0 (addr_rng_access0) */
	REG_DUMP_PRINT_1("   -addr_rng_access0.addr_rng_access0   |         0x%01X  |  [RW][01:00]""Range's access type""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xc0608);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_bus2.addr_rng_max0     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_bus2_addr_rng_max0_type */
	/* skip, unused field unused_addr_rng_max0 (addr_rng_max0) */
	REG_DUMP_PRINT_1("   -addr_rng_max0.addr_rng_max0         |     0x%05X  |  [RW][16:00]""Range's high address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0604);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_bus2.addr_rng_min0     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_bus2_addr_rng_min0_type */
	/* skip, unused field unused_addr_rng_min0 (addr_rng_min0) */
	REG_DUMP_PRINT_1("   -addr_rng_min0.addr_rng_min0         |     0x%05X  |  [RW][16:00]""Range's low address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0600);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_bus2.rd_back_value     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_bus2_rd_back_value_type */
	REG_DUMP_PRINT_1("   -rd_back_value.rd_back_value         |  0x%08X  |  [RW][31:00]""The return data in case of a blocked read.""\n", FIELD_VALUE(val, 0, 31));
} /* end ctrl_bus_ab_mt_bus2 */

/* Generated Debug Code: Device ctrl_bus_ab_mt_dma_ext1 */
void ia_css_debug_dump_ctrl_bus_ab_mt_dma_ext1(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xc0530);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_dma_ext1.addr_rng_access3  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_dma_ext1_addr_rng_access3_type */
	/* skip, unused field unused_addr_rng_access3 (addr_rng_access3) */
	REG_DUMP_PRINT_1("   -addr_rng_access3.addr_rng_access3       |         0x%01X  |  [RW][01:00]""Range's access type""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xc052c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_dma_ext1.addr_rng_max3     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_dma_ext1_addr_rng_max3_type */
	/* skip, unused field unused_addr_rng_max3 (addr_rng_max3) */
	REG_DUMP_PRINT_1("   -addr_rng_max3.addr_rng_max3             |     0x%05X  |  [RW][16:00]""Range's high address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0528);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_dma_ext1.addr_rng_min3     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_dma_ext1_addr_rng_min3_type */
	/* skip, unused field unused_addr_rng_min3 (addr_rng_min3) */
	REG_DUMP_PRINT_1("   -addr_rng_min3.addr_rng_min3             |     0x%05X  |  [RW][16:00]""Range's low address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0524);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_dma_ext1.addr_rng_access2  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_dma_ext1_addr_rng_access2_type */
	/* skip, unused field unused_addr_rng_access2 (addr_rng_access2) */
	REG_DUMP_PRINT_1("   -addr_rng_access2.addr_rng_access2       |         0x%01X  |  [RW][01:00]""Range's access type""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xc0520);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_dma_ext1.addr_rng_max2     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_dma_ext1_addr_rng_max2_type */
	/* skip, unused field unused_addr_rng_max2 (addr_rng_max2) */
	REG_DUMP_PRINT_1("   -addr_rng_max2.addr_rng_max2             |     0x%05X  |  [RW][16:00]""Range's high address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc051c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_dma_ext1.addr_rng_min2     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_dma_ext1_addr_rng_min2_type */
	/* skip, unused field unused_addr_rng_min2 (addr_rng_min2) */
	REG_DUMP_PRINT_1("   -addr_rng_min2.addr_rng_min2             |     0x%05X  |  [RW][16:00]""Range's low address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0518);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_dma_ext1.addr_rng_access1  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_dma_ext1_addr_rng_access1_type */
	/* skip, unused field unused_addr_rng_access1 (addr_rng_access1) */
	REG_DUMP_PRINT_1("   -addr_rng_access1.addr_rng_access1       |         0x%01X  |  [RW][01:00]""Range's access type""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xc0514);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_dma_ext1.addr_rng_max1     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_dma_ext1_addr_rng_max1_type */
	/* skip, unused field unused_addr_rng_max1 (addr_rng_max1) */
	REG_DUMP_PRINT_1("   -addr_rng_max1.addr_rng_max1             |     0x%05X  |  [RW][16:00]""Range's high address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0510);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_dma_ext1.addr_rng_min1     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_dma_ext1_addr_rng_min1_type */
	/* skip, unused field unused_addr_rng_min1 (addr_rng_min1) */
	REG_DUMP_PRINT_1("   -addr_rng_min1.addr_rng_min1             |     0x%05X  |  [RW][16:00]""Range's low address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc050c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_dma_ext1.addr_rng_access0  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_dma_ext1_addr_rng_access0_type */
	/* skip, unused field unused_addr_rng_access0 (addr_rng_access0) */
	REG_DUMP_PRINT_1("   -addr_rng_access0.addr_rng_access0       |         0x%01X  |  [RW][01:00]""Range's access type""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xc0508);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_dma_ext1.addr_rng_max0     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_dma_ext1_addr_rng_max0_type */
	/* skip, unused field unused_addr_rng_max0 (addr_rng_max0) */
	REG_DUMP_PRINT_1("   -addr_rng_max0.addr_rng_max0             |     0x%05X  |  [RW][16:00]""Range's high address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0504);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_dma_ext1.addr_rng_min0     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_dma_ext1_addr_rng_min0_type */
	/* skip, unused field unused_addr_rng_min0 (addr_rng_min0) */
	REG_DUMP_PRINT_1("   -addr_rng_min0.addr_rng_min0             |     0x%05X  |  [RW][16:00]""Range's low address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0500);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_dma_ext1.rd_back_value     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_dma_ext1_rd_back_value_type */
	REG_DUMP_PRINT_1("   -rd_back_value.rd_back_value             |  0x%08X  |  [RW][31:00]""The return data in case of a blocked read.""\n", FIELD_VALUE(val, 0, 31));
} /* end ctrl_bus_ab_mt_dma_ext1 */

/* Generated Debug Code: Device ctrl_bus_ab_mt_dma_ext0 */
void ia_css_debug_dump_ctrl_bus_ab_mt_dma_ext0(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xc0430);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_dma_ext0.addr_rng_access3  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_dma_ext0_addr_rng_access3_type */
	/* skip, unused field unused_addr_rng_access3 (addr_rng_access3) */
	REG_DUMP_PRINT_1("   -addr_rng_access3.addr_rng_access3       |         0x%01X  |  [RW][01:00]""Range's access type""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xc042c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_dma_ext0.addr_rng_max3     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_dma_ext0_addr_rng_max3_type */
	/* skip, unused field unused_addr_rng_max3 (addr_rng_max3) */
	REG_DUMP_PRINT_1("   -addr_rng_max3.addr_rng_max3             |     0x%05X  |  [RW][16:00]""Range's high address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0428);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_dma_ext0.addr_rng_min3     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_dma_ext0_addr_rng_min3_type */
	/* skip, unused field unused_addr_rng_min3 (addr_rng_min3) */
	REG_DUMP_PRINT_1("   -addr_rng_min3.addr_rng_min3             |     0x%05X  |  [RW][16:00]""Range's low address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0424);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_dma_ext0.addr_rng_access2  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_dma_ext0_addr_rng_access2_type */
	/* skip, unused field unused_addr_rng_access2 (addr_rng_access2) */
	REG_DUMP_PRINT_1("   -addr_rng_access2.addr_rng_access2       |         0x%01X  |  [RW][01:00]""Range's access type""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xc0420);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_dma_ext0.addr_rng_max2     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_dma_ext0_addr_rng_max2_type */
	/* skip, unused field unused_addr_rng_max2 (addr_rng_max2) */
	REG_DUMP_PRINT_1("   -addr_rng_max2.addr_rng_max2             |     0x%05X  |  [RW][16:00]""Range's high address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc041c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_dma_ext0.addr_rng_min2     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_dma_ext0_addr_rng_min2_type */
	/* skip, unused field unused_addr_rng_min2 (addr_rng_min2) */
	REG_DUMP_PRINT_1("   -addr_rng_min2.addr_rng_min2             |     0x%05X  |  [RW][16:00]""Range's low address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0418);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_dma_ext0.addr_rng_access1  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_dma_ext0_addr_rng_access1_type */
	/* skip, unused field unused_addr_rng_access1 (addr_rng_access1) */
	REG_DUMP_PRINT_1("   -addr_rng_access1.addr_rng_access1       |         0x%01X  |  [RW][01:00]""Range's access type""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xc0414);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_dma_ext0.addr_rng_max1     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_dma_ext0_addr_rng_max1_type */
	/* skip, unused field unused_addr_rng_max1 (addr_rng_max1) */
	REG_DUMP_PRINT_1("   -addr_rng_max1.addr_rng_max1             |     0x%05X  |  [RW][16:00]""Range's high address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0410);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_dma_ext0.addr_rng_min1     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_dma_ext0_addr_rng_min1_type */
	/* skip, unused field unused_addr_rng_min1 (addr_rng_min1) */
	REG_DUMP_PRINT_1("   -addr_rng_min1.addr_rng_min1             |     0x%05X  |  [RW][16:00]""Range's low address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc040c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_dma_ext0.addr_rng_access0  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_dma_ext0_addr_rng_access0_type */
	/* skip, unused field unused_addr_rng_access0 (addr_rng_access0) */
	REG_DUMP_PRINT_1("   -addr_rng_access0.addr_rng_access0       |         0x%01X  |  [RW][01:00]""Range's access type""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xc0408);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_dma_ext0.addr_rng_max0     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_dma_ext0_addr_rng_max0_type */
	/* skip, unused field unused_addr_rng_max0 (addr_rng_max0) */
	REG_DUMP_PRINT_1("   -addr_rng_max0.addr_rng_max0             |     0x%05X  |  [RW][16:00]""Range's high address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0404);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_dma_ext0.addr_rng_min0     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_dma_ext0_addr_rng_min0_type */
	/* skip, unused field unused_addr_rng_min0 (addr_rng_min0) */
	REG_DUMP_PRINT_1("   -addr_rng_min0.addr_rng_min0             |     0x%05X  |  [RW][16:00]""Range's low address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0400);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_dma_ext0.rd_back_value     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_dma_ext0_rd_back_value_type */
	REG_DUMP_PRINT_1("   -rd_back_value.rd_back_value             |  0x%08X  |  [RW][31:00]""The return data in case of a blocked read.""\n", FIELD_VALUE(val, 0, 31));
} /* end ctrl_bus_ab_mt_dma_ext0 */

/* Generated Debug Code: Device ctrl_bus_ab_mt_sp */
void ia_css_debug_dump_ctrl_bus_ab_mt_sp(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xc033c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_sp.addr_rng_access4   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_sp_addr_rng_access4_type */
	/* skip, unused field unused_addr_rng_access4 (addr_rng_access4) */
	REG_DUMP_PRINT_1("   -addr_rng_access4.addr_rng_access4  |         0x%01X  |  [RW][01:00]""Range's access type""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xc0338);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_sp.addr_rng_max4      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_sp_addr_rng_max4_type */
	/* skip, unused field unused_addr_rng_max4 (addr_rng_max4) */
	REG_DUMP_PRINT_1("   -addr_rng_max4.addr_rng_max4        |     0x%05X  |  [RW][16:00]""Range's high address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0334);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_sp.addr_rng_min4      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_sp_addr_rng_min4_type */
	/* skip, unused field unused_addr_rng_min4 (addr_rng_min4) */
	REG_DUMP_PRINT_1("   -addr_rng_min4.addr_rng_min4        |     0x%05X  |  [RW][16:00]""Range's low address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0330);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_sp.addr_rng_access3   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_sp_addr_rng_access3_type */
	/* skip, unused field unused_addr_rng_access3 (addr_rng_access3) */
	REG_DUMP_PRINT_1("   -addr_rng_access3.addr_rng_access3  |         0x%01X  |  [RW][01:00]""Range's access type""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xc032c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_sp.addr_rng_max3      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_sp_addr_rng_max3_type */
	/* skip, unused field unused_addr_rng_max3 (addr_rng_max3) */
	REG_DUMP_PRINT_1("   -addr_rng_max3.addr_rng_max3        |     0x%05X  |  [RW][16:00]""Range's high address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0328);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_sp.addr_rng_min3      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_sp_addr_rng_min3_type */
	/* skip, unused field unused_addr_rng_min3 (addr_rng_min3) */
	REG_DUMP_PRINT_1("   -addr_rng_min3.addr_rng_min3        |     0x%05X  |  [RW][16:00]""Range's low address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0324);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_sp.addr_rng_access2   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_sp_addr_rng_access2_type */
	/* skip, unused field unused_addr_rng_access2 (addr_rng_access2) */
	REG_DUMP_PRINT_1("   -addr_rng_access2.addr_rng_access2  |         0x%01X  |  [RW][01:00]""Range's access type""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xc0320);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_sp.addr_rng_max2      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_sp_addr_rng_max2_type */
	/* skip, unused field unused_addr_rng_max2 (addr_rng_max2) */
	REG_DUMP_PRINT_1("   -addr_rng_max2.addr_rng_max2        |     0x%05X  |  [RW][16:00]""Range's high address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc031c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_sp.addr_rng_min2      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_sp_addr_rng_min2_type */
	/* skip, unused field unused_addr_rng_min2 (addr_rng_min2) */
	REG_DUMP_PRINT_1("   -addr_rng_min2.addr_rng_min2        |     0x%05X  |  [RW][16:00]""Range's low address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0318);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_sp.addr_rng_access1   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_sp_addr_rng_access1_type */
	/* skip, unused field unused_addr_rng_access1 (addr_rng_access1) */
	REG_DUMP_PRINT_1("   -addr_rng_access1.addr_rng_access1  |         0x%01X  |  [RW][01:00]""Range's access type""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xc0314);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_sp.addr_rng_max1      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_sp_addr_rng_max1_type */
	/* skip, unused field unused_addr_rng_max1 (addr_rng_max1) */
	REG_DUMP_PRINT_1("   -addr_rng_max1.addr_rng_max1        |     0x%05X  |  [RW][16:00]""Range's high address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0310);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_sp.addr_rng_min1      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_sp_addr_rng_min1_type */
	/* skip, unused field unused_addr_rng_min1 (addr_rng_min1) */
	REG_DUMP_PRINT_1("   -addr_rng_min1.addr_rng_min1        |     0x%05X  |  [RW][16:00]""Range's low address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc030c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_sp.addr_rng_access0   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_sp_addr_rng_access0_type */
	/* skip, unused field unused_addr_rng_access0 (addr_rng_access0) */
	REG_DUMP_PRINT_1("   -addr_rng_access0.addr_rng_access0  |         0x%01X  |  [RW][01:00]""Range's access type""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xc0308);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_sp.addr_rng_max0      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_sp_addr_rng_max0_type */
	/* skip, unused field unused_addr_rng_max0 (addr_rng_max0) */
	REG_DUMP_PRINT_1("   -addr_rng_max0.addr_rng_max0        |     0x%05X  |  [RW][16:00]""Range's high address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0304);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_sp.addr_rng_min0      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_sp_addr_rng_min0_type */
	/* skip, unused field unused_addr_rng_min0 (addr_rng_min0) */
	REG_DUMP_PRINT_1("   -addr_rng_min0.addr_rng_min0        |     0x%05X  |  [RW][16:00]""Range's low address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0300);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_sp.rd_back_value      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_sp_rd_back_value_type */
	REG_DUMP_PRINT_1("   -rd_back_value.rd_back_value        |  0x%08X  |  [RW][31:00]""The return data in case of a blocked read.""\n", FIELD_VALUE(val, 0, 31));
} /* end ctrl_bus_ab_mt_sp */

/* Generated Debug Code: Device ctrl_bus_ab_mt_fw_dma */
void ia_css_debug_dump_ctrl_bus_ab_mt_fw_dma(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xc0230);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_fw_dma.addr_rng_access3  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_fw_dma_addr_rng_access3_type */
	/* skip, unused field unused_addr_rng_access3 (addr_rng_access3) */
	REG_DUMP_PRINT_1("   -addr_rng_access3.addr_rng_access3     |         0x%01X  |  [RW][01:00]""Range's access type""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xc022c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_fw_dma.addr_rng_max3     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_fw_dma_addr_rng_max3_type */
	/* skip, unused field unused_addr_rng_max3 (addr_rng_max3) */
	REG_DUMP_PRINT_1("   -addr_rng_max3.addr_rng_max3           |     0x%05X  |  [RW][16:00]""Range's high address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0228);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_fw_dma.addr_rng_min3     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_fw_dma_addr_rng_min3_type */
	/* skip, unused field unused_addr_rng_min3 (addr_rng_min3) */
	REG_DUMP_PRINT_1("   -addr_rng_min3.addr_rng_min3           |     0x%05X  |  [RW][16:00]""Range's low address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0224);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_fw_dma.addr_rng_access2  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_fw_dma_addr_rng_access2_type */
	/* skip, unused field unused_addr_rng_access2 (addr_rng_access2) */
	REG_DUMP_PRINT_1("   -addr_rng_access2.addr_rng_access2     |         0x%01X  |  [RW][01:00]""Range's access type""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xc0220);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_fw_dma.addr_rng_max2     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_fw_dma_addr_rng_max2_type */
	/* skip, unused field unused_addr_rng_max2 (addr_rng_max2) */
	REG_DUMP_PRINT_1("   -addr_rng_max2.addr_rng_max2           |     0x%05X  |  [RW][16:00]""Range's high address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc021c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_fw_dma.addr_rng_min2     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_fw_dma_addr_rng_min2_type */
	/* skip, unused field unused_addr_rng_min2 (addr_rng_min2) */
	REG_DUMP_PRINT_1("   -addr_rng_min2.addr_rng_min2           |     0x%05X  |  [RW][16:00]""Range's low address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0218);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_fw_dma.addr_rng_access1  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_fw_dma_addr_rng_access1_type */
	/* skip, unused field unused_addr_rng_access1 (addr_rng_access1) */
	REG_DUMP_PRINT_1("   -addr_rng_access1.addr_rng_access1     |         0x%01X  |  [RW][01:00]""Range's access type""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xc0214);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_fw_dma.addr_rng_max1     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_fw_dma_addr_rng_max1_type */
	/* skip, unused field unused_addr_rng_max1 (addr_rng_max1) */
	REG_DUMP_PRINT_1("   -addr_rng_max1.addr_rng_max1           |     0x%05X  |  [RW][16:00]""Range's high address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0210);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_fw_dma.addr_rng_min1     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_fw_dma_addr_rng_min1_type */
	/* skip, unused field unused_addr_rng_min1 (addr_rng_min1) */
	REG_DUMP_PRINT_1("   -addr_rng_min1.addr_rng_min1           |     0x%05X  |  [RW][16:00]""Range's low address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc020c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_fw_dma.addr_rng_access0  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_fw_dma_addr_rng_access0_type */
	/* skip, unused field unused_addr_rng_access0 (addr_rng_access0) */
	REG_DUMP_PRINT_1("   -addr_rng_access0.addr_rng_access0     |         0x%01X  |  [RW][01:00]""Range's access type""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xc0208);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_fw_dma.addr_rng_max0     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_fw_dma_addr_rng_max0_type */
	/* skip, unused field unused_addr_rng_max0 (addr_rng_max0) */
	REG_DUMP_PRINT_1("   -addr_rng_max0.addr_rng_max0           |     0x%05X  |  [RW][16:00]""Range's high address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0204);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_fw_dma.addr_rng_min0     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_fw_dma_addr_rng_min0_type */
	/* skip, unused field unused_addr_rng_min0 (addr_rng_min0) */
	REG_DUMP_PRINT_1("   -addr_rng_min0.addr_rng_min0           |     0x%05X  |  [RW][16:00]""Range's low address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0200);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_fw_dma.rd_back_value     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_fw_dma_rd_back_value_type */
	REG_DUMP_PRINT_1("   -rd_back_value.rd_back_value           |  0x%08X  |  [RW][31:00]""The return data in case of a blocked read.""\n", FIELD_VALUE(val, 0, 31));
} /* end ctrl_bus_ab_mt_fw_dma */

/* Generated Debug Code: Device ctrl_bus_ab_mt_is_a */
void ia_css_debug_dump_ctrl_bus_ab_mt_is_a(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xc0130);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_is_a.addr_rng_access3  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_is_a_addr_rng_access3_type */
	/* skip, unused field unused_addr_rng_access3 (addr_rng_access3) */
	REG_DUMP_PRINT_1("   -addr_rng_access3.addr_rng_access3   |         0x%01X  |  [RW][01:00]""Range's access type""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xc012c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_is_a.addr_rng_max3     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_is_a_addr_rng_max3_type */
	/* skip, unused field unused_addr_rng_max3 (addr_rng_max3) */
	REG_DUMP_PRINT_1("   -addr_rng_max3.addr_rng_max3         |     0x%05X  |  [RW][16:00]""Range's high address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0128);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_is_a.addr_rng_min3     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_is_a_addr_rng_min3_type */
	/* skip, unused field unused_addr_rng_min3 (addr_rng_min3) */
	REG_DUMP_PRINT_1("   -addr_rng_min3.addr_rng_min3         |     0x%05X  |  [RW][16:00]""Range's low address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0124);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_is_a.addr_rng_access2  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_is_a_addr_rng_access2_type */
	/* skip, unused field unused_addr_rng_access2 (addr_rng_access2) */
	REG_DUMP_PRINT_1("   -addr_rng_access2.addr_rng_access2   |         0x%01X  |  [RW][01:00]""Range's access type""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xc0120);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_is_a.addr_rng_max2     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_is_a_addr_rng_max2_type */
	/* skip, unused field unused_addr_rng_max2 (addr_rng_max2) */
	REG_DUMP_PRINT_1("   -addr_rng_max2.addr_rng_max2         |     0x%05X  |  [RW][16:00]""Range's high address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc011c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_is_a.addr_rng_min2     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_is_a_addr_rng_min2_type */
	/* skip, unused field unused_addr_rng_min2 (addr_rng_min2) */
	REG_DUMP_PRINT_1("   -addr_rng_min2.addr_rng_min2         |     0x%05X  |  [RW][16:00]""Range's low address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0118);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_is_a.addr_rng_access1  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_is_a_addr_rng_access1_type */
	/* skip, unused field unused_addr_rng_access1 (addr_rng_access1) */
	REG_DUMP_PRINT_1("   -addr_rng_access1.addr_rng_access1   |         0x%01X  |  [RW][01:00]""Range's access type""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xc0114);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_is_a.addr_rng_max1     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_is_a_addr_rng_max1_type */
	/* skip, unused field unused_addr_rng_max1 (addr_rng_max1) */
	REG_DUMP_PRINT_1("   -addr_rng_max1.addr_rng_max1         |     0x%05X  |  [RW][16:00]""Range's high address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0110);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_is_a.addr_rng_min1     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_is_a_addr_rng_min1_type */
	/* skip, unused field unused_addr_rng_min1 (addr_rng_min1) */
	REG_DUMP_PRINT_1("   -addr_rng_min1.addr_rng_min1         |     0x%05X  |  [RW][16:00]""Range's low address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc010c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_is_a.addr_rng_access0  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_is_a_addr_rng_access0_type */
	/* skip, unused field unused_addr_rng_access0 (addr_rng_access0) */
	REG_DUMP_PRINT_1("   -addr_rng_access0.addr_rng_access0   |         0x%01X  |  [RW][01:00]""Range's access type""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xc0108);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_is_a.addr_rng_max0     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_is_a_addr_rng_max0_type */
	/* skip, unused field unused_addr_rng_max0 (addr_rng_max0) */
	REG_DUMP_PRINT_1("   -addr_rng_max0.addr_rng_max0         |     0x%05X  |  [RW][16:00]""Range's high address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0104);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_is_a.addr_rng_min0     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_is_a_addr_rng_min0_type */
	/* skip, unused field unused_addr_rng_min0 (addr_rng_min0) */
	REG_DUMP_PRINT_1("   -addr_rng_min0.addr_rng_min0         |     0x%05X  |  [RW][16:00]""Range's low address register""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xc0100);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ctrl_bus_ab_mt_is_a.rd_back_value     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_ctrl_bus_ab_mt_is_a_rd_back_value_type */
	REG_DUMP_PRINT_1("   -rd_back_value.rd_back_value         |  0x%08X  |  [RW][31:00]""The return data in case of a blocked read.""\n", FIELD_VALUE(val, 0, 31));
} /* end ctrl_bus_ab_mt_is_a */

/* Generated Debug Code: Device soc_isapf */
void ia_css_debug_dump_soc_isapf(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xbf05c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_isapf.pad_set3                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_isapf_pad_set3_type */
	/* skip, unused field unused_pad_set3 (pad_set3) */
	REG_DUMP_PRINT_1("   -pad_set3.pad_set3                  |         0x%01X  |  [RW][01:00]""Horizontal padding definition""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xbf058);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_isapf.out_set3                   |  0x%08X  |  ""Output definition register""\n", val);
/* reg_type: reg_input_system_is_a_logic_soc_isapf_out_set3_type */
	/* skip, unused field unused_out_set3 (out_set3) */
	REG_DUMP_PRINT_1("   -out_set3.stream                    |         0x%01X  |  [RW][01:00]""PIF output setting""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -out_set3.mode                      |         0x%01X  |  [RW][03:02]""Mux output setting""\n", FIELD_VALUE(val, 2, 3));
	val = REG_DUMP_READ_REGISTER(0xbf054);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_isapf.size_set3                  |  0x%08X  |  ""Horizontal/Vertical size register""\n", val);
/* reg_type: reg_input_system_is_a_logic_soc_isapf_size_set3_type */
	REG_DUMP_PRINT_1("   -size_set3.stream                   |      0x%04X  |  [RW][15:00]""Horizontal size value""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -size_set3.mode                     |      0x%04X  |  [RW][31:16]""Vertical size value""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xbf050);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_isapf.start_set3                 |  0x%08X  |  ""Horizontal/Vertical start register""\n", val);
/* reg_type: reg_input_system_is_a_logic_soc_isapf_start_set3_type */
	REG_DUMP_PRINT_1("   -start_set3.stream                  |      0x%04X  |  [RW][15:00]""Horizontal start value""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -start_set3.mode                    |      0x%04X  |  [RW][31:16]""Vertical start value""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xbf04c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_isapf.pad_set2                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_isapf_pad_set2_type */
	/* skip, unused field unused_pad_set2 (pad_set2) */
	REG_DUMP_PRINT_1("   -pad_set2.pad_set2                  |         0x%01X  |  [RW][01:00]""Horizontal padding definition""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xbf048);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_isapf.out_set2                   |  0x%08X  |  ""Output definition register""\n", val);
/* reg_type: reg_input_system_is_a_logic_soc_isapf_out_set2_type */
	/* skip, unused field unused_out_set2 (out_set2) */
	REG_DUMP_PRINT_1("   -out_set2.stream                    |         0x%01X  |  [RW][01:00]""PIF output setting""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -out_set2.mode                      |         0x%01X  |  [RW][03:02]""Mux output setting""\n", FIELD_VALUE(val, 2, 3));
	val = REG_DUMP_READ_REGISTER(0xbf044);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_isapf.size_set2                  |  0x%08X  |  ""Horizontal/Vertical size register""\n", val);
/* reg_type: reg_input_system_is_a_logic_soc_isapf_size_set2_type */
	REG_DUMP_PRINT_1("   -size_set2.stream                   |      0x%04X  |  [RW][15:00]""Horizontal size value""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -size_set2.mode                     |      0x%04X  |  [RW][31:16]""Vertical size value""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xbf040);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_isapf.start_set2                 |  0x%08X  |  ""Horizontal/Vertical start register""\n", val);
/* reg_type: reg_input_system_is_a_logic_soc_isapf_start_set2_type */
	REG_DUMP_PRINT_1("   -start_set2.stream                  |      0x%04X  |  [RW][15:00]""Horizontal start value""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -start_set2.mode                    |      0x%04X  |  [RW][31:16]""Vertical start value""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xbf03c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_isapf.pad_set1                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_isapf_pad_set1_type */
	/* skip, unused field unused_pad_set1 (pad_set1) */
	REG_DUMP_PRINT_1("   -pad_set1.pad_set1                  |         0x%01X  |  [RW][01:00]""Horizontal padding definition""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xbf038);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_isapf.out_set1                   |  0x%08X  |  ""Output definition register""\n", val);
/* reg_type: reg_input_system_is_a_logic_soc_isapf_out_set1_type */
	/* skip, unused field unused_out_set1 (out_set1) */
	REG_DUMP_PRINT_1("   -out_set1.stream                    |         0x%01X  |  [RW][01:00]""PIF output setting""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -out_set1.mode                      |         0x%01X  |  [RW][03:02]""Mux output setting""\n", FIELD_VALUE(val, 2, 3));
	val = REG_DUMP_READ_REGISTER(0xbf034);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_isapf.size_set1                  |  0x%08X  |  ""Horizontal/Vertical size register""\n", val);
/* reg_type: reg_input_system_is_a_logic_soc_isapf_size_set1_type */
	REG_DUMP_PRINT_1("   -size_set1.stream                   |      0x%04X  |  [RW][15:00]""Horizontal size value""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -size_set1.mode                     |      0x%04X  |  [RW][31:16]""Vertical size value""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xbf030);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_isapf.start_set1                 |  0x%08X  |  ""Horizontal/Vertical start register""\n", val);
/* reg_type: reg_input_system_is_a_logic_soc_isapf_start_set1_type */
	REG_DUMP_PRINT_1("   -start_set1.stream                  |      0x%04X  |  [RW][15:00]""Horizontal start value""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -start_set1.mode                    |      0x%04X  |  [RW][31:16]""Vertical start value""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xbf02c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_isapf.pad_set0                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_isapf_pad_set0_type */
	/* skip, unused field unused_pad_set0 (pad_set0) */
	REG_DUMP_PRINT_1("   -pad_set0.pad_set0                  |         0x%01X  |  [RW][01:00]""Horizontal padding definition""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xbf028);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_isapf.out_set0                   |  0x%08X  |  ""Output definition register""\n", val);
/* reg_type: reg_input_system_is_a_logic_soc_isapf_out_set0_type */
	/* skip, unused field unused_out_set0 (out_set0) */
	REG_DUMP_PRINT_1("   -out_set0.stream                    |         0x%01X  |  [RW][01:00]""PIF output setting""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -out_set0.mode                      |         0x%01X  |  [RW][03:02]""Mux output setting""\n", FIELD_VALUE(val, 2, 3));
	val = REG_DUMP_READ_REGISTER(0xbf024);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_isapf.size_set0                  |  0x%08X  |  ""Horizontal/Vertical size register""\n", val);
/* reg_type: reg_input_system_is_a_logic_soc_isapf_size_set0_type */
	REG_DUMP_PRINT_1("   -size_set0.stream                   |      0x%04X  |  [RW][15:00]""Horizontal size value""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -size_set0.mode                     |      0x%04X  |  [RW][31:16]""Vertical size value""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xbf020);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_isapf.start_set0                 |  0x%08X  |  ""Horizontal/Vertical start register""\n", val);
/* reg_type: reg_input_system_is_a_logic_soc_isapf_start_set0_type */
	REG_DUMP_PRINT_1("   -start_set0.stream                  |      0x%04X  |  [RW][15:00]""Horizontal start value""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -start_set0.mode                    |      0x%04X  |  [RW][31:16]""Vertical start value""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xbf01c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_isapf.interrupt_enable           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_isapf_interrupt_enable_type */
	REG_DUMP_PRINT_1("   -interrupt_enable.interrupt_enable  |  0x%08X  |  [RW][31:00]""Interrupt enable register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xbf018);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_isapf.interrupt_status           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_isapf_interrupt_status_type */
	REG_DUMP_PRINT_1("   -interrupt_status.interrupt_status  |  0x%08X  |  [RO][31:00]""Interrupt status register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xbf008);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_isapf.status                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_isapf_status_type */
	REG_DUMP_PRINT_1("   -status.status                      |  0x%08X  |  [RO][31:00]""Status register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xbf000);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_isapf.configuration              |  0x%08X  |  ""Configuration register""\n", val);
/* reg_type: reg_input_system_is_a_logic_soc_isapf_configuration_type */
	/* skip, unused field unused_configuration (configuration) */
	REG_DUMP_PRINT_1("   -configuration.stream               |         0x%01X  |  [RW][00:00]""Single stream mode (0) or double stream mode (1)""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -configuration.mode                 |         0x%01X  |  [RW][02:01]""Bayer Quad Merge mode (00), mux mode (01) or bypass mode (10)""\n", FIELD_VALUE(val, 1, 2));
	REG_DUMP_PRINT_1("   -configuration.set_usage_01         |         0x%01X  |  [RW][03:03]""Use register set 0 (0) or register set 1 (1)""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -configuration.set_usage_23         |         0x%01X  |  [RW][04:04]""Use register set 2 (0) or register set 3 (1)""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -configuration.copy_size_1          |         0x%01X  |  [RW][05:05]""Run mux mode of stream 1 in copy mode (0) or size mode (1)""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -configuration.copy_size_2          |         0x%01X  |  [RW][06:06]""Run mux mode of stream 2 in copy mode (0) or size mode (1)""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -configuration.bypass_pix_size      |         0x%01X  |  [RW][07:07]""Bypass pixel size 8-bit (0) or 16-bit (1)""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -configuration.first_pix_remove     |         0x%01X  |  [RW][08:08]""First pixel removal""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -configuration.merge_8lane          |         0x%01X  |  [RW][10:09]""8 lane merge mode (optional)""\n", FIELD_VALUE(val, 9, 10));
} /* end soc_isapf */

/* Generated Debug Code: Device socpf */
void ia_css_debug_dump_socpf(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xbec3c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  socpf.socpf_opmode_inb_sid7        |  0x%08X  |  ""Socpf operation mode config register for sid7 data on input B""\n", val);
/* reg_type: reg_input_system_is_a_logic_socpf_socpf_opmode_inb_sid7_type */
	/* skip, unused field unused_socpf_opmode_inb_sid7 (socpf_opmode_inb_sid7) */
	REG_DUMP_PRINT_1("   -socpf_opmode_inb_sid7.opmode     |         0x%01X  |  [RW][02:00]""000=discard, 001=8lane mode, 010=soc mode 1:1 pass""\n", FIELD_VALUE(val, 0, 2));
	REG_DUMP_PRINT_1("   -socpf_opmode_inb_sid7.sid_socb   |         0x%01X  |  [RW][05:03]""sid for soc output B""\n", FIELD_VALUE(val, 3, 5));
	REG_DUMP_PRINT_1("   -socpf_opmode_inb_sid7.disc_fs_b  |         0x%01X  |  [RW][06:06]""discard frame start (fs) for soc output B""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -socpf_opmode_inb_sid7.disc_fe_a  |         0x%01X  |  [RW][07:07]""discard frame end (fe) for soc output B""\n", FIELD_VALUE(val, 7, 7));
	val = REG_DUMP_READ_REGISTER(0xbec38);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  socpf.socpf_opmode_inb_sid6        |  0x%08X  |  ""Socpf operation mode config register for sid6 data on input B""\n", val);
/* reg_type: reg_input_system_is_a_logic_socpf_socpf_opmode_inb_sid6_type */
	/* skip, unused field unused_socpf_opmode_inb_sid6 (socpf_opmode_inb_sid6) */
	REG_DUMP_PRINT_1("   -socpf_opmode_inb_sid6.opmode     |         0x%01X  |  [RW][02:00]""000=discard, 001=8lane mode, 010=soc mode 1:1 pass""\n", FIELD_VALUE(val, 0, 2));
	REG_DUMP_PRINT_1("   -socpf_opmode_inb_sid6.sid_socb   |         0x%01X  |  [RW][05:03]""sid for soc output B""\n", FIELD_VALUE(val, 3, 5));
	REG_DUMP_PRINT_1("   -socpf_opmode_inb_sid6.disc_fs_b  |         0x%01X  |  [RW][06:06]""discard frame start (fs) for soc output B""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -socpf_opmode_inb_sid6.disc_fe_a  |         0x%01X  |  [RW][07:07]""discard frame end (fe) for soc output B""\n", FIELD_VALUE(val, 7, 7));
	val = REG_DUMP_READ_REGISTER(0xbec34);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  socpf.socpf_opmode_inb_sid5        |  0x%08X  |  ""Socpf operation mode config register for sid5 data on input B""\n", val);
/* reg_type: reg_input_system_is_a_logic_socpf_socpf_opmode_inb_sid5_type */
	/* skip, unused field unused_socpf_opmode_inb_sid5 (socpf_opmode_inb_sid5) */
	REG_DUMP_PRINT_1("   -socpf_opmode_inb_sid5.opmode     |         0x%01X  |  [RW][02:00]""000=discard, 001=8lane mode, 010=soc mode 1:1 pass""\n", FIELD_VALUE(val, 0, 2));
	REG_DUMP_PRINT_1("   -socpf_opmode_inb_sid5.sid_socb   |         0x%01X  |  [RW][05:03]""sid for soc output B""\n", FIELD_VALUE(val, 3, 5));
	REG_DUMP_PRINT_1("   -socpf_opmode_inb_sid5.disc_fs_b  |         0x%01X  |  [RW][06:06]""discard frame start (fs) for soc output B""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -socpf_opmode_inb_sid5.disc_fe_a  |         0x%01X  |  [RW][07:07]""discard frame end (fe) for soc output B""\n", FIELD_VALUE(val, 7, 7));
	val = REG_DUMP_READ_REGISTER(0xbec30);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  socpf.socpf_opmode_inb_sid4        |  0x%08X  |  ""Socpf operation mode config register for sid4 data on input B""\n", val);
/* reg_type: reg_input_system_is_a_logic_socpf_socpf_opmode_inb_sid4_type */
	/* skip, unused field unused_socpf_opmode_inb_sid4 (socpf_opmode_inb_sid4) */
	REG_DUMP_PRINT_1("   -socpf_opmode_inb_sid4.opmode     |         0x%01X  |  [RW][02:00]""000=discard, 001=8lane mode, 010=soc mode 1:1 pass""\n", FIELD_VALUE(val, 0, 2));
	REG_DUMP_PRINT_1("   -socpf_opmode_inb_sid4.sid_socb   |         0x%01X  |  [RW][05:03]""sid for soc output B""\n", FIELD_VALUE(val, 3, 5));
	REG_DUMP_PRINT_1("   -socpf_opmode_inb_sid4.disc_fs_b  |         0x%01X  |  [RW][06:06]""discard frame start (fs) for soc output B""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -socpf_opmode_inb_sid4.disc_fe_a  |         0x%01X  |  [RW][07:07]""discard frame end (fe) for soc output B""\n", FIELD_VALUE(val, 7, 7));
	val = REG_DUMP_READ_REGISTER(0xbec2c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  socpf.socpf_opmode_inb_sid3        |  0x%08X  |  ""Socpf operation mode config register for sid3 data on input B""\n", val);
/* reg_type: reg_input_system_is_a_logic_socpf_socpf_opmode_inb_sid3_type */
	/* skip, unused field unused_socpf_opmode_inb_sid3 (socpf_opmode_inb_sid3) */
	REG_DUMP_PRINT_1("   -socpf_opmode_inb_sid3.opmode     |         0x%01X  |  [RW][02:00]""000=discard, 001=8lane mode, 010=soc mode 1:1 pass""\n", FIELD_VALUE(val, 0, 2));
	REG_DUMP_PRINT_1("   -socpf_opmode_inb_sid3.sid_socb   |         0x%01X  |  [RW][05:03]""sid for soc output B""\n", FIELD_VALUE(val, 3, 5));
	REG_DUMP_PRINT_1("   -socpf_opmode_inb_sid3.disc_fs_b  |         0x%01X  |  [RW][06:06]""discard frame start (fs) for soc output B""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -socpf_opmode_inb_sid3.disc_fe_a  |         0x%01X  |  [RW][07:07]""discard frame end (fe) for soc output B""\n", FIELD_VALUE(val, 7, 7));
	val = REG_DUMP_READ_REGISTER(0xbec28);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  socpf.socpf_opmode_inb_sid2        |  0x%08X  |  ""Socpf operation mode config register for sid2 data on input B""\n", val);
/* reg_type: reg_input_system_is_a_logic_socpf_socpf_opmode_inb_sid2_type */
	/* skip, unused field unused_socpf_opmode_inb_sid2 (socpf_opmode_inb_sid2) */
	REG_DUMP_PRINT_1("   -socpf_opmode_inb_sid2.opmode     |         0x%01X  |  [RW][02:00]""000=discard, 001=8lane mode, 010=soc mode 1:1 pass""\n", FIELD_VALUE(val, 0, 2));
	REG_DUMP_PRINT_1("   -socpf_opmode_inb_sid2.sid_socb   |         0x%01X  |  [RW][05:03]""sid for soc output B""\n", FIELD_VALUE(val, 3, 5));
	REG_DUMP_PRINT_1("   -socpf_opmode_inb_sid2.disc_fs_b  |         0x%01X  |  [RW][06:06]""discard frame start (fs) for soc output B""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -socpf_opmode_inb_sid2.disc_fe_a  |         0x%01X  |  [RW][07:07]""discard frame end (fe) for soc output B""\n", FIELD_VALUE(val, 7, 7));
	val = REG_DUMP_READ_REGISTER(0xbec24);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  socpf.socpf_opmode_inb_sid1        |  0x%08X  |  ""Socpf operation mode config register for sid1 data on input B""\n", val);
/* reg_type: reg_input_system_is_a_logic_socpf_socpf_opmode_inb_sid1_type */
	/* skip, unused field unused_socpf_opmode_inb_sid1 (socpf_opmode_inb_sid1) */
	REG_DUMP_PRINT_1("   -socpf_opmode_inb_sid1.opmode     |         0x%01X  |  [RW][02:00]""000=discard, 001=8lane mode, 010=soc mode 1:1 pass""\n", FIELD_VALUE(val, 0, 2));
	REG_DUMP_PRINT_1("   -socpf_opmode_inb_sid1.sid_socb   |         0x%01X  |  [RW][05:03]""sid for soc output B""\n", FIELD_VALUE(val, 3, 5));
	REG_DUMP_PRINT_1("   -socpf_opmode_inb_sid1.disc_fs_b  |         0x%01X  |  [RW][06:06]""discard frame start (fs) for soc output B""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -socpf_opmode_inb_sid1.disc_fe_a  |         0x%01X  |  [RW][07:07]""discard frame end (fe) for soc output B""\n", FIELD_VALUE(val, 7, 7));
	val = REG_DUMP_READ_REGISTER(0xbec20);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  socpf.socpf_opmode_inb_sid0        |  0x%08X  |  ""Socpf operation mode config register for sid0 data on input B""\n", val);
/* reg_type: reg_input_system_is_a_logic_socpf_socpf_opmode_inb_sid0_type */
	/* skip, unused field unused_socpf_opmode_inb_sid0 (socpf_opmode_inb_sid0) */
	REG_DUMP_PRINT_1("   -socpf_opmode_inb_sid0.opmode     |         0x%01X  |  [RW][02:00]""000=discard, 001=8lane mode, 010=soc mode 1:1 pass""\n", FIELD_VALUE(val, 0, 2));
	REG_DUMP_PRINT_1("   -socpf_opmode_inb_sid0.sid_socb   |         0x%01X  |  [RW][05:03]""sid for soc output B""\n", FIELD_VALUE(val, 3, 5));
	REG_DUMP_PRINT_1("   -socpf_opmode_inb_sid0.disc_fs_b  |         0x%01X  |  [RW][06:06]""discard frame start (fs) for soc output B""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -socpf_opmode_inb_sid0.disc_fe_a  |         0x%01X  |  [RW][07:07]""discard frame end (fe) for soc output B""\n", FIELD_VALUE(val, 7, 7));
	val = REG_DUMP_READ_REGISTER(0xbec1c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  socpf.socpf_opmode_ina_sid7        |  0x%08X  |  ""Socpf operation mode config register for sid7 data on input A""\n", val);
/* reg_type: reg_input_system_is_a_logic_socpf_socpf_opmode_ina_sid7_type */
	/* skip, unused field unused_socpf_opmode_ina_sid7 (socpf_opmode_ina_sid7) */
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid7.opmode     |         0x%01X  |  [RW][02:00]""000=discard, 001=8lane mode, 010=soc mode 1:1 pass,011=soc mode 2_2, 100=soc mode 2_1""\n", FIELD_VALUE(val, 0, 2));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid7.sid_soca   |         0x%01X  |  [RW][05:03]""sid for soc output A""\n", FIELD_VALUE(val, 3, 5));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid7.sid_socb   |         0x%01X  |  [RW][08:06]""sid for soc output B""\n", FIELD_VALUE(val, 6, 8));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid7.disc_fs_a  |         0x%01X  |  [RW][09:09]""discard frame start (fs) for soc output A""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid7.disc_fe_a  |         0x%01X  |  [RW][10:10]""discard frame end (fe) for soc output A""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid7.disc_fs_b  |         0x%01X  |  [RW][11:11]""discard frame start (fs) for soc output B""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid7.disc_fe_b  |         0x%01X  |  [RW][12:12]""discard frame end (fe) for soc output B""\n", FIELD_VALUE(val, 12, 12));
	val = REG_DUMP_READ_REGISTER(0xbec18);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  socpf.socpf_opmode_ina_sid6        |  0x%08X  |  ""Socpf operation mode config register for sid6 data on input A""\n", val);
/* reg_type: reg_input_system_is_a_logic_socpf_socpf_opmode_ina_sid6_type */
	/* skip, unused field unused_socpf_opmode_ina_sid6 (socpf_opmode_ina_sid6) */
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid6.opmode     |         0x%01X  |  [RW][02:00]""000=discard, 001=8lane mode, 010=soc mode 1:1 pass,011=soc mode 2_2, 100=soc mode 2_1""\n", FIELD_VALUE(val, 0, 2));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid6.sid_soca   |         0x%01X  |  [RW][05:03]""sid for soc output A""\n", FIELD_VALUE(val, 3, 5));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid6.sid_socb   |         0x%01X  |  [RW][08:06]""sid for soc output B""\n", FIELD_VALUE(val, 6, 8));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid6.disc_fs_a  |         0x%01X  |  [RW][09:09]""discard frame start (fs) for soc output A""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid6.disc_fe_a  |         0x%01X  |  [RW][10:10]""discard frame end (fe) for soc output A""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid6.disc_fs_b  |         0x%01X  |  [RW][11:11]""discard frame start (fs) for soc output B""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid6.disc_fe_b  |         0x%01X  |  [RW][12:12]""discard frame end (fe) for soc output B""\n", FIELD_VALUE(val, 12, 12));
	val = REG_DUMP_READ_REGISTER(0xbec14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  socpf.socpf_opmode_ina_sid5        |  0x%08X  |  ""Socpf operation mode config register for sid5 data on input A""\n", val);
/* reg_type: reg_input_system_is_a_logic_socpf_socpf_opmode_ina_sid5_type */
	/* skip, unused field unused_socpf_opmode_ina_sid5 (socpf_opmode_ina_sid5) */
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid5.opmode     |         0x%01X  |  [RW][02:00]""000=discard, 001=8lane mode, 010=soc mode 1:1 pass,011=soc mode 2_2, 100=soc mode 2_1""\n", FIELD_VALUE(val, 0, 2));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid5.sid_soca   |         0x%01X  |  [RW][05:03]""sid for soc output A""\n", FIELD_VALUE(val, 3, 5));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid5.sid_socb   |         0x%01X  |  [RW][08:06]""sid for soc output B""\n", FIELD_VALUE(val, 6, 8));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid5.disc_fs_a  |         0x%01X  |  [RW][09:09]""discard frame start (fs) for soc output A""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid5.disc_fe_a  |         0x%01X  |  [RW][10:10]""discard frame end (fe) for soc output A""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid5.disc_fs_b  |         0x%01X  |  [RW][11:11]""discard frame start (fs) for soc output B""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid5.disc_fe_b  |         0x%01X  |  [RW][12:12]""discard frame end (fe) for soc output B""\n", FIELD_VALUE(val, 12, 12));
	val = REG_DUMP_READ_REGISTER(0xbec10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  socpf.socpf_opmode_ina_sid4        |  0x%08X  |  ""Socpf operation mode config register for sid4 data on input A""\n", val);
/* reg_type: reg_input_system_is_a_logic_socpf_socpf_opmode_ina_sid4_type */
	/* skip, unused field unused_socpf_opmode_ina_sid4 (socpf_opmode_ina_sid4) */
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid4.opmode     |         0x%01X  |  [RW][02:00]""000=discard, 001=8lane mode, 010=soc mode 1:1 pass,011=soc mode 2_2, 100=soc mode 2_1""\n", FIELD_VALUE(val, 0, 2));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid4.sid_soca   |         0x%01X  |  [RW][05:03]""sid for soc output A""\n", FIELD_VALUE(val, 3, 5));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid4.sid_socb   |         0x%01X  |  [RW][08:06]""sid for soc output B""\n", FIELD_VALUE(val, 6, 8));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid4.disc_fs_a  |         0x%01X  |  [RW][09:09]""discard frame start (fs) for soc output A""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid4.disc_fe_a  |         0x%01X  |  [RW][10:10]""discard frame end (fe) for soc output A""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid4.disc_fs_b  |         0x%01X  |  [RW][11:11]""discard frame start (fs) for soc output B""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid4.disc_fe_b  |         0x%01X  |  [RW][12:12]""discard frame end (fe) for soc output B""\n", FIELD_VALUE(val, 12, 12));
	val = REG_DUMP_READ_REGISTER(0xbec0c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  socpf.socpf_opmode_ina_sid3        |  0x%08X  |  ""Socpf operation mode config register for sid3 data on input A""\n", val);
/* reg_type: reg_input_system_is_a_logic_socpf_socpf_opmode_ina_sid3_type */
	/* skip, unused field unused_socpf_opmode_ina_sid3 (socpf_opmode_ina_sid3) */
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid3.opmode     |         0x%01X  |  [RW][02:00]""000=discard, 001=8lane mode, 010=soc mode 1:1 pass,011=soc mode 2_2, 100=soc mode 2_1""\n", FIELD_VALUE(val, 0, 2));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid3.sid_soca   |         0x%01X  |  [RW][05:03]""sid for soc output A""\n", FIELD_VALUE(val, 3, 5));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid3.sid_socb   |         0x%01X  |  [RW][08:06]""sid for soc output B""\n", FIELD_VALUE(val, 6, 8));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid3.disc_fs_a  |         0x%01X  |  [RW][09:09]""discard frame start (fs) for soc output A""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid3.disc_fe_a  |         0x%01X  |  [RW][10:10]""discard frame end (fe) for soc output A""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid3.disc_fs_b  |         0x%01X  |  [RW][11:11]""discard frame start (fs) for soc output B""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid3.disc_fe_b  |         0x%01X  |  [RW][12:12]""discard frame end (fe) for soc output B""\n", FIELD_VALUE(val, 12, 12));
	val = REG_DUMP_READ_REGISTER(0xbec08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  socpf.socpf_opmode_ina_sid2        |  0x%08X  |  ""Socpf operation mode config register for sid2 data on input A""\n", val);
/* reg_type: reg_input_system_is_a_logic_socpf_socpf_opmode_ina_sid2_type */
	/* skip, unused field unused_socpf_opmode_ina_sid2 (socpf_opmode_ina_sid2) */
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid2.opmode     |         0x%01X  |  [RW][02:00]""000=discard, 001=8lane mode, 010=soc mode 1:1 pass,011=soc mode 2_2, 100=soc mode 2_1""\n", FIELD_VALUE(val, 0, 2));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid2.sid_soca   |         0x%01X  |  [RW][05:03]""sid for soc output A""\n", FIELD_VALUE(val, 3, 5));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid2.sid_socb   |         0x%01X  |  [RW][08:06]""sid for soc output B""\n", FIELD_VALUE(val, 6, 8));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid2.disc_fs_a  |         0x%01X  |  [RW][09:09]""discard frame start (fs) for soc output A""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid2.disc_fe_a  |         0x%01X  |  [RW][10:10]""discard frame end (fe) for soc output A""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid2.disc_fs_b  |         0x%01X  |  [RW][11:11]""discard frame start (fs) for soc output B""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid2.disc_fe_b  |         0x%01X  |  [RW][12:12]""discard frame end (fe) for soc output B""\n", FIELD_VALUE(val, 12, 12));
	val = REG_DUMP_READ_REGISTER(0xbec04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  socpf.socpf_opmode_ina_sid1        |  0x%08X  |  ""Socpf operation mode config register for sid1 data on input A""\n", val);
/* reg_type: reg_input_system_is_a_logic_socpf_socpf_opmode_ina_sid1_type */
	/* skip, unused field unused_socpf_opmode_ina_sid1 (socpf_opmode_ina_sid1) */
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid1.opmode     |         0x%01X  |  [RW][02:00]""000=discard, 001=8lane mode, 010=soc mode 1:1 pass,011=soc mode 2_2, 100=soc mode 2_1""\n", FIELD_VALUE(val, 0, 2));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid1.sid_soca   |         0x%01X  |  [RW][05:03]""sid for soc output A""\n", FIELD_VALUE(val, 3, 5));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid1.sid_socb   |         0x%01X  |  [RW][08:06]""sid for soc output B""\n", FIELD_VALUE(val, 6, 8));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid1.disc_fs_a  |         0x%01X  |  [RW][09:09]""discard frame start (fs) for soc output A""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid1.disc_fe_a  |         0x%01X  |  [RW][10:10]""discard frame end (fe) for soc output A""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid1.disc_fs_b  |         0x%01X  |  [RW][11:11]""discard frame start (fs) for soc output B""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid1.disc_fe_b  |         0x%01X  |  [RW][12:12]""discard frame end (fe) for soc output B""\n", FIELD_VALUE(val, 12, 12));
	val = REG_DUMP_READ_REGISTER(0xbec00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  socpf.socpf_opmode_ina_sid0        |  0x%08X  |  ""Socpf operation mode config register for sid0 data on input A""\n", val);
/* reg_type: reg_input_system_is_a_logic_socpf_socpf_opmode_ina_sid0_type */
	/* skip, unused field unused_socpf_opmode_ina_sid0 (socpf_opmode_ina_sid0) */
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid0.opmode     |         0x%01X  |  [RW][02:00]""000=discard, 001=8lane mode, 010=soc mode 1:1 pass,011=soc mode 2_2, 100=soc mode 2_1""\n", FIELD_VALUE(val, 0, 2));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid0.sid_soca   |         0x%01X  |  [RW][05:03]""sid for soc output A""\n", FIELD_VALUE(val, 3, 5));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid0.sid_socb   |         0x%01X  |  [RW][08:06]""sid for soc output B""\n", FIELD_VALUE(val, 6, 8));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid0.disc_fs_a  |         0x%01X  |  [RW][09:09]""discard frame start (fs) for soc output A""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid0.disc_fe_a  |         0x%01X  |  [RW][10:10]""discard frame end (fe) for soc output A""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid0.disc_fs_b  |         0x%01X  |  [RW][11:11]""discard frame start (fs) for soc output B""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -socpf_opmode_ina_sid0.disc_fe_b  |         0x%01X  |  [RW][12:12]""discard frame end (fe) for soc output B""\n", FIELD_VALUE(val, 12, 12));
} /* end socpf */

/* Generated Debug Code: Device soc_cio2str */
void ia_css_debug_dump_soc_cio2str(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xbd830);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_cio2str.sl_vec_status_reg              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_cio2str_sl_vec_status_reg_type */
	REG_DUMP_PRINT_1("   -sl_vec_status_reg.sl_vec_status_reg      |  0x%08X  |  [RO][31:00]""The status of the vector slave port. Bit 31 = CS; bit 30 = WE_N; bit [29:0] = ADDR [29:0].""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xbd82c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_cio2str.str_status_reg1                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_cio2str_str_status_reg1_type */
	/* skip, unused field unused_str_status_reg1 (str_status_reg1) */
	REG_DUMP_PRINT_1("   -str_status_reg1.str_status_reg1          |         0x%01X  |  [RO][01:00]""The status of the stream out port B, i.e. valid and accept.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xbd828);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_cio2str.str_out_cnt_reg1               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_cio2str_str_out_cnt_reg1_type */
	/* skip, unused field unused_str_out_cnt_reg1 (str_out_cnt_reg1) */
	REG_DUMP_PRINT_1("   -str_out_cnt_reg1.str_out_cnt_reg1        |        0x%02X  |  [RO][06:00]""Port B counter for the valid number of stream out transfers.""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xbd824);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_cio2str.sl_vec_valid_reg1              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_cio2str_sl_vec_valid_reg1_type */
	REG_DUMP_PRINT_1("   -sl_vec_valid_reg1.sl_vec_valid_reg1      |  0x%08X  |  [RO][31:00]""Index of valid data words available in the internal buffer of port B.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xbd820);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_cio2str.sl_vec_rcv_cnt_reg1            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_cio2str_sl_vec_rcv_cnt_reg1_type */
	/* skip, unused field unused_sl_vec_rcv_cnt_reg1 (sl_vec_rcv_cnt_reg1) */
	REG_DUMP_PRINT_1("   -sl_vec_rcv_cnt_reg1.sl_vec_rcv_cnt_reg1  |        0x%02X  |  [RO][05:00]""Port B counter for the number of vector words received.""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0xbd81c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_cio2str.sl_addr_cmpv_reg1              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_cio2str_sl_addr_cmpv_reg1_type */
	REG_DUMP_PRINT_1("   -sl_addr_cmpv_reg1.sl_addr_cmpv_reg1      |  0x%08X  |  [RW][31:00]""Port B address compare register.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xbd818);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_cio2str.sl_addr_mask_reg1              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_cio2str_sl_addr_mask_reg1_type */
	REG_DUMP_PRINT_1("   -sl_addr_mask_reg1.sl_addr_mask_reg1      |  0x%08X  |  [RW][31:00]""Port B address mask register.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xbd814);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_cio2str.str_status_reg0                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_cio2str_str_status_reg0_type */
	/* skip, unused field unused_str_status_reg0 (str_status_reg0) */
	REG_DUMP_PRINT_1("   -str_status_reg0.str_status_reg0          |         0x%01X  |  [RO][01:00]""The status of the stream out port A, i.e. valid and accept.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xbd810);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_cio2str.str_out_cnt_reg0               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_cio2str_str_out_cnt_reg0_type */
	/* skip, unused field unused_str_out_cnt_reg0 (str_out_cnt_reg0) */
	REG_DUMP_PRINT_1("   -str_out_cnt_reg0.str_out_cnt_reg0        |        0x%02X  |  [RO][06:00]""Port A counter for the valid number of stream out transfers.""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xbd80c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_cio2str.sl_vec_valid_reg0              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_cio2str_sl_vec_valid_reg0_type */
	REG_DUMP_PRINT_1("   -sl_vec_valid_reg0.sl_vec_valid_reg0      |  0x%08X  |  [RO][31:00]""Index of valid data words available in the internal buffer of port A.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xbd808);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_cio2str.sl_vec_rcv_cnt_reg0            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_cio2str_sl_vec_rcv_cnt_reg0_type */
	/* skip, unused field unused_sl_vec_rcv_cnt_reg0 (sl_vec_rcv_cnt_reg0) */
	REG_DUMP_PRINT_1("   -sl_vec_rcv_cnt_reg0.sl_vec_rcv_cnt_reg0  |        0x%02X  |  [RO][05:00]""Port A counter for the number of vector words received.""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0xbd804);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_cio2str.sl_addr_cmpv_reg0              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_cio2str_sl_addr_cmpv_reg0_type */
	REG_DUMP_PRINT_1("   -sl_addr_cmpv_reg0.sl_addr_cmpv_reg0      |  0x%08X  |  [RW][31:00]""Port A address compare register.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xbd800);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_cio2str.sl_addr_mask_reg0              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_cio2str_sl_addr_mask_reg0_type */
	REG_DUMP_PRINT_1("   -sl_addr_mask_reg0.sl_addr_mask_reg0      |  0x%08X  |  [RW][31:00]""Port A address mask register.""\n", FIELD_VALUE(val, 0, 31));
} /* end soc_cio2str */

/* Generated Debug Code: Device gp_counter */
void ia_css_debug_dump_gp_counter(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xbd4bc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_irq_enable_reg_3                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_irq_enable_reg_3_type */
	/* skip, unused field unused_gpc_irq_enable_reg_3 (gpc_irq_enable_reg_3) */
	REG_DUMP_PRINT_1("   -gpc_irq_enable_reg_3.gpc_irq_enable_reg_3                |         0x%01X  |  [RW][00:00]""Enable trigger 3 and sticky bits""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xbd4b8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_irq_enable_reg_2                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_irq_enable_reg_2_type */
	/* skip, unused field unused_gpc_irq_enable_reg_2 (gpc_irq_enable_reg_2) */
	REG_DUMP_PRINT_1("   -gpc_irq_enable_reg_2.gpc_irq_enable_reg_2                |         0x%01X  |  [RW][00:00]""Enable trigger 2 and sticky bits""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xbd4b4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_irq_enable_reg_1                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_irq_enable_reg_1_type */
	/* skip, unused field unused_gpc_irq_enable_reg_1 (gpc_irq_enable_reg_1) */
	REG_DUMP_PRINT_1("   -gpc_irq_enable_reg_1.gpc_irq_enable_reg_1                |         0x%01X  |  [RW][00:00]""Enable trigger 1 and sticky bits""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xbd4b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_irq_enable_reg_0                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_irq_enable_reg_0_type */
	/* skip, unused field unused_gpc_irq_enable_reg_0 (gpc_irq_enable_reg_0) */
	REG_DUMP_PRINT_1("   -gpc_irq_enable_reg_0.gpc_irq_enable_reg_0                |         0x%01X  |  [RW][00:00]""Enable trigger 0 and sticky bits""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xbd4ac);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_irq_timer_sel_reg_3                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_irq_timer_sel_reg_3_type */
	/* skip, unused field unused_gpc_irq_timer_sel_reg_3 (gpc_irq_timer_sel_reg_3) */
	REG_DUMP_PRINT_1("   -gpc_irq_timer_sel_reg_3.gpc_irq_timer_sel_reg_3          |         0x%01X  |  [RW][01:00]""Selects which counter to be used for matching for trigger 3""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xbd4a8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_irq_timer_sel_reg_2                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_irq_timer_sel_reg_2_type */
	/* skip, unused field unused_gpc_irq_timer_sel_reg_2 (gpc_irq_timer_sel_reg_2) */
	REG_DUMP_PRINT_1("   -gpc_irq_timer_sel_reg_2.gpc_irq_timer_sel_reg_2          |         0x%01X  |  [RW][01:00]""Selects which counter to be used for matching for trigger 2""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xbd4a4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_irq_timer_sel_reg_1                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_irq_timer_sel_reg_1_type */
	/* skip, unused field unused_gpc_irq_timer_sel_reg_1 (gpc_irq_timer_sel_reg_1) */
	REG_DUMP_PRINT_1("   -gpc_irq_timer_sel_reg_1.gpc_irq_timer_sel_reg_1          |         0x%01X  |  [RW][01:00]""Selects which counter to be used for matching for trigger 1""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xbd4a0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_irq_timer_sel_reg_0                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_irq_timer_sel_reg_0_type */
	/* skip, unused field unused_gpc_irq_timer_sel_reg_0 (gpc_irq_timer_sel_reg_0) */
	REG_DUMP_PRINT_1("   -gpc_irq_timer_sel_reg_0.gpc_irq_timer_sel_reg_0          |         0x%01X  |  [RW][01:00]""Selects which counter to be used for matching for trigger 0""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xbd49c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_irq_trigger_value_reg_3                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_irq_trigger_value_reg_3_type */
	REG_DUMP_PRINT_1("   -gpc_irq_trigger_value_reg_3.gpc_irq_trigger_value_reg_3  |  0x%08X  |  [RW][31:00]""The reference value that is used for comparisson and trigger 3 generation""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xbd498);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_irq_trigger_value_reg_2                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_irq_trigger_value_reg_2_type */
	REG_DUMP_PRINT_1("   -gpc_irq_trigger_value_reg_2.gpc_irq_trigger_value_reg_2  |  0x%08X  |  [RW][31:00]""The reference value that is used for comparisson and trigger 2 generation""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xbd494);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_irq_trigger_value_reg_1                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_irq_trigger_value_reg_1_type */
	REG_DUMP_PRINT_1("   -gpc_irq_trigger_value_reg_1.gpc_irq_trigger_value_reg_1  |  0x%08X  |  [RW][31:00]""The reference value that is used for comparisson and trigger 1 generation""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xbd490);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_irq_trigger_value_reg_0                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_irq_trigger_value_reg_0_type */
	REG_DUMP_PRINT_1("   -gpc_irq_trigger_value_reg_0.gpc_irq_trigger_value_reg_0  |  0x%08X  |  [RW][31:00]""The reference value that is used for comparisson and trigger 0 generation""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xbd48c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_trace_pload_sel_reg_3                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_trace_pload_sel_reg_3_type */
	/* skip, unused field unused_gpc_trace_pload_sel_reg_3 (gpc_trace_pload_sel_reg_3) */
	REG_DUMP_PRINT_1("   -gpc_trace_pload_sel_reg_3.gpc_trace_pload_sel_reg_3      |         0x%01X  |  [RW][01:00]""GPC payload selection for counter 3""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xbd488);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_trace_pload_sel_reg_2                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_trace_pload_sel_reg_2_type */
	/* skip, unused field unused_gpc_trace_pload_sel_reg_2 (gpc_trace_pload_sel_reg_2) */
	REG_DUMP_PRINT_1("   -gpc_trace_pload_sel_reg_2.gpc_trace_pload_sel_reg_2      |         0x%01X  |  [RW][01:00]""GPC payload selection for counter 2""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xbd484);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_trace_pload_sel_reg_1                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_trace_pload_sel_reg_1_type */
	/* skip, unused field unused_gpc_trace_pload_sel_reg_1 (gpc_trace_pload_sel_reg_1) */
	REG_DUMP_PRINT_1("   -gpc_trace_pload_sel_reg_1.gpc_trace_pload_sel_reg_1      |         0x%01X  |  [RW][01:00]""GPC payload selection for counter 1""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xbd480);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_trace_pload_sel_reg_0                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_trace_pload_sel_reg_0_type */
	/* skip, unused field unused_gpc_trace_pload_sel_reg_0 (gpc_trace_pload_sel_reg_0) */
	REG_DUMP_PRINT_1("   -gpc_trace_pload_sel_reg_0.gpc_trace_pload_sel_reg_0      |         0x%01X  |  [RW][01:00]""GPC payload selection for counter 0""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xbd47c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_trace_msg_sel_reg_3                         |  0x%08X  |  ""GPC message selection for counter 3""\n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_trace_msg_sel_reg_3_type */
	/* skip, unused field unused_gpc_trace_msg_sel_reg_3 (gpc_trace_msg_sel_reg_3) */
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_3.SrcSel                           |        0x%02X  |  [RW][04:00]""Select input / output""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_3.RoutSel                          |         0x%01X  |  [RW][06:05]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 5, 6));
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_3.SensSel                          |         0x%01X  |  [RW][08:07]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 7, 8));
	val = REG_DUMP_READ_REGISTER(0xbd478);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_trace_msg_sel_reg_2                         |  0x%08X  |  ""GPC message selection for counter 2""\n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_trace_msg_sel_reg_2_type */
	/* skip, unused field unused_gpc_trace_msg_sel_reg_2 (gpc_trace_msg_sel_reg_2) */
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_2.SrcSel                           |        0x%02X  |  [RW][04:00]""Select input / output""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_2.RoutSel                          |         0x%01X  |  [RW][06:05]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 5, 6));
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_2.SensSel                          |         0x%01X  |  [RW][08:07]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 7, 8));
	val = REG_DUMP_READ_REGISTER(0xbd474);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_trace_msg_sel_reg_1                         |  0x%08X  |  ""GPC message selection for counter 1""\n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_trace_msg_sel_reg_1_type */
	/* skip, unused field unused_gpc_trace_msg_sel_reg_1 (gpc_trace_msg_sel_reg_1) */
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_1.SrcSel                           |        0x%02X  |  [RW][04:00]""Select input / output""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_1.RoutSel                          |         0x%01X  |  [RW][06:05]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 5, 6));
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_1.SensSel                          |         0x%01X  |  [RW][08:07]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 7, 8));
	val = REG_DUMP_READ_REGISTER(0xbd470);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_trace_msg_sel_reg_0                         |  0x%08X  |  ""GPC message selection for counter 0""\n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_trace_msg_sel_reg_0_type */
	/* skip, unused field unused_gpc_trace_msg_sel_reg_0 (gpc_trace_msg_sel_reg_0) */
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_0.SrcSel                           |        0x%02X  |  [RW][04:00]""Select input / output""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_0.RoutSel                          |         0x%01X  |  [RW][06:05]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 5, 6));
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_0.SensSel                          |         0x%01X  |  [RW][08:07]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 7, 8));
	val = REG_DUMP_READ_REGISTER(0xbd46c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_trace_stop_sel_reg_3                        |  0x%08X  |  ""GPC stop selection for counter 3""\n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_trace_stop_sel_reg_3_type */
	/* skip, unused field unused_gpc_trace_stop_sel_reg_3 (gpc_trace_stop_sel_reg_3) */
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_3.SrcSel                          |        0x%02X  |  [RW][04:00]""Select input / output""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_3.RoutSel                         |         0x%01X  |  [RW][06:05]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 5, 6));
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_3.SensSel                         |         0x%01X  |  [RW][08:07]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 7, 8));
	val = REG_DUMP_READ_REGISTER(0xbd468);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_trace_stop_sel_reg_2                        |  0x%08X  |  ""GPC stop selection for counter 2""\n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_trace_stop_sel_reg_2_type */
	/* skip, unused field unused_gpc_trace_stop_sel_reg_2 (gpc_trace_stop_sel_reg_2) */
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_2.SrcSel                          |        0x%02X  |  [RW][04:00]""Select input / output""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_2.RoutSel                         |         0x%01X  |  [RW][06:05]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 5, 6));
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_2.SensSel                         |         0x%01X  |  [RW][08:07]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 7, 8));
	val = REG_DUMP_READ_REGISTER(0xbd464);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_trace_stop_sel_reg_1                        |  0x%08X  |  ""GPC stop selection for counter 1""\n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_trace_stop_sel_reg_1_type */
	/* skip, unused field unused_gpc_trace_stop_sel_reg_1 (gpc_trace_stop_sel_reg_1) */
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_1.SrcSel                          |        0x%02X  |  [RW][04:00]""Select input / output""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_1.RoutSel                         |         0x%01X  |  [RW][06:05]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 5, 6));
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_1.SensSel                         |         0x%01X  |  [RW][08:07]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 7, 8));
	val = REG_DUMP_READ_REGISTER(0xbd460);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_trace_stop_sel_reg_0                        |  0x%08X  |  ""GPC stop selection for counter 0""\n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_trace_stop_sel_reg_0_type */
	/* skip, unused field unused_gpc_trace_stop_sel_reg_0 (gpc_trace_stop_sel_reg_0) */
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_0.SrcSel                          |        0x%02X  |  [RW][04:00]""Select input / output""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_0.RoutSel                         |         0x%01X  |  [RW][06:05]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 5, 6));
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_0.SensSel                         |         0x%01X  |  [RW][08:07]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 7, 8));
	val = REG_DUMP_READ_REGISTER(0xbd45c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_trace_start_sel_reg_3                       |  0x%08X  |  ""GPC start selection for counter 3""\n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_trace_start_sel_reg_3_type */
	/* skip, unused field unused_gpc_trace_start_sel_reg_3 (gpc_trace_start_sel_reg_3) */
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_3.SrcSel                         |        0x%02X  |  [RW][04:00]""Select input / output""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_3.RoutSel                        |         0x%01X  |  [RW][06:05]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 5, 6));
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_3.SensSel                        |         0x%01X  |  [RW][08:07]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 7, 8));
	val = REG_DUMP_READ_REGISTER(0xbd458);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_trace_start_sel_reg_2                       |  0x%08X  |  ""GPC start selection for counter 2""\n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_trace_start_sel_reg_2_type */
	/* skip, unused field unused_gpc_trace_start_sel_reg_2 (gpc_trace_start_sel_reg_2) */
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_2.SrcSel                         |        0x%02X  |  [RW][04:00]""Select input / output""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_2.RoutSel                        |         0x%01X  |  [RW][06:05]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 5, 6));
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_2.SensSel                        |         0x%01X  |  [RW][08:07]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 7, 8));
	val = REG_DUMP_READ_REGISTER(0xbd454);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_trace_start_sel_reg_1                       |  0x%08X  |  ""GPC start selection for counter 1""\n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_trace_start_sel_reg_1_type */
	/* skip, unused field unused_gpc_trace_start_sel_reg_1 (gpc_trace_start_sel_reg_1) */
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_1.SrcSel                         |        0x%02X  |  [RW][04:00]""Select input / output""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_1.RoutSel                        |         0x%01X  |  [RW][06:05]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 5, 6));
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_1.SensSel                        |         0x%01X  |  [RW][08:07]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 7, 8));
	val = REG_DUMP_READ_REGISTER(0xbd450);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_trace_start_sel_reg_0                       |  0x%08X  |  ""GPC start selection for counter 0""\n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_trace_start_sel_reg_0_type */
	/* skip, unused field unused_gpc_trace_start_sel_reg_0 (gpc_trace_start_sel_reg_0) */
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_0.SrcSel                         |        0x%02X  |  [RW][04:00]""Select input / output""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_0.RoutSel                        |         0x%01X  |  [RW][06:05]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 5, 6));
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_0.SensSel                        |         0x%01X  |  [RW][08:07]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 7, 8));
	val = REG_DUMP_READ_REGISTER(0xbd44c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_trace_input_sel_reg_3                       |  0x%08X  |  ""GPC input selection for counter 3""\n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_trace_input_sel_reg_3_type */
	/* skip, unused field unused_gpc_trace_input_sel_reg_3 (gpc_trace_input_sel_reg_3) */
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_3.SrcSel                         |        0x%02X  |  [RW][04:00]""Select input / output""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_3.RoutSel                        |         0x%01X  |  [RW][06:05]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 5, 6));
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_3.SensSel                        |         0x%01X  |  [RW][08:07]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 7, 8));
	val = REG_DUMP_READ_REGISTER(0xbd448);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_trace_input_sel_reg_2                       |  0x%08X  |  ""GPC input selection for counter 2""\n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_trace_input_sel_reg_2_type */
	/* skip, unused field unused_gpc_trace_input_sel_reg_2 (gpc_trace_input_sel_reg_2) */
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_2.SrcSel                         |        0x%02X  |  [RW][04:00]""Select input / output""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_2.RoutSel                        |         0x%01X  |  [RW][06:05]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 5, 6));
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_2.SensSel                        |         0x%01X  |  [RW][08:07]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 7, 8));
	val = REG_DUMP_READ_REGISTER(0xbd444);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_trace_input_sel_reg_1                       |  0x%08X  |  ""GPC input selection for counter 1""\n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_trace_input_sel_reg_1_type */
	/* skip, unused field unused_gpc_trace_input_sel_reg_1 (gpc_trace_input_sel_reg_1) */
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_1.SrcSel                         |        0x%02X  |  [RW][04:00]""Select input / output""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_1.RoutSel                        |         0x%01X  |  [RW][06:05]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 5, 6));
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_1.SensSel                        |         0x%01X  |  [RW][08:07]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 7, 8));
	val = REG_DUMP_READ_REGISTER(0xbd440);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_trace_input_sel_reg_0                       |  0x%08X  |  ""GPC input selection for counter 0""\n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_trace_input_sel_reg_0_type */
	/* skip, unused field unused_gpc_trace_input_sel_reg_0 (gpc_trace_input_sel_reg_0) */
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_0.SrcSel                         |        0x%02X  |  [RW][04:00]""Select input / output""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_0.RoutSel                        |         0x%01X  |  [RW][06:05]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 5, 6));
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_0.SensSel                        |         0x%01X  |  [RW][08:07]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 7, 8));
	val = REG_DUMP_READ_REGISTER(0xbd43c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_value_reg_3                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_value_reg_3_type */
	REG_DUMP_PRINT_1("   -gpc_value_reg_3.gpc_value_reg_3                          |  0x%08X  |  [RO][31:00]""GPC current value of counter 3""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xbd438);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_value_reg_2                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_value_reg_2_type */
	REG_DUMP_PRINT_1("   -gpc_value_reg_2.gpc_value_reg_2                          |  0x%08X  |  [RO][31:00]""GPC current value of counter 2""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xbd434);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_value_reg_1                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_value_reg_1_type */
	REG_DUMP_PRINT_1("   -gpc_value_reg_1.gpc_value_reg_1                          |  0x%08X  |  [RO][31:00]""GPC current value of counter 1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xbd430);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_value_reg_0                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_value_reg_0_type */
	REG_DUMP_PRINT_1("   -gpc_value_reg_0.gpc_value_reg_0                          |  0x%08X  |  [RO][31:00]""GPC current value of counter 0""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xbd42c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_enable_reg_3                                |  0x%08X  |  ""GPC counter 3 enable""\n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_enable_reg_3_type */
	/* skip, unused field unused_gpc_enable_reg_3 (gpc_enable_reg_3) */
	REG_DUMP_PRINT_1("   -gpc_enable_reg_3.Enable                                  |         0x%01X  |  [RW][00:00]""When 0 counter is enabled, when 1 counter is enabled""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -gpc_enable_reg_3.Halt                                    |         0x%01X  |  [RW][01:01]""When 0 counter will wrap around, when 1 counter will halt""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -gpc_enable_reg_3.Reset_on_match                          |         0x%01X  |  [RW][02:02]""When 0 counter is not modified, when 1 counter reset on match""\n", FIELD_VALUE(val, 2, 2));
	val = REG_DUMP_READ_REGISTER(0xbd428);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_enable_reg_2                                |  0x%08X  |  ""GPC counter 2 enable""\n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_enable_reg_2_type */
	/* skip, unused field unused_gpc_enable_reg_2 (gpc_enable_reg_2) */
	REG_DUMP_PRINT_1("   -gpc_enable_reg_2.Enable                                  |         0x%01X  |  [RW][00:00]""When 0 counter is enabled, when 1 counter is enabled""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -gpc_enable_reg_2.Halt                                    |         0x%01X  |  [RW][01:01]""When 0 counter will wrap around, when 1 counter will halt""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -gpc_enable_reg_2.Reset_on_match                          |         0x%01X  |  [RW][02:02]""When 0 counter is not modified, when 1 counter reset on match""\n", FIELD_VALUE(val, 2, 2));
	val = REG_DUMP_READ_REGISTER(0xbd424);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_enable_reg_1                                |  0x%08X  |  ""GPC counter 1 enable""\n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_enable_reg_1_type */
	/* skip, unused field unused_gpc_enable_reg_1 (gpc_enable_reg_1) */
	REG_DUMP_PRINT_1("   -gpc_enable_reg_1.Enable                                  |         0x%01X  |  [RW][00:00]""When 0 counter is enabled, when 1 counter is enabled""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -gpc_enable_reg_1.Halt                                    |         0x%01X  |  [RW][01:01]""When 0 counter will wrap around, when 1 counter will halt""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -gpc_enable_reg_1.Reset_on_match                          |         0x%01X  |  [RW][02:02]""When 0 counter is not modified, when 1 counter reset on match""\n", FIELD_VALUE(val, 2, 2));
	val = REG_DUMP_READ_REGISTER(0xbd420);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_enable_reg_0                                |  0x%08X  |  ""GPC counter 0 enable""\n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_enable_reg_0_type */
	/* skip, unused field unused_gpc_enable_reg_0 (gpc_enable_reg_0) */
	REG_DUMP_PRINT_1("   -gpc_enable_reg_0.Enable                                  |         0x%01X  |  [RW][00:00]""When 0 counter is enabled, when 1 counter is enabled""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -gpc_enable_reg_0.Halt                                    |         0x%01X  |  [RW][01:01]""When 0 counter will wrap around, when 1 counter will halt""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -gpc_enable_reg_0.Reset_on_match                          |         0x%01X  |  [RW][02:02]""When 0 counter is not modified, when 1 counter reset on match""\n", FIELD_VALUE(val, 2, 2));
	val = REG_DUMP_READ_REGISTER(0xbd41c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_lost_packets_reg                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_lost_packets_reg_type */
	/* skip, unused field unused_gpc_lost_packets_reg (gpc_lost_packets_reg) */
	REG_DUMP_PRINT_1("   -gpc_lost_packets_reg.gpc_lost_packets_reg                |      0x%04X  |  [RO][15:00]""Tracks number of lost packets in acase of lossy tracing.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xbd414);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_trace_enable_ddr_reg                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_trace_enable_ddr_reg_type */
	/* skip, unused field unused_gpc_trace_enable_ddr_reg (gpc_trace_enable_ddr_reg) */
	REG_DUMP_PRINT_1("   -gpc_trace_enable_ddr_reg.gpc_trace_enable_ddr_reg        |         0x%01X  |  [RW][03:00]""Individual trace enable for tracing to DDR""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xbd410);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_trace_enable_npk_reg                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_trace_enable_npk_reg_type */
	/* skip, unused field unused_gpc_trace_enable_npk_reg (gpc_trace_enable_npk_reg) */
	REG_DUMP_PRINT_1("   -gpc_trace_enable_npk_reg.gpc_trace_enable_npk_reg        |         0x%01X  |  [RW][03:00]""Individual trace enable for tracing to NPK.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xbd40c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_trace_addr_reg                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_trace_addr_reg_type */
	REG_DUMP_PRINT_1("   -gpc_trace_addr_reg.gpc_trace_addr_reg                    |  0x%08X  |  [RW][31:00]""Address to which all trace packet are sent.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xbd408);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_trace_header_reg                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_trace_header_reg_type */
	/* skip, unused field unused_gpc_trace_header_reg (gpc_trace_header_reg) */
	REG_DUMP_PRINT_1("   -gpc_trace_header_reg.gpc_trace_header_reg                |        0x%02X  |  [RW][07:00]""SVEN header""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xbd404);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gp_counter.gpc_overall_enable_reg                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_gp_counter_gpc_overall_enable_reg_type */
	/* skip, unused field unused_gpc_overall_enable_reg (gpc_overall_enable_reg) */
	REG_DUMP_PRINT_1("   -gpc_overall_enable_reg.gpc_overall_enable_reg            |         0x%01X  |  [RW][00:00]""Overall enable all the counters""\n", FIELD_VALUE(val, 0, 0));
} /* end gp_counter */

/* Generated Debug Code: Device pf */
void ia_css_debug_dump_pf(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xbc85c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  pf.pad_set3                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_pf_pad_set3_type */
	/* skip, unused field unused_pad_set3 (pad_set3) */
	REG_DUMP_PRINT_1("   -pad_set3.pad_set3                  |         0x%01X  |  [RW][01:00]""Horizontal padding definition""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xbc858);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  pf.out_set3                          |  0x%08X  |  ""Output definition register""\n", val);
/* reg_type: reg_input_system_is_a_logic_pf_out_set3_type */
	/* skip, unused field unused_out_set3 (out_set3) */
	REG_DUMP_PRINT_1("   -out_set3.stream                    |         0x%01X  |  [RW][01:00]""PIF output setting""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -out_set3.mode                      |         0x%01X  |  [RW][03:02]""Mux output setting""\n", FIELD_VALUE(val, 2, 3));
	val = REG_DUMP_READ_REGISTER(0xbc854);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  pf.size_set3                         |  0x%08X  |  ""Horizontal/Vertical size register""\n", val);
/* reg_type: reg_input_system_is_a_logic_pf_size_set3_type */
	REG_DUMP_PRINT_1("   -size_set3.stream                   |      0x%04X  |  [RW][15:00]""Horizontal size value""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -size_set3.mode                     |      0x%04X  |  [RW][31:16]""Vertical size value""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xbc850);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  pf.start_set3                        |  0x%08X  |  ""Horizontal/Vertical start register""\n", val);
/* reg_type: reg_input_system_is_a_logic_pf_start_set3_type */
	REG_DUMP_PRINT_1("   -start_set3.stream                  |      0x%04X  |  [RW][15:00]""Horizontal start value""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -start_set3.mode                    |      0x%04X  |  [RW][31:16]""Vertical start value""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xbc84c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  pf.pad_set2                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_pf_pad_set2_type */
	/* skip, unused field unused_pad_set2 (pad_set2) */
	REG_DUMP_PRINT_1("   -pad_set2.pad_set2                  |         0x%01X  |  [RW][01:00]""Horizontal padding definition""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xbc848);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  pf.out_set2                          |  0x%08X  |  ""Output definition register""\n", val);
/* reg_type: reg_input_system_is_a_logic_pf_out_set2_type */
	/* skip, unused field unused_out_set2 (out_set2) */
	REG_DUMP_PRINT_1("   -out_set2.stream                    |         0x%01X  |  [RW][01:00]""PIF output setting""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -out_set2.mode                      |         0x%01X  |  [RW][03:02]""Mux output setting""\n", FIELD_VALUE(val, 2, 3));
	val = REG_DUMP_READ_REGISTER(0xbc844);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  pf.size_set2                         |  0x%08X  |  ""Horizontal/Vertical size register""\n", val);
/* reg_type: reg_input_system_is_a_logic_pf_size_set2_type */
	REG_DUMP_PRINT_1("   -size_set2.stream                   |      0x%04X  |  [RW][15:00]""Horizontal size value""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -size_set2.mode                     |      0x%04X  |  [RW][31:16]""Vertical size value""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xbc840);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  pf.start_set2                        |  0x%08X  |  ""Horizontal/Vertical start register""\n", val);
/* reg_type: reg_input_system_is_a_logic_pf_start_set2_type */
	REG_DUMP_PRINT_1("   -start_set2.stream                  |      0x%04X  |  [RW][15:00]""Horizontal start value""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -start_set2.mode                    |      0x%04X  |  [RW][31:16]""Vertical start value""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xbc83c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  pf.pad_set1                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_pf_pad_set1_type */
	/* skip, unused field unused_pad_set1 (pad_set1) */
	REG_DUMP_PRINT_1("   -pad_set1.pad_set1                  |         0x%01X  |  [RW][01:00]""Horizontal padding definition""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xbc838);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  pf.out_set1                          |  0x%08X  |  ""Output definition register""\n", val);
/* reg_type: reg_input_system_is_a_logic_pf_out_set1_type */
	/* skip, unused field unused_out_set1 (out_set1) */
	REG_DUMP_PRINT_1("   -out_set1.stream                    |         0x%01X  |  [RW][01:00]""PIF output setting""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -out_set1.mode                      |         0x%01X  |  [RW][03:02]""Mux output setting""\n", FIELD_VALUE(val, 2, 3));
	val = REG_DUMP_READ_REGISTER(0xbc834);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  pf.size_set1                         |  0x%08X  |  ""Horizontal/Vertical size register""\n", val);
/* reg_type: reg_input_system_is_a_logic_pf_size_set1_type */
	REG_DUMP_PRINT_1("   -size_set1.stream                   |      0x%04X  |  [RW][15:00]""Horizontal size value""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -size_set1.mode                     |      0x%04X  |  [RW][31:16]""Vertical size value""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xbc830);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  pf.start_set1                        |  0x%08X  |  ""Horizontal/Vertical start register""\n", val);
/* reg_type: reg_input_system_is_a_logic_pf_start_set1_type */
	REG_DUMP_PRINT_1("   -start_set1.stream                  |      0x%04X  |  [RW][15:00]""Horizontal start value""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -start_set1.mode                    |      0x%04X  |  [RW][31:16]""Vertical start value""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xbc82c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  pf.pad_set0                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_pf_pad_set0_type */
	/* skip, unused field unused_pad_set0 (pad_set0) */
	REG_DUMP_PRINT_1("   -pad_set0.pad_set0                  |         0x%01X  |  [RW][01:00]""Horizontal padding definition""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xbc828);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  pf.out_set0                          |  0x%08X  |  ""Output definition register""\n", val);
/* reg_type: reg_input_system_is_a_logic_pf_out_set0_type */
	/* skip, unused field unused_out_set0 (out_set0) */
	REG_DUMP_PRINT_1("   -out_set0.stream                    |         0x%01X  |  [RW][01:00]""PIF output setting""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -out_set0.mode                      |         0x%01X  |  [RW][03:02]""Mux output setting""\n", FIELD_VALUE(val, 2, 3));
	val = REG_DUMP_READ_REGISTER(0xbc824);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  pf.size_set0                         |  0x%08X  |  ""Horizontal/Vertical size register""\n", val);
/* reg_type: reg_input_system_is_a_logic_pf_size_set0_type */
	REG_DUMP_PRINT_1("   -size_set0.stream                   |      0x%04X  |  [RW][15:00]""Horizontal size value""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -size_set0.mode                     |      0x%04X  |  [RW][31:16]""Vertical size value""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xbc820);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  pf.start_set0                        |  0x%08X  |  ""Horizontal/Vertical start register""\n", val);
/* reg_type: reg_input_system_is_a_logic_pf_start_set0_type */
	REG_DUMP_PRINT_1("   -start_set0.stream                  |      0x%04X  |  [RW][15:00]""Horizontal start value""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -start_set0.mode                    |      0x%04X  |  [RW][31:16]""Vertical start value""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xbc81c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  pf.interrupt_enable                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_pf_interrupt_enable_type */
	REG_DUMP_PRINT_1("   -interrupt_enable.interrupt_enable  |  0x%08X  |  [RW][31:00]""Interrupt enable register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xbc818);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  pf.interrupt_status                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_pf_interrupt_status_type */
	REG_DUMP_PRINT_1("   -interrupt_status.interrupt_status  |  0x%08X  |  [RO][31:00]""Interrupt status register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xbc808);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  pf.status                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_pf_status_type */
	REG_DUMP_PRINT_1("   -status.status                      |  0x%08X  |  [RO][31:00]""Status register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xbc800);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  pf.configuration                     |  0x%08X  |  ""Configuration register""\n", val);
/* reg_type: reg_input_system_is_a_logic_pf_configuration_type */
	/* skip, unused field unused_configuration (configuration) */
	REG_DUMP_PRINT_1("   -configuration.stream               |         0x%01X  |  [RW][00:00]""Single stream mode (0) or double stream mode (1)""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -configuration.mode                 |         0x%01X  |  [RW][02:01]""Bayer Quad Merge mode (00), mux mode (01) or bypass mode (10)""\n", FIELD_VALUE(val, 1, 2));
	REG_DUMP_PRINT_1("   -configuration.set_usage_01         |         0x%01X  |  [RW][03:03]""Use register set 0 (0) or register set 1 (1)""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -configuration.set_usage_23         |         0x%01X  |  [RW][04:04]""Use register set 2 (0) or register set 3 (1)""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -configuration.copy_size_1          |         0x%01X  |  [RW][05:05]""Run mux mode of stream 1 in copy mode (0) or size mode (1)""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -configuration.copy_size_2          |         0x%01X  |  [RW][06:06]""Run mux mode of stream 2 in copy mode (0) or size mode (1)""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -configuration.bypass_pix_size      |         0x%01X  |  [RW][07:07]""Bypass pixel size 8-bit (0) or 16-bit (1)""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -configuration.first_pix_remove     |         0x%01X  |  [RW][08:08]""First pixel removal""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -configuration.merge_8lane          |         0x%01X  |  [RW][10:09]""8 lane merge mode (optional)""\n", FIELD_VALUE(val, 9, 10));
} /* end pf */

/* Generated Debug Code: Device soc_pixel_s2m1 */
void ia_css_debug_dump_soc_pixel_s2m1(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xb9624);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_datafield_remap_cfg_sid7                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_datafield_remap_cfg_sid7_type */
	/* skip, unused field unused_stream2mmio_datafield_remap_cfg_sid7 (stream2mmio_datafield_remap_cfg_sid7) */
	REG_DUMP_PRINT_1("   -stream2mmio_datafield_remap_cfg_sid7.stream2mmio_datafield_remap_cfg_sid7  |         0x%01X  |  [RO][02:00]""Datafield remap cfg_sid.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0xb9620);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_sidpid_addr_sid7                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_sidpid_addr_sid7_type */
	/* skip, unused field unused_stream2mmio_sidpid_addr_sid7 (stream2mmio_sidpid_addr_sid7) */
	REG_DUMP_PRINT_1("   -stream2mmio_sidpid_addr_sid7.stream2mmio_sidpid_addr_sid7                  |       0x%03X  |  [RW][11:00]""Identifier code attached to every acknoledgment (MSB side).""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb961c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_ack_base_addr_sid7                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_ack_base_addr_sid7_type */
	/* skip, unused field unused_stream2mmio_ack_base_addr_sid7 (stream2mmio_ack_base_addr_sid7) */
	REG_DUMP_PRINT_1("   -stream2mmio_ack_base_addr_sid7.stream2mmio_ack_base_addr_sid7              |  0x%08X  |  [RW][29:00]""Stream2mmio register address where the ack master  stores its acknowledgment.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb9618);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_block_when_no_cmd_sid7                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_block_when_no_cmd_sid7_type */
	/* skip, unused field unused_stream2mmio_block_when_no_cmd_sid7 (stream2mmio_block_when_no_cmd_sid7) */
	REG_DUMP_PRINT_1("   -stream2mmio_block_when_no_cmd_sid7.stream2mmio_block_when_no_cmd_sid7      |         0x%01X  |  [RW][00:00]""Stream2mmio block_when_no_cmd register . If 1, stream2mmio blocks input when not in open frame mode, and no command is available. If 0, inputs are just discarded for this situation""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb9614);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_num_items_sid7                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_num_items_sid7_type */
	/* skip, unused field unused_stream2mmio_num_items_sid7 (stream2mmio_num_items_sid7) */
	REG_DUMP_PRINT_1("   -stream2mmio_num_items_sid7.stream2mmio_num_items_sid7                      |      0x%04X  |  [RW][15:00]""Stream2mmio num_items register. Indicates the number of words to store for a store_word command. Indicates the number of packets to store for a store packet command. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb9610);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_stride_sid7                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_stride_sid7_type */
	/* skip, unused field unused_stream2mmio_stride_sid7 (stream2mmio_stride_sid7) */
	REG_DUMP_PRINT_1("   -stream2mmio_stride_sid7.stream2mmio_stride_sid7                            |   0x%07X  |  [RW][25:00]""Stream2mmio stride register. Indicates the increment per command in master port words. ""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb960c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_end_address_sid7                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_end_address_sid7_type */
	/* skip, unused field unused_stream2mmio_end_address_sid7 (stream2mmio_end_address_sid7) */
	REG_DUMP_PRINT_1("   -stream2mmio_end_address_sid7.stream2mmio_end_address_sid7                  |   0x%07X  |  [RW][25:00]""Stream2mmio end_address register. Indicates the last address of the memory region the stream2mmio can write to. Address is indicated in master port words""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb9608);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_start_address_sid7                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_start_address_sid7_type */
	/* skip, unused field unused_stream2mmio_start_address_sid7 (stream2mmio_start_address_sid7) */
	REG_DUMP_PRINT_1("   -stream2mmio_start_address_sid7.stream2mmio_start_address_sid7              |   0x%07X  |  [RW][25:00]""Stream2mmio start_address register. Indicates the start of the memory region the stream2mmio can write to. Address is indicated in master port words""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb9604);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_pix_width_id_sid7                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_pix_width_id_sid7_type */
	/* skip, unused field unused_stream2mmio_pix_width_id_sid7 (stream2mmio_pix_width_id_sid7) */
	REG_DUMP_PRINT_1("   -stream2mmio_pix_width_id_sid7.stream2mmio_pix_width_id_sid7                |         0x%01X  |  [RW][01:00]""Stream2mmio pix_width_id register. If 0, 8 bits pixels will be written out on the master port, if 1, 16 bits pixels will be written out on the master port""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb95e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_datafield_remap_cfg_sid6                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_datafield_remap_cfg_sid6_type */
	/* skip, unused field unused_stream2mmio_datafield_remap_cfg_sid6 (stream2mmio_datafield_remap_cfg_sid6) */
	REG_DUMP_PRINT_1("   -stream2mmio_datafield_remap_cfg_sid6.stream2mmio_datafield_remap_cfg_sid6  |         0x%01X  |  [RO][02:00]""Datafield remap cfg_sid.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0xb95e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_sidpid_addr_sid6                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_sidpid_addr_sid6_type */
	/* skip, unused field unused_stream2mmio_sidpid_addr_sid6 (stream2mmio_sidpid_addr_sid6) */
	REG_DUMP_PRINT_1("   -stream2mmio_sidpid_addr_sid6.stream2mmio_sidpid_addr_sid6                  |       0x%03X  |  [RW][11:00]""Identifier code attached to every acknoledgment (MSB side).""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb95dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_ack_base_addr_sid6                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_ack_base_addr_sid6_type */
	/* skip, unused field unused_stream2mmio_ack_base_addr_sid6 (stream2mmio_ack_base_addr_sid6) */
	REG_DUMP_PRINT_1("   -stream2mmio_ack_base_addr_sid6.stream2mmio_ack_base_addr_sid6              |  0x%08X  |  [RW][29:00]""Stream2mmio register address where the ack master  stores its acknowledgment.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb95d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_block_when_no_cmd_sid6                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_block_when_no_cmd_sid6_type */
	/* skip, unused field unused_stream2mmio_block_when_no_cmd_sid6 (stream2mmio_block_when_no_cmd_sid6) */
	REG_DUMP_PRINT_1("   -stream2mmio_block_when_no_cmd_sid6.stream2mmio_block_when_no_cmd_sid6      |         0x%01X  |  [RW][00:00]""Stream2mmio block_when_no_cmd register . If 1, stream2mmio blocks input when not in open frame mode, and no command is available. If 0, inputs are just discarded for this situation""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb95d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_num_items_sid6                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_num_items_sid6_type */
	/* skip, unused field unused_stream2mmio_num_items_sid6 (stream2mmio_num_items_sid6) */
	REG_DUMP_PRINT_1("   -stream2mmio_num_items_sid6.stream2mmio_num_items_sid6                      |      0x%04X  |  [RW][15:00]""Stream2mmio num_items register. Indicates the number of words to store for a store_word command. Indicates the number of packets to store for a store packet command. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb95d0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_stride_sid6                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_stride_sid6_type */
	/* skip, unused field unused_stream2mmio_stride_sid6 (stream2mmio_stride_sid6) */
	REG_DUMP_PRINT_1("   -stream2mmio_stride_sid6.stream2mmio_stride_sid6                            |   0x%07X  |  [RW][25:00]""Stream2mmio stride register. Indicates the increment per command in master port words. ""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb95cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_end_address_sid6                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_end_address_sid6_type */
	/* skip, unused field unused_stream2mmio_end_address_sid6 (stream2mmio_end_address_sid6) */
	REG_DUMP_PRINT_1("   -stream2mmio_end_address_sid6.stream2mmio_end_address_sid6                  |   0x%07X  |  [RW][25:00]""Stream2mmio end_address register. Indicates the last address of the memory region the stream2mmio can write to. Address is indicated in master port words""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb95c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_start_address_sid6                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_start_address_sid6_type */
	/* skip, unused field unused_stream2mmio_start_address_sid6 (stream2mmio_start_address_sid6) */
	REG_DUMP_PRINT_1("   -stream2mmio_start_address_sid6.stream2mmio_start_address_sid6              |   0x%07X  |  [RW][25:00]""Stream2mmio start_address register. Indicates the start of the memory region the stream2mmio can write to. Address is indicated in master port words""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb95c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_pix_width_id_sid6                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_pix_width_id_sid6_type */
	/* skip, unused field unused_stream2mmio_pix_width_id_sid6 (stream2mmio_pix_width_id_sid6) */
	REG_DUMP_PRINT_1("   -stream2mmio_pix_width_id_sid6.stream2mmio_pix_width_id_sid6                |         0x%01X  |  [RW][01:00]""Stream2mmio pix_width_id register. If 0, 8 bits pixels will be written out on the master port, if 1, 16 bits pixels will be written out on the master port""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb95a4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_datafield_remap_cfg_sid5                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_datafield_remap_cfg_sid5_type */
	/* skip, unused field unused_stream2mmio_datafield_remap_cfg_sid5 (stream2mmio_datafield_remap_cfg_sid5) */
	REG_DUMP_PRINT_1("   -stream2mmio_datafield_remap_cfg_sid5.stream2mmio_datafield_remap_cfg_sid5  |         0x%01X  |  [RO][02:00]""Datafield remap cfg_sid.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0xb95a0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_sidpid_addr_sid5                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_sidpid_addr_sid5_type */
	/* skip, unused field unused_stream2mmio_sidpid_addr_sid5 (stream2mmio_sidpid_addr_sid5) */
	REG_DUMP_PRINT_1("   -stream2mmio_sidpid_addr_sid5.stream2mmio_sidpid_addr_sid5                  |       0x%03X  |  [RW][11:00]""Identifier code attached to every acknoledgment (MSB side).""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb959c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_ack_base_addr_sid5                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_ack_base_addr_sid5_type */
	/* skip, unused field unused_stream2mmio_ack_base_addr_sid5 (stream2mmio_ack_base_addr_sid5) */
	REG_DUMP_PRINT_1("   -stream2mmio_ack_base_addr_sid5.stream2mmio_ack_base_addr_sid5              |  0x%08X  |  [RW][29:00]""Stream2mmio register address where the ack master  stores its acknowledgment.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb9598);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_block_when_no_cmd_sid5                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_block_when_no_cmd_sid5_type */
	/* skip, unused field unused_stream2mmio_block_when_no_cmd_sid5 (stream2mmio_block_when_no_cmd_sid5) */
	REG_DUMP_PRINT_1("   -stream2mmio_block_when_no_cmd_sid5.stream2mmio_block_when_no_cmd_sid5      |         0x%01X  |  [RW][00:00]""Stream2mmio block_when_no_cmd register . If 1, stream2mmio blocks input when not in open frame mode, and no command is available. If 0, inputs are just discarded for this situation""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb9594);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_num_items_sid5                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_num_items_sid5_type */
	/* skip, unused field unused_stream2mmio_num_items_sid5 (stream2mmio_num_items_sid5) */
	REG_DUMP_PRINT_1("   -stream2mmio_num_items_sid5.stream2mmio_num_items_sid5                      |      0x%04X  |  [RW][15:00]""Stream2mmio num_items register. Indicates the number of words to store for a store_word command. Indicates the number of packets to store for a store packet command. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb9590);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_stride_sid5                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_stride_sid5_type */
	/* skip, unused field unused_stream2mmio_stride_sid5 (stream2mmio_stride_sid5) */
	REG_DUMP_PRINT_1("   -stream2mmio_stride_sid5.stream2mmio_stride_sid5                            |   0x%07X  |  [RW][25:00]""Stream2mmio stride register. Indicates the increment per command in master port words. ""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb958c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_end_address_sid5                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_end_address_sid5_type */
	/* skip, unused field unused_stream2mmio_end_address_sid5 (stream2mmio_end_address_sid5) */
	REG_DUMP_PRINT_1("   -stream2mmio_end_address_sid5.stream2mmio_end_address_sid5                  |   0x%07X  |  [RW][25:00]""Stream2mmio end_address register. Indicates the last address of the memory region the stream2mmio can write to. Address is indicated in master port words""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb9588);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_start_address_sid5                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_start_address_sid5_type */
	/* skip, unused field unused_stream2mmio_start_address_sid5 (stream2mmio_start_address_sid5) */
	REG_DUMP_PRINT_1("   -stream2mmio_start_address_sid5.stream2mmio_start_address_sid5              |   0x%07X  |  [RW][25:00]""Stream2mmio start_address register. Indicates the start of the memory region the stream2mmio can write to. Address is indicated in master port words""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb9584);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_pix_width_id_sid5                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_pix_width_id_sid5_type */
	/* skip, unused field unused_stream2mmio_pix_width_id_sid5 (stream2mmio_pix_width_id_sid5) */
	REG_DUMP_PRINT_1("   -stream2mmio_pix_width_id_sid5.stream2mmio_pix_width_id_sid5                |         0x%01X  |  [RW][01:00]""Stream2mmio pix_width_id register. If 0, 8 bits pixels will be written out on the master port, if 1, 16 bits pixels will be written out on the master port""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb9564);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_datafield_remap_cfg_sid4                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_datafield_remap_cfg_sid4_type */
	/* skip, unused field unused_stream2mmio_datafield_remap_cfg_sid4 (stream2mmio_datafield_remap_cfg_sid4) */
	REG_DUMP_PRINT_1("   -stream2mmio_datafield_remap_cfg_sid4.stream2mmio_datafield_remap_cfg_sid4  |         0x%01X  |  [RO][02:00]""Datafield remap cfg_sid.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0xb9560);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_sidpid_addr_sid4                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_sidpid_addr_sid4_type */
	/* skip, unused field unused_stream2mmio_sidpid_addr_sid4 (stream2mmio_sidpid_addr_sid4) */
	REG_DUMP_PRINT_1("   -stream2mmio_sidpid_addr_sid4.stream2mmio_sidpid_addr_sid4                  |       0x%03X  |  [RW][11:00]""Identifier code attached to every acknoledgment (MSB side).""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb955c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_ack_base_addr_sid4                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_ack_base_addr_sid4_type */
	/* skip, unused field unused_stream2mmio_ack_base_addr_sid4 (stream2mmio_ack_base_addr_sid4) */
	REG_DUMP_PRINT_1("   -stream2mmio_ack_base_addr_sid4.stream2mmio_ack_base_addr_sid4              |  0x%08X  |  [RW][29:00]""Stream2mmio register address where the ack master  stores its acknowledgment.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb9558);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_block_when_no_cmd_sid4                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_block_when_no_cmd_sid4_type */
	/* skip, unused field unused_stream2mmio_block_when_no_cmd_sid4 (stream2mmio_block_when_no_cmd_sid4) */
	REG_DUMP_PRINT_1("   -stream2mmio_block_when_no_cmd_sid4.stream2mmio_block_when_no_cmd_sid4      |         0x%01X  |  [RW][00:00]""Stream2mmio block_when_no_cmd register . If 1, stream2mmio blocks input when not in open frame mode, and no command is available. If 0, inputs are just discarded for this situation""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb9554);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_num_items_sid4                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_num_items_sid4_type */
	/* skip, unused field unused_stream2mmio_num_items_sid4 (stream2mmio_num_items_sid4) */
	REG_DUMP_PRINT_1("   -stream2mmio_num_items_sid4.stream2mmio_num_items_sid4                      |      0x%04X  |  [RW][15:00]""Stream2mmio num_items register. Indicates the number of words to store for a store_word command. Indicates the number of packets to store for a store packet command. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb9550);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_stride_sid4                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_stride_sid4_type */
	/* skip, unused field unused_stream2mmio_stride_sid4 (stream2mmio_stride_sid4) */
	REG_DUMP_PRINT_1("   -stream2mmio_stride_sid4.stream2mmio_stride_sid4                            |   0x%07X  |  [RW][25:00]""Stream2mmio stride register. Indicates the increment per command in master port words. ""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb954c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_end_address_sid4                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_end_address_sid4_type */
	/* skip, unused field unused_stream2mmio_end_address_sid4 (stream2mmio_end_address_sid4) */
	REG_DUMP_PRINT_1("   -stream2mmio_end_address_sid4.stream2mmio_end_address_sid4                  |   0x%07X  |  [RW][25:00]""Stream2mmio end_address register. Indicates the last address of the memory region the stream2mmio can write to. Address is indicated in master port words""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb9548);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_start_address_sid4                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_start_address_sid4_type */
	/* skip, unused field unused_stream2mmio_start_address_sid4 (stream2mmio_start_address_sid4) */
	REG_DUMP_PRINT_1("   -stream2mmio_start_address_sid4.stream2mmio_start_address_sid4              |   0x%07X  |  [RW][25:00]""Stream2mmio start_address register. Indicates the start of the memory region the stream2mmio can write to. Address is indicated in master port words""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb9544);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_pix_width_id_sid4                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_pix_width_id_sid4_type */
	/* skip, unused field unused_stream2mmio_pix_width_id_sid4 (stream2mmio_pix_width_id_sid4) */
	REG_DUMP_PRINT_1("   -stream2mmio_pix_width_id_sid4.stream2mmio_pix_width_id_sid4                |         0x%01X  |  [RW][01:00]""Stream2mmio pix_width_id register. If 0, 8 bits pixels will be written out on the master port, if 1, 16 bits pixels will be written out on the master port""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb9524);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_datafield_remap_cfg_sid3                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_datafield_remap_cfg_sid3_type */
	/* skip, unused field unused_stream2mmio_datafield_remap_cfg_sid3 (stream2mmio_datafield_remap_cfg_sid3) */
	REG_DUMP_PRINT_1("   -stream2mmio_datafield_remap_cfg_sid3.stream2mmio_datafield_remap_cfg_sid3  |         0x%01X  |  [RO][02:00]""Datafield remap cfg_sid.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0xb9520);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_sidpid_addr_sid3                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_sidpid_addr_sid3_type */
	/* skip, unused field unused_stream2mmio_sidpid_addr_sid3 (stream2mmio_sidpid_addr_sid3) */
	REG_DUMP_PRINT_1("   -stream2mmio_sidpid_addr_sid3.stream2mmio_sidpid_addr_sid3                  |       0x%03X  |  [RW][11:00]""Identifier code attached to every acknoledgment (MSB side).""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb951c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_ack_base_addr_sid3                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_ack_base_addr_sid3_type */
	/* skip, unused field unused_stream2mmio_ack_base_addr_sid3 (stream2mmio_ack_base_addr_sid3) */
	REG_DUMP_PRINT_1("   -stream2mmio_ack_base_addr_sid3.stream2mmio_ack_base_addr_sid3              |  0x%08X  |  [RW][29:00]""Stream2mmio register address where the ack master  stores its acknowledgment.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb9518);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_block_when_no_cmd_sid3                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_block_when_no_cmd_sid3_type */
	/* skip, unused field unused_stream2mmio_block_when_no_cmd_sid3 (stream2mmio_block_when_no_cmd_sid3) */
	REG_DUMP_PRINT_1("   -stream2mmio_block_when_no_cmd_sid3.stream2mmio_block_when_no_cmd_sid3      |         0x%01X  |  [RW][00:00]""Stream2mmio block_when_no_cmd register . If 1, stream2mmio blocks input when not in open frame mode, and no command is available. If 0, inputs are just discarded for this situation""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb9514);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_num_items_sid3                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_num_items_sid3_type */
	/* skip, unused field unused_stream2mmio_num_items_sid3 (stream2mmio_num_items_sid3) */
	REG_DUMP_PRINT_1("   -stream2mmio_num_items_sid3.stream2mmio_num_items_sid3                      |      0x%04X  |  [RW][15:00]""Stream2mmio num_items register. Indicates the number of words to store for a store_word command. Indicates the number of packets to store for a store packet command. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb9510);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_stride_sid3                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_stride_sid3_type */
	/* skip, unused field unused_stream2mmio_stride_sid3 (stream2mmio_stride_sid3) */
	REG_DUMP_PRINT_1("   -stream2mmio_stride_sid3.stream2mmio_stride_sid3                            |   0x%07X  |  [RW][25:00]""Stream2mmio stride register. Indicates the increment per command in master port words. ""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb950c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_end_address_sid3                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_end_address_sid3_type */
	/* skip, unused field unused_stream2mmio_end_address_sid3 (stream2mmio_end_address_sid3) */
	REG_DUMP_PRINT_1("   -stream2mmio_end_address_sid3.stream2mmio_end_address_sid3                  |   0x%07X  |  [RW][25:00]""Stream2mmio end_address register. Indicates the last address of the memory region the stream2mmio can write to. Address is indicated in master port words""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb9508);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_start_address_sid3                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_start_address_sid3_type */
	/* skip, unused field unused_stream2mmio_start_address_sid3 (stream2mmio_start_address_sid3) */
	REG_DUMP_PRINT_1("   -stream2mmio_start_address_sid3.stream2mmio_start_address_sid3              |   0x%07X  |  [RW][25:00]""Stream2mmio start_address register. Indicates the start of the memory region the stream2mmio can write to. Address is indicated in master port words""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb9504);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_pix_width_id_sid3                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_pix_width_id_sid3_type */
	/* skip, unused field unused_stream2mmio_pix_width_id_sid3 (stream2mmio_pix_width_id_sid3) */
	REG_DUMP_PRINT_1("   -stream2mmio_pix_width_id_sid3.stream2mmio_pix_width_id_sid3                |         0x%01X  |  [RW][01:00]""Stream2mmio pix_width_id register. If 0, 8 bits pixels will be written out on the master port, if 1, 16 bits pixels will be written out on the master port""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb94e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_datafield_remap_cfg_sid2                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_datafield_remap_cfg_sid2_type */
	/* skip, unused field unused_stream2mmio_datafield_remap_cfg_sid2 (stream2mmio_datafield_remap_cfg_sid2) */
	REG_DUMP_PRINT_1("   -stream2mmio_datafield_remap_cfg_sid2.stream2mmio_datafield_remap_cfg_sid2  |         0x%01X  |  [RO][02:00]""Datafield remap cfg_sid.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0xb94e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_sidpid_addr_sid2                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_sidpid_addr_sid2_type */
	/* skip, unused field unused_stream2mmio_sidpid_addr_sid2 (stream2mmio_sidpid_addr_sid2) */
	REG_DUMP_PRINT_1("   -stream2mmio_sidpid_addr_sid2.stream2mmio_sidpid_addr_sid2                  |       0x%03X  |  [RW][11:00]""Identifier code attached to every acknoledgment (MSB side).""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb94dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_ack_base_addr_sid2                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_ack_base_addr_sid2_type */
	/* skip, unused field unused_stream2mmio_ack_base_addr_sid2 (stream2mmio_ack_base_addr_sid2) */
	REG_DUMP_PRINT_1("   -stream2mmio_ack_base_addr_sid2.stream2mmio_ack_base_addr_sid2              |  0x%08X  |  [RW][29:00]""Stream2mmio register address where the ack master  stores its acknowledgment.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb94d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_block_when_no_cmd_sid2                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_block_when_no_cmd_sid2_type */
	/* skip, unused field unused_stream2mmio_block_when_no_cmd_sid2 (stream2mmio_block_when_no_cmd_sid2) */
	REG_DUMP_PRINT_1("   -stream2mmio_block_when_no_cmd_sid2.stream2mmio_block_when_no_cmd_sid2      |         0x%01X  |  [RW][00:00]""Stream2mmio block_when_no_cmd register . If 1, stream2mmio blocks input when not in open frame mode, and no command is available. If 0, inputs are just discarded for this situation""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb94d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_num_items_sid2                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_num_items_sid2_type */
	/* skip, unused field unused_stream2mmio_num_items_sid2 (stream2mmio_num_items_sid2) */
	REG_DUMP_PRINT_1("   -stream2mmio_num_items_sid2.stream2mmio_num_items_sid2                      |      0x%04X  |  [RW][15:00]""Stream2mmio num_items register. Indicates the number of words to store for a store_word command. Indicates the number of packets to store for a store packet command. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb94d0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_stride_sid2                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_stride_sid2_type */
	/* skip, unused field unused_stream2mmio_stride_sid2 (stream2mmio_stride_sid2) */
	REG_DUMP_PRINT_1("   -stream2mmio_stride_sid2.stream2mmio_stride_sid2                            |   0x%07X  |  [RW][25:00]""Stream2mmio stride register. Indicates the increment per command in master port words. ""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb94cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_end_address_sid2                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_end_address_sid2_type */
	/* skip, unused field unused_stream2mmio_end_address_sid2 (stream2mmio_end_address_sid2) */
	REG_DUMP_PRINT_1("   -stream2mmio_end_address_sid2.stream2mmio_end_address_sid2                  |   0x%07X  |  [RW][25:00]""Stream2mmio end_address register. Indicates the last address of the memory region the stream2mmio can write to. Address is indicated in master port words""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb94c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_start_address_sid2                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_start_address_sid2_type */
	/* skip, unused field unused_stream2mmio_start_address_sid2 (stream2mmio_start_address_sid2) */
	REG_DUMP_PRINT_1("   -stream2mmio_start_address_sid2.stream2mmio_start_address_sid2              |   0x%07X  |  [RW][25:00]""Stream2mmio start_address register. Indicates the start of the memory region the stream2mmio can write to. Address is indicated in master port words""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb94c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_pix_width_id_sid2                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_pix_width_id_sid2_type */
	/* skip, unused field unused_stream2mmio_pix_width_id_sid2 (stream2mmio_pix_width_id_sid2) */
	REG_DUMP_PRINT_1("   -stream2mmio_pix_width_id_sid2.stream2mmio_pix_width_id_sid2                |         0x%01X  |  [RW][01:00]""Stream2mmio pix_width_id register. If 0, 8 bits pixels will be written out on the master port, if 1, 16 bits pixels will be written out on the master port""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb94a4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_datafield_remap_cfg_sid1                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_datafield_remap_cfg_sid1_type */
	/* skip, unused field unused_stream2mmio_datafield_remap_cfg_sid1 (stream2mmio_datafield_remap_cfg_sid1) */
	REG_DUMP_PRINT_1("   -stream2mmio_datafield_remap_cfg_sid1.stream2mmio_datafield_remap_cfg_sid1  |         0x%01X  |  [RO][02:00]""Datafield remap cfg_sid.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0xb94a0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_sidpid_addr_sid1                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_sidpid_addr_sid1_type */
	/* skip, unused field unused_stream2mmio_sidpid_addr_sid1 (stream2mmio_sidpid_addr_sid1) */
	REG_DUMP_PRINT_1("   -stream2mmio_sidpid_addr_sid1.stream2mmio_sidpid_addr_sid1                  |       0x%03X  |  [RW][11:00]""Identifier code attached to every acknoledgment (MSB side).""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb949c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_ack_base_addr_sid1                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_ack_base_addr_sid1_type */
	/* skip, unused field unused_stream2mmio_ack_base_addr_sid1 (stream2mmio_ack_base_addr_sid1) */
	REG_DUMP_PRINT_1("   -stream2mmio_ack_base_addr_sid1.stream2mmio_ack_base_addr_sid1              |  0x%08X  |  [RW][29:00]""Stream2mmio register address where the ack master  stores its acknowledgment.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb9498);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_block_when_no_cmd_sid1                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_block_when_no_cmd_sid1_type */
	/* skip, unused field unused_stream2mmio_block_when_no_cmd_sid1 (stream2mmio_block_when_no_cmd_sid1) */
	REG_DUMP_PRINT_1("   -stream2mmio_block_when_no_cmd_sid1.stream2mmio_block_when_no_cmd_sid1      |         0x%01X  |  [RW][00:00]""Stream2mmio block_when_no_cmd register . If 1, stream2mmio blocks input when not in open frame mode, and no command is available. If 0, inputs are just discarded for this situation""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb9494);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_num_items_sid1                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_num_items_sid1_type */
	/* skip, unused field unused_stream2mmio_num_items_sid1 (stream2mmio_num_items_sid1) */
	REG_DUMP_PRINT_1("   -stream2mmio_num_items_sid1.stream2mmio_num_items_sid1                      |      0x%04X  |  [RW][15:00]""Stream2mmio num_items register. Indicates the number of words to store for a store_word command. Indicates the number of packets to store for a store packet command. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb9490);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_stride_sid1                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_stride_sid1_type */
	/* skip, unused field unused_stream2mmio_stride_sid1 (stream2mmio_stride_sid1) */
	REG_DUMP_PRINT_1("   -stream2mmio_stride_sid1.stream2mmio_stride_sid1                            |   0x%07X  |  [RW][25:00]""Stream2mmio stride register. Indicates the increment per command in master port words. ""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb948c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_end_address_sid1                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_end_address_sid1_type */
	/* skip, unused field unused_stream2mmio_end_address_sid1 (stream2mmio_end_address_sid1) */
	REG_DUMP_PRINT_1("   -stream2mmio_end_address_sid1.stream2mmio_end_address_sid1                  |   0x%07X  |  [RW][25:00]""Stream2mmio end_address register. Indicates the last address of the memory region the stream2mmio can write to. Address is indicated in master port words""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb9488);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_start_address_sid1                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_start_address_sid1_type */
	/* skip, unused field unused_stream2mmio_start_address_sid1 (stream2mmio_start_address_sid1) */
	REG_DUMP_PRINT_1("   -stream2mmio_start_address_sid1.stream2mmio_start_address_sid1              |   0x%07X  |  [RW][25:00]""Stream2mmio start_address register. Indicates the start of the memory region the stream2mmio can write to. Address is indicated in master port words""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb9484);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_pix_width_id_sid1                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_pix_width_id_sid1_type */
	/* skip, unused field unused_stream2mmio_pix_width_id_sid1 (stream2mmio_pix_width_id_sid1) */
	REG_DUMP_PRINT_1("   -stream2mmio_pix_width_id_sid1.stream2mmio_pix_width_id_sid1                |         0x%01X  |  [RW][01:00]""Stream2mmio pix_width_id register. If 0, 8 bits pixels will be written out on the master port, if 1, 16 bits pixels will be written out on the master port""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb9464);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_datafield_remap_cfg_sid0                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_datafield_remap_cfg_sid0_type */
	/* skip, unused field unused_stream2mmio_datafield_remap_cfg_sid0 (stream2mmio_datafield_remap_cfg_sid0) */
	REG_DUMP_PRINT_1("   -stream2mmio_datafield_remap_cfg_sid0.stream2mmio_datafield_remap_cfg_sid0  |         0x%01X  |  [RO][02:00]""Datafield remap cfg_sid.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0xb9460);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_sidpid_addr_sid0                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_sidpid_addr_sid0_type */
	/* skip, unused field unused_stream2mmio_sidpid_addr_sid0 (stream2mmio_sidpid_addr_sid0) */
	REG_DUMP_PRINT_1("   -stream2mmio_sidpid_addr_sid0.stream2mmio_sidpid_addr_sid0                  |       0x%03X  |  [RW][11:00]""Identifier code attached to every acknoledgment (MSB side).""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb945c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_ack_base_addr_sid0                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_ack_base_addr_sid0_type */
	/* skip, unused field unused_stream2mmio_ack_base_addr_sid0 (stream2mmio_ack_base_addr_sid0) */
	REG_DUMP_PRINT_1("   -stream2mmio_ack_base_addr_sid0.stream2mmio_ack_base_addr_sid0              |  0x%08X  |  [RW][29:00]""Stream2mmio register address where the ack master  stores its acknowledgment.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb9458);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_block_when_no_cmd_sid0                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_block_when_no_cmd_sid0_type */
	/* skip, unused field unused_stream2mmio_block_when_no_cmd_sid0 (stream2mmio_block_when_no_cmd_sid0) */
	REG_DUMP_PRINT_1("   -stream2mmio_block_when_no_cmd_sid0.stream2mmio_block_when_no_cmd_sid0      |         0x%01X  |  [RW][00:00]""Stream2mmio block_when_no_cmd register . If 1, stream2mmio blocks input when not in open frame mode, and no command is available. If 0, inputs are just discarded for this situation""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb9454);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_num_items_sid0                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_num_items_sid0_type */
	/* skip, unused field unused_stream2mmio_num_items_sid0 (stream2mmio_num_items_sid0) */
	REG_DUMP_PRINT_1("   -stream2mmio_num_items_sid0.stream2mmio_num_items_sid0                      |      0x%04X  |  [RW][15:00]""Stream2mmio num_items register. Indicates the number of words to store for a store_word command. Indicates the number of packets to store for a store packet command. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb9450);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_stride_sid0                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_stride_sid0_type */
	/* skip, unused field unused_stream2mmio_stride_sid0 (stream2mmio_stride_sid0) */
	REG_DUMP_PRINT_1("   -stream2mmio_stride_sid0.stream2mmio_stride_sid0                            |   0x%07X  |  [RW][25:00]""Stream2mmio stride register. Indicates the increment per command in master port words. ""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb944c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_end_address_sid0                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_end_address_sid0_type */
	/* skip, unused field unused_stream2mmio_end_address_sid0 (stream2mmio_end_address_sid0) */
	REG_DUMP_PRINT_1("   -stream2mmio_end_address_sid0.stream2mmio_end_address_sid0                  |   0x%07X  |  [RW][25:00]""Stream2mmio end_address register. Indicates the last address of the memory region the stream2mmio can write to. Address is indicated in master port words""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb9448);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_start_address_sid0                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_start_address_sid0_type */
	/* skip, unused field unused_stream2mmio_start_address_sid0 (stream2mmio_start_address_sid0) */
	REG_DUMP_PRINT_1("   -stream2mmio_start_address_sid0.stream2mmio_start_address_sid0              |   0x%07X  |  [RW][25:00]""Stream2mmio start_address register. Indicates the start of the memory region the stream2mmio can write to. Address is indicated in master port words""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb9444);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m1.stream2mmio_pix_width_id_sid0                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m1_stream2mmio_pix_width_id_sid0_type */
	/* skip, unused field unused_stream2mmio_pix_width_id_sid0 (stream2mmio_pix_width_id_sid0) */
	REG_DUMP_PRINT_1("   -stream2mmio_pix_width_id_sid0.stream2mmio_pix_width_id_sid0                |         0x%01X  |  [RW][01:00]""Stream2mmio pix_width_id register. If 0, 8 bits pixels will be written out on the master port, if 1, 16 bits pixels will be written out on the master port""\n", FIELD_VALUE(val, 0, 1));
} /* end soc_pixel_s2m1 */

/* Generated Debug Code: Device soc_pixel_s2m0 */
void ia_css_debug_dump_soc_pixel_s2m0(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xb9124);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_datafield_remap_cfg_sid3                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_datafield_remap_cfg_sid3_type */
	/* skip, unused field unused_stream2mmio_datafield_remap_cfg_sid3 (stream2mmio_datafield_remap_cfg_sid3) */
	REG_DUMP_PRINT_1("   -stream2mmio_datafield_remap_cfg_sid3.stream2mmio_datafield_remap_cfg_sid3  |         0x%01X  |  [RO][02:00]""Datafield remap cfg_sid.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0xb9120);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_sidpid_addr_sid3                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_sidpid_addr_sid3_type */
	/* skip, unused field unused_stream2mmio_sidpid_addr_sid3 (stream2mmio_sidpid_addr_sid3) */
	REG_DUMP_PRINT_1("   -stream2mmio_sidpid_addr_sid3.stream2mmio_sidpid_addr_sid3                  |       0x%03X  |  [RW][11:00]""Identifier code attached to every acknoledgment (MSB side).""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb911c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_ack_base_addr_sid3                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_ack_base_addr_sid3_type */
	/* skip, unused field unused_stream2mmio_ack_base_addr_sid3 (stream2mmio_ack_base_addr_sid3) */
	REG_DUMP_PRINT_1("   -stream2mmio_ack_base_addr_sid3.stream2mmio_ack_base_addr_sid3              |  0x%08X  |  [RW][29:00]""Stream2mmio register address where the ack master  stores its acknowledgment.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb9118);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_block_when_no_cmd_sid3                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_block_when_no_cmd_sid3_type */
	/* skip, unused field unused_stream2mmio_block_when_no_cmd_sid3 (stream2mmio_block_when_no_cmd_sid3) */
	REG_DUMP_PRINT_1("   -stream2mmio_block_when_no_cmd_sid3.stream2mmio_block_when_no_cmd_sid3      |         0x%01X  |  [RW][00:00]""Stream2mmio block_when_no_cmd register . If 1, stream2mmio blocks input when not in open frame mode, and no command is available. If 0, inputs are just discarded for this situation""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb9114);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_num_items_sid3                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_num_items_sid3_type */
	/* skip, unused field unused_stream2mmio_num_items_sid3 (stream2mmio_num_items_sid3) */
	REG_DUMP_PRINT_1("   -stream2mmio_num_items_sid3.stream2mmio_num_items_sid3                      |      0x%04X  |  [RW][15:00]""Stream2mmio num_items register. Indicates the number of words to store for a store_word command. Indicates the number of packets to store for a store packet command. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb9110);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_stride_sid3                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_stride_sid3_type */
	/* skip, unused field unused_stream2mmio_stride_sid3 (stream2mmio_stride_sid3) */
	REG_DUMP_PRINT_1("   -stream2mmio_stride_sid3.stream2mmio_stride_sid3                            |   0x%07X  |  [RW][25:00]""Stream2mmio stride register. Indicates the increment per command in master port words. ""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb910c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_end_address_sid3                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_end_address_sid3_type */
	/* skip, unused field unused_stream2mmio_end_address_sid3 (stream2mmio_end_address_sid3) */
	REG_DUMP_PRINT_1("   -stream2mmio_end_address_sid3.stream2mmio_end_address_sid3                  |   0x%07X  |  [RW][25:00]""Stream2mmio end_address register. Indicates the last address of the memory region the stream2mmio can write to. Address is indicated in master port words""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb9108);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_start_address_sid3                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_start_address_sid3_type */
	/* skip, unused field unused_stream2mmio_start_address_sid3 (stream2mmio_start_address_sid3) */
	REG_DUMP_PRINT_1("   -stream2mmio_start_address_sid3.stream2mmio_start_address_sid3              |   0x%07X  |  [RW][25:00]""Stream2mmio start_address register. Indicates the start of the memory region the stream2mmio can write to. Address is indicated in master port words""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb9104);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_pix_width_id_sid3                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_pix_width_id_sid3_type */
	/* skip, unused field unused_stream2mmio_pix_width_id_sid3 (stream2mmio_pix_width_id_sid3) */
	REG_DUMP_PRINT_1("   -stream2mmio_pix_width_id_sid3.stream2mmio_pix_width_id_sid3                |         0x%01X  |  [RW][01:00]""Stream2mmio pix_width_id register. If 0, 8 bits pixels will be written out on the master port, if 1, 16 bits pixels will be written out on the master port""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb90e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_datafield_remap_cfg_sid2                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_datafield_remap_cfg_sid2_type */
	/* skip, unused field unused_stream2mmio_datafield_remap_cfg_sid2 (stream2mmio_datafield_remap_cfg_sid2) */
	REG_DUMP_PRINT_1("   -stream2mmio_datafield_remap_cfg_sid2.stream2mmio_datafield_remap_cfg_sid2  |         0x%01X  |  [RO][02:00]""Datafield remap cfg_sid.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0xb90e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_sidpid_addr_sid2                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_sidpid_addr_sid2_type */
	/* skip, unused field unused_stream2mmio_sidpid_addr_sid2 (stream2mmio_sidpid_addr_sid2) */
	REG_DUMP_PRINT_1("   -stream2mmio_sidpid_addr_sid2.stream2mmio_sidpid_addr_sid2                  |       0x%03X  |  [RW][11:00]""Identifier code attached to every acknoledgment (MSB side).""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb90dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_ack_base_addr_sid2                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_ack_base_addr_sid2_type */
	/* skip, unused field unused_stream2mmio_ack_base_addr_sid2 (stream2mmio_ack_base_addr_sid2) */
	REG_DUMP_PRINT_1("   -stream2mmio_ack_base_addr_sid2.stream2mmio_ack_base_addr_sid2              |  0x%08X  |  [RW][29:00]""Stream2mmio register address where the ack master  stores its acknowledgment.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb90d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_block_when_no_cmd_sid2                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_block_when_no_cmd_sid2_type */
	/* skip, unused field unused_stream2mmio_block_when_no_cmd_sid2 (stream2mmio_block_when_no_cmd_sid2) */
	REG_DUMP_PRINT_1("   -stream2mmio_block_when_no_cmd_sid2.stream2mmio_block_when_no_cmd_sid2      |         0x%01X  |  [RW][00:00]""Stream2mmio block_when_no_cmd register . If 1, stream2mmio blocks input when not in open frame mode, and no command is available. If 0, inputs are just discarded for this situation""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb90d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_num_items_sid2                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_num_items_sid2_type */
	/* skip, unused field unused_stream2mmio_num_items_sid2 (stream2mmio_num_items_sid2) */
	REG_DUMP_PRINT_1("   -stream2mmio_num_items_sid2.stream2mmio_num_items_sid2                      |      0x%04X  |  [RW][15:00]""Stream2mmio num_items register. Indicates the number of words to store for a store_word command. Indicates the number of packets to store for a store packet command. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb90d0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_stride_sid2                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_stride_sid2_type */
	/* skip, unused field unused_stream2mmio_stride_sid2 (stream2mmio_stride_sid2) */
	REG_DUMP_PRINT_1("   -stream2mmio_stride_sid2.stream2mmio_stride_sid2                            |   0x%07X  |  [RW][25:00]""Stream2mmio stride register. Indicates the increment per command in master port words. ""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb90cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_end_address_sid2                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_end_address_sid2_type */
	/* skip, unused field unused_stream2mmio_end_address_sid2 (stream2mmio_end_address_sid2) */
	REG_DUMP_PRINT_1("   -stream2mmio_end_address_sid2.stream2mmio_end_address_sid2                  |   0x%07X  |  [RW][25:00]""Stream2mmio end_address register. Indicates the last address of the memory region the stream2mmio can write to. Address is indicated in master port words""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb90c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_start_address_sid2                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_start_address_sid2_type */
	/* skip, unused field unused_stream2mmio_start_address_sid2 (stream2mmio_start_address_sid2) */
	REG_DUMP_PRINT_1("   -stream2mmio_start_address_sid2.stream2mmio_start_address_sid2              |   0x%07X  |  [RW][25:00]""Stream2mmio start_address register. Indicates the start of the memory region the stream2mmio can write to. Address is indicated in master port words""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb90c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_pix_width_id_sid2                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_pix_width_id_sid2_type */
	/* skip, unused field unused_stream2mmio_pix_width_id_sid2 (stream2mmio_pix_width_id_sid2) */
	REG_DUMP_PRINT_1("   -stream2mmio_pix_width_id_sid2.stream2mmio_pix_width_id_sid2                |         0x%01X  |  [RW][01:00]""Stream2mmio pix_width_id register. If 0, 8 bits pixels will be written out on the master port, if 1, 16 bits pixels will be written out on the master port""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb90a4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_datafield_remap_cfg_sid1                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_datafield_remap_cfg_sid1_type */
	/* skip, unused field unused_stream2mmio_datafield_remap_cfg_sid1 (stream2mmio_datafield_remap_cfg_sid1) */
	REG_DUMP_PRINT_1("   -stream2mmio_datafield_remap_cfg_sid1.stream2mmio_datafield_remap_cfg_sid1  |         0x%01X  |  [RO][02:00]""Datafield remap cfg_sid.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0xb90a0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_sidpid_addr_sid1                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_sidpid_addr_sid1_type */
	/* skip, unused field unused_stream2mmio_sidpid_addr_sid1 (stream2mmio_sidpid_addr_sid1) */
	REG_DUMP_PRINT_1("   -stream2mmio_sidpid_addr_sid1.stream2mmio_sidpid_addr_sid1                  |       0x%03X  |  [RW][11:00]""Identifier code attached to every acknoledgment (MSB side).""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb909c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_ack_base_addr_sid1                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_ack_base_addr_sid1_type */
	/* skip, unused field unused_stream2mmio_ack_base_addr_sid1 (stream2mmio_ack_base_addr_sid1) */
	REG_DUMP_PRINT_1("   -stream2mmio_ack_base_addr_sid1.stream2mmio_ack_base_addr_sid1              |  0x%08X  |  [RW][29:00]""Stream2mmio register address where the ack master  stores its acknowledgment.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb9098);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_block_when_no_cmd_sid1                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_block_when_no_cmd_sid1_type */
	/* skip, unused field unused_stream2mmio_block_when_no_cmd_sid1 (stream2mmio_block_when_no_cmd_sid1) */
	REG_DUMP_PRINT_1("   -stream2mmio_block_when_no_cmd_sid1.stream2mmio_block_when_no_cmd_sid1      |         0x%01X  |  [RW][00:00]""Stream2mmio block_when_no_cmd register . If 1, stream2mmio blocks input when not in open frame mode, and no command is available. If 0, inputs are just discarded for this situation""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb9094);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_num_items_sid1                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_num_items_sid1_type */
	/* skip, unused field unused_stream2mmio_num_items_sid1 (stream2mmio_num_items_sid1) */
	REG_DUMP_PRINT_1("   -stream2mmio_num_items_sid1.stream2mmio_num_items_sid1                      |      0x%04X  |  [RW][15:00]""Stream2mmio num_items register. Indicates the number of words to store for a store_word command. Indicates the number of packets to store for a store packet command. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb9090);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_stride_sid1                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_stride_sid1_type */
	/* skip, unused field unused_stream2mmio_stride_sid1 (stream2mmio_stride_sid1) */
	REG_DUMP_PRINT_1("   -stream2mmio_stride_sid1.stream2mmio_stride_sid1                            |   0x%07X  |  [RW][25:00]""Stream2mmio stride register. Indicates the increment per command in master port words. ""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb908c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_end_address_sid1                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_end_address_sid1_type */
	/* skip, unused field unused_stream2mmio_end_address_sid1 (stream2mmio_end_address_sid1) */
	REG_DUMP_PRINT_1("   -stream2mmio_end_address_sid1.stream2mmio_end_address_sid1                  |   0x%07X  |  [RW][25:00]""Stream2mmio end_address register. Indicates the last address of the memory region the stream2mmio can write to. Address is indicated in master port words""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb9088);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_start_address_sid1                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_start_address_sid1_type */
	/* skip, unused field unused_stream2mmio_start_address_sid1 (stream2mmio_start_address_sid1) */
	REG_DUMP_PRINT_1("   -stream2mmio_start_address_sid1.stream2mmio_start_address_sid1              |   0x%07X  |  [RW][25:00]""Stream2mmio start_address register. Indicates the start of the memory region the stream2mmio can write to. Address is indicated in master port words""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb9084);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_pix_width_id_sid1                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_pix_width_id_sid1_type */
	/* skip, unused field unused_stream2mmio_pix_width_id_sid1 (stream2mmio_pix_width_id_sid1) */
	REG_DUMP_PRINT_1("   -stream2mmio_pix_width_id_sid1.stream2mmio_pix_width_id_sid1                |         0x%01X  |  [RW][01:00]""Stream2mmio pix_width_id register. If 0, 8 bits pixels will be written out on the master port, if 1, 16 bits pixels will be written out on the master port""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb9064);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_datafield_remap_cfg_sid0                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_datafield_remap_cfg_sid0_type */
	/* skip, unused field unused_stream2mmio_datafield_remap_cfg_sid0 (stream2mmio_datafield_remap_cfg_sid0) */
	REG_DUMP_PRINT_1("   -stream2mmio_datafield_remap_cfg_sid0.stream2mmio_datafield_remap_cfg_sid0  |         0x%01X  |  [RO][02:00]""Datafield remap cfg_sid.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0xb9060);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_sidpid_addr_sid0                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_sidpid_addr_sid0_type */
	/* skip, unused field unused_stream2mmio_sidpid_addr_sid0 (stream2mmio_sidpid_addr_sid0) */
	REG_DUMP_PRINT_1("   -stream2mmio_sidpid_addr_sid0.stream2mmio_sidpid_addr_sid0                  |       0x%03X  |  [RW][11:00]""Identifier code attached to every acknoledgment (MSB side).""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb905c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_ack_base_addr_sid0                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_ack_base_addr_sid0_type */
	/* skip, unused field unused_stream2mmio_ack_base_addr_sid0 (stream2mmio_ack_base_addr_sid0) */
	REG_DUMP_PRINT_1("   -stream2mmio_ack_base_addr_sid0.stream2mmio_ack_base_addr_sid0              |  0x%08X  |  [RW][29:00]""Stream2mmio register address where the ack master  stores its acknowledgment.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb9058);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_block_when_no_cmd_sid0                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_block_when_no_cmd_sid0_type */
	/* skip, unused field unused_stream2mmio_block_when_no_cmd_sid0 (stream2mmio_block_when_no_cmd_sid0) */
	REG_DUMP_PRINT_1("   -stream2mmio_block_when_no_cmd_sid0.stream2mmio_block_when_no_cmd_sid0      |         0x%01X  |  [RW][00:00]""Stream2mmio block_when_no_cmd register . If 1, stream2mmio blocks input when not in open frame mode, and no command is available. If 0, inputs are just discarded for this situation""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb9054);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_num_items_sid0                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_num_items_sid0_type */
	/* skip, unused field unused_stream2mmio_num_items_sid0 (stream2mmio_num_items_sid0) */
	REG_DUMP_PRINT_1("   -stream2mmio_num_items_sid0.stream2mmio_num_items_sid0                      |      0x%04X  |  [RW][15:00]""Stream2mmio num_items register. Indicates the number of words to store for a store_word command. Indicates the number of packets to store for a store packet command. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb9050);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_stride_sid0                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_stride_sid0_type */
	/* skip, unused field unused_stream2mmio_stride_sid0 (stream2mmio_stride_sid0) */
	REG_DUMP_PRINT_1("   -stream2mmio_stride_sid0.stream2mmio_stride_sid0                            |   0x%07X  |  [RW][25:00]""Stream2mmio stride register. Indicates the increment per command in master port words. ""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb904c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_end_address_sid0                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_end_address_sid0_type */
	/* skip, unused field unused_stream2mmio_end_address_sid0 (stream2mmio_end_address_sid0) */
	REG_DUMP_PRINT_1("   -stream2mmio_end_address_sid0.stream2mmio_end_address_sid0                  |   0x%07X  |  [RW][25:00]""Stream2mmio end_address register. Indicates the last address of the memory region the stream2mmio can write to. Address is indicated in master port words""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb9048);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_start_address_sid0                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_start_address_sid0_type */
	/* skip, unused field unused_stream2mmio_start_address_sid0 (stream2mmio_start_address_sid0) */
	REG_DUMP_PRINT_1("   -stream2mmio_start_address_sid0.stream2mmio_start_address_sid0              |   0x%07X  |  [RW][25:00]""Stream2mmio start_address register. Indicates the start of the memory region the stream2mmio can write to. Address is indicated in master port words""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb9044);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  soc_pixel_s2m0.stream2mmio_pix_width_id_sid0                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_soc_pixel_s2m0_stream2mmio_pix_width_id_sid0_type */
	/* skip, unused field unused_stream2mmio_pix_width_id_sid0 (stream2mmio_pix_width_id_sid0) */
	REG_DUMP_PRINT_1("   -stream2mmio_pix_width_id_sid0.stream2mmio_pix_width_id_sid0                |         0x%01X  |  [RW][01:00]""Stream2mmio pix_width_id register. If 0, 8 bits pixels will be written out on the master port, if 1, 16 bits pixels will be written out on the master port""\n", FIELD_VALUE(val, 0, 1));
} /* end soc_pixel_s2m0 */

/* Generated Debug Code: Device str2vec_ack_conv_bayer_1 */
void ia_css_debug_dump_str2vec_ack_conv_bayer_1(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xb8c04);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str2vec_ack_conv_bayer_1.reg_Ack_Addr_Info  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str2vec_ack_conv_bayer_1_reg_Ack_Addr_Info_type */
	REG_DUMP_PRINT_1("   -reg_Ack_Addr_Info.reg_Ack_Addr_Info       |  0x%08X  |  [RW][31:00]""Ack Addr iNFO register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb8c00);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str2vec_ack_conv_bayer_1.reg_Ack_Cmd_Info   |  0x%08X  |  ""Ack cMD iNFO register""\n", val);
/* reg_type: reg_input_system_is_a_logic_str2vec_ack_conv_bayer_1_reg_Ack_Cmd_Info_type */
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.Message                  |     0x%05X  |  [RW][18:00]""""\n", FIELD_VALUE(val, 0, 18));
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.CMD                      |         0x%01X  |  [RO][19:19]""""\n", FIELD_VALUE(val, 19, 19));
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.PID                      |        0x%02X  |  [RW][25:20]""""\n", FIELD_VALUE(val, 20, 25));
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.SID                      |        0x%02X  |  [RW][31:26]""""\n", FIELD_VALUE(val, 26, 31));
} /* end str2vec_ack_conv_bayer_1 */

/* Generated Debug Code: Device str2vec_ack_conv_bayer_0 */
void ia_css_debug_dump_str2vec_ack_conv_bayer_0(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xb8804);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str2vec_ack_conv_bayer_0.reg_Ack_Addr_Info  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str2vec_ack_conv_bayer_0_reg_Ack_Addr_Info_type */
	REG_DUMP_PRINT_1("   -reg_Ack_Addr_Info.reg_Ack_Addr_Info       |  0x%08X  |  [RW][31:00]""Ack Addr iNFO register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb8800);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str2vec_ack_conv_bayer_0.reg_Ack_Cmd_Info   |  0x%08X  |  ""Ack cMD iNFO register""\n", val);
/* reg_type: reg_input_system_is_a_logic_str2vec_ack_conv_bayer_0_reg_Ack_Cmd_Info_type */
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.Message                  |     0x%05X  |  [RW][18:00]""""\n", FIELD_VALUE(val, 0, 18));
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.CMD                      |         0x%01X  |  [RO][19:19]""""\n", FIELD_VALUE(val, 19, 19));
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.PID                      |        0x%02X  |  [RW][25:20]""""\n", FIELD_VALUE(val, 20, 25));
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.SID                      |        0x%02X  |  [RW][31:26]""""\n", FIELD_VALUE(val, 26, 31));
} /* end str2vec_ack_conv_bayer_0 */

/* Generated Debug Code: Device str_to_vec_v2_2_isl_bayer_yuv420_4ppc */
void ia_css_debug_dump_str_to_vec_v2_2_isl_bayer_yuv420_4ppc(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xb84d0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.bayer_mode_en        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_bayer_mode_en_type */
	/* skip, unused field unused_bayer_mode_en (bayer_mode_en) */
	REG_DUMP_PRINT_1("   -bayer_mode_en.bayer_mode_en                              |         0x%01X  |  [RW][00:00]""Bayer mode enable. When bayer_mode_en=1 device is in Bayer mode. When bayer_mode_en=0 device is in YUV420 mode.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb84c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.tracker_status       |  0x%08X  |  ""The status of the tracker""\n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_tracker_status_type */
	/* skip, unused field unused_tracker_status (tracker_status) */
	REG_DUMP_PRINT_1("   -tracker_status.hold_rcv                                  |         0x%01X  |  [RO][00:00]""Hold receiving signal""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -tracker_status.first_half_rcvd                           |         0x%01X  |  [RO][01:01]""First half of vector received""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -tracker_status.vec_full                                  |         0x%01X  |  [RO][02:02]""Full vector (2nd half) received""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -tracker_status.frame_done                                |         0x%01X  |  [RO][03:03]""Frame done""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -tracker_status.give_n_0                                  |         0x%01X  |  [RO][04:04]""Give_n counter is zero""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -tracker_status.vec_avaialble                             |        0x%02X  |  [RO][10:05]""The vectors that are available""\n", FIELD_VALUE(val, 5, 10));
	REG_DUMP_PRINT_1("   -tracker_status.line_done                                 |        0x%02X  |  [RO][16:11]""Last vector of current line""\n", FIELD_VALUE(val, 11, 16));
	val = REG_DUMP_READ_REGISTER(0xb84c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.main_status          |  0x%08X  |  ""The status of the main controller and signals""\n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_main_status_type */
	/* skip, unused field unused_main_status (main_status) */
	REG_DUMP_PRINT_1("   -main_status.main_cntrl_state                             |         0x%01X  |  [RO][00:00]""The state of the main controller""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -main_status.vec_sel                                      |         0x%01X  |  [RO][04:01]""The vector that is selected""\n", FIELD_VALUE(val, 1, 4));
	REG_DUMP_PRINT_1("   -main_status.vec_sel_data                                 |         0x%01X  |  [RO][08:05]""The vector data that is selected""\n", FIELD_VALUE(val, 5, 8));
	REG_DUMP_PRINT_1("   -main_status.vec_sel_addr                                 |         0x%01X  |  [RO][11:09]""The vector address buffer that is selected""\n", FIELD_VALUE(val, 9, 11));
	REG_DUMP_PRINT_1("   -main_status.initialized                                  |         0x%01X  |  [RO][12:12]""Initialized state""\n", FIELD_VALUE(val, 12, 12));
	REG_DUMP_PRINT_1("   -main_status.me_busy                                      |         0x%01X  |  [RO][13:13]""The internal me busy state""\n", FIELD_VALUE(val, 13, 13));
	REG_DUMP_PRINT_1("   -main_status.command_state                                |         0x%01X  |  [RO][16:14]""The state of the command handling""\n", FIELD_VALUE(val, 14, 16));
	val = REG_DUMP_READ_REGISTER(0xb84bc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.ack_status           |  0x%08X  |  ""The status of the acknowledgement controller and FIFO's""\n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_ack_status_type */
	/* skip, unused field unused_ack_status (ack_status) */
	REG_DUMP_PRINT_1("   -ack_status.ack_cntrl_state                               |         0x%01X  |  [RO][01:00]""The state of the acknowlegdement controller""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -ack_status.ret_ack_valid                                 |         0x%01X  |  [RO][02:02]""Return ack valid""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -ack_status.ret_ack_accept                                |         0x%01X  |  [RO][03:03]""Return ack accept""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -ack_status.int_ack_valid                                 |         0x%01X  |  [RO][04:04]""Internal ack wrvalid""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -ack_status.int_ack_accept                                |         0x%01X  |  [RO][05:05]""Internal ack wraccept""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -ack_status.stall_sending                                 |         0x%01X  |  [RO][06:06]""Stall sending vectors""\n", FIELD_VALUE(val, 6, 6));
	val = REG_DUMP_READ_REGISTER(0xb84b8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.io_status            |  0x%08X  |  ""The status of the input and outputs of the device.""\n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_io_status_type */
	REG_DUMP_PRINT_1("   -io_status.out_ack_vld                                    |         0x%01X  |  [RO][00:00]""Out acknowledge valid""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -io_status.out_ack_accept                                 |         0x%01X  |  [RO][01:01]""Out acknowledge accept""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -io_status.pxl_cmpnt_vld                                  |         0x%01X  |  [RO][02:02]""Pixel component stream valid""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -io_status.pxl_cmpnt_accept                               |         0x%01X  |  [RO][03:03]""Pixel component stream accept""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -io_status.cio_mt_cs                                      |         0x%01X  |  [RO][04:04]""CIO Master CS signal""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -io_status.cio_mt_run                                     |         0x%01X  |  [RO][05:05]""CIO Master RUN signal""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -io_status.cio_mt_we_n                                    |         0x%01X  |  [RO][06:06]""CIO Master WE_N signal""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -io_status.cio_mt_addr                                    |   0x%07X  |  [RO][31:07]""CIO master ADDR [upper_bit : lower_bit] (With lower_bit : CEIL(LOG2(BITS_TO_BYTES(master port width))) and upper_bit : lower_bit + 20)""\n", FIELD_VALUE(val, 7, 31));
	val = REG_DUMP_READ_REGISTER(0xb84b4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.lines_done           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_lines_done_type */
	/* skip, unused field unused_lines_done (lines_done) */
	REG_DUMP_PRINT_1("   -lines_done.lines_done                                    |       0x%03X  |  [RO][09:00]""The amount of lines done for the current frame.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb84b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.pxls_cur_line        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_pxls_cur_line_type */
	/* skip, unused field unused_pxls_cur_line (pxls_cur_line) */
	REG_DUMP_PRINT_1("   -pxls_cur_line.pxls_cur_line                              |       0x%03X  |  [RO][11:00]""The amount of pixel components processed so far for the current line.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb84ac);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_5_sts_cur_addr  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_5_sts_cur_addr_type */
	/* skip, unused field unused_buff_5_sts_cur_addr (buff_5_sts_cur_addr) */
	REG_DUMP_PRINT_1("   -buff_5_sts_cur_addr.buff_5_sts_cur_addr                  |   0x%07X  |  [RO][25:00]""The current address of buffer 5.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb84a8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_4_sts_cur_addr  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_4_sts_cur_addr_type */
	/* skip, unused field unused_buff_4_sts_cur_addr (buff_4_sts_cur_addr) */
	REG_DUMP_PRINT_1("   -buff_4_sts_cur_addr.buff_4_sts_cur_addr                  |   0x%07X  |  [RO][25:00]""The current address of buffer 4.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb84a4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_3_sts_cur_addr  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_3_sts_cur_addr_type */
	/* skip, unused field unused_buff_3_sts_cur_addr (buff_3_sts_cur_addr) */
	REG_DUMP_PRINT_1("   -buff_3_sts_cur_addr.buff_3_sts_cur_addr                  |   0x%07X  |  [RO][25:00]""The current address of buffer 3.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb84a0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_2_sts_cur_addr  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_2_sts_cur_addr_type */
	/* skip, unused field unused_buff_2_sts_cur_addr (buff_2_sts_cur_addr) */
	REG_DUMP_PRINT_1("   -buff_2_sts_cur_addr.buff_2_sts_cur_addr                  |   0x%07X  |  [RO][25:00]""The current address of buffer 2.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb849c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_1_sts_cur_addr  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_1_sts_cur_addr_type */
	/* skip, unused field unused_buff_1_sts_cur_addr (buff_1_sts_cur_addr) */
	REG_DUMP_PRINT_1("   -buff_1_sts_cur_addr.buff_1_sts_cur_addr                  |   0x%07X  |  [RO][25:00]""The current address of buffer 1.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8498);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_0_sts_cur_addr  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_0_sts_cur_addr_type */
	/* skip, unused field unused_buff_0_sts_cur_addr (buff_0_sts_cur_addr) */
	REG_DUMP_PRINT_1("   -buff_0_sts_cur_addr.buff_0_sts_cur_addr                  |   0x%07X  |  [RO][25:00]""The current address of buffer 0.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8494);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_5_cfg_stride    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_5_cfg_stride_type */
	/* skip, unused field unused_buff_5_cfg_stride (buff_5_cfg_stride) */
	REG_DUMP_PRINT_1("   -buff_5_cfg_stride.buff_5_cfg_stride                      |   0x%07X  |  [RO][25:00]""The stride for buffer 5.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8490);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_5_cfg_offset_1  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_5_cfg_offset_1_type */
	/* skip, unused field unused_buff_5_cfg_offset_1 (buff_5_cfg_offset_1) */
	REG_DUMP_PRINT_1("   -buff_5_cfg_offset_1.buff_5_cfg_offset_1                  |   0x%07X  |  [RO][25:00]""The offset for buffer 5.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb848c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_5_cfg_offset_0  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_5_cfg_offset_0_type */
	/* skip, unused field unused_buff_5_cfg_offset_0 (buff_5_cfg_offset_0) */
	REG_DUMP_PRINT_1("   -buff_5_cfg_offset_0.buff_5_cfg_offset_0                  |   0x%07X  |  [RO][25:00]""The offset for buffer 5.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8488);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_5_cfg_end_addr  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_5_cfg_end_addr_type */
	/* skip, unused field unused_buff_5_cfg_end_addr (buff_5_cfg_end_addr) */
	REG_DUMP_PRINT_1("   -buff_5_cfg_end_addr.buff_5_cfg_end_addr                  |   0x%07X  |  [RO][25:00]""The end address for buffer 5.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8484);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_5_cfg_st_addr   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_5_cfg_st_addr_type */
	/* skip, unused field unused_buff_5_cfg_st_addr (buff_5_cfg_st_addr) */
	REG_DUMP_PRINT_1("   -buff_5_cfg_st_addr.buff_5_cfg_st_addr                    |   0x%07X  |  [RO][25:00]""The starting address for buffer 5.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8480);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_4_cfg_stride    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_4_cfg_stride_type */
	/* skip, unused field unused_buff_4_cfg_stride (buff_4_cfg_stride) */
	REG_DUMP_PRINT_1("   -buff_4_cfg_stride.buff_4_cfg_stride                      |   0x%07X  |  [RO][25:00]""The stride for buffer 4.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb847c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_4_cfg_offset_1  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_4_cfg_offset_1_type */
	/* skip, unused field unused_buff_4_cfg_offset_1 (buff_4_cfg_offset_1) */
	REG_DUMP_PRINT_1("   -buff_4_cfg_offset_1.buff_4_cfg_offset_1                  |   0x%07X  |  [RO][25:00]""The offset for buffer 4.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8478);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_4_cfg_offset_0  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_4_cfg_offset_0_type */
	/* skip, unused field unused_buff_4_cfg_offset_0 (buff_4_cfg_offset_0) */
	REG_DUMP_PRINT_1("   -buff_4_cfg_offset_0.buff_4_cfg_offset_0                  |   0x%07X  |  [RO][25:00]""The offset for buffer 4.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8474);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_4_cfg_end_addr  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_4_cfg_end_addr_type */
	/* skip, unused field unused_buff_4_cfg_end_addr (buff_4_cfg_end_addr) */
	REG_DUMP_PRINT_1("   -buff_4_cfg_end_addr.buff_4_cfg_end_addr                  |   0x%07X  |  [RO][25:00]""The end address for buffer 4.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8470);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_4_cfg_st_addr   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_4_cfg_st_addr_type */
	/* skip, unused field unused_buff_4_cfg_st_addr (buff_4_cfg_st_addr) */
	REG_DUMP_PRINT_1("   -buff_4_cfg_st_addr.buff_4_cfg_st_addr                    |   0x%07X  |  [RO][25:00]""The starting address for buffer 4.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb846c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_3_cfg_stride    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_3_cfg_stride_type */
	/* skip, unused field unused_buff_3_cfg_stride (buff_3_cfg_stride) */
	REG_DUMP_PRINT_1("   -buff_3_cfg_stride.buff_3_cfg_stride                      |   0x%07X  |  [RW][25:00]""The stride for buffer 3.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8468);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_3_cfg_offset_1  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_3_cfg_offset_1_type */
	/* skip, unused field unused_buff_3_cfg_offset_1 (buff_3_cfg_offset_1) */
	REG_DUMP_PRINT_1("   -buff_3_cfg_offset_1.buff_3_cfg_offset_1                  |   0x%07X  |  [RW][25:00]""The offset for buffer 3.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8464);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_3_cfg_offset_0  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_3_cfg_offset_0_type */
	/* skip, unused field unused_buff_3_cfg_offset_0 (buff_3_cfg_offset_0) */
	REG_DUMP_PRINT_1("   -buff_3_cfg_offset_0.buff_3_cfg_offset_0                  |   0x%07X  |  [RW][25:00]""The offset for buffer 3.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8460);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_3_cfg_end_addr  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_3_cfg_end_addr_type */
	/* skip, unused field unused_buff_3_cfg_end_addr (buff_3_cfg_end_addr) */
	REG_DUMP_PRINT_1("   -buff_3_cfg_end_addr.buff_3_cfg_end_addr                  |   0x%07X  |  [RW][25:00]""The end address for buffer 3.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb845c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_3_cfg_st_addr   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_3_cfg_st_addr_type */
	/* skip, unused field unused_buff_3_cfg_st_addr (buff_3_cfg_st_addr) */
	REG_DUMP_PRINT_1("   -buff_3_cfg_st_addr.buff_3_cfg_st_addr                    |   0x%07X  |  [RW][25:00]""The starting address for buffer 3.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8458);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_2_cfg_stride    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_2_cfg_stride_type */
	/* skip, unused field unused_buff_2_cfg_stride (buff_2_cfg_stride) */
	REG_DUMP_PRINT_1("   -buff_2_cfg_stride.buff_2_cfg_stride                      |   0x%07X  |  [RW][25:00]""The stride for buffer 2.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8454);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_2_cfg_offset_1  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_2_cfg_offset_1_type */
	/* skip, unused field unused_buff_2_cfg_offset_1 (buff_2_cfg_offset_1) */
	REG_DUMP_PRINT_1("   -buff_2_cfg_offset_1.buff_2_cfg_offset_1                  |   0x%07X  |  [RW][25:00]""The offset for buffer 2.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8450);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_2_cfg_offset_0  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_2_cfg_offset_0_type */
	/* skip, unused field unused_buff_2_cfg_offset_0 (buff_2_cfg_offset_0) */
	REG_DUMP_PRINT_1("   -buff_2_cfg_offset_0.buff_2_cfg_offset_0                  |   0x%07X  |  [RW][25:00]""The offset for buffer 2.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb844c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_2_cfg_end_addr  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_2_cfg_end_addr_type */
	/* skip, unused field unused_buff_2_cfg_end_addr (buff_2_cfg_end_addr) */
	REG_DUMP_PRINT_1("   -buff_2_cfg_end_addr.buff_2_cfg_end_addr                  |   0x%07X  |  [RW][25:00]""The end address for buffer 2.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8448);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_2_cfg_st_addr   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_2_cfg_st_addr_type */
	/* skip, unused field unused_buff_2_cfg_st_addr (buff_2_cfg_st_addr) */
	REG_DUMP_PRINT_1("   -buff_2_cfg_st_addr.buff_2_cfg_st_addr                    |   0x%07X  |  [RW][25:00]""The starting address for buffer 2.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8444);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_1_cfg_stride    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_1_cfg_stride_type */
	/* skip, unused field unused_buff_1_cfg_stride (buff_1_cfg_stride) */
	REG_DUMP_PRINT_1("   -buff_1_cfg_stride.buff_1_cfg_stride                      |   0x%07X  |  [RW][25:00]""The stride for buffer 1.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8440);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_1_cfg_offset_1  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_1_cfg_offset_1_type */
	/* skip, unused field unused_buff_1_cfg_offset_1 (buff_1_cfg_offset_1) */
	REG_DUMP_PRINT_1("   -buff_1_cfg_offset_1.buff_1_cfg_offset_1                  |   0x%07X  |  [RW][25:00]""The offset for buffer 1.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb843c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_1_cfg_offset_0  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_1_cfg_offset_0_type */
	/* skip, unused field unused_buff_1_cfg_offset_0 (buff_1_cfg_offset_0) */
	REG_DUMP_PRINT_1("   -buff_1_cfg_offset_0.buff_1_cfg_offset_0                  |   0x%07X  |  [RW][25:00]""The offset for buffer 1.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8438);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_1_cfg_end_addr  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_1_cfg_end_addr_type */
	/* skip, unused field unused_buff_1_cfg_end_addr (buff_1_cfg_end_addr) */
	REG_DUMP_PRINT_1("   -buff_1_cfg_end_addr.buff_1_cfg_end_addr                  |   0x%07X  |  [RW][25:00]""The end address for buffer 1.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8434);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_1_cfg_st_addr   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_1_cfg_st_addr_type */
	/* skip, unused field unused_buff_1_cfg_st_addr (buff_1_cfg_st_addr) */
	REG_DUMP_PRINT_1("   -buff_1_cfg_st_addr.buff_1_cfg_st_addr                    |   0x%07X  |  [RW][25:00]""The starting address for buffer 1.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8430);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_0_cfg_stride    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_0_cfg_stride_type */
	/* skip, unused field unused_buff_0_cfg_stride (buff_0_cfg_stride) */
	REG_DUMP_PRINT_1("   -buff_0_cfg_stride.buff_0_cfg_stride                      |   0x%07X  |  [RW][25:00]""The stride for buffer 0.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb842c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_0_cfg_offset_1  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_0_cfg_offset_1_type */
	/* skip, unused field unused_buff_0_cfg_offset_1 (buff_0_cfg_offset_1) */
	REG_DUMP_PRINT_1("   -buff_0_cfg_offset_1.buff_0_cfg_offset_1                  |   0x%07X  |  [RW][25:00]""The offset for buffer 0.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8428);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_0_cfg_offset_0  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_0_cfg_offset_0_type */
	/* skip, unused field unused_buff_0_cfg_offset_0 (buff_0_cfg_offset_0) */
	REG_DUMP_PRINT_1("   -buff_0_cfg_offset_0.buff_0_cfg_offset_0                  |   0x%07X  |  [RW][25:00]""The offset for buffer 0.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8424);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_0_cfg_end_addr  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_0_cfg_end_addr_type */
	/* skip, unused field unused_buff_0_cfg_end_addr (buff_0_cfg_end_addr) */
	REG_DUMP_PRINT_1("   -buff_0_cfg_end_addr.buff_0_cfg_end_addr                  |   0x%07X  |  [RW][25:00]""The end address for buffer 0.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8420);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.buff_0_cfg_st_addr   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_buff_0_cfg_st_addr_type */
	/* skip, unused field unused_buff_0_cfg_st_addr (buff_0_cfg_st_addr) */
	REG_DUMP_PRINT_1("   -buff_0_cfg_st_addr.buff_0_cfg_st_addr                    |   0x%07X  |  [RW][25:00]""The starting address for buffer 0.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb841c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.irq_false_cmd_val    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_irq_false_cmd_val_type */
	/* skip, unused field unused_irq_false_cmd_val (irq_false_cmd_val) */
	REG_DUMP_PRINT_1("   -irq_false_cmd_val.irq_false_cmd_val                      |         0x%01X  |  [RO][00:00]""The value of the false command after an interrupt; Register with destructive read.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb8418);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.dev_null_en          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_dev_null_en_type */
	/* skip, unused field unused_dev_null_en (dev_null_en) */
	REG_DUMP_PRINT_1("   -dev_null_en.dev_null_en                                  |         0x%01X  |  [RW][00:00]""Discard incoming streaming pixel components instead of stalling when device is not busy (initialized and no frame is done) (default: on)""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb8414);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.interleave_en        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_interleave_en_type */
	/* skip, unused field unused_interleave_en (interleave_en) */
	REG_DUMP_PRINT_1("   -interleave_en.interleave_en                              |         0x%01X  |  [RW][00:00]""Enable interleaving in the outputted vectors when Bayer 2ppc is used (default: off). Instead of 4 vectors with Gr, R, B, and Gb, 2 times 2 vectors of R-Gr-R-Gr... and Gb-B-Gb-B... are used. Only available when Bayer 2PPC is used. ""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb8410);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.yuv420_en            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_yuv420_en_type */
	/* skip, unused field unused_yuv420_en (yuv420_en) */
	REG_DUMP_PRINT_1("   -yuv420_en.yuv420_en                                      |         0x%01X  |  [RO][00:00]""Enable YUV420 when a stream width for YUV422 is used (12 * #pixel_bits) (default: off). Only available when a stream width for YUV422 is used. ""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb840c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.lines_frame          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_lines_frame_type */
	/* skip, unused field unused_lines_frame (lines_frame) */
	REG_DUMP_PRINT_1("   -lines_frame.lines_frame                                  |      0x%04X  |  [RW][15:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb8408);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.pxlcmp_line          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_pxlcmp_line_type */
	/* skip, unused field unused_pxlcmp_line (pxlcmp_line) */
	REG_DUMP_PRINT_1("   -pxlcmp_line.pxlcmp_line                                  |      0x%04X  |  [RW][13:00]""The number of pixel components per line.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb8404);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_yuv420_4ppc.ack_k_vec            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_yuv420_4ppc_ack_k_vec_type */
	/* skip, unused field unused_ack_k_vec (ack_k_vec) */
	REG_DUMP_PRINT_1("   -ack_k_vec.ack_k_vec                                      |       0x%03X  |  [RW][09:00]""Send acknowledge every K vectors that are written.""\n", FIELD_VALUE(val, 0, 9));
} /* end str_to_vec_v2_2_isl_bayer_yuv420_4ppc */

/* Generated Debug Code: Device str_to_vec_v2_2_isl_bayer_4ppc */
void ia_css_debug_dump_str_to_vec_v2_2_isl_bayer_4ppc(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xb80c4);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.tracker_status       |  0x%08X  |  ""The status of the tracker""\n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_tracker_status_type */
	/* skip, unused field unused_tracker_status (tracker_status) */
	REG_DUMP_PRINT_1("   -tracker_status.hold_rcv                           |         0x%01X  |  [RO][00:00]""Hold receiving signal""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -tracker_status.first_half_rcvd                    |         0x%01X  |  [RO][01:01]""First half of vector received""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -tracker_status.vec_full                           |         0x%01X  |  [RO][02:02]""Full vector (2nd half) received""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -tracker_status.frame_done                         |         0x%01X  |  [RO][03:03]""Frame done""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -tracker_status.give_n_0                           |         0x%01X  |  [RO][04:04]""Give_n counter is zero""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -tracker_status.vec_avaialble                      |        0x%02X  |  [RO][10:05]""The vectors that are available""\n", FIELD_VALUE(val, 5, 10));
	REG_DUMP_PRINT_1("   -tracker_status.line_done                          |        0x%02X  |  [RO][16:11]""Last vector of current line""\n", FIELD_VALUE(val, 11, 16));
	val = REG_DUMP_READ_REGISTER(0xb80c0);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.main_status          |  0x%08X  |  ""The status of the main controller and signals""\n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_main_status_type */
	/* skip, unused field unused_main_status (main_status) */
	REG_DUMP_PRINT_1("   -main_status.main_cntrl_state                      |         0x%01X  |  [RO][00:00]""The state of the main controller""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -main_status.vec_sel                               |         0x%01X  |  [RO][04:01]""The vector that is selected""\n", FIELD_VALUE(val, 1, 4));
	REG_DUMP_PRINT_1("   -main_status.vec_sel_data                          |         0x%01X  |  [RO][08:05]""The vector data that is selected""\n", FIELD_VALUE(val, 5, 8));
	REG_DUMP_PRINT_1("   -main_status.vec_sel_addr                          |         0x%01X  |  [RO][11:09]""The vector address buffer that is selected""\n", FIELD_VALUE(val, 9, 11));
	REG_DUMP_PRINT_1("   -main_status.initialized                           |         0x%01X  |  [RO][12:12]""Initialized state""\n", FIELD_VALUE(val, 12, 12));
	REG_DUMP_PRINT_1("   -main_status.me_busy                               |         0x%01X  |  [RO][13:13]""The internal me busy state""\n", FIELD_VALUE(val, 13, 13));
	REG_DUMP_PRINT_1("   -main_status.command_state                         |         0x%01X  |  [RO][16:14]""The state of the command handling""\n", FIELD_VALUE(val, 14, 16));
	val = REG_DUMP_READ_REGISTER(0xb80bc);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.ack_status           |  0x%08X  |  ""The status of the acknowledgement controller and FIFO's""\n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_ack_status_type */
	/* skip, unused field unused_ack_status (ack_status) */
	REG_DUMP_PRINT_1("   -ack_status.ack_cntrl_state                        |         0x%01X  |  [RO][01:00]""The state of the acknowlegdement controller""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -ack_status.ret_ack_valid                          |         0x%01X  |  [RO][02:02]""Return ack valid""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -ack_status.ret_ack_accept                         |         0x%01X  |  [RO][03:03]""Return ack accept""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -ack_status.int_ack_valid                          |         0x%01X  |  [RO][04:04]""Internal ack wrvalid""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -ack_status.int_ack_accept                         |         0x%01X  |  [RO][05:05]""Internal ack wraccept""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -ack_status.stall_sending                          |         0x%01X  |  [RO][06:06]""Stall sending vectors""\n", FIELD_VALUE(val, 6, 6));
	val = REG_DUMP_READ_REGISTER(0xb80b8);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.io_status            |  0x%08X  |  ""The status of the input and outputs of the device.""\n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_io_status_type */
	REG_DUMP_PRINT_1("   -io_status.out_ack_vld                             |         0x%01X  |  [RO][00:00]""Out acknowledge valid""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -io_status.out_ack_accept                          |         0x%01X  |  [RO][01:01]""Out acknowledge accept""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -io_status.pxl_cmpnt_vld                           |         0x%01X  |  [RO][02:02]""Pixel component stream valid""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -io_status.pxl_cmpnt_accept                        |         0x%01X  |  [RO][03:03]""Pixel component stream accept""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -io_status.cio_mt_cs                               |         0x%01X  |  [RO][04:04]""CIO Master CS signal""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -io_status.cio_mt_run                              |         0x%01X  |  [RO][05:05]""CIO Master RUN signal""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -io_status.cio_mt_we_n                             |         0x%01X  |  [RO][06:06]""CIO Master WE_N signal""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -io_status.cio_mt_addr                             |   0x%07X  |  [RO][31:07]""CIO master ADDR [upper_bit : lower_bit] (With lower_bit : CEIL(LOG2(BITS_TO_BYTES(master port width))) and upper_bit : lower_bit + 20)""\n", FIELD_VALUE(val, 7, 31));
	val = REG_DUMP_READ_REGISTER(0xb80b4);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.lines_done           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_lines_done_type */
	/* skip, unused field unused_lines_done (lines_done) */
	REG_DUMP_PRINT_1("   -lines_done.lines_done                             |       0x%03X  |  [RO][09:00]""The amount of lines done for the current frame.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb80b0);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.pxls_cur_line        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_pxls_cur_line_type */
	/* skip, unused field unused_pxls_cur_line (pxls_cur_line) */
	REG_DUMP_PRINT_1("   -pxls_cur_line.pxls_cur_line                       |       0x%03X  |  [RO][11:00]""The amount of pixel components processed so far for the current line.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb80ac);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_5_sts_cur_addr  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_5_sts_cur_addr_type */
	/* skip, unused field unused_buff_5_sts_cur_addr (buff_5_sts_cur_addr) */
	REG_DUMP_PRINT_1("   -buff_5_sts_cur_addr.buff_5_sts_cur_addr           |   0x%07X  |  [RO][25:00]""The current address of buffer 5.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb80a8);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_4_sts_cur_addr  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_4_sts_cur_addr_type */
	/* skip, unused field unused_buff_4_sts_cur_addr (buff_4_sts_cur_addr) */
	REG_DUMP_PRINT_1("   -buff_4_sts_cur_addr.buff_4_sts_cur_addr           |   0x%07X  |  [RO][25:00]""The current address of buffer 4.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb80a4);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_3_sts_cur_addr  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_3_sts_cur_addr_type */
	/* skip, unused field unused_buff_3_sts_cur_addr (buff_3_sts_cur_addr) */
	REG_DUMP_PRINT_1("   -buff_3_sts_cur_addr.buff_3_sts_cur_addr           |   0x%07X  |  [RO][25:00]""The current address of buffer 3.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb80a0);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_2_sts_cur_addr  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_2_sts_cur_addr_type */
	/* skip, unused field unused_buff_2_sts_cur_addr (buff_2_sts_cur_addr) */
	REG_DUMP_PRINT_1("   -buff_2_sts_cur_addr.buff_2_sts_cur_addr           |   0x%07X  |  [RO][25:00]""The current address of buffer 2.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb809c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_1_sts_cur_addr  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_1_sts_cur_addr_type */
	/* skip, unused field unused_buff_1_sts_cur_addr (buff_1_sts_cur_addr) */
	REG_DUMP_PRINT_1("   -buff_1_sts_cur_addr.buff_1_sts_cur_addr           |   0x%07X  |  [RO][25:00]""The current address of buffer 1.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8098);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_0_sts_cur_addr  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_0_sts_cur_addr_type */
	/* skip, unused field unused_buff_0_sts_cur_addr (buff_0_sts_cur_addr) */
	REG_DUMP_PRINT_1("   -buff_0_sts_cur_addr.buff_0_sts_cur_addr           |   0x%07X  |  [RO][25:00]""The current address of buffer 0.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8094);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_5_cfg_stride    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_5_cfg_stride_type */
	/* skip, unused field unused_buff_5_cfg_stride (buff_5_cfg_stride) */
	REG_DUMP_PRINT_1("   -buff_5_cfg_stride.buff_5_cfg_stride               |   0x%07X  |  [RO][25:00]""The stride for buffer 5.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8090);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_5_cfg_offset_1  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_5_cfg_offset_1_type */
	/* skip, unused field unused_buff_5_cfg_offset_1 (buff_5_cfg_offset_1) */
	REG_DUMP_PRINT_1("   -buff_5_cfg_offset_1.buff_5_cfg_offset_1           |   0x%07X  |  [RO][25:00]""The offset for buffer 5.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb808c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_5_cfg_offset_0  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_5_cfg_offset_0_type */
	/* skip, unused field unused_buff_5_cfg_offset_0 (buff_5_cfg_offset_0) */
	REG_DUMP_PRINT_1("   -buff_5_cfg_offset_0.buff_5_cfg_offset_0           |   0x%07X  |  [RO][25:00]""The offset for buffer 5.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8088);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_5_cfg_end_addr  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_5_cfg_end_addr_type */
	/* skip, unused field unused_buff_5_cfg_end_addr (buff_5_cfg_end_addr) */
	REG_DUMP_PRINT_1("   -buff_5_cfg_end_addr.buff_5_cfg_end_addr           |   0x%07X  |  [RO][25:00]""The end address for buffer 5.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8084);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_5_cfg_st_addr   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_5_cfg_st_addr_type */
	/* skip, unused field unused_buff_5_cfg_st_addr (buff_5_cfg_st_addr) */
	REG_DUMP_PRINT_1("   -buff_5_cfg_st_addr.buff_5_cfg_st_addr             |   0x%07X  |  [RO][25:00]""The starting address for buffer 5.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8080);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_4_cfg_stride    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_4_cfg_stride_type */
	/* skip, unused field unused_buff_4_cfg_stride (buff_4_cfg_stride) */
	REG_DUMP_PRINT_1("   -buff_4_cfg_stride.buff_4_cfg_stride               |   0x%07X  |  [RO][25:00]""The stride for buffer 4.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb807c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_4_cfg_offset_1  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_4_cfg_offset_1_type */
	/* skip, unused field unused_buff_4_cfg_offset_1 (buff_4_cfg_offset_1) */
	REG_DUMP_PRINT_1("   -buff_4_cfg_offset_1.buff_4_cfg_offset_1           |   0x%07X  |  [RO][25:00]""The offset for buffer 4.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8078);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_4_cfg_offset_0  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_4_cfg_offset_0_type */
	/* skip, unused field unused_buff_4_cfg_offset_0 (buff_4_cfg_offset_0) */
	REG_DUMP_PRINT_1("   -buff_4_cfg_offset_0.buff_4_cfg_offset_0           |   0x%07X  |  [RO][25:00]""The offset for buffer 4.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8074);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_4_cfg_end_addr  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_4_cfg_end_addr_type */
	/* skip, unused field unused_buff_4_cfg_end_addr (buff_4_cfg_end_addr) */
	REG_DUMP_PRINT_1("   -buff_4_cfg_end_addr.buff_4_cfg_end_addr           |   0x%07X  |  [RO][25:00]""The end address for buffer 4.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8070);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_4_cfg_st_addr   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_4_cfg_st_addr_type */
	/* skip, unused field unused_buff_4_cfg_st_addr (buff_4_cfg_st_addr) */
	REG_DUMP_PRINT_1("   -buff_4_cfg_st_addr.buff_4_cfg_st_addr             |   0x%07X  |  [RO][25:00]""The starting address for buffer 4.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb806c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_3_cfg_stride    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_3_cfg_stride_type */
	/* skip, unused field unused_buff_3_cfg_stride (buff_3_cfg_stride) */
	REG_DUMP_PRINT_1("   -buff_3_cfg_stride.buff_3_cfg_stride               |   0x%07X  |  [RW][25:00]""The stride for buffer 3.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8068);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_3_cfg_offset_1  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_3_cfg_offset_1_type */
	/* skip, unused field unused_buff_3_cfg_offset_1 (buff_3_cfg_offset_1) */
	REG_DUMP_PRINT_1("   -buff_3_cfg_offset_1.buff_3_cfg_offset_1           |   0x%07X  |  [RW][25:00]""The offset for buffer 3.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8064);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_3_cfg_offset_0  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_3_cfg_offset_0_type */
	/* skip, unused field unused_buff_3_cfg_offset_0 (buff_3_cfg_offset_0) */
	REG_DUMP_PRINT_1("   -buff_3_cfg_offset_0.buff_3_cfg_offset_0           |   0x%07X  |  [RW][25:00]""The offset for buffer 3.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8060);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_3_cfg_end_addr  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_3_cfg_end_addr_type */
	/* skip, unused field unused_buff_3_cfg_end_addr (buff_3_cfg_end_addr) */
	REG_DUMP_PRINT_1("   -buff_3_cfg_end_addr.buff_3_cfg_end_addr           |   0x%07X  |  [RW][25:00]""The end address for buffer 3.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb805c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_3_cfg_st_addr   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_3_cfg_st_addr_type */
	/* skip, unused field unused_buff_3_cfg_st_addr (buff_3_cfg_st_addr) */
	REG_DUMP_PRINT_1("   -buff_3_cfg_st_addr.buff_3_cfg_st_addr             |   0x%07X  |  [RW][25:00]""The starting address for buffer 3.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8058);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_2_cfg_stride    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_2_cfg_stride_type */
	/* skip, unused field unused_buff_2_cfg_stride (buff_2_cfg_stride) */
	REG_DUMP_PRINT_1("   -buff_2_cfg_stride.buff_2_cfg_stride               |   0x%07X  |  [RW][25:00]""The stride for buffer 2.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8054);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_2_cfg_offset_1  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_2_cfg_offset_1_type */
	/* skip, unused field unused_buff_2_cfg_offset_1 (buff_2_cfg_offset_1) */
	REG_DUMP_PRINT_1("   -buff_2_cfg_offset_1.buff_2_cfg_offset_1           |   0x%07X  |  [RW][25:00]""The offset for buffer 2.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8050);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_2_cfg_offset_0  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_2_cfg_offset_0_type */
	/* skip, unused field unused_buff_2_cfg_offset_0 (buff_2_cfg_offset_0) */
	REG_DUMP_PRINT_1("   -buff_2_cfg_offset_0.buff_2_cfg_offset_0           |   0x%07X  |  [RW][25:00]""The offset for buffer 2.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb804c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_2_cfg_end_addr  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_2_cfg_end_addr_type */
	/* skip, unused field unused_buff_2_cfg_end_addr (buff_2_cfg_end_addr) */
	REG_DUMP_PRINT_1("   -buff_2_cfg_end_addr.buff_2_cfg_end_addr           |   0x%07X  |  [RW][25:00]""The end address for buffer 2.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8048);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_2_cfg_st_addr   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_2_cfg_st_addr_type */
	/* skip, unused field unused_buff_2_cfg_st_addr (buff_2_cfg_st_addr) */
	REG_DUMP_PRINT_1("   -buff_2_cfg_st_addr.buff_2_cfg_st_addr             |   0x%07X  |  [RW][25:00]""The starting address for buffer 2.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8044);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_1_cfg_stride    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_1_cfg_stride_type */
	/* skip, unused field unused_buff_1_cfg_stride (buff_1_cfg_stride) */
	REG_DUMP_PRINT_1("   -buff_1_cfg_stride.buff_1_cfg_stride               |   0x%07X  |  [RW][25:00]""The stride for buffer 1.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8040);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_1_cfg_offset_1  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_1_cfg_offset_1_type */
	/* skip, unused field unused_buff_1_cfg_offset_1 (buff_1_cfg_offset_1) */
	REG_DUMP_PRINT_1("   -buff_1_cfg_offset_1.buff_1_cfg_offset_1           |   0x%07X  |  [RW][25:00]""The offset for buffer 1.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb803c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_1_cfg_offset_0  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_1_cfg_offset_0_type */
	/* skip, unused field unused_buff_1_cfg_offset_0 (buff_1_cfg_offset_0) */
	REG_DUMP_PRINT_1("   -buff_1_cfg_offset_0.buff_1_cfg_offset_0           |   0x%07X  |  [RW][25:00]""The offset for buffer 1.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8038);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_1_cfg_end_addr  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_1_cfg_end_addr_type */
	/* skip, unused field unused_buff_1_cfg_end_addr (buff_1_cfg_end_addr) */
	REG_DUMP_PRINT_1("   -buff_1_cfg_end_addr.buff_1_cfg_end_addr           |   0x%07X  |  [RW][25:00]""The end address for buffer 1.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8034);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_1_cfg_st_addr   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_1_cfg_st_addr_type */
	/* skip, unused field unused_buff_1_cfg_st_addr (buff_1_cfg_st_addr) */
	REG_DUMP_PRINT_1("   -buff_1_cfg_st_addr.buff_1_cfg_st_addr             |   0x%07X  |  [RW][25:00]""The starting address for buffer 1.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8030);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_0_cfg_stride    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_0_cfg_stride_type */
	/* skip, unused field unused_buff_0_cfg_stride (buff_0_cfg_stride) */
	REG_DUMP_PRINT_1("   -buff_0_cfg_stride.buff_0_cfg_stride               |   0x%07X  |  [RW][25:00]""The stride for buffer 0.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb802c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_0_cfg_offset_1  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_0_cfg_offset_1_type */
	/* skip, unused field unused_buff_0_cfg_offset_1 (buff_0_cfg_offset_1) */
	REG_DUMP_PRINT_1("   -buff_0_cfg_offset_1.buff_0_cfg_offset_1           |   0x%07X  |  [RW][25:00]""The offset for buffer 0.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8028);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_0_cfg_offset_0  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_0_cfg_offset_0_type */
	/* skip, unused field unused_buff_0_cfg_offset_0 (buff_0_cfg_offset_0) */
	REG_DUMP_PRINT_1("   -buff_0_cfg_offset_0.buff_0_cfg_offset_0           |   0x%07X  |  [RW][25:00]""The offset for buffer 0.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8024);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_0_cfg_end_addr  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_0_cfg_end_addr_type */
	/* skip, unused field unused_buff_0_cfg_end_addr (buff_0_cfg_end_addr) */
	REG_DUMP_PRINT_1("   -buff_0_cfg_end_addr.buff_0_cfg_end_addr           |   0x%07X  |  [RW][25:00]""The end address for buffer 0.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb8020);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.buff_0_cfg_st_addr   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_buff_0_cfg_st_addr_type */
	/* skip, unused field unused_buff_0_cfg_st_addr (buff_0_cfg_st_addr) */
	REG_DUMP_PRINT_1("   -buff_0_cfg_st_addr.buff_0_cfg_st_addr             |   0x%07X  |  [RW][25:00]""The starting address for buffer 0.""\n", FIELD_VALUE(val, 0, 25));
	val = REG_DUMP_READ_REGISTER(0xb801c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.irq_false_cmd_val    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_irq_false_cmd_val_type */
	/* skip, unused field unused_irq_false_cmd_val (irq_false_cmd_val) */
	REG_DUMP_PRINT_1("   -irq_false_cmd_val.irq_false_cmd_val               |         0x%01X  |  [RO][00:00]""The value of the false command after an interrupt; Register with destructive read.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb8018);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.dev_null_en          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_dev_null_en_type */
	/* skip, unused field unused_dev_null_en (dev_null_en) */
	REG_DUMP_PRINT_1("   -dev_null_en.dev_null_en                           |         0x%01X  |  [RW][00:00]""Discard incoming streaming pixel components instead of stalling when device is not busy (initialized and no frame is done) (default: on)""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb8014);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.interleave_en        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_interleave_en_type */
	/* skip, unused field unused_interleave_en (interleave_en) */
	REG_DUMP_PRINT_1("   -interleave_en.interleave_en                       |         0x%01X  |  [RW][00:00]""Enable interleaving in the outputted vectors when Bayer 2ppc is used (default: off). Instead of 4 vectors with Gr, R, B, and Gb, 2 times 2 vectors of R-Gr-R-Gr... and Gb-B-Gb-B... are used. Only available when Bayer 2PPC is used. ""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb8010);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.yuv420_en            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_yuv420_en_type */
	/* skip, unused field unused_yuv420_en (yuv420_en) */
	REG_DUMP_PRINT_1("   -yuv420_en.yuv420_en                               |         0x%01X  |  [RO][00:00]""Enable YUV420 when a stream width for YUV422 is used (12 * #pixel_bits) (default: off). Only available when a stream width for YUV422 is used. ""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb800c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.lines_frame          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_lines_frame_type */
	/* skip, unused field unused_lines_frame (lines_frame) */
	REG_DUMP_PRINT_1("   -lines_frame.lines_frame                           |      0x%04X  |  [RW][15:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb8008);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.pxlcmp_line          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_pxlcmp_line_type */
	/* skip, unused field unused_pxlcmp_line (pxlcmp_line) */
	REG_DUMP_PRINT_1("   -pxlcmp_line.pxlcmp_line                           |      0x%04X  |  [RW][13:00]""The number of pixel components per line.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb8004);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  str_to_vec_v2_2_isl_bayer_4ppc.ack_k_vec            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_str_to_vec_v2_2_isl_bayer_4ppc_ack_k_vec_type */
	/* skip, unused field unused_ack_k_vec (ack_k_vec) */
	REG_DUMP_PRINT_1("   -ack_k_vec.ack_k_vec                               |       0x%03X  |  [RW][09:00]""Send acknowledge every K vectors that are written.""\n", FIELD_VALUE(val, 0, 9));
} /* end str_to_vec_v2_2_isl_bayer_4ppc */

/* Generated Debug Code: Device dma */
void ia_css_debug_dump_dma(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xb37f4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal31_lock_status                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal31_lock_status_type */
	/* skip, unused field unused_terminal31_lock_status (terminal31_lock_status) */
	REG_DUMP_PRINT_1("   -terminal31_lock_status.terminal31_lock_status                          |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb37f0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal31_pending_counter                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal31_pending_counter_type */
	/* skip, unused field unused_terminal31_pending_counter (terminal31_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal31_pending_counter.terminal31_pending_counter                  |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb37d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal31_port_mode                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal31_port_mode_type */
	/* skip, unused field unused_terminal31_port_mode (terminal31_port_mode) */
	REG_DUMP_PRINT_1("   -terminal31_port_mode.terminal31_port_mode                              |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb37cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal31_element_setup                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal31_element_setup_type */
	/* skip, unused field unused_terminal31_element_setup (terminal31_element_setup) */
	REG_DUMP_PRINT_1("   -terminal31_element_setup.terminal31_element_setup                      |         0x%01X  |  [RW][00:00]""Specifies the element precision by means of an index into a hardwired LUT containing all unique supported element precisions for the DMA.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb37c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal31_region_stride                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal31_region_stride_type */
	/* skip, unused field unused_terminal31_region_stride (terminal31_region_stride) */
	REG_DUMP_PRINT_1("   -terminal31_region_stride.terminal31_region_stride                      |     0x%05X  |  [RW][16:00]""Specifies the region stride to be used in transferring data to or from the terminal. The region stride is expressed as the byte address offset between consecutive elements across the vertical axis of the region. The value of region stride must be word aligned to the maximum word width across both DMA data masters mA and mB.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xb37c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal31_region_width                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal31_region_width_type */
	/* skip, unused field unused_terminal31_region_width (terminal31_region_width) */
	REG_DUMP_PRINT_1("   -terminal31_region_width.terminal31_region_width                        |      0x%04X  |  [RW][13:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb37c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal31_region_origin                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal31_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal31_region_origin.terminal31_region_origin                      |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb37b4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal30_lock_status                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal30_lock_status_type */
	/* skip, unused field unused_terminal30_lock_status (terminal30_lock_status) */
	REG_DUMP_PRINT_1("   -terminal30_lock_status.terminal30_lock_status                          |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb37b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal30_pending_counter                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal30_pending_counter_type */
	/* skip, unused field unused_terminal30_pending_counter (terminal30_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal30_pending_counter.terminal30_pending_counter                  |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb3794);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal30_port_mode                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal30_port_mode_type */
	/* skip, unused field unused_terminal30_port_mode (terminal30_port_mode) */
	REG_DUMP_PRINT_1("   -terminal30_port_mode.terminal30_port_mode                              |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb378c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal30_element_setup                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal30_element_setup_type */
	/* skip, unused field unused_terminal30_element_setup (terminal30_element_setup) */
	REG_DUMP_PRINT_1("   -terminal30_element_setup.terminal30_element_setup                      |         0x%01X  |  [RW][00:00]""Specifies the element precision by means of an index into a hardwired LUT containing all unique supported element precisions for the DMA.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3788);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal30_region_stride                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal30_region_stride_type */
	/* skip, unused field unused_terminal30_region_stride (terminal30_region_stride) */
	REG_DUMP_PRINT_1("   -terminal30_region_stride.terminal30_region_stride                      |     0x%05X  |  [RW][16:00]""Specifies the region stride to be used in transferring data to or from the terminal. The region stride is expressed as the byte address offset between consecutive elements across the vertical axis of the region. The value of region stride must be word aligned to the maximum word width across both DMA data masters mA and mB.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xb3784);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal30_region_width                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal30_region_width_type */
	/* skip, unused field unused_terminal30_region_width (terminal30_region_width) */
	REG_DUMP_PRINT_1("   -terminal30_region_width.terminal30_region_width                        |      0x%04X  |  [RW][13:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb3780);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal30_region_origin                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal30_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal30_region_origin.terminal30_region_origin                      |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb3774);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal29_lock_status                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal29_lock_status_type */
	/* skip, unused field unused_terminal29_lock_status (terminal29_lock_status) */
	REG_DUMP_PRINT_1("   -terminal29_lock_status.terminal29_lock_status                          |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3770);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal29_pending_counter                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal29_pending_counter_type */
	/* skip, unused field unused_terminal29_pending_counter (terminal29_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal29_pending_counter.terminal29_pending_counter                  |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb3754);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal29_port_mode                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal29_port_mode_type */
	/* skip, unused field unused_terminal29_port_mode (terminal29_port_mode) */
	REG_DUMP_PRINT_1("   -terminal29_port_mode.terminal29_port_mode                              |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb374c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal29_element_setup                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal29_element_setup_type */
	/* skip, unused field unused_terminal29_element_setup (terminal29_element_setup) */
	REG_DUMP_PRINT_1("   -terminal29_element_setup.terminal29_element_setup                      |         0x%01X  |  [RW][00:00]""Specifies the element precision by means of an index into a hardwired LUT containing all unique supported element precisions for the DMA.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3748);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal29_region_stride                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal29_region_stride_type */
	/* skip, unused field unused_terminal29_region_stride (terminal29_region_stride) */
	REG_DUMP_PRINT_1("   -terminal29_region_stride.terminal29_region_stride                      |     0x%05X  |  [RW][16:00]""Specifies the region stride to be used in transferring data to or from the terminal. The region stride is expressed as the byte address offset between consecutive elements across the vertical axis of the region. The value of region stride must be word aligned to the maximum word width across both DMA data masters mA and mB.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xb3744);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal29_region_width                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal29_region_width_type */
	/* skip, unused field unused_terminal29_region_width (terminal29_region_width) */
	REG_DUMP_PRINT_1("   -terminal29_region_width.terminal29_region_width                        |      0x%04X  |  [RW][13:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb3740);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal29_region_origin                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal29_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal29_region_origin.terminal29_region_origin                      |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb3734);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal28_lock_status                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal28_lock_status_type */
	/* skip, unused field unused_terminal28_lock_status (terminal28_lock_status) */
	REG_DUMP_PRINT_1("   -terminal28_lock_status.terminal28_lock_status                          |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3730);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal28_pending_counter                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal28_pending_counter_type */
	/* skip, unused field unused_terminal28_pending_counter (terminal28_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal28_pending_counter.terminal28_pending_counter                  |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb3714);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal28_port_mode                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal28_port_mode_type */
	/* skip, unused field unused_terminal28_port_mode (terminal28_port_mode) */
	REG_DUMP_PRINT_1("   -terminal28_port_mode.terminal28_port_mode                              |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb370c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal28_element_setup                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal28_element_setup_type */
	/* skip, unused field unused_terminal28_element_setup (terminal28_element_setup) */
	REG_DUMP_PRINT_1("   -terminal28_element_setup.terminal28_element_setup                      |         0x%01X  |  [RW][00:00]""Specifies the element precision by means of an index into a hardwired LUT containing all unique supported element precisions for the DMA.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3708);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal28_region_stride                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal28_region_stride_type */
	/* skip, unused field unused_terminal28_region_stride (terminal28_region_stride) */
	REG_DUMP_PRINT_1("   -terminal28_region_stride.terminal28_region_stride                      |     0x%05X  |  [RW][16:00]""Specifies the region stride to be used in transferring data to or from the terminal. The region stride is expressed as the byte address offset between consecutive elements across the vertical axis of the region. The value of region stride must be word aligned to the maximum word width across both DMA data masters mA and mB.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xb3704);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal28_region_width                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal28_region_width_type */
	/* skip, unused field unused_terminal28_region_width (terminal28_region_width) */
	REG_DUMP_PRINT_1("   -terminal28_region_width.terminal28_region_width                        |      0x%04X  |  [RW][13:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb3700);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal28_region_origin                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal28_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal28_region_origin.terminal28_region_origin                      |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb36f4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal27_lock_status                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal27_lock_status_type */
	/* skip, unused field unused_terminal27_lock_status (terminal27_lock_status) */
	REG_DUMP_PRINT_1("   -terminal27_lock_status.terminal27_lock_status                          |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb36f0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal27_pending_counter                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal27_pending_counter_type */
	/* skip, unused field unused_terminal27_pending_counter (terminal27_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal27_pending_counter.terminal27_pending_counter                  |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb36d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal27_port_mode                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal27_port_mode_type */
	/* skip, unused field unused_terminal27_port_mode (terminal27_port_mode) */
	REG_DUMP_PRINT_1("   -terminal27_port_mode.terminal27_port_mode                              |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb36cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal27_element_setup                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal27_element_setup_type */
	/* skip, unused field unused_terminal27_element_setup (terminal27_element_setup) */
	REG_DUMP_PRINT_1("   -terminal27_element_setup.terminal27_element_setup                      |         0x%01X  |  [RW][00:00]""Specifies the element precision by means of an index into a hardwired LUT containing all unique supported element precisions for the DMA.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb36c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal27_region_stride                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal27_region_stride_type */
	/* skip, unused field unused_terminal27_region_stride (terminal27_region_stride) */
	REG_DUMP_PRINT_1("   -terminal27_region_stride.terminal27_region_stride                      |     0x%05X  |  [RW][16:00]""Specifies the region stride to be used in transferring data to or from the terminal. The region stride is expressed as the byte address offset between consecutive elements across the vertical axis of the region. The value of region stride must be word aligned to the maximum word width across both DMA data masters mA and mB.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xb36c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal27_region_width                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal27_region_width_type */
	/* skip, unused field unused_terminal27_region_width (terminal27_region_width) */
	REG_DUMP_PRINT_1("   -terminal27_region_width.terminal27_region_width                        |      0x%04X  |  [RW][13:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb36c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal27_region_origin                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal27_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal27_region_origin.terminal27_region_origin                      |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb36b4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal26_lock_status                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal26_lock_status_type */
	/* skip, unused field unused_terminal26_lock_status (terminal26_lock_status) */
	REG_DUMP_PRINT_1("   -terminal26_lock_status.terminal26_lock_status                          |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb36b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal26_pending_counter                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal26_pending_counter_type */
	/* skip, unused field unused_terminal26_pending_counter (terminal26_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal26_pending_counter.terminal26_pending_counter                  |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb3694);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal26_port_mode                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal26_port_mode_type */
	/* skip, unused field unused_terminal26_port_mode (terminal26_port_mode) */
	REG_DUMP_PRINT_1("   -terminal26_port_mode.terminal26_port_mode                              |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb368c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal26_element_setup                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal26_element_setup_type */
	/* skip, unused field unused_terminal26_element_setup (terminal26_element_setup) */
	REG_DUMP_PRINT_1("   -terminal26_element_setup.terminal26_element_setup                      |         0x%01X  |  [RW][00:00]""Specifies the element precision by means of an index into a hardwired LUT containing all unique supported element precisions for the DMA.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3688);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal26_region_stride                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal26_region_stride_type */
	/* skip, unused field unused_terminal26_region_stride (terminal26_region_stride) */
	REG_DUMP_PRINT_1("   -terminal26_region_stride.terminal26_region_stride                      |     0x%05X  |  [RW][16:00]""Specifies the region stride to be used in transferring data to or from the terminal. The region stride is expressed as the byte address offset between consecutive elements across the vertical axis of the region. The value of region stride must be word aligned to the maximum word width across both DMA data masters mA and mB.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xb3684);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal26_region_width                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal26_region_width_type */
	/* skip, unused field unused_terminal26_region_width (terminal26_region_width) */
	REG_DUMP_PRINT_1("   -terminal26_region_width.terminal26_region_width                        |      0x%04X  |  [RW][13:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb3680);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal26_region_origin                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal26_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal26_region_origin.terminal26_region_origin                      |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb3674);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal25_lock_status                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal25_lock_status_type */
	/* skip, unused field unused_terminal25_lock_status (terminal25_lock_status) */
	REG_DUMP_PRINT_1("   -terminal25_lock_status.terminal25_lock_status                          |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3670);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal25_pending_counter                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal25_pending_counter_type */
	/* skip, unused field unused_terminal25_pending_counter (terminal25_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal25_pending_counter.terminal25_pending_counter                  |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb3654);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal25_port_mode                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal25_port_mode_type */
	/* skip, unused field unused_terminal25_port_mode (terminal25_port_mode) */
	REG_DUMP_PRINT_1("   -terminal25_port_mode.terminal25_port_mode                              |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb364c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal25_element_setup                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal25_element_setup_type */
	/* skip, unused field unused_terminal25_element_setup (terminal25_element_setup) */
	REG_DUMP_PRINT_1("   -terminal25_element_setup.terminal25_element_setup                      |         0x%01X  |  [RW][00:00]""Specifies the element precision by means of an index into a hardwired LUT containing all unique supported element precisions for the DMA.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3648);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal25_region_stride                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal25_region_stride_type */
	/* skip, unused field unused_terminal25_region_stride (terminal25_region_stride) */
	REG_DUMP_PRINT_1("   -terminal25_region_stride.terminal25_region_stride                      |     0x%05X  |  [RW][16:00]""Specifies the region stride to be used in transferring data to or from the terminal. The region stride is expressed as the byte address offset between consecutive elements across the vertical axis of the region. The value of region stride must be word aligned to the maximum word width across both DMA data masters mA and mB.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xb3644);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal25_region_width                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal25_region_width_type */
	/* skip, unused field unused_terminal25_region_width (terminal25_region_width) */
	REG_DUMP_PRINT_1("   -terminal25_region_width.terminal25_region_width                        |      0x%04X  |  [RW][13:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb3640);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal25_region_origin                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal25_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal25_region_origin.terminal25_region_origin                      |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb3634);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal24_lock_status                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal24_lock_status_type */
	/* skip, unused field unused_terminal24_lock_status (terminal24_lock_status) */
	REG_DUMP_PRINT_1("   -terminal24_lock_status.terminal24_lock_status                          |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3630);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal24_pending_counter                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal24_pending_counter_type */
	/* skip, unused field unused_terminal24_pending_counter (terminal24_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal24_pending_counter.terminal24_pending_counter                  |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb3614);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal24_port_mode                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal24_port_mode_type */
	/* skip, unused field unused_terminal24_port_mode (terminal24_port_mode) */
	REG_DUMP_PRINT_1("   -terminal24_port_mode.terminal24_port_mode                              |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb360c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal24_element_setup                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal24_element_setup_type */
	/* skip, unused field unused_terminal24_element_setup (terminal24_element_setup) */
	REG_DUMP_PRINT_1("   -terminal24_element_setup.terminal24_element_setup                      |         0x%01X  |  [RW][00:00]""Specifies the element precision by means of an index into a hardwired LUT containing all unique supported element precisions for the DMA.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3608);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal24_region_stride                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal24_region_stride_type */
	/* skip, unused field unused_terminal24_region_stride (terminal24_region_stride) */
	REG_DUMP_PRINT_1("   -terminal24_region_stride.terminal24_region_stride                      |     0x%05X  |  [RW][16:00]""Specifies the region stride to be used in transferring data to or from the terminal. The region stride is expressed as the byte address offset between consecutive elements across the vertical axis of the region. The value of region stride must be word aligned to the maximum word width across both DMA data masters mA and mB.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xb3604);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal24_region_width                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal24_region_width_type */
	/* skip, unused field unused_terminal24_region_width (terminal24_region_width) */
	REG_DUMP_PRINT_1("   -terminal24_region_width.terminal24_region_width                        |      0x%04X  |  [RW][13:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb3600);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal24_region_origin                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal24_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal24_region_origin.terminal24_region_origin                      |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb35f4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal23_lock_status                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal23_lock_status_type */
	/* skip, unused field unused_terminal23_lock_status (terminal23_lock_status) */
	REG_DUMP_PRINT_1("   -terminal23_lock_status.terminal23_lock_status                          |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb35f0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal23_pending_counter                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal23_pending_counter_type */
	/* skip, unused field unused_terminal23_pending_counter (terminal23_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal23_pending_counter.terminal23_pending_counter                  |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb35d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal23_port_mode                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal23_port_mode_type */
	/* skip, unused field unused_terminal23_port_mode (terminal23_port_mode) */
	REG_DUMP_PRINT_1("   -terminal23_port_mode.terminal23_port_mode                              |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb35cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal23_element_setup                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal23_element_setup_type */
	/* skip, unused field unused_terminal23_element_setup (terminal23_element_setup) */
	REG_DUMP_PRINT_1("   -terminal23_element_setup.terminal23_element_setup                      |         0x%01X  |  [RW][00:00]""Specifies the element precision by means of an index into a hardwired LUT containing all unique supported element precisions for the DMA.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb35c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal23_region_stride                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal23_region_stride_type */
	/* skip, unused field unused_terminal23_region_stride (terminal23_region_stride) */
	REG_DUMP_PRINT_1("   -terminal23_region_stride.terminal23_region_stride                      |     0x%05X  |  [RW][16:00]""Specifies the region stride to be used in transferring data to or from the terminal. The region stride is expressed as the byte address offset between consecutive elements across the vertical axis of the region. The value of region stride must be word aligned to the maximum word width across both DMA data masters mA and mB.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xb35c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal23_region_width                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal23_region_width_type */
	/* skip, unused field unused_terminal23_region_width (terminal23_region_width) */
	REG_DUMP_PRINT_1("   -terminal23_region_width.terminal23_region_width                        |      0x%04X  |  [RW][13:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb35c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal23_region_origin                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal23_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal23_region_origin.terminal23_region_origin                      |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb35b4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal22_lock_status                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal22_lock_status_type */
	/* skip, unused field unused_terminal22_lock_status (terminal22_lock_status) */
	REG_DUMP_PRINT_1("   -terminal22_lock_status.terminal22_lock_status                          |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb35b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal22_pending_counter                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal22_pending_counter_type */
	/* skip, unused field unused_terminal22_pending_counter (terminal22_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal22_pending_counter.terminal22_pending_counter                  |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb3594);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal22_port_mode                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal22_port_mode_type */
	/* skip, unused field unused_terminal22_port_mode (terminal22_port_mode) */
	REG_DUMP_PRINT_1("   -terminal22_port_mode.terminal22_port_mode                              |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb358c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal22_element_setup                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal22_element_setup_type */
	/* skip, unused field unused_terminal22_element_setup (terminal22_element_setup) */
	REG_DUMP_PRINT_1("   -terminal22_element_setup.terminal22_element_setup                      |         0x%01X  |  [RW][00:00]""Specifies the element precision by means of an index into a hardwired LUT containing all unique supported element precisions for the DMA.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3588);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal22_region_stride                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal22_region_stride_type */
	/* skip, unused field unused_terminal22_region_stride (terminal22_region_stride) */
	REG_DUMP_PRINT_1("   -terminal22_region_stride.terminal22_region_stride                      |     0x%05X  |  [RW][16:00]""Specifies the region stride to be used in transferring data to or from the terminal. The region stride is expressed as the byte address offset between consecutive elements across the vertical axis of the region. The value of region stride must be word aligned to the maximum word width across both DMA data masters mA and mB.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xb3584);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal22_region_width                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal22_region_width_type */
	/* skip, unused field unused_terminal22_region_width (terminal22_region_width) */
	REG_DUMP_PRINT_1("   -terminal22_region_width.terminal22_region_width                        |      0x%04X  |  [RW][13:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb3580);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal22_region_origin                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal22_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal22_region_origin.terminal22_region_origin                      |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb3574);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal21_lock_status                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal21_lock_status_type */
	/* skip, unused field unused_terminal21_lock_status (terminal21_lock_status) */
	REG_DUMP_PRINT_1("   -terminal21_lock_status.terminal21_lock_status                          |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3570);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal21_pending_counter                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal21_pending_counter_type */
	/* skip, unused field unused_terminal21_pending_counter (terminal21_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal21_pending_counter.terminal21_pending_counter                  |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb3554);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal21_port_mode                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal21_port_mode_type */
	/* skip, unused field unused_terminal21_port_mode (terminal21_port_mode) */
	REG_DUMP_PRINT_1("   -terminal21_port_mode.terminal21_port_mode                              |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb354c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal21_element_setup                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal21_element_setup_type */
	/* skip, unused field unused_terminal21_element_setup (terminal21_element_setup) */
	REG_DUMP_PRINT_1("   -terminal21_element_setup.terminal21_element_setup                      |         0x%01X  |  [RW][00:00]""Specifies the element precision by means of an index into a hardwired LUT containing all unique supported element precisions for the DMA.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3548);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal21_region_stride                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal21_region_stride_type */
	/* skip, unused field unused_terminal21_region_stride (terminal21_region_stride) */
	REG_DUMP_PRINT_1("   -terminal21_region_stride.terminal21_region_stride                      |     0x%05X  |  [RW][16:00]""Specifies the region stride to be used in transferring data to or from the terminal. The region stride is expressed as the byte address offset between consecutive elements across the vertical axis of the region. The value of region stride must be word aligned to the maximum word width across both DMA data masters mA and mB.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xb3544);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal21_region_width                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal21_region_width_type */
	/* skip, unused field unused_terminal21_region_width (terminal21_region_width) */
	REG_DUMP_PRINT_1("   -terminal21_region_width.terminal21_region_width                        |      0x%04X  |  [RW][13:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb3540);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal21_region_origin                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal21_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal21_region_origin.terminal21_region_origin                      |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb3534);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal20_lock_status                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal20_lock_status_type */
	/* skip, unused field unused_terminal20_lock_status (terminal20_lock_status) */
	REG_DUMP_PRINT_1("   -terminal20_lock_status.terminal20_lock_status                          |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3530);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal20_pending_counter                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal20_pending_counter_type */
	/* skip, unused field unused_terminal20_pending_counter (terminal20_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal20_pending_counter.terminal20_pending_counter                  |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb3514);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal20_port_mode                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal20_port_mode_type */
	/* skip, unused field unused_terminal20_port_mode (terminal20_port_mode) */
	REG_DUMP_PRINT_1("   -terminal20_port_mode.terminal20_port_mode                              |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb350c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal20_element_setup                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal20_element_setup_type */
	/* skip, unused field unused_terminal20_element_setup (terminal20_element_setup) */
	REG_DUMP_PRINT_1("   -terminal20_element_setup.terminal20_element_setup                      |         0x%01X  |  [RW][00:00]""Specifies the element precision by means of an index into a hardwired LUT containing all unique supported element precisions for the DMA.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3508);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal20_region_stride                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal20_region_stride_type */
	/* skip, unused field unused_terminal20_region_stride (terminal20_region_stride) */
	REG_DUMP_PRINT_1("   -terminal20_region_stride.terminal20_region_stride                      |     0x%05X  |  [RW][16:00]""Specifies the region stride to be used in transferring data to or from the terminal. The region stride is expressed as the byte address offset between consecutive elements across the vertical axis of the region. The value of region stride must be word aligned to the maximum word width across both DMA data masters mA and mB.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xb3504);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal20_region_width                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal20_region_width_type */
	/* skip, unused field unused_terminal20_region_width (terminal20_region_width) */
	REG_DUMP_PRINT_1("   -terminal20_region_width.terminal20_region_width                        |      0x%04X  |  [RW][13:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb3500);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal20_region_origin                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal20_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal20_region_origin.terminal20_region_origin                      |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb34f4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal19_lock_status                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal19_lock_status_type */
	/* skip, unused field unused_terminal19_lock_status (terminal19_lock_status) */
	REG_DUMP_PRINT_1("   -terminal19_lock_status.terminal19_lock_status                          |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb34f0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal19_pending_counter                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal19_pending_counter_type */
	/* skip, unused field unused_terminal19_pending_counter (terminal19_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal19_pending_counter.terminal19_pending_counter                  |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb34d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal19_port_mode                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal19_port_mode_type */
	/* skip, unused field unused_terminal19_port_mode (terminal19_port_mode) */
	REG_DUMP_PRINT_1("   -terminal19_port_mode.terminal19_port_mode                              |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb34cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal19_element_setup                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal19_element_setup_type */
	/* skip, unused field unused_terminal19_element_setup (terminal19_element_setup) */
	REG_DUMP_PRINT_1("   -terminal19_element_setup.terminal19_element_setup                      |         0x%01X  |  [RW][00:00]""Specifies the element precision by means of an index into a hardwired LUT containing all unique supported element precisions for the DMA.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb34c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal19_region_stride                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal19_region_stride_type */
	/* skip, unused field unused_terminal19_region_stride (terminal19_region_stride) */
	REG_DUMP_PRINT_1("   -terminal19_region_stride.terminal19_region_stride                      |     0x%05X  |  [RW][16:00]""Specifies the region stride to be used in transferring data to or from the terminal. The region stride is expressed as the byte address offset between consecutive elements across the vertical axis of the region. The value of region stride must be word aligned to the maximum word width across both DMA data masters mA and mB.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xb34c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal19_region_width                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal19_region_width_type */
	/* skip, unused field unused_terminal19_region_width (terminal19_region_width) */
	REG_DUMP_PRINT_1("   -terminal19_region_width.terminal19_region_width                        |      0x%04X  |  [RW][13:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb34c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal19_region_origin                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal19_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal19_region_origin.terminal19_region_origin                      |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb34b4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal18_lock_status                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal18_lock_status_type */
	/* skip, unused field unused_terminal18_lock_status (terminal18_lock_status) */
	REG_DUMP_PRINT_1("   -terminal18_lock_status.terminal18_lock_status                          |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb34b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal18_pending_counter                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal18_pending_counter_type */
	/* skip, unused field unused_terminal18_pending_counter (terminal18_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal18_pending_counter.terminal18_pending_counter                  |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb3494);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal18_port_mode                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal18_port_mode_type */
	/* skip, unused field unused_terminal18_port_mode (terminal18_port_mode) */
	REG_DUMP_PRINT_1("   -terminal18_port_mode.terminal18_port_mode                              |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb348c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal18_element_setup                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal18_element_setup_type */
	/* skip, unused field unused_terminal18_element_setup (terminal18_element_setup) */
	REG_DUMP_PRINT_1("   -terminal18_element_setup.terminal18_element_setup                      |         0x%01X  |  [RW][00:00]""Specifies the element precision by means of an index into a hardwired LUT containing all unique supported element precisions for the DMA.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3488);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal18_region_stride                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal18_region_stride_type */
	/* skip, unused field unused_terminal18_region_stride (terminal18_region_stride) */
	REG_DUMP_PRINT_1("   -terminal18_region_stride.terminal18_region_stride                      |     0x%05X  |  [RW][16:00]""Specifies the region stride to be used in transferring data to or from the terminal. The region stride is expressed as the byte address offset between consecutive elements across the vertical axis of the region. The value of region stride must be word aligned to the maximum word width across both DMA data masters mA and mB.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xb3484);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal18_region_width                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal18_region_width_type */
	/* skip, unused field unused_terminal18_region_width (terminal18_region_width) */
	REG_DUMP_PRINT_1("   -terminal18_region_width.terminal18_region_width                        |      0x%04X  |  [RW][13:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb3480);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal18_region_origin                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal18_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal18_region_origin.terminal18_region_origin                      |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb3474);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal17_lock_status                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal17_lock_status_type */
	/* skip, unused field unused_terminal17_lock_status (terminal17_lock_status) */
	REG_DUMP_PRINT_1("   -terminal17_lock_status.terminal17_lock_status                          |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3470);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal17_pending_counter                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal17_pending_counter_type */
	/* skip, unused field unused_terminal17_pending_counter (terminal17_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal17_pending_counter.terminal17_pending_counter                  |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb3454);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal17_port_mode                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal17_port_mode_type */
	/* skip, unused field unused_terminal17_port_mode (terminal17_port_mode) */
	REG_DUMP_PRINT_1("   -terminal17_port_mode.terminal17_port_mode                              |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb344c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal17_element_setup                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal17_element_setup_type */
	/* skip, unused field unused_terminal17_element_setup (terminal17_element_setup) */
	REG_DUMP_PRINT_1("   -terminal17_element_setup.terminal17_element_setup                      |         0x%01X  |  [RW][00:00]""Specifies the element precision by means of an index into a hardwired LUT containing all unique supported element precisions for the DMA.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3448);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal17_region_stride                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal17_region_stride_type */
	/* skip, unused field unused_terminal17_region_stride (terminal17_region_stride) */
	REG_DUMP_PRINT_1("   -terminal17_region_stride.terminal17_region_stride                      |     0x%05X  |  [RW][16:00]""Specifies the region stride to be used in transferring data to or from the terminal. The region stride is expressed as the byte address offset between consecutive elements across the vertical axis of the region. The value of region stride must be word aligned to the maximum word width across both DMA data masters mA and mB.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xb3444);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal17_region_width                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal17_region_width_type */
	/* skip, unused field unused_terminal17_region_width (terminal17_region_width) */
	REG_DUMP_PRINT_1("   -terminal17_region_width.terminal17_region_width                        |      0x%04X  |  [RW][13:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb3440);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal17_region_origin                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal17_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal17_region_origin.terminal17_region_origin                      |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb3434);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal16_lock_status                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal16_lock_status_type */
	/* skip, unused field unused_terminal16_lock_status (terminal16_lock_status) */
	REG_DUMP_PRINT_1("   -terminal16_lock_status.terminal16_lock_status                          |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3430);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal16_pending_counter                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal16_pending_counter_type */
	/* skip, unused field unused_terminal16_pending_counter (terminal16_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal16_pending_counter.terminal16_pending_counter                  |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb3414);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal16_port_mode                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal16_port_mode_type */
	/* skip, unused field unused_terminal16_port_mode (terminal16_port_mode) */
	REG_DUMP_PRINT_1("   -terminal16_port_mode.terminal16_port_mode                              |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb340c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal16_element_setup                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal16_element_setup_type */
	/* skip, unused field unused_terminal16_element_setup (terminal16_element_setup) */
	REG_DUMP_PRINT_1("   -terminal16_element_setup.terminal16_element_setup                      |         0x%01X  |  [RW][00:00]""Specifies the element precision by means of an index into a hardwired LUT containing all unique supported element precisions for the DMA.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3408);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal16_region_stride                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal16_region_stride_type */
	/* skip, unused field unused_terminal16_region_stride (terminal16_region_stride) */
	REG_DUMP_PRINT_1("   -terminal16_region_stride.terminal16_region_stride                      |     0x%05X  |  [RW][16:00]""Specifies the region stride to be used in transferring data to or from the terminal. The region stride is expressed as the byte address offset between consecutive elements across the vertical axis of the region. The value of region stride must be word aligned to the maximum word width across both DMA data masters mA and mB.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xb3404);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal16_region_width                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal16_region_width_type */
	/* skip, unused field unused_terminal16_region_width (terminal16_region_width) */
	REG_DUMP_PRINT_1("   -terminal16_region_width.terminal16_region_width                        |      0x%04X  |  [RW][13:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb3400);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal16_region_origin                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal16_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal16_region_origin.terminal16_region_origin                      |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb33f4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal15_lock_status                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal15_lock_status_type */
	/* skip, unused field unused_terminal15_lock_status (terminal15_lock_status) */
	REG_DUMP_PRINT_1("   -terminal15_lock_status.terminal15_lock_status                          |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb33f0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal15_pending_counter                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal15_pending_counter_type */
	/* skip, unused field unused_terminal15_pending_counter (terminal15_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal15_pending_counter.terminal15_pending_counter                  |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb33d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal15_port_mode                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal15_port_mode_type */
	/* skip, unused field unused_terminal15_port_mode (terminal15_port_mode) */
	REG_DUMP_PRINT_1("   -terminal15_port_mode.terminal15_port_mode                              |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb33cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal15_element_setup                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal15_element_setup_type */
	/* skip, unused field unused_terminal15_element_setup (terminal15_element_setup) */
	REG_DUMP_PRINT_1("   -terminal15_element_setup.terminal15_element_setup                      |         0x%01X  |  [RW][00:00]""Specifies the element precision by means of an index into a hardwired LUT containing all unique supported element precisions for the DMA.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb33c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal15_region_stride                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal15_region_stride_type */
	/* skip, unused field unused_terminal15_region_stride (terminal15_region_stride) */
	REG_DUMP_PRINT_1("   -terminal15_region_stride.terminal15_region_stride                      |     0x%05X  |  [RW][16:00]""Specifies the region stride to be used in transferring data to or from the terminal. The region stride is expressed as the byte address offset between consecutive elements across the vertical axis of the region. The value of region stride must be word aligned to the maximum word width across both DMA data masters mA and mB.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xb33c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal15_region_width                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal15_region_width_type */
	/* skip, unused field unused_terminal15_region_width (terminal15_region_width) */
	REG_DUMP_PRINT_1("   -terminal15_region_width.terminal15_region_width                        |      0x%04X  |  [RW][13:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb33c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal15_region_origin                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal15_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal15_region_origin.terminal15_region_origin                      |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb33b4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal14_lock_status                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal14_lock_status_type */
	/* skip, unused field unused_terminal14_lock_status (terminal14_lock_status) */
	REG_DUMP_PRINT_1("   -terminal14_lock_status.terminal14_lock_status                          |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb33b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal14_pending_counter                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal14_pending_counter_type */
	/* skip, unused field unused_terminal14_pending_counter (terminal14_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal14_pending_counter.terminal14_pending_counter                  |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb3394);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal14_port_mode                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal14_port_mode_type */
	/* skip, unused field unused_terminal14_port_mode (terminal14_port_mode) */
	REG_DUMP_PRINT_1("   -terminal14_port_mode.terminal14_port_mode                              |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb338c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal14_element_setup                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal14_element_setup_type */
	/* skip, unused field unused_terminal14_element_setup (terminal14_element_setup) */
	REG_DUMP_PRINT_1("   -terminal14_element_setup.terminal14_element_setup                      |         0x%01X  |  [RW][00:00]""Specifies the element precision by means of an index into a hardwired LUT containing all unique supported element precisions for the DMA.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3388);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal14_region_stride                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal14_region_stride_type */
	/* skip, unused field unused_terminal14_region_stride (terminal14_region_stride) */
	REG_DUMP_PRINT_1("   -terminal14_region_stride.terminal14_region_stride                      |     0x%05X  |  [RW][16:00]""Specifies the region stride to be used in transferring data to or from the terminal. The region stride is expressed as the byte address offset between consecutive elements across the vertical axis of the region. The value of region stride must be word aligned to the maximum word width across both DMA data masters mA and mB.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xb3384);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal14_region_width                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal14_region_width_type */
	/* skip, unused field unused_terminal14_region_width (terminal14_region_width) */
	REG_DUMP_PRINT_1("   -terminal14_region_width.terminal14_region_width                        |      0x%04X  |  [RW][13:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb3380);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal14_region_origin                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal14_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal14_region_origin.terminal14_region_origin                      |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb3374);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal13_lock_status                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal13_lock_status_type */
	/* skip, unused field unused_terminal13_lock_status (terminal13_lock_status) */
	REG_DUMP_PRINT_1("   -terminal13_lock_status.terminal13_lock_status                          |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3370);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal13_pending_counter                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal13_pending_counter_type */
	/* skip, unused field unused_terminal13_pending_counter (terminal13_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal13_pending_counter.terminal13_pending_counter                  |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb3354);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal13_port_mode                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal13_port_mode_type */
	/* skip, unused field unused_terminal13_port_mode (terminal13_port_mode) */
	REG_DUMP_PRINT_1("   -terminal13_port_mode.terminal13_port_mode                              |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb334c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal13_element_setup                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal13_element_setup_type */
	/* skip, unused field unused_terminal13_element_setup (terminal13_element_setup) */
	REG_DUMP_PRINT_1("   -terminal13_element_setup.terminal13_element_setup                      |         0x%01X  |  [RW][00:00]""Specifies the element precision by means of an index into a hardwired LUT containing all unique supported element precisions for the DMA.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3348);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal13_region_stride                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal13_region_stride_type */
	/* skip, unused field unused_terminal13_region_stride (terminal13_region_stride) */
	REG_DUMP_PRINT_1("   -terminal13_region_stride.terminal13_region_stride                      |     0x%05X  |  [RW][16:00]""Specifies the region stride to be used in transferring data to or from the terminal. The region stride is expressed as the byte address offset between consecutive elements across the vertical axis of the region. The value of region stride must be word aligned to the maximum word width across both DMA data masters mA and mB.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xb3344);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal13_region_width                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal13_region_width_type */
	/* skip, unused field unused_terminal13_region_width (terminal13_region_width) */
	REG_DUMP_PRINT_1("   -terminal13_region_width.terminal13_region_width                        |      0x%04X  |  [RW][13:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb3340);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal13_region_origin                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal13_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal13_region_origin.terminal13_region_origin                      |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb3334);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal12_lock_status                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal12_lock_status_type */
	/* skip, unused field unused_terminal12_lock_status (terminal12_lock_status) */
	REG_DUMP_PRINT_1("   -terminal12_lock_status.terminal12_lock_status                          |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3330);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal12_pending_counter                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal12_pending_counter_type */
	/* skip, unused field unused_terminal12_pending_counter (terminal12_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal12_pending_counter.terminal12_pending_counter                  |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb3314);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal12_port_mode                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal12_port_mode_type */
	/* skip, unused field unused_terminal12_port_mode (terminal12_port_mode) */
	REG_DUMP_PRINT_1("   -terminal12_port_mode.terminal12_port_mode                              |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb330c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal12_element_setup                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal12_element_setup_type */
	/* skip, unused field unused_terminal12_element_setup (terminal12_element_setup) */
	REG_DUMP_PRINT_1("   -terminal12_element_setup.terminal12_element_setup                      |         0x%01X  |  [RW][00:00]""Specifies the element precision by means of an index into a hardwired LUT containing all unique supported element precisions for the DMA.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3308);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal12_region_stride                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal12_region_stride_type */
	/* skip, unused field unused_terminal12_region_stride (terminal12_region_stride) */
	REG_DUMP_PRINT_1("   -terminal12_region_stride.terminal12_region_stride                      |     0x%05X  |  [RW][16:00]""Specifies the region stride to be used in transferring data to or from the terminal. The region stride is expressed as the byte address offset between consecutive elements across the vertical axis of the region. The value of region stride must be word aligned to the maximum word width across both DMA data masters mA and mB.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xb3304);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal12_region_width                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal12_region_width_type */
	/* skip, unused field unused_terminal12_region_width (terminal12_region_width) */
	REG_DUMP_PRINT_1("   -terminal12_region_width.terminal12_region_width                        |      0x%04X  |  [RW][13:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb3300);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal12_region_origin                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal12_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal12_region_origin.terminal12_region_origin                      |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb32f4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal11_lock_status                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal11_lock_status_type */
	/* skip, unused field unused_terminal11_lock_status (terminal11_lock_status) */
	REG_DUMP_PRINT_1("   -terminal11_lock_status.terminal11_lock_status                          |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb32f0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal11_pending_counter                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal11_pending_counter_type */
	/* skip, unused field unused_terminal11_pending_counter (terminal11_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal11_pending_counter.terminal11_pending_counter                  |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb32d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal11_port_mode                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal11_port_mode_type */
	/* skip, unused field unused_terminal11_port_mode (terminal11_port_mode) */
	REG_DUMP_PRINT_1("   -terminal11_port_mode.terminal11_port_mode                              |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb32cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal11_element_setup                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal11_element_setup_type */
	/* skip, unused field unused_terminal11_element_setup (terminal11_element_setup) */
	REG_DUMP_PRINT_1("   -terminal11_element_setup.terminal11_element_setup                      |         0x%01X  |  [RW][00:00]""Specifies the element precision by means of an index into a hardwired LUT containing all unique supported element precisions for the DMA.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb32c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal11_region_stride                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal11_region_stride_type */
	/* skip, unused field unused_terminal11_region_stride (terminal11_region_stride) */
	REG_DUMP_PRINT_1("   -terminal11_region_stride.terminal11_region_stride                      |     0x%05X  |  [RW][16:00]""Specifies the region stride to be used in transferring data to or from the terminal. The region stride is expressed as the byte address offset between consecutive elements across the vertical axis of the region. The value of region stride must be word aligned to the maximum word width across both DMA data masters mA and mB.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xb32c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal11_region_width                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal11_region_width_type */
	/* skip, unused field unused_terminal11_region_width (terminal11_region_width) */
	REG_DUMP_PRINT_1("   -terminal11_region_width.terminal11_region_width                        |      0x%04X  |  [RW][13:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb32c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal11_region_origin                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal11_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal11_region_origin.terminal11_region_origin                      |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb32b4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal10_lock_status                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal10_lock_status_type */
	/* skip, unused field unused_terminal10_lock_status (terminal10_lock_status) */
	REG_DUMP_PRINT_1("   -terminal10_lock_status.terminal10_lock_status                          |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb32b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal10_pending_counter                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal10_pending_counter_type */
	/* skip, unused field unused_terminal10_pending_counter (terminal10_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal10_pending_counter.terminal10_pending_counter                  |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb3294);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal10_port_mode                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal10_port_mode_type */
	/* skip, unused field unused_terminal10_port_mode (terminal10_port_mode) */
	REG_DUMP_PRINT_1("   -terminal10_port_mode.terminal10_port_mode                              |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb328c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal10_element_setup                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal10_element_setup_type */
	/* skip, unused field unused_terminal10_element_setup (terminal10_element_setup) */
	REG_DUMP_PRINT_1("   -terminal10_element_setup.terminal10_element_setup                      |         0x%01X  |  [RW][00:00]""Specifies the element precision by means of an index into a hardwired LUT containing all unique supported element precisions for the DMA.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3288);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal10_region_stride                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal10_region_stride_type */
	/* skip, unused field unused_terminal10_region_stride (terminal10_region_stride) */
	REG_DUMP_PRINT_1("   -terminal10_region_stride.terminal10_region_stride                      |     0x%05X  |  [RW][16:00]""Specifies the region stride to be used in transferring data to or from the terminal. The region stride is expressed as the byte address offset between consecutive elements across the vertical axis of the region. The value of region stride must be word aligned to the maximum word width across both DMA data masters mA and mB.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xb3284);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal10_region_width                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal10_region_width_type */
	/* skip, unused field unused_terminal10_region_width (terminal10_region_width) */
	REG_DUMP_PRINT_1("   -terminal10_region_width.terminal10_region_width                        |      0x%04X  |  [RW][13:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb3280);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal10_region_origin                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal10_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal10_region_origin.terminal10_region_origin                      |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb3274);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal9_lock_status                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal9_lock_status_type */
	/* skip, unused field unused_terminal9_lock_status (terminal9_lock_status) */
	REG_DUMP_PRINT_1("   -terminal9_lock_status.terminal9_lock_status                            |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3270);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal9_pending_counter                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal9_pending_counter_type */
	/* skip, unused field unused_terminal9_pending_counter (terminal9_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal9_pending_counter.terminal9_pending_counter                    |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb3254);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal9_port_mode                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal9_port_mode_type */
	/* skip, unused field unused_terminal9_port_mode (terminal9_port_mode) */
	REG_DUMP_PRINT_1("   -terminal9_port_mode.terminal9_port_mode                                |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb324c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal9_element_setup                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal9_element_setup_type */
	/* skip, unused field unused_terminal9_element_setup (terminal9_element_setup) */
	REG_DUMP_PRINT_1("   -terminal9_element_setup.terminal9_element_setup                        |         0x%01X  |  [RW][00:00]""Specifies the element precision by means of an index into a hardwired LUT containing all unique supported element precisions for the DMA.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3248);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal9_region_stride                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal9_region_stride_type */
	/* skip, unused field unused_terminal9_region_stride (terminal9_region_stride) */
	REG_DUMP_PRINT_1("   -terminal9_region_stride.terminal9_region_stride                        |     0x%05X  |  [RW][16:00]""Specifies the region stride to be used in transferring data to or from the terminal. The region stride is expressed as the byte address offset between consecutive elements across the vertical axis of the region. The value of region stride must be word aligned to the maximum word width across both DMA data masters mA and mB.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xb3244);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal9_region_width                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal9_region_width_type */
	/* skip, unused field unused_terminal9_region_width (terminal9_region_width) */
	REG_DUMP_PRINT_1("   -terminal9_region_width.terminal9_region_width                          |      0x%04X  |  [RW][13:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb3240);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal9_region_origin                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal9_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal9_region_origin.terminal9_region_origin                        |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb3234);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal8_lock_status                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal8_lock_status_type */
	/* skip, unused field unused_terminal8_lock_status (terminal8_lock_status) */
	REG_DUMP_PRINT_1("   -terminal8_lock_status.terminal8_lock_status                            |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3230);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal8_pending_counter                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal8_pending_counter_type */
	/* skip, unused field unused_terminal8_pending_counter (terminal8_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal8_pending_counter.terminal8_pending_counter                    |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb3214);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal8_port_mode                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal8_port_mode_type */
	/* skip, unused field unused_terminal8_port_mode (terminal8_port_mode) */
	REG_DUMP_PRINT_1("   -terminal8_port_mode.terminal8_port_mode                                |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb320c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal8_element_setup                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal8_element_setup_type */
	/* skip, unused field unused_terminal8_element_setup (terminal8_element_setup) */
	REG_DUMP_PRINT_1("   -terminal8_element_setup.terminal8_element_setup                        |         0x%01X  |  [RW][00:00]""Specifies the element precision by means of an index into a hardwired LUT containing all unique supported element precisions for the DMA.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3208);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal8_region_stride                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal8_region_stride_type */
	/* skip, unused field unused_terminal8_region_stride (terminal8_region_stride) */
	REG_DUMP_PRINT_1("   -terminal8_region_stride.terminal8_region_stride                        |     0x%05X  |  [RW][16:00]""Specifies the region stride to be used in transferring data to or from the terminal. The region stride is expressed as the byte address offset between consecutive elements across the vertical axis of the region. The value of region stride must be word aligned to the maximum word width across both DMA data masters mA and mB.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xb3204);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal8_region_width                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal8_region_width_type */
	/* skip, unused field unused_terminal8_region_width (terminal8_region_width) */
	REG_DUMP_PRINT_1("   -terminal8_region_width.terminal8_region_width                          |      0x%04X  |  [RW][13:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb3200);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal8_region_origin                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal8_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal8_region_origin.terminal8_region_origin                        |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb31f4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal7_lock_status                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal7_lock_status_type */
	/* skip, unused field unused_terminal7_lock_status (terminal7_lock_status) */
	REG_DUMP_PRINT_1("   -terminal7_lock_status.terminal7_lock_status                            |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb31f0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal7_pending_counter                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal7_pending_counter_type */
	/* skip, unused field unused_terminal7_pending_counter (terminal7_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal7_pending_counter.terminal7_pending_counter                    |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb31d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal7_port_mode                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal7_port_mode_type */
	/* skip, unused field unused_terminal7_port_mode (terminal7_port_mode) */
	REG_DUMP_PRINT_1("   -terminal7_port_mode.terminal7_port_mode                                |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb31cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal7_element_setup                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal7_element_setup_type */
	/* skip, unused field unused_terminal7_element_setup (terminal7_element_setup) */
	REG_DUMP_PRINT_1("   -terminal7_element_setup.terminal7_element_setup                        |         0x%01X  |  [RW][00:00]""Specifies the element precision by means of an index into a hardwired LUT containing all unique supported element precisions for the DMA.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb31c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal7_region_stride                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal7_region_stride_type */
	/* skip, unused field unused_terminal7_region_stride (terminal7_region_stride) */
	REG_DUMP_PRINT_1("   -terminal7_region_stride.terminal7_region_stride                        |     0x%05X  |  [RW][16:00]""Specifies the region stride to be used in transferring data to or from the terminal. The region stride is expressed as the byte address offset between consecutive elements across the vertical axis of the region. The value of region stride must be word aligned to the maximum word width across both DMA data masters mA and mB.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xb31c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal7_region_width                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal7_region_width_type */
	/* skip, unused field unused_terminal7_region_width (terminal7_region_width) */
	REG_DUMP_PRINT_1("   -terminal7_region_width.terminal7_region_width                          |      0x%04X  |  [RW][13:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb31c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal7_region_origin                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal7_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal7_region_origin.terminal7_region_origin                        |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb31b4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal6_lock_status                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal6_lock_status_type */
	/* skip, unused field unused_terminal6_lock_status (terminal6_lock_status) */
	REG_DUMP_PRINT_1("   -terminal6_lock_status.terminal6_lock_status                            |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb31b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal6_pending_counter                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal6_pending_counter_type */
	/* skip, unused field unused_terminal6_pending_counter (terminal6_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal6_pending_counter.terminal6_pending_counter                    |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb3194);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal6_port_mode                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal6_port_mode_type */
	/* skip, unused field unused_terminal6_port_mode (terminal6_port_mode) */
	REG_DUMP_PRINT_1("   -terminal6_port_mode.terminal6_port_mode                                |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb318c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal6_element_setup                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal6_element_setup_type */
	/* skip, unused field unused_terminal6_element_setup (terminal6_element_setup) */
	REG_DUMP_PRINT_1("   -terminal6_element_setup.terminal6_element_setup                        |         0x%01X  |  [RW][00:00]""Specifies the element precision by means of an index into a hardwired LUT containing all unique supported element precisions for the DMA.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3188);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal6_region_stride                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal6_region_stride_type */
	/* skip, unused field unused_terminal6_region_stride (terminal6_region_stride) */
	REG_DUMP_PRINT_1("   -terminal6_region_stride.terminal6_region_stride                        |     0x%05X  |  [RW][16:00]""Specifies the region stride to be used in transferring data to or from the terminal. The region stride is expressed as the byte address offset between consecutive elements across the vertical axis of the region. The value of region stride must be word aligned to the maximum word width across both DMA data masters mA and mB.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xb3184);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal6_region_width                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal6_region_width_type */
	/* skip, unused field unused_terminal6_region_width (terminal6_region_width) */
	REG_DUMP_PRINT_1("   -terminal6_region_width.terminal6_region_width                          |      0x%04X  |  [RW][13:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb3180);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal6_region_origin                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal6_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal6_region_origin.terminal6_region_origin                        |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb3174);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal5_lock_status                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal5_lock_status_type */
	/* skip, unused field unused_terminal5_lock_status (terminal5_lock_status) */
	REG_DUMP_PRINT_1("   -terminal5_lock_status.terminal5_lock_status                            |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3170);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal5_pending_counter                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal5_pending_counter_type */
	/* skip, unused field unused_terminal5_pending_counter (terminal5_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal5_pending_counter.terminal5_pending_counter                    |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb3154);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal5_port_mode                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal5_port_mode_type */
	/* skip, unused field unused_terminal5_port_mode (terminal5_port_mode) */
	REG_DUMP_PRINT_1("   -terminal5_port_mode.terminal5_port_mode                                |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb314c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal5_element_setup                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal5_element_setup_type */
	/* skip, unused field unused_terminal5_element_setup (terminal5_element_setup) */
	REG_DUMP_PRINT_1("   -terminal5_element_setup.terminal5_element_setup                        |         0x%01X  |  [RW][00:00]""Specifies the element precision by means of an index into a hardwired LUT containing all unique supported element precisions for the DMA.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3148);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal5_region_stride                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal5_region_stride_type */
	/* skip, unused field unused_terminal5_region_stride (terminal5_region_stride) */
	REG_DUMP_PRINT_1("   -terminal5_region_stride.terminal5_region_stride                        |     0x%05X  |  [RW][16:00]""Specifies the region stride to be used in transferring data to or from the terminal. The region stride is expressed as the byte address offset between consecutive elements across the vertical axis of the region. The value of region stride must be word aligned to the maximum word width across both DMA data masters mA and mB.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xb3144);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal5_region_width                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal5_region_width_type */
	/* skip, unused field unused_terminal5_region_width (terminal5_region_width) */
	REG_DUMP_PRINT_1("   -terminal5_region_width.terminal5_region_width                          |      0x%04X  |  [RW][13:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb3140);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal5_region_origin                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal5_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal5_region_origin.terminal5_region_origin                        |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb3134);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal4_lock_status                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal4_lock_status_type */
	/* skip, unused field unused_terminal4_lock_status (terminal4_lock_status) */
	REG_DUMP_PRINT_1("   -terminal4_lock_status.terminal4_lock_status                            |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3130);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal4_pending_counter                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal4_pending_counter_type */
	/* skip, unused field unused_terminal4_pending_counter (terminal4_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal4_pending_counter.terminal4_pending_counter                    |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb3114);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal4_port_mode                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal4_port_mode_type */
	/* skip, unused field unused_terminal4_port_mode (terminal4_port_mode) */
	REG_DUMP_PRINT_1("   -terminal4_port_mode.terminal4_port_mode                                |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb310c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal4_element_setup                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal4_element_setup_type */
	/* skip, unused field unused_terminal4_element_setup (terminal4_element_setup) */
	REG_DUMP_PRINT_1("   -terminal4_element_setup.terminal4_element_setup                        |         0x%01X  |  [RW][00:00]""Specifies the element precision by means of an index into a hardwired LUT containing all unique supported element precisions for the DMA.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3108);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal4_region_stride                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal4_region_stride_type */
	/* skip, unused field unused_terminal4_region_stride (terminal4_region_stride) */
	REG_DUMP_PRINT_1("   -terminal4_region_stride.terminal4_region_stride                        |     0x%05X  |  [RW][16:00]""Specifies the region stride to be used in transferring data to or from the terminal. The region stride is expressed as the byte address offset between consecutive elements across the vertical axis of the region. The value of region stride must be word aligned to the maximum word width across both DMA data masters mA and mB.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xb3104);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal4_region_width                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal4_region_width_type */
	/* skip, unused field unused_terminal4_region_width (terminal4_region_width) */
	REG_DUMP_PRINT_1("   -terminal4_region_width.terminal4_region_width                          |      0x%04X  |  [RW][13:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb3100);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal4_region_origin                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal4_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal4_region_origin.terminal4_region_origin                        |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb30f4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal3_lock_status                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal3_lock_status_type */
	/* skip, unused field unused_terminal3_lock_status (terminal3_lock_status) */
	REG_DUMP_PRINT_1("   -terminal3_lock_status.terminal3_lock_status                            |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb30f0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal3_pending_counter                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal3_pending_counter_type */
	/* skip, unused field unused_terminal3_pending_counter (terminal3_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal3_pending_counter.terminal3_pending_counter                    |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb30d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal3_port_mode                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal3_port_mode_type */
	/* skip, unused field unused_terminal3_port_mode (terminal3_port_mode) */
	REG_DUMP_PRINT_1("   -terminal3_port_mode.terminal3_port_mode                                |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb30cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal3_element_setup                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal3_element_setup_type */
	/* skip, unused field unused_terminal3_element_setup (terminal3_element_setup) */
	REG_DUMP_PRINT_1("   -terminal3_element_setup.terminal3_element_setup                        |         0x%01X  |  [RW][00:00]""Specifies the element precision by means of an index into a hardwired LUT containing all unique supported element precisions for the DMA.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb30c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal3_region_stride                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal3_region_stride_type */
	/* skip, unused field unused_terminal3_region_stride (terminal3_region_stride) */
	REG_DUMP_PRINT_1("   -terminal3_region_stride.terminal3_region_stride                        |     0x%05X  |  [RW][16:00]""Specifies the region stride to be used in transferring data to or from the terminal. The region stride is expressed as the byte address offset between consecutive elements across the vertical axis of the region. The value of region stride must be word aligned to the maximum word width across both DMA data masters mA and mB.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xb30c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal3_region_width                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal3_region_width_type */
	/* skip, unused field unused_terminal3_region_width (terminal3_region_width) */
	REG_DUMP_PRINT_1("   -terminal3_region_width.terminal3_region_width                          |      0x%04X  |  [RW][13:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb30c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal3_region_origin                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal3_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal3_region_origin.terminal3_region_origin                        |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb30b4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal2_lock_status                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal2_lock_status_type */
	/* skip, unused field unused_terminal2_lock_status (terminal2_lock_status) */
	REG_DUMP_PRINT_1("   -terminal2_lock_status.terminal2_lock_status                            |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb30b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal2_pending_counter                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal2_pending_counter_type */
	/* skip, unused field unused_terminal2_pending_counter (terminal2_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal2_pending_counter.terminal2_pending_counter                    |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb3094);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal2_port_mode                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal2_port_mode_type */
	/* skip, unused field unused_terminal2_port_mode (terminal2_port_mode) */
	REG_DUMP_PRINT_1("   -terminal2_port_mode.terminal2_port_mode                                |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb308c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal2_element_setup                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal2_element_setup_type */
	/* skip, unused field unused_terminal2_element_setup (terminal2_element_setup) */
	REG_DUMP_PRINT_1("   -terminal2_element_setup.terminal2_element_setup                        |         0x%01X  |  [RW][00:00]""Specifies the element precision by means of an index into a hardwired LUT containing all unique supported element precisions for the DMA.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3088);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal2_region_stride                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal2_region_stride_type */
	/* skip, unused field unused_terminal2_region_stride (terminal2_region_stride) */
	REG_DUMP_PRINT_1("   -terminal2_region_stride.terminal2_region_stride                        |     0x%05X  |  [RW][16:00]""Specifies the region stride to be used in transferring data to or from the terminal. The region stride is expressed as the byte address offset between consecutive elements across the vertical axis of the region. The value of region stride must be word aligned to the maximum word width across both DMA data masters mA and mB.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xb3084);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal2_region_width                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal2_region_width_type */
	/* skip, unused field unused_terminal2_region_width (terminal2_region_width) */
	REG_DUMP_PRINT_1("   -terminal2_region_width.terminal2_region_width                          |      0x%04X  |  [RW][13:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb3080);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal2_region_origin                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal2_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal2_region_origin.terminal2_region_origin                        |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb3074);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal1_lock_status                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal1_lock_status_type */
	/* skip, unused field unused_terminal1_lock_status (terminal1_lock_status) */
	REG_DUMP_PRINT_1("   -terminal1_lock_status.terminal1_lock_status                            |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3070);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal1_pending_counter                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal1_pending_counter_type */
	/* skip, unused field unused_terminal1_pending_counter (terminal1_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal1_pending_counter.terminal1_pending_counter                    |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb3054);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal1_port_mode                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal1_port_mode_type */
	/* skip, unused field unused_terminal1_port_mode (terminal1_port_mode) */
	REG_DUMP_PRINT_1("   -terminal1_port_mode.terminal1_port_mode                                |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb304c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal1_element_setup                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal1_element_setup_type */
	/* skip, unused field unused_terminal1_element_setup (terminal1_element_setup) */
	REG_DUMP_PRINT_1("   -terminal1_element_setup.terminal1_element_setup                        |         0x%01X  |  [RW][00:00]""Specifies the element precision by means of an index into a hardwired LUT containing all unique supported element precisions for the DMA.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3048);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal1_region_stride                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal1_region_stride_type */
	/* skip, unused field unused_terminal1_region_stride (terminal1_region_stride) */
	REG_DUMP_PRINT_1("   -terminal1_region_stride.terminal1_region_stride                        |     0x%05X  |  [RW][16:00]""Specifies the region stride to be used in transferring data to or from the terminal. The region stride is expressed as the byte address offset between consecutive elements across the vertical axis of the region. The value of region stride must be word aligned to the maximum word width across both DMA data masters mA and mB.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xb3044);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal1_region_width                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal1_region_width_type */
	/* skip, unused field unused_terminal1_region_width (terminal1_region_width) */
	REG_DUMP_PRINT_1("   -terminal1_region_width.terminal1_region_width                          |      0x%04X  |  [RW][13:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb3040);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal1_region_origin                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal1_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal1_region_origin.terminal1_region_origin                        |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb3034);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal0_lock_status                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal0_lock_status_type */
	/* skip, unused field unused_terminal0_lock_status (terminal0_lock_status) */
	REG_DUMP_PRINT_1("   -terminal0_lock_status.terminal0_lock_status                            |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3030);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal0_pending_counter                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal0_pending_counter_type */
	/* skip, unused field unused_terminal0_pending_counter (terminal0_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal0_pending_counter.terminal0_pending_counter                    |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb3014);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal0_port_mode                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal0_port_mode_type */
	/* skip, unused field unused_terminal0_port_mode (terminal0_port_mode) */
	REG_DUMP_PRINT_1("   -terminal0_port_mode.terminal0_port_mode                                |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb300c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal0_element_setup                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal0_element_setup_type */
	/* skip, unused field unused_terminal0_element_setup (terminal0_element_setup) */
	REG_DUMP_PRINT_1("   -terminal0_element_setup.terminal0_element_setup                        |         0x%01X  |  [RW][00:00]""Specifies the element precision by means of an index into a hardwired LUT containing all unique supported element precisions for the DMA.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb3008);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal0_region_stride                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal0_region_stride_type */
	/* skip, unused field unused_terminal0_region_stride (terminal0_region_stride) */
	REG_DUMP_PRINT_1("   -terminal0_region_stride.terminal0_region_stride                        |     0x%05X  |  [RW][16:00]""Specifies the region stride to be used in transferring data to or from the terminal. The region stride is expressed as the byte address offset between consecutive elements across the vertical axis of the region. The value of region stride must be word aligned to the maximum word width across both DMA data masters mA and mB.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0xb3004);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal0_region_width                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal0_region_width_type */
	/* skip, unused field unused_terminal0_region_width (terminal0_region_width) */
	REG_DUMP_PRINT_1("   -terminal0_region_width.terminal0_region_width                          |      0x%04X  |  [RW][13:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb3000);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal0_region_origin                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal0_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal0_region_origin.terminal0_region_origin                        |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb2bf4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit15_lock_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit15_lock_status_type */
	/* skip, unused field unused_unit15_lock_status (unit15_lock_status) */
	REG_DUMP_PRINT_1("   -unit15_lock_status.unit15_lock_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2bf0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit15_pending_counter                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit15_pending_counter_type */
	/* skip, unused field unused_unit15_pending_counter (unit15_pending_counter) */
	REG_DUMP_PRINT_1("   -unit15_pending_counter.unit15_pending_counter                          |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2bc4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit15_unit_height                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit15_unit_height_type */
	/* skip, unused field unused_unit15_unit_height (unit15_unit_height) */
	REG_DUMP_PRINT_1("   -unit15_unit_height.unit15_unit_height                                  |         0x%01X  |  [RW][01:00]""Register holding the unit height field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2bc0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit15_unit_width                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit15_unit_width_type */
	/* skip, unused field unused_unit15_unit_width (unit15_unit_width) */
	REG_DUMP_PRINT_1("   -unit15_unit_width.unit15_unit_width                                    |      0x%04X  |  [RW][12:00]""Register holding the unit width field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2bb4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit14_lock_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit14_lock_status_type */
	/* skip, unused field unused_unit14_lock_status (unit14_lock_status) */
	REG_DUMP_PRINT_1("   -unit14_lock_status.unit14_lock_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2bb0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit14_pending_counter                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit14_pending_counter_type */
	/* skip, unused field unused_unit14_pending_counter (unit14_pending_counter) */
	REG_DUMP_PRINT_1("   -unit14_pending_counter.unit14_pending_counter                          |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2b84);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit14_unit_height                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit14_unit_height_type */
	/* skip, unused field unused_unit14_unit_height (unit14_unit_height) */
	REG_DUMP_PRINT_1("   -unit14_unit_height.unit14_unit_height                                  |         0x%01X  |  [RW][01:00]""Register holding the unit height field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2b80);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit14_unit_width                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit14_unit_width_type */
	/* skip, unused field unused_unit14_unit_width (unit14_unit_width) */
	REG_DUMP_PRINT_1("   -unit14_unit_width.unit14_unit_width                                    |      0x%04X  |  [RW][12:00]""Register holding the unit width field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2b74);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit13_lock_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit13_lock_status_type */
	/* skip, unused field unused_unit13_lock_status (unit13_lock_status) */
	REG_DUMP_PRINT_1("   -unit13_lock_status.unit13_lock_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2b70);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit13_pending_counter                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit13_pending_counter_type */
	/* skip, unused field unused_unit13_pending_counter (unit13_pending_counter) */
	REG_DUMP_PRINT_1("   -unit13_pending_counter.unit13_pending_counter                          |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2b44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit13_unit_height                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit13_unit_height_type */
	/* skip, unused field unused_unit13_unit_height (unit13_unit_height) */
	REG_DUMP_PRINT_1("   -unit13_unit_height.unit13_unit_height                                  |         0x%01X  |  [RW][01:00]""Register holding the unit height field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2b40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit13_unit_width                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit13_unit_width_type */
	/* skip, unused field unused_unit13_unit_width (unit13_unit_width) */
	REG_DUMP_PRINT_1("   -unit13_unit_width.unit13_unit_width                                    |      0x%04X  |  [RW][12:00]""Register holding the unit width field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2b34);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit12_lock_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit12_lock_status_type */
	/* skip, unused field unused_unit12_lock_status (unit12_lock_status) */
	REG_DUMP_PRINT_1("   -unit12_lock_status.unit12_lock_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2b30);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit12_pending_counter                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit12_pending_counter_type */
	/* skip, unused field unused_unit12_pending_counter (unit12_pending_counter) */
	REG_DUMP_PRINT_1("   -unit12_pending_counter.unit12_pending_counter                          |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2b04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit12_unit_height                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit12_unit_height_type */
	/* skip, unused field unused_unit12_unit_height (unit12_unit_height) */
	REG_DUMP_PRINT_1("   -unit12_unit_height.unit12_unit_height                                  |         0x%01X  |  [RW][01:00]""Register holding the unit height field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2b00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit12_unit_width                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit12_unit_width_type */
	/* skip, unused field unused_unit12_unit_width (unit12_unit_width) */
	REG_DUMP_PRINT_1("   -unit12_unit_width.unit12_unit_width                                    |      0x%04X  |  [RW][12:00]""Register holding the unit width field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2af4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit11_lock_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit11_lock_status_type */
	/* skip, unused field unused_unit11_lock_status (unit11_lock_status) */
	REG_DUMP_PRINT_1("   -unit11_lock_status.unit11_lock_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2af0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit11_pending_counter                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit11_pending_counter_type */
	/* skip, unused field unused_unit11_pending_counter (unit11_pending_counter) */
	REG_DUMP_PRINT_1("   -unit11_pending_counter.unit11_pending_counter                          |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2ac4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit11_unit_height                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit11_unit_height_type */
	/* skip, unused field unused_unit11_unit_height (unit11_unit_height) */
	REG_DUMP_PRINT_1("   -unit11_unit_height.unit11_unit_height                                  |         0x%01X  |  [RW][01:00]""Register holding the unit height field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2ac0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit11_unit_width                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit11_unit_width_type */
	/* skip, unused field unused_unit11_unit_width (unit11_unit_width) */
	REG_DUMP_PRINT_1("   -unit11_unit_width.unit11_unit_width                                    |      0x%04X  |  [RW][12:00]""Register holding the unit width field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2ab4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit10_lock_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit10_lock_status_type */
	/* skip, unused field unused_unit10_lock_status (unit10_lock_status) */
	REG_DUMP_PRINT_1("   -unit10_lock_status.unit10_lock_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2ab0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit10_pending_counter                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit10_pending_counter_type */
	/* skip, unused field unused_unit10_pending_counter (unit10_pending_counter) */
	REG_DUMP_PRINT_1("   -unit10_pending_counter.unit10_pending_counter                          |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2a84);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit10_unit_height                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit10_unit_height_type */
	/* skip, unused field unused_unit10_unit_height (unit10_unit_height) */
	REG_DUMP_PRINT_1("   -unit10_unit_height.unit10_unit_height                                  |         0x%01X  |  [RW][01:00]""Register holding the unit height field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2a80);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit10_unit_width                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit10_unit_width_type */
	/* skip, unused field unused_unit10_unit_width (unit10_unit_width) */
	REG_DUMP_PRINT_1("   -unit10_unit_width.unit10_unit_width                                    |      0x%04X  |  [RW][12:00]""Register holding the unit width field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2a74);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit9_lock_status                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit9_lock_status_type */
	/* skip, unused field unused_unit9_lock_status (unit9_lock_status) */
	REG_DUMP_PRINT_1("   -unit9_lock_status.unit9_lock_status                                    |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2a70);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit9_pending_counter                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit9_pending_counter_type */
	/* skip, unused field unused_unit9_pending_counter (unit9_pending_counter) */
	REG_DUMP_PRINT_1("   -unit9_pending_counter.unit9_pending_counter                            |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2a44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit9_unit_height                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit9_unit_height_type */
	/* skip, unused field unused_unit9_unit_height (unit9_unit_height) */
	REG_DUMP_PRINT_1("   -unit9_unit_height.unit9_unit_height                                    |         0x%01X  |  [RW][01:00]""Register holding the unit height field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2a40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit9_unit_width                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit9_unit_width_type */
	/* skip, unused field unused_unit9_unit_width (unit9_unit_width) */
	REG_DUMP_PRINT_1("   -unit9_unit_width.unit9_unit_width                                      |      0x%04X  |  [RW][12:00]""Register holding the unit width field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2a34);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit8_lock_status                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit8_lock_status_type */
	/* skip, unused field unused_unit8_lock_status (unit8_lock_status) */
	REG_DUMP_PRINT_1("   -unit8_lock_status.unit8_lock_status                                    |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2a30);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit8_pending_counter                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit8_pending_counter_type */
	/* skip, unused field unused_unit8_pending_counter (unit8_pending_counter) */
	REG_DUMP_PRINT_1("   -unit8_pending_counter.unit8_pending_counter                            |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2a04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit8_unit_height                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit8_unit_height_type */
	/* skip, unused field unused_unit8_unit_height (unit8_unit_height) */
	REG_DUMP_PRINT_1("   -unit8_unit_height.unit8_unit_height                                    |         0x%01X  |  [RW][01:00]""Register holding the unit height field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2a00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit8_unit_width                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit8_unit_width_type */
	/* skip, unused field unused_unit8_unit_width (unit8_unit_width) */
	REG_DUMP_PRINT_1("   -unit8_unit_width.unit8_unit_width                                      |      0x%04X  |  [RW][12:00]""Register holding the unit width field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb29f4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit7_lock_status                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit7_lock_status_type */
	/* skip, unused field unused_unit7_lock_status (unit7_lock_status) */
	REG_DUMP_PRINT_1("   -unit7_lock_status.unit7_lock_status                                    |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb29f0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit7_pending_counter                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit7_pending_counter_type */
	/* skip, unused field unused_unit7_pending_counter (unit7_pending_counter) */
	REG_DUMP_PRINT_1("   -unit7_pending_counter.unit7_pending_counter                            |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb29c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit7_unit_height                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit7_unit_height_type */
	/* skip, unused field unused_unit7_unit_height (unit7_unit_height) */
	REG_DUMP_PRINT_1("   -unit7_unit_height.unit7_unit_height                                    |         0x%01X  |  [RW][01:00]""Register holding the unit height field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb29c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit7_unit_width                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit7_unit_width_type */
	/* skip, unused field unused_unit7_unit_width (unit7_unit_width) */
	REG_DUMP_PRINT_1("   -unit7_unit_width.unit7_unit_width                                      |      0x%04X  |  [RW][12:00]""Register holding the unit width field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb29b4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit6_lock_status                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit6_lock_status_type */
	/* skip, unused field unused_unit6_lock_status (unit6_lock_status) */
	REG_DUMP_PRINT_1("   -unit6_lock_status.unit6_lock_status                                    |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb29b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit6_pending_counter                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit6_pending_counter_type */
	/* skip, unused field unused_unit6_pending_counter (unit6_pending_counter) */
	REG_DUMP_PRINT_1("   -unit6_pending_counter.unit6_pending_counter                            |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2984);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit6_unit_height                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit6_unit_height_type */
	/* skip, unused field unused_unit6_unit_height (unit6_unit_height) */
	REG_DUMP_PRINT_1("   -unit6_unit_height.unit6_unit_height                                    |         0x%01X  |  [RW][01:00]""Register holding the unit height field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2980);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit6_unit_width                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit6_unit_width_type */
	/* skip, unused field unused_unit6_unit_width (unit6_unit_width) */
	REG_DUMP_PRINT_1("   -unit6_unit_width.unit6_unit_width                                      |      0x%04X  |  [RW][12:00]""Register holding the unit width field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2974);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit5_lock_status                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit5_lock_status_type */
	/* skip, unused field unused_unit5_lock_status (unit5_lock_status) */
	REG_DUMP_PRINT_1("   -unit5_lock_status.unit5_lock_status                                    |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2970);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit5_pending_counter                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit5_pending_counter_type */
	/* skip, unused field unused_unit5_pending_counter (unit5_pending_counter) */
	REG_DUMP_PRINT_1("   -unit5_pending_counter.unit5_pending_counter                            |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2944);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit5_unit_height                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit5_unit_height_type */
	/* skip, unused field unused_unit5_unit_height (unit5_unit_height) */
	REG_DUMP_PRINT_1("   -unit5_unit_height.unit5_unit_height                                    |         0x%01X  |  [RW][01:00]""Register holding the unit height field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2940);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit5_unit_width                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit5_unit_width_type */
	/* skip, unused field unused_unit5_unit_width (unit5_unit_width) */
	REG_DUMP_PRINT_1("   -unit5_unit_width.unit5_unit_width                                      |      0x%04X  |  [RW][12:00]""Register holding the unit width field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2934);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit4_lock_status                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit4_lock_status_type */
	/* skip, unused field unused_unit4_lock_status (unit4_lock_status) */
	REG_DUMP_PRINT_1("   -unit4_lock_status.unit4_lock_status                                    |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2930);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit4_pending_counter                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit4_pending_counter_type */
	/* skip, unused field unused_unit4_pending_counter (unit4_pending_counter) */
	REG_DUMP_PRINT_1("   -unit4_pending_counter.unit4_pending_counter                            |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2904);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit4_unit_height                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit4_unit_height_type */
	/* skip, unused field unused_unit4_unit_height (unit4_unit_height) */
	REG_DUMP_PRINT_1("   -unit4_unit_height.unit4_unit_height                                    |         0x%01X  |  [RW][01:00]""Register holding the unit height field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2900);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit4_unit_width                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit4_unit_width_type */
	/* skip, unused field unused_unit4_unit_width (unit4_unit_width) */
	REG_DUMP_PRINT_1("   -unit4_unit_width.unit4_unit_width                                      |      0x%04X  |  [RW][12:00]""Register holding the unit width field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb28f4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit3_lock_status                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit3_lock_status_type */
	/* skip, unused field unused_unit3_lock_status (unit3_lock_status) */
	REG_DUMP_PRINT_1("   -unit3_lock_status.unit3_lock_status                                    |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb28f0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit3_pending_counter                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit3_pending_counter_type */
	/* skip, unused field unused_unit3_pending_counter (unit3_pending_counter) */
	REG_DUMP_PRINT_1("   -unit3_pending_counter.unit3_pending_counter                            |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb28c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit3_unit_height                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit3_unit_height_type */
	/* skip, unused field unused_unit3_unit_height (unit3_unit_height) */
	REG_DUMP_PRINT_1("   -unit3_unit_height.unit3_unit_height                                    |         0x%01X  |  [RW][01:00]""Register holding the unit height field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb28c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit3_unit_width                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit3_unit_width_type */
	/* skip, unused field unused_unit3_unit_width (unit3_unit_width) */
	REG_DUMP_PRINT_1("   -unit3_unit_width.unit3_unit_width                                      |      0x%04X  |  [RW][12:00]""Register holding the unit width field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb28b4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit2_lock_status                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit2_lock_status_type */
	/* skip, unused field unused_unit2_lock_status (unit2_lock_status) */
	REG_DUMP_PRINT_1("   -unit2_lock_status.unit2_lock_status                                    |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb28b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit2_pending_counter                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit2_pending_counter_type */
	/* skip, unused field unused_unit2_pending_counter (unit2_pending_counter) */
	REG_DUMP_PRINT_1("   -unit2_pending_counter.unit2_pending_counter                            |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2884);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit2_unit_height                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit2_unit_height_type */
	/* skip, unused field unused_unit2_unit_height (unit2_unit_height) */
	REG_DUMP_PRINT_1("   -unit2_unit_height.unit2_unit_height                                    |         0x%01X  |  [RW][01:00]""Register holding the unit height field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2880);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit2_unit_width                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit2_unit_width_type */
	/* skip, unused field unused_unit2_unit_width (unit2_unit_width) */
	REG_DUMP_PRINT_1("   -unit2_unit_width.unit2_unit_width                                      |      0x%04X  |  [RW][12:00]""Register holding the unit width field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2874);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit1_lock_status                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit1_lock_status_type */
	/* skip, unused field unused_unit1_lock_status (unit1_lock_status) */
	REG_DUMP_PRINT_1("   -unit1_lock_status.unit1_lock_status                                    |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2870);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit1_pending_counter                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit1_pending_counter_type */
	/* skip, unused field unused_unit1_pending_counter (unit1_pending_counter) */
	REG_DUMP_PRINT_1("   -unit1_pending_counter.unit1_pending_counter                            |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2844);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit1_unit_height                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit1_unit_height_type */
	/* skip, unused field unused_unit1_unit_height (unit1_unit_height) */
	REG_DUMP_PRINT_1("   -unit1_unit_height.unit1_unit_height                                    |         0x%01X  |  [RW][01:00]""Register holding the unit height field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2840);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit1_unit_width                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit1_unit_width_type */
	/* skip, unused field unused_unit1_unit_width (unit1_unit_width) */
	REG_DUMP_PRINT_1("   -unit1_unit_width.unit1_unit_width                                      |      0x%04X  |  [RW][12:00]""Register holding the unit width field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2834);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit0_lock_status                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit0_lock_status_type */
	/* skip, unused field unused_unit0_lock_status (unit0_lock_status) */
	REG_DUMP_PRINT_1("   -unit0_lock_status.unit0_lock_status                                    |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2830);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit0_pending_counter                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit0_pending_counter_type */
	/* skip, unused field unused_unit0_pending_counter (unit0_pending_counter) */
	REG_DUMP_PRINT_1("   -unit0_pending_counter.unit0_pending_counter                            |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2804);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit0_unit_height                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit0_unit_height_type */
	/* skip, unused field unused_unit0_unit_height (unit0_unit_height) */
	REG_DUMP_PRINT_1("   -unit0_unit_height.unit0_unit_height                                    |         0x%01X  |  [RW][01:00]""Register holding the unit height field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2800);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit0_unit_width                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit0_unit_width_type */
	/* skip, unused field unused_unit0_unit_width (unit0_unit_width) */
	REG_DUMP_PRINT_1("   -unit0_unit_width.unit0_unit_width                                      |      0x%04X  |  [RW][12:00]""Register holding the unit width field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb27f8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span31_dirty_status                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span31_dirty_status_type */
	/* skip, unused field unused_span31_dirty_status (span31_dirty_status) */
	REG_DUMP_PRINT_1("   -span31_dirty_status.span31_dirty_status                                |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb27f4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span31_lock_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span31_lock_status_type */
	/* skip, unused field unused_span31_lock_status (span31_lock_status) */
	REG_DUMP_PRINT_1("   -span31_lock_status.span31_lock_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb27f0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span31_pending_counter                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span31_pending_counter_type */
	/* skip, unused field unused_span31_pending_counter (span31_pending_counter) */
	REG_DUMP_PRINT_1("   -span31_pending_counter.span31_pending_counter                          |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb27d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span31_span_mode                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span31_span_mode_type */
	/* skip, unused field unused_span31_span_mode (span31_span_mode) */
	REG_DUMP_PRINT_1("   -span31_span_mode.span31_span_mode                                      |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb27d0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span31_span_height                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span31_span_height_type */
	/* skip, unused field unused_span31_span_height (span31_span_height) */
	REG_DUMP_PRINT_1("   -span31_span_height.span31_span_height                                  |      0x%04X  |  [RW][12:00]""Register holding the span height contained in the span descriptor, encoded as the height in number of units minus 1.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb27cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span31_span_width                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span31_span_width_type */
	/* skip, unused field unused_span31_span_width (span31_span_width) */
	REG_DUMP_PRINT_1("   -span31_span_width.span31_span_width                                    |       0x%03X  |  [RW][08:00]""Register holding the span width contained in the span descriptor, encoded as the width in number of units minus 1.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb27c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span31_span_column                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span31_span_column_type */
	/* skip, unused field unused_span31_span_column (span31_span_column) */
	REG_DUMP_PRINT_1("   -span31_span_column.span31_span_column                                  |      0x%04X  |  [RW][12:00]""Register holding the span column index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb27c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span31_span_row                                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span31_span_row_type */
	/* skip, unused field unused_span31_span_row (span31_span_row) */
	REG_DUMP_PRINT_1("   -span31_span_row.span31_span_row                                        |       0x%03X  |  [RW][08:00]""Register holding the span row index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb27c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span31_unit_location                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span31_unit_location_type */
	REG_DUMP_PRINT_1("   -span31_unit_location.span31_unit_location                              |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb27b8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span30_dirty_status                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span30_dirty_status_type */
	/* skip, unused field unused_span30_dirty_status (span30_dirty_status) */
	REG_DUMP_PRINT_1("   -span30_dirty_status.span30_dirty_status                                |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb27b4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span30_lock_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span30_lock_status_type */
	/* skip, unused field unused_span30_lock_status (span30_lock_status) */
	REG_DUMP_PRINT_1("   -span30_lock_status.span30_lock_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb27b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span30_pending_counter                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span30_pending_counter_type */
	/* skip, unused field unused_span30_pending_counter (span30_pending_counter) */
	REG_DUMP_PRINT_1("   -span30_pending_counter.span30_pending_counter                          |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2794);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span30_span_mode                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span30_span_mode_type */
	/* skip, unused field unused_span30_span_mode (span30_span_mode) */
	REG_DUMP_PRINT_1("   -span30_span_mode.span30_span_mode                                      |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2790);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span30_span_height                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span30_span_height_type */
	/* skip, unused field unused_span30_span_height (span30_span_height) */
	REG_DUMP_PRINT_1("   -span30_span_height.span30_span_height                                  |      0x%04X  |  [RW][12:00]""Register holding the span height contained in the span descriptor, encoded as the height in number of units minus 1.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb278c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span30_span_width                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span30_span_width_type */
	/* skip, unused field unused_span30_span_width (span30_span_width) */
	REG_DUMP_PRINT_1("   -span30_span_width.span30_span_width                                    |       0x%03X  |  [RW][08:00]""Register holding the span width contained in the span descriptor, encoded as the width in number of units minus 1.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2788);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span30_span_column                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span30_span_column_type */
	/* skip, unused field unused_span30_span_column (span30_span_column) */
	REG_DUMP_PRINT_1("   -span30_span_column.span30_span_column                                  |      0x%04X  |  [RW][12:00]""Register holding the span column index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2784);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span30_span_row                                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span30_span_row_type */
	/* skip, unused field unused_span30_span_row (span30_span_row) */
	REG_DUMP_PRINT_1("   -span30_span_row.span30_span_row                                        |       0x%03X  |  [RW][08:00]""Register holding the span row index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2780);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span30_unit_location                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span30_unit_location_type */
	REG_DUMP_PRINT_1("   -span30_unit_location.span30_unit_location                              |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb2778);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span29_dirty_status                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span29_dirty_status_type */
	/* skip, unused field unused_span29_dirty_status (span29_dirty_status) */
	REG_DUMP_PRINT_1("   -span29_dirty_status.span29_dirty_status                                |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2774);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span29_lock_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span29_lock_status_type */
	/* skip, unused field unused_span29_lock_status (span29_lock_status) */
	REG_DUMP_PRINT_1("   -span29_lock_status.span29_lock_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2770);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span29_pending_counter                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span29_pending_counter_type */
	/* skip, unused field unused_span29_pending_counter (span29_pending_counter) */
	REG_DUMP_PRINT_1("   -span29_pending_counter.span29_pending_counter                          |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2754);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span29_span_mode                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span29_span_mode_type */
	/* skip, unused field unused_span29_span_mode (span29_span_mode) */
	REG_DUMP_PRINT_1("   -span29_span_mode.span29_span_mode                                      |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2750);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span29_span_height                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span29_span_height_type */
	/* skip, unused field unused_span29_span_height (span29_span_height) */
	REG_DUMP_PRINT_1("   -span29_span_height.span29_span_height                                  |      0x%04X  |  [RW][12:00]""Register holding the span height contained in the span descriptor, encoded as the height in number of units minus 1.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb274c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span29_span_width                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span29_span_width_type */
	/* skip, unused field unused_span29_span_width (span29_span_width) */
	REG_DUMP_PRINT_1("   -span29_span_width.span29_span_width                                    |       0x%03X  |  [RW][08:00]""Register holding the span width contained in the span descriptor, encoded as the width in number of units minus 1.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2748);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span29_span_column                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span29_span_column_type */
	/* skip, unused field unused_span29_span_column (span29_span_column) */
	REG_DUMP_PRINT_1("   -span29_span_column.span29_span_column                                  |      0x%04X  |  [RW][12:00]""Register holding the span column index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2744);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span29_span_row                                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span29_span_row_type */
	/* skip, unused field unused_span29_span_row (span29_span_row) */
	REG_DUMP_PRINT_1("   -span29_span_row.span29_span_row                                        |       0x%03X  |  [RW][08:00]""Register holding the span row index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2740);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span29_unit_location                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span29_unit_location_type */
	REG_DUMP_PRINT_1("   -span29_unit_location.span29_unit_location                              |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb2738);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span28_dirty_status                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span28_dirty_status_type */
	/* skip, unused field unused_span28_dirty_status (span28_dirty_status) */
	REG_DUMP_PRINT_1("   -span28_dirty_status.span28_dirty_status                                |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2734);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span28_lock_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span28_lock_status_type */
	/* skip, unused field unused_span28_lock_status (span28_lock_status) */
	REG_DUMP_PRINT_1("   -span28_lock_status.span28_lock_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2730);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span28_pending_counter                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span28_pending_counter_type */
	/* skip, unused field unused_span28_pending_counter (span28_pending_counter) */
	REG_DUMP_PRINT_1("   -span28_pending_counter.span28_pending_counter                          |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2714);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span28_span_mode                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span28_span_mode_type */
	/* skip, unused field unused_span28_span_mode (span28_span_mode) */
	REG_DUMP_PRINT_1("   -span28_span_mode.span28_span_mode                                      |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2710);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span28_span_height                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span28_span_height_type */
	/* skip, unused field unused_span28_span_height (span28_span_height) */
	REG_DUMP_PRINT_1("   -span28_span_height.span28_span_height                                  |      0x%04X  |  [RW][12:00]""Register holding the span height contained in the span descriptor, encoded as the height in number of units minus 1.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb270c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span28_span_width                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span28_span_width_type */
	/* skip, unused field unused_span28_span_width (span28_span_width) */
	REG_DUMP_PRINT_1("   -span28_span_width.span28_span_width                                    |       0x%03X  |  [RW][08:00]""Register holding the span width contained in the span descriptor, encoded as the width in number of units minus 1.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2708);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span28_span_column                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span28_span_column_type */
	/* skip, unused field unused_span28_span_column (span28_span_column) */
	REG_DUMP_PRINT_1("   -span28_span_column.span28_span_column                                  |      0x%04X  |  [RW][12:00]""Register holding the span column index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2704);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span28_span_row                                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span28_span_row_type */
	/* skip, unused field unused_span28_span_row (span28_span_row) */
	REG_DUMP_PRINT_1("   -span28_span_row.span28_span_row                                        |       0x%03X  |  [RW][08:00]""Register holding the span row index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2700);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span28_unit_location                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span28_unit_location_type */
	REG_DUMP_PRINT_1("   -span28_unit_location.span28_unit_location                              |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb26f8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span27_dirty_status                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span27_dirty_status_type */
	/* skip, unused field unused_span27_dirty_status (span27_dirty_status) */
	REG_DUMP_PRINT_1("   -span27_dirty_status.span27_dirty_status                                |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb26f4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span27_lock_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span27_lock_status_type */
	/* skip, unused field unused_span27_lock_status (span27_lock_status) */
	REG_DUMP_PRINT_1("   -span27_lock_status.span27_lock_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb26f0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span27_pending_counter                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span27_pending_counter_type */
	/* skip, unused field unused_span27_pending_counter (span27_pending_counter) */
	REG_DUMP_PRINT_1("   -span27_pending_counter.span27_pending_counter                          |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb26d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span27_span_mode                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span27_span_mode_type */
	/* skip, unused field unused_span27_span_mode (span27_span_mode) */
	REG_DUMP_PRINT_1("   -span27_span_mode.span27_span_mode                                      |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb26d0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span27_span_height                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span27_span_height_type */
	/* skip, unused field unused_span27_span_height (span27_span_height) */
	REG_DUMP_PRINT_1("   -span27_span_height.span27_span_height                                  |      0x%04X  |  [RW][12:00]""Register holding the span height contained in the span descriptor, encoded as the height in number of units minus 1.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb26cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span27_span_width                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span27_span_width_type */
	/* skip, unused field unused_span27_span_width (span27_span_width) */
	REG_DUMP_PRINT_1("   -span27_span_width.span27_span_width                                    |       0x%03X  |  [RW][08:00]""Register holding the span width contained in the span descriptor, encoded as the width in number of units minus 1.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb26c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span27_span_column                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span27_span_column_type */
	/* skip, unused field unused_span27_span_column (span27_span_column) */
	REG_DUMP_PRINT_1("   -span27_span_column.span27_span_column                                  |      0x%04X  |  [RW][12:00]""Register holding the span column index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb26c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span27_span_row                                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span27_span_row_type */
	/* skip, unused field unused_span27_span_row (span27_span_row) */
	REG_DUMP_PRINT_1("   -span27_span_row.span27_span_row                                        |       0x%03X  |  [RW][08:00]""Register holding the span row index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb26c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span27_unit_location                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span27_unit_location_type */
	REG_DUMP_PRINT_1("   -span27_unit_location.span27_unit_location                              |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb26b8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span26_dirty_status                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span26_dirty_status_type */
	/* skip, unused field unused_span26_dirty_status (span26_dirty_status) */
	REG_DUMP_PRINT_1("   -span26_dirty_status.span26_dirty_status                                |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb26b4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span26_lock_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span26_lock_status_type */
	/* skip, unused field unused_span26_lock_status (span26_lock_status) */
	REG_DUMP_PRINT_1("   -span26_lock_status.span26_lock_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb26b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span26_pending_counter                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span26_pending_counter_type */
	/* skip, unused field unused_span26_pending_counter (span26_pending_counter) */
	REG_DUMP_PRINT_1("   -span26_pending_counter.span26_pending_counter                          |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2694);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span26_span_mode                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span26_span_mode_type */
	/* skip, unused field unused_span26_span_mode (span26_span_mode) */
	REG_DUMP_PRINT_1("   -span26_span_mode.span26_span_mode                                      |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2690);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span26_span_height                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span26_span_height_type */
	/* skip, unused field unused_span26_span_height (span26_span_height) */
	REG_DUMP_PRINT_1("   -span26_span_height.span26_span_height                                  |      0x%04X  |  [RW][12:00]""Register holding the span height contained in the span descriptor, encoded as the height in number of units minus 1.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb268c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span26_span_width                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span26_span_width_type */
	/* skip, unused field unused_span26_span_width (span26_span_width) */
	REG_DUMP_PRINT_1("   -span26_span_width.span26_span_width                                    |       0x%03X  |  [RW][08:00]""Register holding the span width contained in the span descriptor, encoded as the width in number of units minus 1.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2688);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span26_span_column                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span26_span_column_type */
	/* skip, unused field unused_span26_span_column (span26_span_column) */
	REG_DUMP_PRINT_1("   -span26_span_column.span26_span_column                                  |      0x%04X  |  [RW][12:00]""Register holding the span column index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2684);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span26_span_row                                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span26_span_row_type */
	/* skip, unused field unused_span26_span_row (span26_span_row) */
	REG_DUMP_PRINT_1("   -span26_span_row.span26_span_row                                        |       0x%03X  |  [RW][08:00]""Register holding the span row index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2680);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span26_unit_location                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span26_unit_location_type */
	REG_DUMP_PRINT_1("   -span26_unit_location.span26_unit_location                              |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb2678);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span25_dirty_status                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span25_dirty_status_type */
	/* skip, unused field unused_span25_dirty_status (span25_dirty_status) */
	REG_DUMP_PRINT_1("   -span25_dirty_status.span25_dirty_status                                |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2674);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span25_lock_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span25_lock_status_type */
	/* skip, unused field unused_span25_lock_status (span25_lock_status) */
	REG_DUMP_PRINT_1("   -span25_lock_status.span25_lock_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2670);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span25_pending_counter                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span25_pending_counter_type */
	/* skip, unused field unused_span25_pending_counter (span25_pending_counter) */
	REG_DUMP_PRINT_1("   -span25_pending_counter.span25_pending_counter                          |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2654);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span25_span_mode                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span25_span_mode_type */
	/* skip, unused field unused_span25_span_mode (span25_span_mode) */
	REG_DUMP_PRINT_1("   -span25_span_mode.span25_span_mode                                      |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2650);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span25_span_height                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span25_span_height_type */
	/* skip, unused field unused_span25_span_height (span25_span_height) */
	REG_DUMP_PRINT_1("   -span25_span_height.span25_span_height                                  |      0x%04X  |  [RW][12:00]""Register holding the span height contained in the span descriptor, encoded as the height in number of units minus 1.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb264c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span25_span_width                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span25_span_width_type */
	/* skip, unused field unused_span25_span_width (span25_span_width) */
	REG_DUMP_PRINT_1("   -span25_span_width.span25_span_width                                    |       0x%03X  |  [RW][08:00]""Register holding the span width contained in the span descriptor, encoded as the width in number of units minus 1.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2648);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span25_span_column                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span25_span_column_type */
	/* skip, unused field unused_span25_span_column (span25_span_column) */
	REG_DUMP_PRINT_1("   -span25_span_column.span25_span_column                                  |      0x%04X  |  [RW][12:00]""Register holding the span column index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2644);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span25_span_row                                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span25_span_row_type */
	/* skip, unused field unused_span25_span_row (span25_span_row) */
	REG_DUMP_PRINT_1("   -span25_span_row.span25_span_row                                        |       0x%03X  |  [RW][08:00]""Register holding the span row index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2640);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span25_unit_location                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span25_unit_location_type */
	REG_DUMP_PRINT_1("   -span25_unit_location.span25_unit_location                              |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb2638);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span24_dirty_status                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span24_dirty_status_type */
	/* skip, unused field unused_span24_dirty_status (span24_dirty_status) */
	REG_DUMP_PRINT_1("   -span24_dirty_status.span24_dirty_status                                |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2634);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span24_lock_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span24_lock_status_type */
	/* skip, unused field unused_span24_lock_status (span24_lock_status) */
	REG_DUMP_PRINT_1("   -span24_lock_status.span24_lock_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2630);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span24_pending_counter                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span24_pending_counter_type */
	/* skip, unused field unused_span24_pending_counter (span24_pending_counter) */
	REG_DUMP_PRINT_1("   -span24_pending_counter.span24_pending_counter                          |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2614);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span24_span_mode                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span24_span_mode_type */
	/* skip, unused field unused_span24_span_mode (span24_span_mode) */
	REG_DUMP_PRINT_1("   -span24_span_mode.span24_span_mode                                      |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2610);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span24_span_height                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span24_span_height_type */
	/* skip, unused field unused_span24_span_height (span24_span_height) */
	REG_DUMP_PRINT_1("   -span24_span_height.span24_span_height                                  |      0x%04X  |  [RW][12:00]""Register holding the span height contained in the span descriptor, encoded as the height in number of units minus 1.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb260c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span24_span_width                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span24_span_width_type */
	/* skip, unused field unused_span24_span_width (span24_span_width) */
	REG_DUMP_PRINT_1("   -span24_span_width.span24_span_width                                    |       0x%03X  |  [RW][08:00]""Register holding the span width contained in the span descriptor, encoded as the width in number of units minus 1.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2608);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span24_span_column                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span24_span_column_type */
	/* skip, unused field unused_span24_span_column (span24_span_column) */
	REG_DUMP_PRINT_1("   -span24_span_column.span24_span_column                                  |      0x%04X  |  [RW][12:00]""Register holding the span column index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2604);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span24_span_row                                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span24_span_row_type */
	/* skip, unused field unused_span24_span_row (span24_span_row) */
	REG_DUMP_PRINT_1("   -span24_span_row.span24_span_row                                        |       0x%03X  |  [RW][08:00]""Register holding the span row index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2600);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span24_unit_location                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span24_unit_location_type */
	REG_DUMP_PRINT_1("   -span24_unit_location.span24_unit_location                              |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb25f8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span23_dirty_status                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span23_dirty_status_type */
	/* skip, unused field unused_span23_dirty_status (span23_dirty_status) */
	REG_DUMP_PRINT_1("   -span23_dirty_status.span23_dirty_status                                |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb25f4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span23_lock_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span23_lock_status_type */
	/* skip, unused field unused_span23_lock_status (span23_lock_status) */
	REG_DUMP_PRINT_1("   -span23_lock_status.span23_lock_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb25f0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span23_pending_counter                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span23_pending_counter_type */
	/* skip, unused field unused_span23_pending_counter (span23_pending_counter) */
	REG_DUMP_PRINT_1("   -span23_pending_counter.span23_pending_counter                          |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb25d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span23_span_mode                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span23_span_mode_type */
	/* skip, unused field unused_span23_span_mode (span23_span_mode) */
	REG_DUMP_PRINT_1("   -span23_span_mode.span23_span_mode                                      |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb25d0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span23_span_height                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span23_span_height_type */
	/* skip, unused field unused_span23_span_height (span23_span_height) */
	REG_DUMP_PRINT_1("   -span23_span_height.span23_span_height                                  |      0x%04X  |  [RW][12:00]""Register holding the span height contained in the span descriptor, encoded as the height in number of units minus 1.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb25cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span23_span_width                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span23_span_width_type */
	/* skip, unused field unused_span23_span_width (span23_span_width) */
	REG_DUMP_PRINT_1("   -span23_span_width.span23_span_width                                    |       0x%03X  |  [RW][08:00]""Register holding the span width contained in the span descriptor, encoded as the width in number of units minus 1.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb25c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span23_span_column                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span23_span_column_type */
	/* skip, unused field unused_span23_span_column (span23_span_column) */
	REG_DUMP_PRINT_1("   -span23_span_column.span23_span_column                                  |      0x%04X  |  [RW][12:00]""Register holding the span column index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb25c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span23_span_row                                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span23_span_row_type */
	/* skip, unused field unused_span23_span_row (span23_span_row) */
	REG_DUMP_PRINT_1("   -span23_span_row.span23_span_row                                        |       0x%03X  |  [RW][08:00]""Register holding the span row index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb25c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span23_unit_location                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span23_unit_location_type */
	REG_DUMP_PRINT_1("   -span23_unit_location.span23_unit_location                              |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb25b8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span22_dirty_status                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span22_dirty_status_type */
	/* skip, unused field unused_span22_dirty_status (span22_dirty_status) */
	REG_DUMP_PRINT_1("   -span22_dirty_status.span22_dirty_status                                |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb25b4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span22_lock_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span22_lock_status_type */
	/* skip, unused field unused_span22_lock_status (span22_lock_status) */
	REG_DUMP_PRINT_1("   -span22_lock_status.span22_lock_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb25b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span22_pending_counter                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span22_pending_counter_type */
	/* skip, unused field unused_span22_pending_counter (span22_pending_counter) */
	REG_DUMP_PRINT_1("   -span22_pending_counter.span22_pending_counter                          |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2594);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span22_span_mode                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span22_span_mode_type */
	/* skip, unused field unused_span22_span_mode (span22_span_mode) */
	REG_DUMP_PRINT_1("   -span22_span_mode.span22_span_mode                                      |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2590);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span22_span_height                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span22_span_height_type */
	/* skip, unused field unused_span22_span_height (span22_span_height) */
	REG_DUMP_PRINT_1("   -span22_span_height.span22_span_height                                  |      0x%04X  |  [RW][12:00]""Register holding the span height contained in the span descriptor, encoded as the height in number of units minus 1.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb258c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span22_span_width                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span22_span_width_type */
	/* skip, unused field unused_span22_span_width (span22_span_width) */
	REG_DUMP_PRINT_1("   -span22_span_width.span22_span_width                                    |       0x%03X  |  [RW][08:00]""Register holding the span width contained in the span descriptor, encoded as the width in number of units minus 1.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2588);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span22_span_column                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span22_span_column_type */
	/* skip, unused field unused_span22_span_column (span22_span_column) */
	REG_DUMP_PRINT_1("   -span22_span_column.span22_span_column                                  |      0x%04X  |  [RW][12:00]""Register holding the span column index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2584);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span22_span_row                                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span22_span_row_type */
	/* skip, unused field unused_span22_span_row (span22_span_row) */
	REG_DUMP_PRINT_1("   -span22_span_row.span22_span_row                                        |       0x%03X  |  [RW][08:00]""Register holding the span row index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2580);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span22_unit_location                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span22_unit_location_type */
	REG_DUMP_PRINT_1("   -span22_unit_location.span22_unit_location                              |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb2578);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span21_dirty_status                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span21_dirty_status_type */
	/* skip, unused field unused_span21_dirty_status (span21_dirty_status) */
	REG_DUMP_PRINT_1("   -span21_dirty_status.span21_dirty_status                                |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2574);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span21_lock_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span21_lock_status_type */
	/* skip, unused field unused_span21_lock_status (span21_lock_status) */
	REG_DUMP_PRINT_1("   -span21_lock_status.span21_lock_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2570);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span21_pending_counter                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span21_pending_counter_type */
	/* skip, unused field unused_span21_pending_counter (span21_pending_counter) */
	REG_DUMP_PRINT_1("   -span21_pending_counter.span21_pending_counter                          |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2554);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span21_span_mode                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span21_span_mode_type */
	/* skip, unused field unused_span21_span_mode (span21_span_mode) */
	REG_DUMP_PRINT_1("   -span21_span_mode.span21_span_mode                                      |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2550);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span21_span_height                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span21_span_height_type */
	/* skip, unused field unused_span21_span_height (span21_span_height) */
	REG_DUMP_PRINT_1("   -span21_span_height.span21_span_height                                  |      0x%04X  |  [RW][12:00]""Register holding the span height contained in the span descriptor, encoded as the height in number of units minus 1.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb254c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span21_span_width                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span21_span_width_type */
	/* skip, unused field unused_span21_span_width (span21_span_width) */
	REG_DUMP_PRINT_1("   -span21_span_width.span21_span_width                                    |       0x%03X  |  [RW][08:00]""Register holding the span width contained in the span descriptor, encoded as the width in number of units minus 1.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2548);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span21_span_column                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span21_span_column_type */
	/* skip, unused field unused_span21_span_column (span21_span_column) */
	REG_DUMP_PRINT_1("   -span21_span_column.span21_span_column                                  |      0x%04X  |  [RW][12:00]""Register holding the span column index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2544);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span21_span_row                                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span21_span_row_type */
	/* skip, unused field unused_span21_span_row (span21_span_row) */
	REG_DUMP_PRINT_1("   -span21_span_row.span21_span_row                                        |       0x%03X  |  [RW][08:00]""Register holding the span row index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2540);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span21_unit_location                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span21_unit_location_type */
	REG_DUMP_PRINT_1("   -span21_unit_location.span21_unit_location                              |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb2538);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span20_dirty_status                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span20_dirty_status_type */
	/* skip, unused field unused_span20_dirty_status (span20_dirty_status) */
	REG_DUMP_PRINT_1("   -span20_dirty_status.span20_dirty_status                                |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2534);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span20_lock_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span20_lock_status_type */
	/* skip, unused field unused_span20_lock_status (span20_lock_status) */
	REG_DUMP_PRINT_1("   -span20_lock_status.span20_lock_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2530);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span20_pending_counter                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span20_pending_counter_type */
	/* skip, unused field unused_span20_pending_counter (span20_pending_counter) */
	REG_DUMP_PRINT_1("   -span20_pending_counter.span20_pending_counter                          |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2514);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span20_span_mode                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span20_span_mode_type */
	/* skip, unused field unused_span20_span_mode (span20_span_mode) */
	REG_DUMP_PRINT_1("   -span20_span_mode.span20_span_mode                                      |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2510);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span20_span_height                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span20_span_height_type */
	/* skip, unused field unused_span20_span_height (span20_span_height) */
	REG_DUMP_PRINT_1("   -span20_span_height.span20_span_height                                  |      0x%04X  |  [RW][12:00]""Register holding the span height contained in the span descriptor, encoded as the height in number of units minus 1.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb250c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span20_span_width                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span20_span_width_type */
	/* skip, unused field unused_span20_span_width (span20_span_width) */
	REG_DUMP_PRINT_1("   -span20_span_width.span20_span_width                                    |       0x%03X  |  [RW][08:00]""Register holding the span width contained in the span descriptor, encoded as the width in number of units minus 1.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2508);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span20_span_column                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span20_span_column_type */
	/* skip, unused field unused_span20_span_column (span20_span_column) */
	REG_DUMP_PRINT_1("   -span20_span_column.span20_span_column                                  |      0x%04X  |  [RW][12:00]""Register holding the span column index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2504);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span20_span_row                                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span20_span_row_type */
	/* skip, unused field unused_span20_span_row (span20_span_row) */
	REG_DUMP_PRINT_1("   -span20_span_row.span20_span_row                                        |       0x%03X  |  [RW][08:00]""Register holding the span row index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2500);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span20_unit_location                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span20_unit_location_type */
	REG_DUMP_PRINT_1("   -span20_unit_location.span20_unit_location                              |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb24f8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span19_dirty_status                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span19_dirty_status_type */
	/* skip, unused field unused_span19_dirty_status (span19_dirty_status) */
	REG_DUMP_PRINT_1("   -span19_dirty_status.span19_dirty_status                                |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb24f4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span19_lock_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span19_lock_status_type */
	/* skip, unused field unused_span19_lock_status (span19_lock_status) */
	REG_DUMP_PRINT_1("   -span19_lock_status.span19_lock_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb24f0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span19_pending_counter                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span19_pending_counter_type */
	/* skip, unused field unused_span19_pending_counter (span19_pending_counter) */
	REG_DUMP_PRINT_1("   -span19_pending_counter.span19_pending_counter                          |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb24d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span19_span_mode                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span19_span_mode_type */
	/* skip, unused field unused_span19_span_mode (span19_span_mode) */
	REG_DUMP_PRINT_1("   -span19_span_mode.span19_span_mode                                      |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb24d0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span19_span_height                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span19_span_height_type */
	/* skip, unused field unused_span19_span_height (span19_span_height) */
	REG_DUMP_PRINT_1("   -span19_span_height.span19_span_height                                  |      0x%04X  |  [RW][12:00]""Register holding the span height contained in the span descriptor, encoded as the height in number of units minus 1.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb24cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span19_span_width                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span19_span_width_type */
	/* skip, unused field unused_span19_span_width (span19_span_width) */
	REG_DUMP_PRINT_1("   -span19_span_width.span19_span_width                                    |       0x%03X  |  [RW][08:00]""Register holding the span width contained in the span descriptor, encoded as the width in number of units minus 1.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb24c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span19_span_column                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span19_span_column_type */
	/* skip, unused field unused_span19_span_column (span19_span_column) */
	REG_DUMP_PRINT_1("   -span19_span_column.span19_span_column                                  |      0x%04X  |  [RW][12:00]""Register holding the span column index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb24c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span19_span_row                                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span19_span_row_type */
	/* skip, unused field unused_span19_span_row (span19_span_row) */
	REG_DUMP_PRINT_1("   -span19_span_row.span19_span_row                                        |       0x%03X  |  [RW][08:00]""Register holding the span row index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb24c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span19_unit_location                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span19_unit_location_type */
	REG_DUMP_PRINT_1("   -span19_unit_location.span19_unit_location                              |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb24b8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span18_dirty_status                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span18_dirty_status_type */
	/* skip, unused field unused_span18_dirty_status (span18_dirty_status) */
	REG_DUMP_PRINT_1("   -span18_dirty_status.span18_dirty_status                                |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb24b4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span18_lock_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span18_lock_status_type */
	/* skip, unused field unused_span18_lock_status (span18_lock_status) */
	REG_DUMP_PRINT_1("   -span18_lock_status.span18_lock_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb24b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span18_pending_counter                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span18_pending_counter_type */
	/* skip, unused field unused_span18_pending_counter (span18_pending_counter) */
	REG_DUMP_PRINT_1("   -span18_pending_counter.span18_pending_counter                          |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2494);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span18_span_mode                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span18_span_mode_type */
	/* skip, unused field unused_span18_span_mode (span18_span_mode) */
	REG_DUMP_PRINT_1("   -span18_span_mode.span18_span_mode                                      |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2490);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span18_span_height                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span18_span_height_type */
	/* skip, unused field unused_span18_span_height (span18_span_height) */
	REG_DUMP_PRINT_1("   -span18_span_height.span18_span_height                                  |      0x%04X  |  [RW][12:00]""Register holding the span height contained in the span descriptor, encoded as the height in number of units minus 1.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb248c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span18_span_width                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span18_span_width_type */
	/* skip, unused field unused_span18_span_width (span18_span_width) */
	REG_DUMP_PRINT_1("   -span18_span_width.span18_span_width                                    |       0x%03X  |  [RW][08:00]""Register holding the span width contained in the span descriptor, encoded as the width in number of units minus 1.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2488);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span18_span_column                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span18_span_column_type */
	/* skip, unused field unused_span18_span_column (span18_span_column) */
	REG_DUMP_PRINT_1("   -span18_span_column.span18_span_column                                  |      0x%04X  |  [RW][12:00]""Register holding the span column index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2484);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span18_span_row                                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span18_span_row_type */
	/* skip, unused field unused_span18_span_row (span18_span_row) */
	REG_DUMP_PRINT_1("   -span18_span_row.span18_span_row                                        |       0x%03X  |  [RW][08:00]""Register holding the span row index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2480);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span18_unit_location                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span18_unit_location_type */
	REG_DUMP_PRINT_1("   -span18_unit_location.span18_unit_location                              |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb2478);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span17_dirty_status                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span17_dirty_status_type */
	/* skip, unused field unused_span17_dirty_status (span17_dirty_status) */
	REG_DUMP_PRINT_1("   -span17_dirty_status.span17_dirty_status                                |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2474);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span17_lock_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span17_lock_status_type */
	/* skip, unused field unused_span17_lock_status (span17_lock_status) */
	REG_DUMP_PRINT_1("   -span17_lock_status.span17_lock_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2470);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span17_pending_counter                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span17_pending_counter_type */
	/* skip, unused field unused_span17_pending_counter (span17_pending_counter) */
	REG_DUMP_PRINT_1("   -span17_pending_counter.span17_pending_counter                          |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2454);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span17_span_mode                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span17_span_mode_type */
	/* skip, unused field unused_span17_span_mode (span17_span_mode) */
	REG_DUMP_PRINT_1("   -span17_span_mode.span17_span_mode                                      |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2450);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span17_span_height                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span17_span_height_type */
	/* skip, unused field unused_span17_span_height (span17_span_height) */
	REG_DUMP_PRINT_1("   -span17_span_height.span17_span_height                                  |      0x%04X  |  [RW][12:00]""Register holding the span height contained in the span descriptor, encoded as the height in number of units minus 1.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb244c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span17_span_width                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span17_span_width_type */
	/* skip, unused field unused_span17_span_width (span17_span_width) */
	REG_DUMP_PRINT_1("   -span17_span_width.span17_span_width                                    |       0x%03X  |  [RW][08:00]""Register holding the span width contained in the span descriptor, encoded as the width in number of units minus 1.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2448);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span17_span_column                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span17_span_column_type */
	/* skip, unused field unused_span17_span_column (span17_span_column) */
	REG_DUMP_PRINT_1("   -span17_span_column.span17_span_column                                  |      0x%04X  |  [RW][12:00]""Register holding the span column index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2444);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span17_span_row                                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span17_span_row_type */
	/* skip, unused field unused_span17_span_row (span17_span_row) */
	REG_DUMP_PRINT_1("   -span17_span_row.span17_span_row                                        |       0x%03X  |  [RW][08:00]""Register holding the span row index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2440);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span17_unit_location                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span17_unit_location_type */
	REG_DUMP_PRINT_1("   -span17_unit_location.span17_unit_location                              |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb2438);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span16_dirty_status                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span16_dirty_status_type */
	/* skip, unused field unused_span16_dirty_status (span16_dirty_status) */
	REG_DUMP_PRINT_1("   -span16_dirty_status.span16_dirty_status                                |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2434);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span16_lock_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span16_lock_status_type */
	/* skip, unused field unused_span16_lock_status (span16_lock_status) */
	REG_DUMP_PRINT_1("   -span16_lock_status.span16_lock_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2430);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span16_pending_counter                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span16_pending_counter_type */
	/* skip, unused field unused_span16_pending_counter (span16_pending_counter) */
	REG_DUMP_PRINT_1("   -span16_pending_counter.span16_pending_counter                          |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2414);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span16_span_mode                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span16_span_mode_type */
	/* skip, unused field unused_span16_span_mode (span16_span_mode) */
	REG_DUMP_PRINT_1("   -span16_span_mode.span16_span_mode                                      |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2410);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span16_span_height                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span16_span_height_type */
	/* skip, unused field unused_span16_span_height (span16_span_height) */
	REG_DUMP_PRINT_1("   -span16_span_height.span16_span_height                                  |      0x%04X  |  [RW][12:00]""Register holding the span height contained in the span descriptor, encoded as the height in number of units minus 1.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb240c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span16_span_width                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span16_span_width_type */
	/* skip, unused field unused_span16_span_width (span16_span_width) */
	REG_DUMP_PRINT_1("   -span16_span_width.span16_span_width                                    |       0x%03X  |  [RW][08:00]""Register holding the span width contained in the span descriptor, encoded as the width in number of units minus 1.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2408);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span16_span_column                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span16_span_column_type */
	/* skip, unused field unused_span16_span_column (span16_span_column) */
	REG_DUMP_PRINT_1("   -span16_span_column.span16_span_column                                  |      0x%04X  |  [RW][12:00]""Register holding the span column index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2404);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span16_span_row                                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span16_span_row_type */
	/* skip, unused field unused_span16_span_row (span16_span_row) */
	REG_DUMP_PRINT_1("   -span16_span_row.span16_span_row                                        |       0x%03X  |  [RW][08:00]""Register holding the span row index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2400);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span16_unit_location                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span16_unit_location_type */
	REG_DUMP_PRINT_1("   -span16_unit_location.span16_unit_location                              |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb23f8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span15_dirty_status                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span15_dirty_status_type */
	/* skip, unused field unused_span15_dirty_status (span15_dirty_status) */
	REG_DUMP_PRINT_1("   -span15_dirty_status.span15_dirty_status                                |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb23f4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span15_lock_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span15_lock_status_type */
	/* skip, unused field unused_span15_lock_status (span15_lock_status) */
	REG_DUMP_PRINT_1("   -span15_lock_status.span15_lock_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb23f0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span15_pending_counter                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span15_pending_counter_type */
	/* skip, unused field unused_span15_pending_counter (span15_pending_counter) */
	REG_DUMP_PRINT_1("   -span15_pending_counter.span15_pending_counter                          |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb23d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span15_span_mode                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span15_span_mode_type */
	/* skip, unused field unused_span15_span_mode (span15_span_mode) */
	REG_DUMP_PRINT_1("   -span15_span_mode.span15_span_mode                                      |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb23d0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span15_span_height                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span15_span_height_type */
	/* skip, unused field unused_span15_span_height (span15_span_height) */
	REG_DUMP_PRINT_1("   -span15_span_height.span15_span_height                                  |      0x%04X  |  [RW][12:00]""Register holding the span height contained in the span descriptor, encoded as the height in number of units minus 1.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb23cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span15_span_width                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span15_span_width_type */
	/* skip, unused field unused_span15_span_width (span15_span_width) */
	REG_DUMP_PRINT_1("   -span15_span_width.span15_span_width                                    |       0x%03X  |  [RW][08:00]""Register holding the span width contained in the span descriptor, encoded as the width in number of units minus 1.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb23c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span15_span_column                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span15_span_column_type */
	/* skip, unused field unused_span15_span_column (span15_span_column) */
	REG_DUMP_PRINT_1("   -span15_span_column.span15_span_column                                  |      0x%04X  |  [RW][12:00]""Register holding the span column index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb23c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span15_span_row                                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span15_span_row_type */
	/* skip, unused field unused_span15_span_row (span15_span_row) */
	REG_DUMP_PRINT_1("   -span15_span_row.span15_span_row                                        |       0x%03X  |  [RW][08:00]""Register holding the span row index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb23c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span15_unit_location                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span15_unit_location_type */
	REG_DUMP_PRINT_1("   -span15_unit_location.span15_unit_location                              |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb23b8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span14_dirty_status                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span14_dirty_status_type */
	/* skip, unused field unused_span14_dirty_status (span14_dirty_status) */
	REG_DUMP_PRINT_1("   -span14_dirty_status.span14_dirty_status                                |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb23b4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span14_lock_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span14_lock_status_type */
	/* skip, unused field unused_span14_lock_status (span14_lock_status) */
	REG_DUMP_PRINT_1("   -span14_lock_status.span14_lock_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb23b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span14_pending_counter                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span14_pending_counter_type */
	/* skip, unused field unused_span14_pending_counter (span14_pending_counter) */
	REG_DUMP_PRINT_1("   -span14_pending_counter.span14_pending_counter                          |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2394);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span14_span_mode                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span14_span_mode_type */
	/* skip, unused field unused_span14_span_mode (span14_span_mode) */
	REG_DUMP_PRINT_1("   -span14_span_mode.span14_span_mode                                      |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2390);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span14_span_height                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span14_span_height_type */
	/* skip, unused field unused_span14_span_height (span14_span_height) */
	REG_DUMP_PRINT_1("   -span14_span_height.span14_span_height                                  |      0x%04X  |  [RW][12:00]""Register holding the span height contained in the span descriptor, encoded as the height in number of units minus 1.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb238c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span14_span_width                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span14_span_width_type */
	/* skip, unused field unused_span14_span_width (span14_span_width) */
	REG_DUMP_PRINT_1("   -span14_span_width.span14_span_width                                    |       0x%03X  |  [RW][08:00]""Register holding the span width contained in the span descriptor, encoded as the width in number of units minus 1.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2388);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span14_span_column                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span14_span_column_type */
	/* skip, unused field unused_span14_span_column (span14_span_column) */
	REG_DUMP_PRINT_1("   -span14_span_column.span14_span_column                                  |      0x%04X  |  [RW][12:00]""Register holding the span column index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2384);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span14_span_row                                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span14_span_row_type */
	/* skip, unused field unused_span14_span_row (span14_span_row) */
	REG_DUMP_PRINT_1("   -span14_span_row.span14_span_row                                        |       0x%03X  |  [RW][08:00]""Register holding the span row index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2380);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span14_unit_location                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span14_unit_location_type */
	REG_DUMP_PRINT_1("   -span14_unit_location.span14_unit_location                              |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb2378);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span13_dirty_status                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span13_dirty_status_type */
	/* skip, unused field unused_span13_dirty_status (span13_dirty_status) */
	REG_DUMP_PRINT_1("   -span13_dirty_status.span13_dirty_status                                |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2374);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span13_lock_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span13_lock_status_type */
	/* skip, unused field unused_span13_lock_status (span13_lock_status) */
	REG_DUMP_PRINT_1("   -span13_lock_status.span13_lock_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2370);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span13_pending_counter                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span13_pending_counter_type */
	/* skip, unused field unused_span13_pending_counter (span13_pending_counter) */
	REG_DUMP_PRINT_1("   -span13_pending_counter.span13_pending_counter                          |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2354);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span13_span_mode                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span13_span_mode_type */
	/* skip, unused field unused_span13_span_mode (span13_span_mode) */
	REG_DUMP_PRINT_1("   -span13_span_mode.span13_span_mode                                      |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2350);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span13_span_height                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span13_span_height_type */
	/* skip, unused field unused_span13_span_height (span13_span_height) */
	REG_DUMP_PRINT_1("   -span13_span_height.span13_span_height                                  |      0x%04X  |  [RW][12:00]""Register holding the span height contained in the span descriptor, encoded as the height in number of units minus 1.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb234c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span13_span_width                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span13_span_width_type */
	/* skip, unused field unused_span13_span_width (span13_span_width) */
	REG_DUMP_PRINT_1("   -span13_span_width.span13_span_width                                    |       0x%03X  |  [RW][08:00]""Register holding the span width contained in the span descriptor, encoded as the width in number of units minus 1.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2348);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span13_span_column                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span13_span_column_type */
	/* skip, unused field unused_span13_span_column (span13_span_column) */
	REG_DUMP_PRINT_1("   -span13_span_column.span13_span_column                                  |      0x%04X  |  [RW][12:00]""Register holding the span column index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2344);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span13_span_row                                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span13_span_row_type */
	/* skip, unused field unused_span13_span_row (span13_span_row) */
	REG_DUMP_PRINT_1("   -span13_span_row.span13_span_row                                        |       0x%03X  |  [RW][08:00]""Register holding the span row index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2340);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span13_unit_location                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span13_unit_location_type */
	REG_DUMP_PRINT_1("   -span13_unit_location.span13_unit_location                              |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb2338);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span12_dirty_status                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span12_dirty_status_type */
	/* skip, unused field unused_span12_dirty_status (span12_dirty_status) */
	REG_DUMP_PRINT_1("   -span12_dirty_status.span12_dirty_status                                |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2334);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span12_lock_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span12_lock_status_type */
	/* skip, unused field unused_span12_lock_status (span12_lock_status) */
	REG_DUMP_PRINT_1("   -span12_lock_status.span12_lock_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2330);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span12_pending_counter                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span12_pending_counter_type */
	/* skip, unused field unused_span12_pending_counter (span12_pending_counter) */
	REG_DUMP_PRINT_1("   -span12_pending_counter.span12_pending_counter                          |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2314);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span12_span_mode                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span12_span_mode_type */
	/* skip, unused field unused_span12_span_mode (span12_span_mode) */
	REG_DUMP_PRINT_1("   -span12_span_mode.span12_span_mode                                      |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2310);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span12_span_height                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span12_span_height_type */
	/* skip, unused field unused_span12_span_height (span12_span_height) */
	REG_DUMP_PRINT_1("   -span12_span_height.span12_span_height                                  |      0x%04X  |  [RW][12:00]""Register holding the span height contained in the span descriptor, encoded as the height in number of units minus 1.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb230c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span12_span_width                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span12_span_width_type */
	/* skip, unused field unused_span12_span_width (span12_span_width) */
	REG_DUMP_PRINT_1("   -span12_span_width.span12_span_width                                    |       0x%03X  |  [RW][08:00]""Register holding the span width contained in the span descriptor, encoded as the width in number of units minus 1.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2308);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span12_span_column                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span12_span_column_type */
	/* skip, unused field unused_span12_span_column (span12_span_column) */
	REG_DUMP_PRINT_1("   -span12_span_column.span12_span_column                                  |      0x%04X  |  [RW][12:00]""Register holding the span column index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2304);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span12_span_row                                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span12_span_row_type */
	/* skip, unused field unused_span12_span_row (span12_span_row) */
	REG_DUMP_PRINT_1("   -span12_span_row.span12_span_row                                        |       0x%03X  |  [RW][08:00]""Register holding the span row index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2300);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span12_unit_location                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span12_unit_location_type */
	REG_DUMP_PRINT_1("   -span12_unit_location.span12_unit_location                              |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb22f8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span11_dirty_status                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span11_dirty_status_type */
	/* skip, unused field unused_span11_dirty_status (span11_dirty_status) */
	REG_DUMP_PRINT_1("   -span11_dirty_status.span11_dirty_status                                |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb22f4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span11_lock_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span11_lock_status_type */
	/* skip, unused field unused_span11_lock_status (span11_lock_status) */
	REG_DUMP_PRINT_1("   -span11_lock_status.span11_lock_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb22f0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span11_pending_counter                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span11_pending_counter_type */
	/* skip, unused field unused_span11_pending_counter (span11_pending_counter) */
	REG_DUMP_PRINT_1("   -span11_pending_counter.span11_pending_counter                          |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb22d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span11_span_mode                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span11_span_mode_type */
	/* skip, unused field unused_span11_span_mode (span11_span_mode) */
	REG_DUMP_PRINT_1("   -span11_span_mode.span11_span_mode                                      |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb22d0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span11_span_height                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span11_span_height_type */
	/* skip, unused field unused_span11_span_height (span11_span_height) */
	REG_DUMP_PRINT_1("   -span11_span_height.span11_span_height                                  |      0x%04X  |  [RW][12:00]""Register holding the span height contained in the span descriptor, encoded as the height in number of units minus 1.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb22cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span11_span_width                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span11_span_width_type */
	/* skip, unused field unused_span11_span_width (span11_span_width) */
	REG_DUMP_PRINT_1("   -span11_span_width.span11_span_width                                    |       0x%03X  |  [RW][08:00]""Register holding the span width contained in the span descriptor, encoded as the width in number of units minus 1.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb22c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span11_span_column                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span11_span_column_type */
	/* skip, unused field unused_span11_span_column (span11_span_column) */
	REG_DUMP_PRINT_1("   -span11_span_column.span11_span_column                                  |      0x%04X  |  [RW][12:00]""Register holding the span column index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb22c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span11_span_row                                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span11_span_row_type */
	/* skip, unused field unused_span11_span_row (span11_span_row) */
	REG_DUMP_PRINT_1("   -span11_span_row.span11_span_row                                        |       0x%03X  |  [RW][08:00]""Register holding the span row index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb22c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span11_unit_location                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span11_unit_location_type */
	REG_DUMP_PRINT_1("   -span11_unit_location.span11_unit_location                              |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb22b8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span10_dirty_status                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span10_dirty_status_type */
	/* skip, unused field unused_span10_dirty_status (span10_dirty_status) */
	REG_DUMP_PRINT_1("   -span10_dirty_status.span10_dirty_status                                |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb22b4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span10_lock_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span10_lock_status_type */
	/* skip, unused field unused_span10_lock_status (span10_lock_status) */
	REG_DUMP_PRINT_1("   -span10_lock_status.span10_lock_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb22b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span10_pending_counter                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span10_pending_counter_type */
	/* skip, unused field unused_span10_pending_counter (span10_pending_counter) */
	REG_DUMP_PRINT_1("   -span10_pending_counter.span10_pending_counter                          |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2294);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span10_span_mode                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span10_span_mode_type */
	/* skip, unused field unused_span10_span_mode (span10_span_mode) */
	REG_DUMP_PRINT_1("   -span10_span_mode.span10_span_mode                                      |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2290);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span10_span_height                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span10_span_height_type */
	/* skip, unused field unused_span10_span_height (span10_span_height) */
	REG_DUMP_PRINT_1("   -span10_span_height.span10_span_height                                  |      0x%04X  |  [RW][12:00]""Register holding the span height contained in the span descriptor, encoded as the height in number of units minus 1.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb228c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span10_span_width                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span10_span_width_type */
	/* skip, unused field unused_span10_span_width (span10_span_width) */
	REG_DUMP_PRINT_1("   -span10_span_width.span10_span_width                                    |       0x%03X  |  [RW][08:00]""Register holding the span width contained in the span descriptor, encoded as the width in number of units minus 1.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2288);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span10_span_column                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span10_span_column_type */
	/* skip, unused field unused_span10_span_column (span10_span_column) */
	REG_DUMP_PRINT_1("   -span10_span_column.span10_span_column                                  |      0x%04X  |  [RW][12:00]""Register holding the span column index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2284);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span10_span_row                                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span10_span_row_type */
	/* skip, unused field unused_span10_span_row (span10_span_row) */
	REG_DUMP_PRINT_1("   -span10_span_row.span10_span_row                                        |       0x%03X  |  [RW][08:00]""Register holding the span row index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2280);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span10_unit_location                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span10_unit_location_type */
	REG_DUMP_PRINT_1("   -span10_unit_location.span10_unit_location                              |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb2278);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span9_dirty_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span9_dirty_status_type */
	/* skip, unused field unused_span9_dirty_status (span9_dirty_status) */
	REG_DUMP_PRINT_1("   -span9_dirty_status.span9_dirty_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2274);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span9_lock_status                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span9_lock_status_type */
	/* skip, unused field unused_span9_lock_status (span9_lock_status) */
	REG_DUMP_PRINT_1("   -span9_lock_status.span9_lock_status                                    |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2270);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span9_pending_counter                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span9_pending_counter_type */
	/* skip, unused field unused_span9_pending_counter (span9_pending_counter) */
	REG_DUMP_PRINT_1("   -span9_pending_counter.span9_pending_counter                            |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2254);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span9_span_mode                                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span9_span_mode_type */
	/* skip, unused field unused_span9_span_mode (span9_span_mode) */
	REG_DUMP_PRINT_1("   -span9_span_mode.span9_span_mode                                        |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2250);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span9_span_height                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span9_span_height_type */
	/* skip, unused field unused_span9_span_height (span9_span_height) */
	REG_DUMP_PRINT_1("   -span9_span_height.span9_span_height                                    |      0x%04X  |  [RW][12:00]""Register holding the span height contained in the span descriptor, encoded as the height in number of units minus 1.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb224c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span9_span_width                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span9_span_width_type */
	/* skip, unused field unused_span9_span_width (span9_span_width) */
	REG_DUMP_PRINT_1("   -span9_span_width.span9_span_width                                      |       0x%03X  |  [RW][08:00]""Register holding the span width contained in the span descriptor, encoded as the width in number of units minus 1.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2248);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span9_span_column                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span9_span_column_type */
	/* skip, unused field unused_span9_span_column (span9_span_column) */
	REG_DUMP_PRINT_1("   -span9_span_column.span9_span_column                                    |      0x%04X  |  [RW][12:00]""Register holding the span column index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2244);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span9_span_row                                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span9_span_row_type */
	/* skip, unused field unused_span9_span_row (span9_span_row) */
	REG_DUMP_PRINT_1("   -span9_span_row.span9_span_row                                          |       0x%03X  |  [RW][08:00]""Register holding the span row index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2240);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span9_unit_location                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span9_unit_location_type */
	REG_DUMP_PRINT_1("   -span9_unit_location.span9_unit_location                                |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb2238);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span8_dirty_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span8_dirty_status_type */
	/* skip, unused field unused_span8_dirty_status (span8_dirty_status) */
	REG_DUMP_PRINT_1("   -span8_dirty_status.span8_dirty_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2234);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span8_lock_status                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span8_lock_status_type */
	/* skip, unused field unused_span8_lock_status (span8_lock_status) */
	REG_DUMP_PRINT_1("   -span8_lock_status.span8_lock_status                                    |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2230);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span8_pending_counter                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span8_pending_counter_type */
	/* skip, unused field unused_span8_pending_counter (span8_pending_counter) */
	REG_DUMP_PRINT_1("   -span8_pending_counter.span8_pending_counter                            |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2214);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span8_span_mode                                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span8_span_mode_type */
	/* skip, unused field unused_span8_span_mode (span8_span_mode) */
	REG_DUMP_PRINT_1("   -span8_span_mode.span8_span_mode                                        |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2210);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span8_span_height                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span8_span_height_type */
	/* skip, unused field unused_span8_span_height (span8_span_height) */
	REG_DUMP_PRINT_1("   -span8_span_height.span8_span_height                                    |      0x%04X  |  [RW][12:00]""Register holding the span height contained in the span descriptor, encoded as the height in number of units minus 1.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb220c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span8_span_width                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span8_span_width_type */
	/* skip, unused field unused_span8_span_width (span8_span_width) */
	REG_DUMP_PRINT_1("   -span8_span_width.span8_span_width                                      |       0x%03X  |  [RW][08:00]""Register holding the span width contained in the span descriptor, encoded as the width in number of units minus 1.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2208);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span8_span_column                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span8_span_column_type */
	/* skip, unused field unused_span8_span_column (span8_span_column) */
	REG_DUMP_PRINT_1("   -span8_span_column.span8_span_column                                    |      0x%04X  |  [RW][12:00]""Register holding the span column index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2204);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span8_span_row                                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span8_span_row_type */
	/* skip, unused field unused_span8_span_row (span8_span_row) */
	REG_DUMP_PRINT_1("   -span8_span_row.span8_span_row                                          |       0x%03X  |  [RW][08:00]""Register holding the span row index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2200);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span8_unit_location                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span8_unit_location_type */
	REG_DUMP_PRINT_1("   -span8_unit_location.span8_unit_location                                |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb21f8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span7_dirty_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span7_dirty_status_type */
	/* skip, unused field unused_span7_dirty_status (span7_dirty_status) */
	REG_DUMP_PRINT_1("   -span7_dirty_status.span7_dirty_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb21f4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span7_lock_status                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span7_lock_status_type */
	/* skip, unused field unused_span7_lock_status (span7_lock_status) */
	REG_DUMP_PRINT_1("   -span7_lock_status.span7_lock_status                                    |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb21f0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span7_pending_counter                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span7_pending_counter_type */
	/* skip, unused field unused_span7_pending_counter (span7_pending_counter) */
	REG_DUMP_PRINT_1("   -span7_pending_counter.span7_pending_counter                            |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb21d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span7_span_mode                                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span7_span_mode_type */
	/* skip, unused field unused_span7_span_mode (span7_span_mode) */
	REG_DUMP_PRINT_1("   -span7_span_mode.span7_span_mode                                        |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb21d0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span7_span_height                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span7_span_height_type */
	/* skip, unused field unused_span7_span_height (span7_span_height) */
	REG_DUMP_PRINT_1("   -span7_span_height.span7_span_height                                    |      0x%04X  |  [RW][12:00]""Register holding the span height contained in the span descriptor, encoded as the height in number of units minus 1.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb21cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span7_span_width                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span7_span_width_type */
	/* skip, unused field unused_span7_span_width (span7_span_width) */
	REG_DUMP_PRINT_1("   -span7_span_width.span7_span_width                                      |       0x%03X  |  [RW][08:00]""Register holding the span width contained in the span descriptor, encoded as the width in number of units minus 1.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb21c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span7_span_column                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span7_span_column_type */
	/* skip, unused field unused_span7_span_column (span7_span_column) */
	REG_DUMP_PRINT_1("   -span7_span_column.span7_span_column                                    |      0x%04X  |  [RW][12:00]""Register holding the span column index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb21c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span7_span_row                                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span7_span_row_type */
	/* skip, unused field unused_span7_span_row (span7_span_row) */
	REG_DUMP_PRINT_1("   -span7_span_row.span7_span_row                                          |       0x%03X  |  [RW][08:00]""Register holding the span row index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb21c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span7_unit_location                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span7_unit_location_type */
	REG_DUMP_PRINT_1("   -span7_unit_location.span7_unit_location                                |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb21b8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span6_dirty_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span6_dirty_status_type */
	/* skip, unused field unused_span6_dirty_status (span6_dirty_status) */
	REG_DUMP_PRINT_1("   -span6_dirty_status.span6_dirty_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb21b4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span6_lock_status                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span6_lock_status_type */
	/* skip, unused field unused_span6_lock_status (span6_lock_status) */
	REG_DUMP_PRINT_1("   -span6_lock_status.span6_lock_status                                    |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb21b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span6_pending_counter                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span6_pending_counter_type */
	/* skip, unused field unused_span6_pending_counter (span6_pending_counter) */
	REG_DUMP_PRINT_1("   -span6_pending_counter.span6_pending_counter                            |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2194);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span6_span_mode                                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span6_span_mode_type */
	/* skip, unused field unused_span6_span_mode (span6_span_mode) */
	REG_DUMP_PRINT_1("   -span6_span_mode.span6_span_mode                                        |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2190);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span6_span_height                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span6_span_height_type */
	/* skip, unused field unused_span6_span_height (span6_span_height) */
	REG_DUMP_PRINT_1("   -span6_span_height.span6_span_height                                    |      0x%04X  |  [RW][12:00]""Register holding the span height contained in the span descriptor, encoded as the height in number of units minus 1.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb218c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span6_span_width                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span6_span_width_type */
	/* skip, unused field unused_span6_span_width (span6_span_width) */
	REG_DUMP_PRINT_1("   -span6_span_width.span6_span_width                                      |       0x%03X  |  [RW][08:00]""Register holding the span width contained in the span descriptor, encoded as the width in number of units minus 1.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2188);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span6_span_column                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span6_span_column_type */
	/* skip, unused field unused_span6_span_column (span6_span_column) */
	REG_DUMP_PRINT_1("   -span6_span_column.span6_span_column                                    |      0x%04X  |  [RW][12:00]""Register holding the span column index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2184);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span6_span_row                                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span6_span_row_type */
	/* skip, unused field unused_span6_span_row (span6_span_row) */
	REG_DUMP_PRINT_1("   -span6_span_row.span6_span_row                                          |       0x%03X  |  [RW][08:00]""Register holding the span row index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2180);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span6_unit_location                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span6_unit_location_type */
	REG_DUMP_PRINT_1("   -span6_unit_location.span6_unit_location                                |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb2178);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span5_dirty_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span5_dirty_status_type */
	/* skip, unused field unused_span5_dirty_status (span5_dirty_status) */
	REG_DUMP_PRINT_1("   -span5_dirty_status.span5_dirty_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2174);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span5_lock_status                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span5_lock_status_type */
	/* skip, unused field unused_span5_lock_status (span5_lock_status) */
	REG_DUMP_PRINT_1("   -span5_lock_status.span5_lock_status                                    |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2170);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span5_pending_counter                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span5_pending_counter_type */
	/* skip, unused field unused_span5_pending_counter (span5_pending_counter) */
	REG_DUMP_PRINT_1("   -span5_pending_counter.span5_pending_counter                            |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2154);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span5_span_mode                                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span5_span_mode_type */
	/* skip, unused field unused_span5_span_mode (span5_span_mode) */
	REG_DUMP_PRINT_1("   -span5_span_mode.span5_span_mode                                        |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2150);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span5_span_height                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span5_span_height_type */
	/* skip, unused field unused_span5_span_height (span5_span_height) */
	REG_DUMP_PRINT_1("   -span5_span_height.span5_span_height                                    |      0x%04X  |  [RW][12:00]""Register holding the span height contained in the span descriptor, encoded as the height in number of units minus 1.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb214c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span5_span_width                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span5_span_width_type */
	/* skip, unused field unused_span5_span_width (span5_span_width) */
	REG_DUMP_PRINT_1("   -span5_span_width.span5_span_width                                      |       0x%03X  |  [RW][08:00]""Register holding the span width contained in the span descriptor, encoded as the width in number of units minus 1.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2148);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span5_span_column                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span5_span_column_type */
	/* skip, unused field unused_span5_span_column (span5_span_column) */
	REG_DUMP_PRINT_1("   -span5_span_column.span5_span_column                                    |      0x%04X  |  [RW][12:00]""Register holding the span column index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2144);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span5_span_row                                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span5_span_row_type */
	/* skip, unused field unused_span5_span_row (span5_span_row) */
	REG_DUMP_PRINT_1("   -span5_span_row.span5_span_row                                          |       0x%03X  |  [RW][08:00]""Register holding the span row index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2140);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span5_unit_location                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span5_unit_location_type */
	REG_DUMP_PRINT_1("   -span5_unit_location.span5_unit_location                                |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb2138);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span4_dirty_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span4_dirty_status_type */
	/* skip, unused field unused_span4_dirty_status (span4_dirty_status) */
	REG_DUMP_PRINT_1("   -span4_dirty_status.span4_dirty_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2134);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span4_lock_status                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span4_lock_status_type */
	/* skip, unused field unused_span4_lock_status (span4_lock_status) */
	REG_DUMP_PRINT_1("   -span4_lock_status.span4_lock_status                                    |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2130);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span4_pending_counter                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span4_pending_counter_type */
	/* skip, unused field unused_span4_pending_counter (span4_pending_counter) */
	REG_DUMP_PRINT_1("   -span4_pending_counter.span4_pending_counter                            |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2114);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span4_span_mode                                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span4_span_mode_type */
	/* skip, unused field unused_span4_span_mode (span4_span_mode) */
	REG_DUMP_PRINT_1("   -span4_span_mode.span4_span_mode                                        |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2110);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span4_span_height                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span4_span_height_type */
	/* skip, unused field unused_span4_span_height (span4_span_height) */
	REG_DUMP_PRINT_1("   -span4_span_height.span4_span_height                                    |      0x%04X  |  [RW][12:00]""Register holding the span height contained in the span descriptor, encoded as the height in number of units minus 1.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb210c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span4_span_width                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span4_span_width_type */
	/* skip, unused field unused_span4_span_width (span4_span_width) */
	REG_DUMP_PRINT_1("   -span4_span_width.span4_span_width                                      |       0x%03X  |  [RW][08:00]""Register holding the span width contained in the span descriptor, encoded as the width in number of units minus 1.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2108);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span4_span_column                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span4_span_column_type */
	/* skip, unused field unused_span4_span_column (span4_span_column) */
	REG_DUMP_PRINT_1("   -span4_span_column.span4_span_column                                    |      0x%04X  |  [RW][12:00]""Register holding the span column index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2104);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span4_span_row                                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span4_span_row_type */
	/* skip, unused field unused_span4_span_row (span4_span_row) */
	REG_DUMP_PRINT_1("   -span4_span_row.span4_span_row                                          |       0x%03X  |  [RW][08:00]""Register holding the span row index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2100);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span4_unit_location                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span4_unit_location_type */
	REG_DUMP_PRINT_1("   -span4_unit_location.span4_unit_location                                |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb20f8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span3_dirty_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span3_dirty_status_type */
	/* skip, unused field unused_span3_dirty_status (span3_dirty_status) */
	REG_DUMP_PRINT_1("   -span3_dirty_status.span3_dirty_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb20f4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span3_lock_status                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span3_lock_status_type */
	/* skip, unused field unused_span3_lock_status (span3_lock_status) */
	REG_DUMP_PRINT_1("   -span3_lock_status.span3_lock_status                                    |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb20f0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span3_pending_counter                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span3_pending_counter_type */
	/* skip, unused field unused_span3_pending_counter (span3_pending_counter) */
	REG_DUMP_PRINT_1("   -span3_pending_counter.span3_pending_counter                            |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb20d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span3_span_mode                                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span3_span_mode_type */
	/* skip, unused field unused_span3_span_mode (span3_span_mode) */
	REG_DUMP_PRINT_1("   -span3_span_mode.span3_span_mode                                        |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb20d0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span3_span_height                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span3_span_height_type */
	/* skip, unused field unused_span3_span_height (span3_span_height) */
	REG_DUMP_PRINT_1("   -span3_span_height.span3_span_height                                    |      0x%04X  |  [RW][12:00]""Register holding the span height contained in the span descriptor, encoded as the height in number of units minus 1.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb20cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span3_span_width                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span3_span_width_type */
	/* skip, unused field unused_span3_span_width (span3_span_width) */
	REG_DUMP_PRINT_1("   -span3_span_width.span3_span_width                                      |       0x%03X  |  [RW][08:00]""Register holding the span width contained in the span descriptor, encoded as the width in number of units minus 1.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb20c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span3_span_column                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span3_span_column_type */
	/* skip, unused field unused_span3_span_column (span3_span_column) */
	REG_DUMP_PRINT_1("   -span3_span_column.span3_span_column                                    |      0x%04X  |  [RW][12:00]""Register holding the span column index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb20c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span3_span_row                                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span3_span_row_type */
	/* skip, unused field unused_span3_span_row (span3_span_row) */
	REG_DUMP_PRINT_1("   -span3_span_row.span3_span_row                                          |       0x%03X  |  [RW][08:00]""Register holding the span row index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb20c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span3_unit_location                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span3_unit_location_type */
	REG_DUMP_PRINT_1("   -span3_unit_location.span3_unit_location                                |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb20b8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span2_dirty_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span2_dirty_status_type */
	/* skip, unused field unused_span2_dirty_status (span2_dirty_status) */
	REG_DUMP_PRINT_1("   -span2_dirty_status.span2_dirty_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb20b4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span2_lock_status                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span2_lock_status_type */
	/* skip, unused field unused_span2_lock_status (span2_lock_status) */
	REG_DUMP_PRINT_1("   -span2_lock_status.span2_lock_status                                    |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb20b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span2_pending_counter                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span2_pending_counter_type */
	/* skip, unused field unused_span2_pending_counter (span2_pending_counter) */
	REG_DUMP_PRINT_1("   -span2_pending_counter.span2_pending_counter                            |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2094);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span2_span_mode                                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span2_span_mode_type */
	/* skip, unused field unused_span2_span_mode (span2_span_mode) */
	REG_DUMP_PRINT_1("   -span2_span_mode.span2_span_mode                                        |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2090);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span2_span_height                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span2_span_height_type */
	/* skip, unused field unused_span2_span_height (span2_span_height) */
	REG_DUMP_PRINT_1("   -span2_span_height.span2_span_height                                    |      0x%04X  |  [RW][12:00]""Register holding the span height contained in the span descriptor, encoded as the height in number of units minus 1.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb208c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span2_span_width                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span2_span_width_type */
	/* skip, unused field unused_span2_span_width (span2_span_width) */
	REG_DUMP_PRINT_1("   -span2_span_width.span2_span_width                                      |       0x%03X  |  [RW][08:00]""Register holding the span width contained in the span descriptor, encoded as the width in number of units minus 1.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2088);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span2_span_column                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span2_span_column_type */
	/* skip, unused field unused_span2_span_column (span2_span_column) */
	REG_DUMP_PRINT_1("   -span2_span_column.span2_span_column                                    |      0x%04X  |  [RW][12:00]""Register holding the span column index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2084);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span2_span_row                                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span2_span_row_type */
	/* skip, unused field unused_span2_span_row (span2_span_row) */
	REG_DUMP_PRINT_1("   -span2_span_row.span2_span_row                                          |       0x%03X  |  [RW][08:00]""Register holding the span row index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2080);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span2_unit_location                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span2_unit_location_type */
	REG_DUMP_PRINT_1("   -span2_unit_location.span2_unit_location                                |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb2078);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span1_dirty_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span1_dirty_status_type */
	/* skip, unused field unused_span1_dirty_status (span1_dirty_status) */
	REG_DUMP_PRINT_1("   -span1_dirty_status.span1_dirty_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2074);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span1_lock_status                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span1_lock_status_type */
	/* skip, unused field unused_span1_lock_status (span1_lock_status) */
	REG_DUMP_PRINT_1("   -span1_lock_status.span1_lock_status                                    |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2070);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span1_pending_counter                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span1_pending_counter_type */
	/* skip, unused field unused_span1_pending_counter (span1_pending_counter) */
	REG_DUMP_PRINT_1("   -span1_pending_counter.span1_pending_counter                            |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2054);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span1_span_mode                                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span1_span_mode_type */
	/* skip, unused field unused_span1_span_mode (span1_span_mode) */
	REG_DUMP_PRINT_1("   -span1_span_mode.span1_span_mode                                        |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2050);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span1_span_height                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span1_span_height_type */
	/* skip, unused field unused_span1_span_height (span1_span_height) */
	REG_DUMP_PRINT_1("   -span1_span_height.span1_span_height                                    |      0x%04X  |  [RW][12:00]""Register holding the span height contained in the span descriptor, encoded as the height in number of units minus 1.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb204c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span1_span_width                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span1_span_width_type */
	/* skip, unused field unused_span1_span_width (span1_span_width) */
	REG_DUMP_PRINT_1("   -span1_span_width.span1_span_width                                      |       0x%03X  |  [RW][08:00]""Register holding the span width contained in the span descriptor, encoded as the width in number of units minus 1.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2048);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span1_span_column                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span1_span_column_type */
	/* skip, unused field unused_span1_span_column (span1_span_column) */
	REG_DUMP_PRINT_1("   -span1_span_column.span1_span_column                                    |      0x%04X  |  [RW][12:00]""Register holding the span column index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2044);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span1_span_row                                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span1_span_row_type */
	/* skip, unused field unused_span1_span_row (span1_span_row) */
	REG_DUMP_PRINT_1("   -span1_span_row.span1_span_row                                          |       0x%03X  |  [RW][08:00]""Register holding the span row index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2040);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span1_unit_location                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span1_unit_location_type */
	REG_DUMP_PRINT_1("   -span1_unit_location.span1_unit_location                                |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb2038);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span0_dirty_status                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span0_dirty_status_type */
	/* skip, unused field unused_span0_dirty_status (span0_dirty_status) */
	REG_DUMP_PRINT_1("   -span0_dirty_status.span0_dirty_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2034);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span0_lock_status                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span0_lock_status_type */
	/* skip, unused field unused_span0_lock_status (span0_lock_status) */
	REG_DUMP_PRINT_1("   -span0_lock_status.span0_lock_status                                    |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb2030);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span0_pending_counter                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span0_pending_counter_type */
	/* skip, unused field unused_span0_pending_counter (span0_pending_counter) */
	REG_DUMP_PRINT_1("   -span0_pending_counter.span0_pending_counter                            |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb2014);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span0_span_mode                                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span0_span_mode_type */
	/* skip, unused field unused_span0_span_mode (span0_span_mode) */
	REG_DUMP_PRINT_1("   -span0_span_mode.span0_span_mode                                        |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb2010);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span0_span_height                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span0_span_height_type */
	/* skip, unused field unused_span0_span_height (span0_span_height) */
	REG_DUMP_PRINT_1("   -span0_span_height.span0_span_height                                    |      0x%04X  |  [RW][12:00]""Register holding the span height contained in the span descriptor, encoded as the height in number of units minus 1.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb200c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span0_span_width                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span0_span_width_type */
	/* skip, unused field unused_span0_span_width (span0_span_width) */
	REG_DUMP_PRINT_1("   -span0_span_width.span0_span_width                                      |       0x%03X  |  [RW][08:00]""Register holding the span width contained in the span descriptor, encoded as the width in number of units minus 1.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2008);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span0_span_column                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span0_span_column_type */
	/* skip, unused field unused_span0_span_column (span0_span_column) */
	REG_DUMP_PRINT_1("   -span0_span_column.span0_span_column                                    |      0x%04X  |  [RW][12:00]""Register holding the span column index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb2004);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span0_span_row                                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span0_span_row_type */
	/* skip, unused field unused_span0_span_row (span0_span_row) */
	REG_DUMP_PRINT_1("   -span0_span_row.span0_span_row                                          |       0x%03X  |  [RW][08:00]""Register holding the span row index contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb2000);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span0_unit_location                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span0_unit_location_type */
	REG_DUMP_PRINT_1("   -span0_unit_location.span0_unit_location                                |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb1808);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.burst_support                                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_burst_support_type */
	/* skip, unused field unused_burst_support (burst_support) */
	REG_DUMP_PRINT_1("   -burst_support.burst_support                                            |         0x%01X  |  [RW][01:00]""This register enables or disables different levels of burst support on the data master interface associated with this master register bank. The encoding of this register is explained below.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb1800);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.srmd_support                                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_srmd_support_type */
	/* skip, unused field unused_srmd_support (srmd_support) */
	REG_DUMP_PRINT_1("   -srmd_support.srmd_support                                              |         0x%01X  |  [RW][00:00]""This register enables or disables support for Single-Request-Multiple-Data (SRMD) read protocol on the CIO data master interface associated with this master register bank. When set to 0, all data transfers will use Multiple-Request-Multiple-Data (MRMD) protocol. When set to 1, the master will attempt to use SRMD transfers where applicable.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb1028);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.physical_block_width_2d_burst_set1                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_physical_block_width_2d_burst_set1_type */
	/* skip, unused field unused_physical_block_width_2d_burst_set1 (physical_block_width_2d_burst_set1) */
	REG_DUMP_PRINT_1("   -physical_block_width_2d_burst_set1.physical_block_width_2d_burst_set1  |      0x%04X  |  [RW][12:00]""Maximum physical block width, encoded as number of physical block columns minus 1, to be used by the DMA masters when transferring units of data, in case the unit height is larger than 1 line. This value determines the splitting of units into columns of physical blocks. For non-strict element precisions this value is constrained to be a multiple of the maximum number of elements that fit a packed data word for each active master.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb1024);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.physical_block_width_1d_burst_set1                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_physical_block_width_1d_burst_set1_type */
	/* skip, unused field unused_physical_block_width_1d_burst_set1 (physical_block_width_1d_burst_set1) */
	REG_DUMP_PRINT_1("   -physical_block_width_1d_burst_set1.physical_block_width_1d_burst_set1  |      0x%04X  |  [RW][12:00]""Maximum physical block width, encoded as number of physical block columns minus 1, to be used by the DMA masters when transferring units of data, in case the unit height equals 1 line. This value determines the splitting of units into columns of physical blocks. For non-strict element precisions this value is constrained to be a multiple of the maximum number of elements that fit a packed data word for each active master.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb1020);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.physical_block_width_2d_burst_set0                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_physical_block_width_2d_burst_set0_type */
	/* skip, unused field unused_physical_block_width_2d_burst_set0 (physical_block_width_2d_burst_set0) */
	REG_DUMP_PRINT_1("   -physical_block_width_2d_burst_set0.physical_block_width_2d_burst_set0  |      0x%04X  |  [RW][12:00]""Maximum physical block width, encoded as number of physical block columns minus 1, to be used by the DMA masters when transferring units of data, in case the unit height is larger than 1 line. This value determines the splitting of units into columns of physical blocks. For non-strict element precisions this value is constrained to be a multiple of the maximum number of elements that fit a packed data word for each active master.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb101c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.physical_block_width_1d_burst_set0                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_physical_block_width_1d_burst_set0_type */
	/* skip, unused field unused_physical_block_width_1d_burst_set0 (physical_block_width_1d_burst_set0) */
	REG_DUMP_PRINT_1("   -physical_block_width_1d_burst_set0.physical_block_width_1d_burst_set0  |      0x%04X  |  [RW][12:00]""Maximum physical block width, encoded as number of physical block columns minus 1, to be used by the DMA masters when transferring units of data, in case the unit height equals 1 line. This value determines the splitting of units into columns of physical blocks. For non-strict element precisions this value is constrained to be a multiple of the maximum number of elements that fit a packed data word for each active master.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xb1018);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.maximum_physical_block_height                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_maximum_physical_block_height_type */
	/* skip, unused field unused_maximum_physical_block_height (maximum_physical_block_height) */
	REG_DUMP_PRINT_1("   -maximum_physical_block_height.maximum_physical_block_height            |         0x%01X  |  [RW][01:00]""Maximum physical block height, encoded as number of physical block rows minus 1, to be used by the DMA masters when moving or initializing blocks of data. This value determines the splitting of data units into rows of physical blocks.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb1014);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel_descriptor_base_address                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel_descriptor_base_address_type */
	REG_DUMP_PRINT_1("   -channel_descriptor_base_address.channel_descriptor_base_address        |  0x%08X  |  [RW][31:00]""Channel descriptor base address register holding the external memory mapped location from where channel descriptor information is to be fetched on a channel bank refill.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb1010);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.terminal_descriptor_base_address                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_terminal_descriptor_base_address_type */
	REG_DUMP_PRINT_1("   -terminal_descriptor_base_address.terminal_descriptor_base_address      |  0x%08X  |  [RW][31:00]""Terminal descriptor base address register holding the external memory mapped location from where terminal descriptor information is to be fetched on a channel bank refill.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb100c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.span_descriptor_base_address                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_span_descriptor_base_address_type */
	REG_DUMP_PRINT_1("   -span_descriptor_base_address.span_descriptor_base_address              |  0x%08X  |  [RW][31:00]""Span descriptor base address register holding the external memory mapped location from where span descriptor information is to be fetched on a span bank refill.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb1008);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.unit_descriptor_base_address                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_unit_descriptor_base_address_type */
	REG_DUMP_PRINT_1("   -unit_descriptor_base_address.unit_descriptor_base_address              |  0x%08X  |  [RW][31:00]""Unit descriptor base address register holding the external memory mapped location from where unit descriptor information is to be fetched on a unit bank refill.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb1004);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.idle                                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_idle_type */
	/* skip, unused field unused_idle (idle) */
	REG_DUMP_PRINT_1("   -idle.idle                                                              |         0x%01X  |  [RO][00:00]""Idle read-only status register, indicating whether any command is in flight on the DMA or not. When the value of this register is equal to '0', instructions are in flight and/or have not been acknowledged and hence the DMA is regarded as busy. When the value of this register is equal to '1' the DMA is inactive and hence regarded as idle.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0b50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req13_request_resourced                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req13_request_resourced_type */
	/* skip, unused field unused_req13_request_resourced (req13_request_resourced) */
	REG_DUMP_PRINT_1("   -req13_request_resourced.req13_request_resourced                        |         0x%01X  |  [RO][00:00]""Request resourced register indicating that all internal resources required to move the request into the next internal stage have been successfully reserved by the DMA. This register can be read, but not written through the control slave interface. It is automatically set and cleared by internal DMA logic only. Any write to the register via the control slave interface will simply be ignored.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0b4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req13_request_valid                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req13_request_valid_type */
	/* skip, unused field unused_req13_request_valid (req13_request_valid) */
	REG_DUMP_PRINT_1("   -req13_request_valid.req13_request_valid                                |         0x%01X  |  [RO][00:00]""Request valid register indicating that the current settings in the register bank compose a valid pending request. This register can be read, but not written through the control slave interface. It is automatically set and cleared by internal DMA logic only. Any write to the register via the control slave interface will simply be ignored.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0b48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req13_setup_2                                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req13_setup_2_type */
	/* skip, unused field unused_req13_setup_2 (req13_setup_2) */
	REG_DUMP_PRINT_1("   -req13_setup_2.req13_setup_2                                            |       0x%03X  |  [RW][09:00]""Register specifying the span IDs pointing to the corresponding span descriptors to be used with the instruction.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb0b44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req13_setup_1                                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req13_setup_1_type */
	/* skip, unused field unused_req13_setup_1 (req13_setup_1) */
	REG_DUMP_PRINT_1("   -req13_setup_1.req13_setup_1                                            |     0x%05X  |  [RW][17:00]""Register specifying the channel ID, terminal IDs and unit IDs pointing to the corresponding channel descriptor, terminal descriptors, and unit descriptor to be used with the instruction.""\n", FIELD_VALUE(val, 0, 17));
	val = REG_DUMP_READ_REGISTER(0xb0b40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req13_instruction                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req13_instruction_type */
	/* skip, unused field unused_req13_instruction (req13_instruction) */
	REG_DUMP_PRINT_1("   -req13_instruction.req13_instruction                                    |     0x%05X  |  [RW][17:00]""Specify the instruction to be executed. A write to this register automatically sets the request valid register to '1'. This register can only be written if the value of the request valid register is equal to '0'.""\n", FIELD_VALUE(val, 0, 17));
	val = REG_DUMP_READ_REGISTER(0xb0b10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req12_request_resourced                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req12_request_resourced_type */
	/* skip, unused field unused_req12_request_resourced (req12_request_resourced) */
	REG_DUMP_PRINT_1("   -req12_request_resourced.req12_request_resourced                        |         0x%01X  |  [RO][00:00]""Request resourced register indicating that all internal resources required to move the request into the next internal stage have been successfully reserved by the DMA. This register can be read, but not written through the control slave interface. It is automatically set and cleared by internal DMA logic only. Any write to the register via the control slave interface will simply be ignored.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0b0c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req12_request_valid                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req12_request_valid_type */
	/* skip, unused field unused_req12_request_valid (req12_request_valid) */
	REG_DUMP_PRINT_1("   -req12_request_valid.req12_request_valid                                |         0x%01X  |  [RO][00:00]""Request valid register indicating that the current settings in the register bank compose a valid pending request. This register can be read, but not written through the control slave interface. It is automatically set and cleared by internal DMA logic only. Any write to the register via the control slave interface will simply be ignored.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0b08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req12_setup_2                                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req12_setup_2_type */
	/* skip, unused field unused_req12_setup_2 (req12_setup_2) */
	REG_DUMP_PRINT_1("   -req12_setup_2.req12_setup_2                                            |       0x%03X  |  [RW][09:00]""Register specifying the span IDs pointing to the corresponding span descriptors to be used with the instruction.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb0b04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req12_setup_1                                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req12_setup_1_type */
	/* skip, unused field unused_req12_setup_1 (req12_setup_1) */
	REG_DUMP_PRINT_1("   -req12_setup_1.req12_setup_1                                            |     0x%05X  |  [RW][17:00]""Register specifying the channel ID, terminal IDs and unit IDs pointing to the corresponding channel descriptor, terminal descriptors, and unit descriptor to be used with the instruction.""\n", FIELD_VALUE(val, 0, 17));
	val = REG_DUMP_READ_REGISTER(0xb0b00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req12_instruction                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req12_instruction_type */
	/* skip, unused field unused_req12_instruction (req12_instruction) */
	REG_DUMP_PRINT_1("   -req12_instruction.req12_instruction                                    |     0x%05X  |  [RW][17:00]""Specify the instruction to be executed. A write to this register automatically sets the request valid register to '1'. This register can only be written if the value of the request valid register is equal to '0'.""\n", FIELD_VALUE(val, 0, 17));
	val = REG_DUMP_READ_REGISTER(0xb0ad0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req11_request_resourced                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req11_request_resourced_type */
	/* skip, unused field unused_req11_request_resourced (req11_request_resourced) */
	REG_DUMP_PRINT_1("   -req11_request_resourced.req11_request_resourced                        |         0x%01X  |  [RO][00:00]""Request resourced register indicating that all internal resources required to move the request into the next internal stage have been successfully reserved by the DMA. This register can be read, but not written through the control slave interface. It is automatically set and cleared by internal DMA logic only. Any write to the register via the control slave interface will simply be ignored.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0acc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req11_request_valid                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req11_request_valid_type */
	/* skip, unused field unused_req11_request_valid (req11_request_valid) */
	REG_DUMP_PRINT_1("   -req11_request_valid.req11_request_valid                                |         0x%01X  |  [RO][00:00]""Request valid register indicating that the current settings in the register bank compose a valid pending request. This register can be read, but not written through the control slave interface. It is automatically set and cleared by internal DMA logic only. Any write to the register via the control slave interface will simply be ignored.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0ac8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req11_setup_2                                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req11_setup_2_type */
	/* skip, unused field unused_req11_setup_2 (req11_setup_2) */
	REG_DUMP_PRINT_1("   -req11_setup_2.req11_setup_2                                            |       0x%03X  |  [RW][09:00]""Register specifying the span IDs pointing to the corresponding span descriptors to be used with the instruction.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb0ac4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req11_setup_1                                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req11_setup_1_type */
	/* skip, unused field unused_req11_setup_1 (req11_setup_1) */
	REG_DUMP_PRINT_1("   -req11_setup_1.req11_setup_1                                            |     0x%05X  |  [RW][17:00]""Register specifying the channel ID, terminal IDs and unit IDs pointing to the corresponding channel descriptor, terminal descriptors, and unit descriptor to be used with the instruction.""\n", FIELD_VALUE(val, 0, 17));
	val = REG_DUMP_READ_REGISTER(0xb0ac0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req11_instruction                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req11_instruction_type */
	/* skip, unused field unused_req11_instruction (req11_instruction) */
	REG_DUMP_PRINT_1("   -req11_instruction.req11_instruction                                    |     0x%05X  |  [RW][17:00]""Specify the instruction to be executed. A write to this register automatically sets the request valid register to '1'. This register can only be written if the value of the request valid register is equal to '0'.""\n", FIELD_VALUE(val, 0, 17));
	val = REG_DUMP_READ_REGISTER(0xb0a90);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req10_request_resourced                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req10_request_resourced_type */
	/* skip, unused field unused_req10_request_resourced (req10_request_resourced) */
	REG_DUMP_PRINT_1("   -req10_request_resourced.req10_request_resourced                        |         0x%01X  |  [RO][00:00]""Request resourced register indicating that all internal resources required to move the request into the next internal stage have been successfully reserved by the DMA. This register can be read, but not written through the control slave interface. It is automatically set and cleared by internal DMA logic only. Any write to the register via the control slave interface will simply be ignored.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0a8c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req10_request_valid                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req10_request_valid_type */
	/* skip, unused field unused_req10_request_valid (req10_request_valid) */
	REG_DUMP_PRINT_1("   -req10_request_valid.req10_request_valid                                |         0x%01X  |  [RO][00:00]""Request valid register indicating that the current settings in the register bank compose a valid pending request. This register can be read, but not written through the control slave interface. It is automatically set and cleared by internal DMA logic only. Any write to the register via the control slave interface will simply be ignored.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0a88);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req10_setup_2                                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req10_setup_2_type */
	/* skip, unused field unused_req10_setup_2 (req10_setup_2) */
	REG_DUMP_PRINT_1("   -req10_setup_2.req10_setup_2                                            |       0x%03X  |  [RW][09:00]""Register specifying the span IDs pointing to the corresponding span descriptors to be used with the instruction.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb0a84);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req10_setup_1                                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req10_setup_1_type */
	/* skip, unused field unused_req10_setup_1 (req10_setup_1) */
	REG_DUMP_PRINT_1("   -req10_setup_1.req10_setup_1                                            |     0x%05X  |  [RW][17:00]""Register specifying the channel ID, terminal IDs and unit IDs pointing to the corresponding channel descriptor, terminal descriptors, and unit descriptor to be used with the instruction.""\n", FIELD_VALUE(val, 0, 17));
	val = REG_DUMP_READ_REGISTER(0xb0a80);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req10_instruction                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req10_instruction_type */
	/* skip, unused field unused_req10_instruction (req10_instruction) */
	REG_DUMP_PRINT_1("   -req10_instruction.req10_instruction                                    |     0x%05X  |  [RW][17:00]""Specify the instruction to be executed. A write to this register automatically sets the request valid register to '1'. This register can only be written if the value of the request valid register is equal to '0'.""\n", FIELD_VALUE(val, 0, 17));
	val = REG_DUMP_READ_REGISTER(0xb0a50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req9_request_resourced                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req9_request_resourced_type */
	/* skip, unused field unused_req9_request_resourced (req9_request_resourced) */
	REG_DUMP_PRINT_1("   -req9_request_resourced.req9_request_resourced                          |         0x%01X  |  [RO][00:00]""Request resourced register indicating that all internal resources required to move the request into the next internal stage have been successfully reserved by the DMA. This register can be read, but not written through the control slave interface. It is automatically set and cleared by internal DMA logic only. Any write to the register via the control slave interface will simply be ignored.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0a4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req9_request_valid                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req9_request_valid_type */
	/* skip, unused field unused_req9_request_valid (req9_request_valid) */
	REG_DUMP_PRINT_1("   -req9_request_valid.req9_request_valid                                  |         0x%01X  |  [RO][00:00]""Request valid register indicating that the current settings in the register bank compose a valid pending request. This register can be read, but not written through the control slave interface. It is automatically set and cleared by internal DMA logic only. Any write to the register via the control slave interface will simply be ignored.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0a48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req9_setup_2                                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req9_setup_2_type */
	/* skip, unused field unused_req9_setup_2 (req9_setup_2) */
	REG_DUMP_PRINT_1("   -req9_setup_2.req9_setup_2                                              |       0x%03X  |  [RW][09:00]""Register specifying the span IDs pointing to the corresponding span descriptors to be used with the instruction.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb0a44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req9_setup_1                                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req9_setup_1_type */
	/* skip, unused field unused_req9_setup_1 (req9_setup_1) */
	REG_DUMP_PRINT_1("   -req9_setup_1.req9_setup_1                                              |     0x%05X  |  [RW][17:00]""Register specifying the channel ID, terminal IDs and unit IDs pointing to the corresponding channel descriptor, terminal descriptors, and unit descriptor to be used with the instruction.""\n", FIELD_VALUE(val, 0, 17));
	val = REG_DUMP_READ_REGISTER(0xb0a40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req9_instruction                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req9_instruction_type */
	/* skip, unused field unused_req9_instruction (req9_instruction) */
	REG_DUMP_PRINT_1("   -req9_instruction.req9_instruction                                      |     0x%05X  |  [RW][17:00]""Specify the instruction to be executed. A write to this register automatically sets the request valid register to '1'. This register can only be written if the value of the request valid register is equal to '0'.""\n", FIELD_VALUE(val, 0, 17));
	val = REG_DUMP_READ_REGISTER(0xb0a10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req8_request_resourced                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req8_request_resourced_type */
	/* skip, unused field unused_req8_request_resourced (req8_request_resourced) */
	REG_DUMP_PRINT_1("   -req8_request_resourced.req8_request_resourced                          |         0x%01X  |  [RO][00:00]""Request resourced register indicating that all internal resources required to move the request into the next internal stage have been successfully reserved by the DMA. This register can be read, but not written through the control slave interface. It is automatically set and cleared by internal DMA logic only. Any write to the register via the control slave interface will simply be ignored.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0a0c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req8_request_valid                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req8_request_valid_type */
	/* skip, unused field unused_req8_request_valid (req8_request_valid) */
	REG_DUMP_PRINT_1("   -req8_request_valid.req8_request_valid                                  |         0x%01X  |  [RO][00:00]""Request valid register indicating that the current settings in the register bank compose a valid pending request. This register can be read, but not written through the control slave interface. It is automatically set and cleared by internal DMA logic only. Any write to the register via the control slave interface will simply be ignored.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0a08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req8_setup_2                                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req8_setup_2_type */
	/* skip, unused field unused_req8_setup_2 (req8_setup_2) */
	REG_DUMP_PRINT_1("   -req8_setup_2.req8_setup_2                                              |       0x%03X  |  [RW][09:00]""Register specifying the span IDs pointing to the corresponding span descriptors to be used with the instruction.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb0a04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req8_setup_1                                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req8_setup_1_type */
	/* skip, unused field unused_req8_setup_1 (req8_setup_1) */
	REG_DUMP_PRINT_1("   -req8_setup_1.req8_setup_1                                              |     0x%05X  |  [RW][17:00]""Register specifying the channel ID, terminal IDs and unit IDs pointing to the corresponding channel descriptor, terminal descriptors, and unit descriptor to be used with the instruction.""\n", FIELD_VALUE(val, 0, 17));
	val = REG_DUMP_READ_REGISTER(0xb0a00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req8_instruction                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req8_instruction_type */
	/* skip, unused field unused_req8_instruction (req8_instruction) */
	REG_DUMP_PRINT_1("   -req8_instruction.req8_instruction                                      |     0x%05X  |  [RW][17:00]""Specify the instruction to be executed. A write to this register automatically sets the request valid register to '1'. This register can only be written if the value of the request valid register is equal to '0'.""\n", FIELD_VALUE(val, 0, 17));
	val = REG_DUMP_READ_REGISTER(0xb09d0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req7_request_resourced                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req7_request_resourced_type */
	/* skip, unused field unused_req7_request_resourced (req7_request_resourced) */
	REG_DUMP_PRINT_1("   -req7_request_resourced.req7_request_resourced                          |         0x%01X  |  [RO][00:00]""Request resourced register indicating that all internal resources required to move the request into the next internal stage have been successfully reserved by the DMA. This register can be read, but not written through the control slave interface. It is automatically set and cleared by internal DMA logic only. Any write to the register via the control slave interface will simply be ignored.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb09cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req7_request_valid                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req7_request_valid_type */
	/* skip, unused field unused_req7_request_valid (req7_request_valid) */
	REG_DUMP_PRINT_1("   -req7_request_valid.req7_request_valid                                  |         0x%01X  |  [RO][00:00]""Request valid register indicating that the current settings in the register bank compose a valid pending request. This register can be read, but not written through the control slave interface. It is automatically set and cleared by internal DMA logic only. Any write to the register via the control slave interface will simply be ignored.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb09c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req7_setup_2                                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req7_setup_2_type */
	/* skip, unused field unused_req7_setup_2 (req7_setup_2) */
	REG_DUMP_PRINT_1("   -req7_setup_2.req7_setup_2                                              |       0x%03X  |  [RW][09:00]""Register specifying the span IDs pointing to the corresponding span descriptors to be used with the instruction.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb09c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req7_setup_1                                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req7_setup_1_type */
	/* skip, unused field unused_req7_setup_1 (req7_setup_1) */
	REG_DUMP_PRINT_1("   -req7_setup_1.req7_setup_1                                              |     0x%05X  |  [RW][17:00]""Register specifying the channel ID, terminal IDs and unit IDs pointing to the corresponding channel descriptor, terminal descriptors, and unit descriptor to be used with the instruction.""\n", FIELD_VALUE(val, 0, 17));
	val = REG_DUMP_READ_REGISTER(0xb09c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req7_instruction                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req7_instruction_type */
	/* skip, unused field unused_req7_instruction (req7_instruction) */
	REG_DUMP_PRINT_1("   -req7_instruction.req7_instruction                                      |     0x%05X  |  [RW][17:00]""Specify the instruction to be executed. A write to this register automatically sets the request valid register to '1'. This register can only be written if the value of the request valid register is equal to '0'.""\n", FIELD_VALUE(val, 0, 17));
	val = REG_DUMP_READ_REGISTER(0xb0990);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req6_request_resourced                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req6_request_resourced_type */
	/* skip, unused field unused_req6_request_resourced (req6_request_resourced) */
	REG_DUMP_PRINT_1("   -req6_request_resourced.req6_request_resourced                          |         0x%01X  |  [RO][00:00]""Request resourced register indicating that all internal resources required to move the request into the next internal stage have been successfully reserved by the DMA. This register can be read, but not written through the control slave interface. It is automatically set and cleared by internal DMA logic only. Any write to the register via the control slave interface will simply be ignored.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb098c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req6_request_valid                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req6_request_valid_type */
	/* skip, unused field unused_req6_request_valid (req6_request_valid) */
	REG_DUMP_PRINT_1("   -req6_request_valid.req6_request_valid                                  |         0x%01X  |  [RO][00:00]""Request valid register indicating that the current settings in the register bank compose a valid pending request. This register can be read, but not written through the control slave interface. It is automatically set and cleared by internal DMA logic only. Any write to the register via the control slave interface will simply be ignored.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0988);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req6_setup_2                                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req6_setup_2_type */
	/* skip, unused field unused_req6_setup_2 (req6_setup_2) */
	REG_DUMP_PRINT_1("   -req6_setup_2.req6_setup_2                                              |       0x%03X  |  [RW][09:00]""Register specifying the span IDs pointing to the corresponding span descriptors to be used with the instruction.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb0984);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req6_setup_1                                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req6_setup_1_type */
	/* skip, unused field unused_req6_setup_1 (req6_setup_1) */
	REG_DUMP_PRINT_1("   -req6_setup_1.req6_setup_1                                              |     0x%05X  |  [RW][17:00]""Register specifying the channel ID, terminal IDs and unit IDs pointing to the corresponding channel descriptor, terminal descriptors, and unit descriptor to be used with the instruction.""\n", FIELD_VALUE(val, 0, 17));
	val = REG_DUMP_READ_REGISTER(0xb0980);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req6_instruction                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req6_instruction_type */
	/* skip, unused field unused_req6_instruction (req6_instruction) */
	REG_DUMP_PRINT_1("   -req6_instruction.req6_instruction                                      |     0x%05X  |  [RW][17:00]""Specify the instruction to be executed. A write to this register automatically sets the request valid register to '1'. This register can only be written if the value of the request valid register is equal to '0'.""\n", FIELD_VALUE(val, 0, 17));
	val = REG_DUMP_READ_REGISTER(0xb0950);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req5_request_resourced                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req5_request_resourced_type */
	/* skip, unused field unused_req5_request_resourced (req5_request_resourced) */
	REG_DUMP_PRINT_1("   -req5_request_resourced.req5_request_resourced                          |         0x%01X  |  [RO][00:00]""Request resourced register indicating that all internal resources required to move the request into the next internal stage have been successfully reserved by the DMA. This register can be read, but not written through the control slave interface. It is automatically set and cleared by internal DMA logic only. Any write to the register via the control slave interface will simply be ignored.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb094c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req5_request_valid                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req5_request_valid_type */
	/* skip, unused field unused_req5_request_valid (req5_request_valid) */
	REG_DUMP_PRINT_1("   -req5_request_valid.req5_request_valid                                  |         0x%01X  |  [RO][00:00]""Request valid register indicating that the current settings in the register bank compose a valid pending request. This register can be read, but not written through the control slave interface. It is automatically set and cleared by internal DMA logic only. Any write to the register via the control slave interface will simply be ignored.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0948);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req5_setup_2                                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req5_setup_2_type */
	/* skip, unused field unused_req5_setup_2 (req5_setup_2) */
	REG_DUMP_PRINT_1("   -req5_setup_2.req5_setup_2                                              |       0x%03X  |  [RW][09:00]""Register specifying the span IDs pointing to the corresponding span descriptors to be used with the instruction.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb0944);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req5_setup_1                                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req5_setup_1_type */
	/* skip, unused field unused_req5_setup_1 (req5_setup_1) */
	REG_DUMP_PRINT_1("   -req5_setup_1.req5_setup_1                                              |     0x%05X  |  [RW][17:00]""Register specifying the channel ID, terminal IDs and unit IDs pointing to the corresponding channel descriptor, terminal descriptors, and unit descriptor to be used with the instruction.""\n", FIELD_VALUE(val, 0, 17));
	val = REG_DUMP_READ_REGISTER(0xb0940);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req5_instruction                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req5_instruction_type */
	/* skip, unused field unused_req5_instruction (req5_instruction) */
	REG_DUMP_PRINT_1("   -req5_instruction.req5_instruction                                      |     0x%05X  |  [RW][17:00]""Specify the instruction to be executed. A write to this register automatically sets the request valid register to '1'. This register can only be written if the value of the request valid register is equal to '0'.""\n", FIELD_VALUE(val, 0, 17));
	val = REG_DUMP_READ_REGISTER(0xb0910);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req4_request_resourced                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req4_request_resourced_type */
	/* skip, unused field unused_req4_request_resourced (req4_request_resourced) */
	REG_DUMP_PRINT_1("   -req4_request_resourced.req4_request_resourced                          |         0x%01X  |  [RO][00:00]""Request resourced register indicating that all internal resources required to move the request into the next internal stage have been successfully reserved by the DMA. This register can be read, but not written through the control slave interface. It is automatically set and cleared by internal DMA logic only. Any write to the register via the control slave interface will simply be ignored.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb090c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req4_request_valid                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req4_request_valid_type */
	/* skip, unused field unused_req4_request_valid (req4_request_valid) */
	REG_DUMP_PRINT_1("   -req4_request_valid.req4_request_valid                                  |         0x%01X  |  [RO][00:00]""Request valid register indicating that the current settings in the register bank compose a valid pending request. This register can be read, but not written through the control slave interface. It is automatically set and cleared by internal DMA logic only. Any write to the register via the control slave interface will simply be ignored.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0908);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req4_setup_2                                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req4_setup_2_type */
	/* skip, unused field unused_req4_setup_2 (req4_setup_2) */
	REG_DUMP_PRINT_1("   -req4_setup_2.req4_setup_2                                              |       0x%03X  |  [RW][09:00]""Register specifying the span IDs pointing to the corresponding span descriptors to be used with the instruction.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb0904);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req4_setup_1                                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req4_setup_1_type */
	/* skip, unused field unused_req4_setup_1 (req4_setup_1) */
	REG_DUMP_PRINT_1("   -req4_setup_1.req4_setup_1                                              |     0x%05X  |  [RW][17:00]""Register specifying the channel ID, terminal IDs and unit IDs pointing to the corresponding channel descriptor, terminal descriptors, and unit descriptor to be used with the instruction.""\n", FIELD_VALUE(val, 0, 17));
	val = REG_DUMP_READ_REGISTER(0xb0900);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req4_instruction                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req4_instruction_type */
	/* skip, unused field unused_req4_instruction (req4_instruction) */
	REG_DUMP_PRINT_1("   -req4_instruction.req4_instruction                                      |     0x%05X  |  [RW][17:00]""Specify the instruction to be executed. A write to this register automatically sets the request valid register to '1'. This register can only be written if the value of the request valid register is equal to '0'.""\n", FIELD_VALUE(val, 0, 17));
	val = REG_DUMP_READ_REGISTER(0xb08d0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req3_request_resourced                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req3_request_resourced_type */
	/* skip, unused field unused_req3_request_resourced (req3_request_resourced) */
	REG_DUMP_PRINT_1("   -req3_request_resourced.req3_request_resourced                          |         0x%01X  |  [RO][00:00]""Request resourced register indicating that all internal resources required to move the request into the next internal stage have been successfully reserved by the DMA. This register can be read, but not written through the control slave interface. It is automatically set and cleared by internal DMA logic only. Any write to the register via the control slave interface will simply be ignored.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb08cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req3_request_valid                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req3_request_valid_type */
	/* skip, unused field unused_req3_request_valid (req3_request_valid) */
	REG_DUMP_PRINT_1("   -req3_request_valid.req3_request_valid                                  |         0x%01X  |  [RO][00:00]""Request valid register indicating that the current settings in the register bank compose a valid pending request. This register can be read, but not written through the control slave interface. It is automatically set and cleared by internal DMA logic only. Any write to the register via the control slave interface will simply be ignored.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb08c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req3_setup_2                                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req3_setup_2_type */
	/* skip, unused field unused_req3_setup_2 (req3_setup_2) */
	REG_DUMP_PRINT_1("   -req3_setup_2.req3_setup_2                                              |       0x%03X  |  [RW][09:00]""Register specifying the span IDs pointing to the corresponding span descriptors to be used with the instruction.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb08c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req3_setup_1                                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req3_setup_1_type */
	/* skip, unused field unused_req3_setup_1 (req3_setup_1) */
	REG_DUMP_PRINT_1("   -req3_setup_1.req3_setup_1                                              |     0x%05X  |  [RW][17:00]""Register specifying the channel ID, terminal IDs and unit IDs pointing to the corresponding channel descriptor, terminal descriptors, and unit descriptor to be used with the instruction.""\n", FIELD_VALUE(val, 0, 17));
	val = REG_DUMP_READ_REGISTER(0xb08c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req3_instruction                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req3_instruction_type */
	/* skip, unused field unused_req3_instruction (req3_instruction) */
	REG_DUMP_PRINT_1("   -req3_instruction.req3_instruction                                      |     0x%05X  |  [RW][17:00]""Specify the instruction to be executed. A write to this register automatically sets the request valid register to '1'. This register can only be written if the value of the request valid register is equal to '0'.""\n", FIELD_VALUE(val, 0, 17));
	val = REG_DUMP_READ_REGISTER(0xb0890);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req2_request_resourced                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req2_request_resourced_type */
	/* skip, unused field unused_req2_request_resourced (req2_request_resourced) */
	REG_DUMP_PRINT_1("   -req2_request_resourced.req2_request_resourced                          |         0x%01X  |  [RO][00:00]""Request resourced register indicating that all internal resources required to move the request into the next internal stage have been successfully reserved by the DMA. This register can be read, but not written through the control slave interface. It is automatically set and cleared by internal DMA logic only. Any write to the register via the control slave interface will simply be ignored.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb088c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req2_request_valid                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req2_request_valid_type */
	/* skip, unused field unused_req2_request_valid (req2_request_valid) */
	REG_DUMP_PRINT_1("   -req2_request_valid.req2_request_valid                                  |         0x%01X  |  [RO][00:00]""Request valid register indicating that the current settings in the register bank compose a valid pending request. This register can be read, but not written through the control slave interface. It is automatically set and cleared by internal DMA logic only. Any write to the register via the control slave interface will simply be ignored.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0888);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req2_setup_2                                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req2_setup_2_type */
	/* skip, unused field unused_req2_setup_2 (req2_setup_2) */
	REG_DUMP_PRINT_1("   -req2_setup_2.req2_setup_2                                              |       0x%03X  |  [RW][09:00]""Register specifying the span IDs pointing to the corresponding span descriptors to be used with the instruction.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb0884);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req2_setup_1                                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req2_setup_1_type */
	/* skip, unused field unused_req2_setup_1 (req2_setup_1) */
	REG_DUMP_PRINT_1("   -req2_setup_1.req2_setup_1                                              |     0x%05X  |  [RW][17:00]""Register specifying the channel ID, terminal IDs and unit IDs pointing to the corresponding channel descriptor, terminal descriptors, and unit descriptor to be used with the instruction.""\n", FIELD_VALUE(val, 0, 17));
	val = REG_DUMP_READ_REGISTER(0xb0880);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req2_instruction                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req2_instruction_type */
	/* skip, unused field unused_req2_instruction (req2_instruction) */
	REG_DUMP_PRINT_1("   -req2_instruction.req2_instruction                                      |     0x%05X  |  [RW][17:00]""Specify the instruction to be executed. A write to this register automatically sets the request valid register to '1'. This register can only be written if the value of the request valid register is equal to '0'.""\n", FIELD_VALUE(val, 0, 17));
	val = REG_DUMP_READ_REGISTER(0xb0850);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req1_request_resourced                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req1_request_resourced_type */
	/* skip, unused field unused_req1_request_resourced (req1_request_resourced) */
	REG_DUMP_PRINT_1("   -req1_request_resourced.req1_request_resourced                          |         0x%01X  |  [RO][00:00]""Request resourced register indicating that all internal resources required to move the request into the next internal stage have been successfully reserved by the DMA. This register can be read, but not written through the control slave interface. It is automatically set and cleared by internal DMA logic only. Any write to the register via the control slave interface will simply be ignored.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb084c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req1_request_valid                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req1_request_valid_type */
	/* skip, unused field unused_req1_request_valid (req1_request_valid) */
	REG_DUMP_PRINT_1("   -req1_request_valid.req1_request_valid                                  |         0x%01X  |  [RO][00:00]""Request valid register indicating that the current settings in the register bank compose a valid pending request. This register can be read, but not written through the control slave interface. It is automatically set and cleared by internal DMA logic only. Any write to the register via the control slave interface will simply be ignored.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0848);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req1_setup_2                                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req1_setup_2_type */
	/* skip, unused field unused_req1_setup_2 (req1_setup_2) */
	REG_DUMP_PRINT_1("   -req1_setup_2.req1_setup_2                                              |       0x%03X  |  [RW][09:00]""Register specifying the span IDs pointing to the corresponding span descriptors to be used with the instruction.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb0844);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req1_setup_1                                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req1_setup_1_type */
	/* skip, unused field unused_req1_setup_1 (req1_setup_1) */
	REG_DUMP_PRINT_1("   -req1_setup_1.req1_setup_1                                              |     0x%05X  |  [RW][17:00]""Register specifying the channel ID, terminal IDs and unit IDs pointing to the corresponding channel descriptor, terminal descriptors, and unit descriptor to be used with the instruction.""\n", FIELD_VALUE(val, 0, 17));
	val = REG_DUMP_READ_REGISTER(0xb0840);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req1_instruction                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req1_instruction_type */
	/* skip, unused field unused_req1_instruction (req1_instruction) */
	REG_DUMP_PRINT_1("   -req1_instruction.req1_instruction                                      |     0x%05X  |  [RW][17:00]""Specify the instruction to be executed. A write to this register automatically sets the request valid register to '1'. This register can only be written if the value of the request valid register is equal to '0'.""\n", FIELD_VALUE(val, 0, 17));
	val = REG_DUMP_READ_REGISTER(0xb0810);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req0_request_resourced                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req0_request_resourced_type */
	/* skip, unused field unused_req0_request_resourced (req0_request_resourced) */
	REG_DUMP_PRINT_1("   -req0_request_resourced.req0_request_resourced                          |         0x%01X  |  [RO][00:00]""Request resourced register indicating that all internal resources required to move the request into the next internal stage have been successfully reserved by the DMA. This register can be read, but not written through the control slave interface. It is automatically set and cleared by internal DMA logic only. Any write to the register via the control slave interface will simply be ignored.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb080c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req0_request_valid                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req0_request_valid_type */
	/* skip, unused field unused_req0_request_valid (req0_request_valid) */
	REG_DUMP_PRINT_1("   -req0_request_valid.req0_request_valid                                  |         0x%01X  |  [RO][00:00]""Request valid register indicating that the current settings in the register bank compose a valid pending request. This register can be read, but not written through the control slave interface. It is automatically set and cleared by internal DMA logic only. Any write to the register via the control slave interface will simply be ignored.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0808);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req0_setup_2                                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req0_setup_2_type */
	/* skip, unused field unused_req0_setup_2 (req0_setup_2) */
	REG_DUMP_PRINT_1("   -req0_setup_2.req0_setup_2                                              |       0x%03X  |  [RW][09:00]""Register specifying the span IDs pointing to the corresponding span descriptors to be used with the instruction.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb0804);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req0_setup_1                                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req0_setup_1_type */
	/* skip, unused field unused_req0_setup_1 (req0_setup_1) */
	REG_DUMP_PRINT_1("   -req0_setup_1.req0_setup_1                                              |     0x%05X  |  [RW][17:00]""Register specifying the channel ID, terminal IDs and unit IDs pointing to the corresponding channel descriptor, terminal descriptors, and unit descriptor to be used with the instruction.""\n", FIELD_VALUE(val, 0, 17));
	val = REG_DUMP_READ_REGISTER(0xb0800);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.req0_instruction                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_req0_instruction_type */
	/* skip, unused field unused_req0_instruction (req0_instruction) */
	REG_DUMP_PRINT_1("   -req0_instruction.req0_instruction                                      |     0x%05X  |  [RW][17:00]""Specify the instruction to be executed. A write to this register automatically sets the request valid register to '1'. This register can only be written if the value of the request valid register is equal to '0'.""\n", FIELD_VALUE(val, 0, 17));
	val = REG_DUMP_READ_REGISTER(0xb03f8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel15_dirty_status                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel15_dirty_status_type */
	/* skip, unused field unused_channel15_dirty_status (channel15_dirty_status) */
	REG_DUMP_PRINT_1("   -channel15_dirty_status.channel15_dirty_status                          |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb03f4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel15_lock_status                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel15_lock_status_type */
	/* skip, unused field unused_channel15_lock_status (channel15_lock_status) */
	REG_DUMP_PRINT_1("   -channel15_lock_status.channel15_lock_status                            |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb03f0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel15_pending_counter                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel15_pending_counter_type */
	/* skip, unused field unused_channel15_pending_counter (channel15_pending_counter) */
	REG_DUMP_PRINT_1("   -channel15_pending_counter.channel15_pending_counter                    |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb03ec);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel15_completed_counter                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel15_completed_counter_type */
	/* skip, unused field unused_channel15_completed_counter (channel15_completed_counter) */
	REG_DUMP_PRINT_1("   -channel15_completed_counter.channel15_completed_counter                |        0x%02X  |  [RW][04:00]""Register keeping track of the number of operations using this channel that have completed and have been acknowledged, since the last time the register was read. When read through the slave interface and the channel is configured for passive acknowledgement, or when an active acknowledgment occurs, this register is automatically reset to 0. The register can written through the control slave interface for the purpose of state restore, typically when switching bank modes while using active acknowledge.""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0xb03dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel15_acknowledge_data                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel15_acknowledge_data_type */
	REG_DUMP_PRINT_1("   -channel15_acknowledge_data.channel15_acknowledge_data                  |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge data field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb03d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel15_acknowledge_address                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel15_acknowledge_address_type */
	REG_DUMP_PRINT_1("   -channel15_acknowledge_address.channel15_acknowledge_address            |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge address field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb03d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel15_acknowledge_mode                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel15_acknowledge_mode_type */
	/* skip, unused field unused_channel15_acknowledge_mode (channel15_acknowledge_mode) */
	REG_DUMP_PRINT_1("   -channel15_acknowledge_mode.channel15_acknowledge_mode                  |         0x%01X  |  [RW][03:00]""Register holding the value of the acknowledge mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb03d0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel15_global_set_id                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel15_global_set_id_type */
	/* skip, unused field unused_channel15_global_set_id (channel15_global_set_id) */
	REG_DUMP_PRINT_1("   -channel15_global_set_id.channel15_global_set_id                        |         0x%01X  |  [RW][00:00]""Register holding the value of the global set ID field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb03c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel15_padding_mode                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel15_padding_mode_type */
	/* skip, unused field unused_channel15_padding_mode (channel15_padding_mode) */
	REG_DUMP_PRINT_1("   -channel15_padding_mode.channel15_padding_mode                          |         0x%01X  |  [RW][02:00]""Register holding the value of the padding mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0xb03c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel15_element_extend_mode                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel15_element_extend_mode_type */
	/* skip, unused field unused_channel15_element_extend_mode (channel15_element_extend_mode) */
	REG_DUMP_PRINT_1("   -channel15_element_extend_mode.channel15_element_extend_mode            |         0x%01X  |  [RW][00:00]""Register holding the value of the element extend mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb03b8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel14_dirty_status                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel14_dirty_status_type */
	/* skip, unused field unused_channel14_dirty_status (channel14_dirty_status) */
	REG_DUMP_PRINT_1("   -channel14_dirty_status.channel14_dirty_status                          |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb03b4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel14_lock_status                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel14_lock_status_type */
	/* skip, unused field unused_channel14_lock_status (channel14_lock_status) */
	REG_DUMP_PRINT_1("   -channel14_lock_status.channel14_lock_status                            |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb03b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel14_pending_counter                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel14_pending_counter_type */
	/* skip, unused field unused_channel14_pending_counter (channel14_pending_counter) */
	REG_DUMP_PRINT_1("   -channel14_pending_counter.channel14_pending_counter                    |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb03ac);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel14_completed_counter                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel14_completed_counter_type */
	/* skip, unused field unused_channel14_completed_counter (channel14_completed_counter) */
	REG_DUMP_PRINT_1("   -channel14_completed_counter.channel14_completed_counter                |        0x%02X  |  [RW][04:00]""Register keeping track of the number of operations using this channel that have completed and have been acknowledged, since the last time the register was read. When read through the slave interface and the channel is configured for passive acknowledgement, or when an active acknowledgment occurs, this register is automatically reset to 0. The register can written through the control slave interface for the purpose of state restore, typically when switching bank modes while using active acknowledge.""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0xb039c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel14_acknowledge_data                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel14_acknowledge_data_type */
	REG_DUMP_PRINT_1("   -channel14_acknowledge_data.channel14_acknowledge_data                  |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge data field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb0398);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel14_acknowledge_address                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel14_acknowledge_address_type */
	REG_DUMP_PRINT_1("   -channel14_acknowledge_address.channel14_acknowledge_address            |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge address field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb0394);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel14_acknowledge_mode                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel14_acknowledge_mode_type */
	/* skip, unused field unused_channel14_acknowledge_mode (channel14_acknowledge_mode) */
	REG_DUMP_PRINT_1("   -channel14_acknowledge_mode.channel14_acknowledge_mode                  |         0x%01X  |  [RW][03:00]""Register holding the value of the acknowledge mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb0390);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel14_global_set_id                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel14_global_set_id_type */
	/* skip, unused field unused_channel14_global_set_id (channel14_global_set_id) */
	REG_DUMP_PRINT_1("   -channel14_global_set_id.channel14_global_set_id                        |         0x%01X  |  [RW][00:00]""Register holding the value of the global set ID field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0388);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel14_padding_mode                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel14_padding_mode_type */
	/* skip, unused field unused_channel14_padding_mode (channel14_padding_mode) */
	REG_DUMP_PRINT_1("   -channel14_padding_mode.channel14_padding_mode                          |         0x%01X  |  [RW][02:00]""Register holding the value of the padding mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0xb0380);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel14_element_extend_mode                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel14_element_extend_mode_type */
	/* skip, unused field unused_channel14_element_extend_mode (channel14_element_extend_mode) */
	REG_DUMP_PRINT_1("   -channel14_element_extend_mode.channel14_element_extend_mode            |         0x%01X  |  [RW][00:00]""Register holding the value of the element extend mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0378);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel13_dirty_status                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel13_dirty_status_type */
	/* skip, unused field unused_channel13_dirty_status (channel13_dirty_status) */
	REG_DUMP_PRINT_1("   -channel13_dirty_status.channel13_dirty_status                          |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0374);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel13_lock_status                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel13_lock_status_type */
	/* skip, unused field unused_channel13_lock_status (channel13_lock_status) */
	REG_DUMP_PRINT_1("   -channel13_lock_status.channel13_lock_status                            |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0370);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel13_pending_counter                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel13_pending_counter_type */
	/* skip, unused field unused_channel13_pending_counter (channel13_pending_counter) */
	REG_DUMP_PRINT_1("   -channel13_pending_counter.channel13_pending_counter                    |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb036c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel13_completed_counter                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel13_completed_counter_type */
	/* skip, unused field unused_channel13_completed_counter (channel13_completed_counter) */
	REG_DUMP_PRINT_1("   -channel13_completed_counter.channel13_completed_counter                |        0x%02X  |  [RW][04:00]""Register keeping track of the number of operations using this channel that have completed and have been acknowledged, since the last time the register was read. When read through the slave interface and the channel is configured for passive acknowledgement, or when an active acknowledgment occurs, this register is automatically reset to 0. The register can written through the control slave interface for the purpose of state restore, typically when switching bank modes while using active acknowledge.""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0xb035c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel13_acknowledge_data                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel13_acknowledge_data_type */
	REG_DUMP_PRINT_1("   -channel13_acknowledge_data.channel13_acknowledge_data                  |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge data field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb0358);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel13_acknowledge_address                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel13_acknowledge_address_type */
	REG_DUMP_PRINT_1("   -channel13_acknowledge_address.channel13_acknowledge_address            |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge address field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb0354);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel13_acknowledge_mode                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel13_acknowledge_mode_type */
	/* skip, unused field unused_channel13_acknowledge_mode (channel13_acknowledge_mode) */
	REG_DUMP_PRINT_1("   -channel13_acknowledge_mode.channel13_acknowledge_mode                  |         0x%01X  |  [RW][03:00]""Register holding the value of the acknowledge mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb0350);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel13_global_set_id                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel13_global_set_id_type */
	/* skip, unused field unused_channel13_global_set_id (channel13_global_set_id) */
	REG_DUMP_PRINT_1("   -channel13_global_set_id.channel13_global_set_id                        |         0x%01X  |  [RW][00:00]""Register holding the value of the global set ID field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0348);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel13_padding_mode                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel13_padding_mode_type */
	/* skip, unused field unused_channel13_padding_mode (channel13_padding_mode) */
	REG_DUMP_PRINT_1("   -channel13_padding_mode.channel13_padding_mode                          |         0x%01X  |  [RW][02:00]""Register holding the value of the padding mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0xb0340);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel13_element_extend_mode                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel13_element_extend_mode_type */
	/* skip, unused field unused_channel13_element_extend_mode (channel13_element_extend_mode) */
	REG_DUMP_PRINT_1("   -channel13_element_extend_mode.channel13_element_extend_mode            |         0x%01X  |  [RW][00:00]""Register holding the value of the element extend mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0338);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel12_dirty_status                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel12_dirty_status_type */
	/* skip, unused field unused_channel12_dirty_status (channel12_dirty_status) */
	REG_DUMP_PRINT_1("   -channel12_dirty_status.channel12_dirty_status                          |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0334);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel12_lock_status                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel12_lock_status_type */
	/* skip, unused field unused_channel12_lock_status (channel12_lock_status) */
	REG_DUMP_PRINT_1("   -channel12_lock_status.channel12_lock_status                            |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0330);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel12_pending_counter                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel12_pending_counter_type */
	/* skip, unused field unused_channel12_pending_counter (channel12_pending_counter) */
	REG_DUMP_PRINT_1("   -channel12_pending_counter.channel12_pending_counter                    |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb032c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel12_completed_counter                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel12_completed_counter_type */
	/* skip, unused field unused_channel12_completed_counter (channel12_completed_counter) */
	REG_DUMP_PRINT_1("   -channel12_completed_counter.channel12_completed_counter                |        0x%02X  |  [RW][04:00]""Register keeping track of the number of operations using this channel that have completed and have been acknowledged, since the last time the register was read. When read through the slave interface and the channel is configured for passive acknowledgement, or when an active acknowledgment occurs, this register is automatically reset to 0. The register can written through the control slave interface for the purpose of state restore, typically when switching bank modes while using active acknowledge.""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0xb031c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel12_acknowledge_data                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel12_acknowledge_data_type */
	REG_DUMP_PRINT_1("   -channel12_acknowledge_data.channel12_acknowledge_data                  |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge data field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb0318);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel12_acknowledge_address                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel12_acknowledge_address_type */
	REG_DUMP_PRINT_1("   -channel12_acknowledge_address.channel12_acknowledge_address            |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge address field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb0314);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel12_acknowledge_mode                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel12_acknowledge_mode_type */
	/* skip, unused field unused_channel12_acknowledge_mode (channel12_acknowledge_mode) */
	REG_DUMP_PRINT_1("   -channel12_acknowledge_mode.channel12_acknowledge_mode                  |         0x%01X  |  [RW][03:00]""Register holding the value of the acknowledge mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb0310);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel12_global_set_id                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel12_global_set_id_type */
	/* skip, unused field unused_channel12_global_set_id (channel12_global_set_id) */
	REG_DUMP_PRINT_1("   -channel12_global_set_id.channel12_global_set_id                        |         0x%01X  |  [RW][00:00]""Register holding the value of the global set ID field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0308);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel12_padding_mode                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel12_padding_mode_type */
	/* skip, unused field unused_channel12_padding_mode (channel12_padding_mode) */
	REG_DUMP_PRINT_1("   -channel12_padding_mode.channel12_padding_mode                          |         0x%01X  |  [RW][02:00]""Register holding the value of the padding mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0xb0300);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel12_element_extend_mode                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel12_element_extend_mode_type */
	/* skip, unused field unused_channel12_element_extend_mode (channel12_element_extend_mode) */
	REG_DUMP_PRINT_1("   -channel12_element_extend_mode.channel12_element_extend_mode            |         0x%01X  |  [RW][00:00]""Register holding the value of the element extend mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb02f8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel11_dirty_status                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel11_dirty_status_type */
	/* skip, unused field unused_channel11_dirty_status (channel11_dirty_status) */
	REG_DUMP_PRINT_1("   -channel11_dirty_status.channel11_dirty_status                          |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb02f4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel11_lock_status                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel11_lock_status_type */
	/* skip, unused field unused_channel11_lock_status (channel11_lock_status) */
	REG_DUMP_PRINT_1("   -channel11_lock_status.channel11_lock_status                            |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb02f0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel11_pending_counter                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel11_pending_counter_type */
	/* skip, unused field unused_channel11_pending_counter (channel11_pending_counter) */
	REG_DUMP_PRINT_1("   -channel11_pending_counter.channel11_pending_counter                    |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb02ec);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel11_completed_counter                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel11_completed_counter_type */
	/* skip, unused field unused_channel11_completed_counter (channel11_completed_counter) */
	REG_DUMP_PRINT_1("   -channel11_completed_counter.channel11_completed_counter                |        0x%02X  |  [RW][04:00]""Register keeping track of the number of operations using this channel that have completed and have been acknowledged, since the last time the register was read. When read through the slave interface and the channel is configured for passive acknowledgement, or when an active acknowledgment occurs, this register is automatically reset to 0. The register can written through the control slave interface for the purpose of state restore, typically when switching bank modes while using active acknowledge.""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0xb02dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel11_acknowledge_data                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel11_acknowledge_data_type */
	REG_DUMP_PRINT_1("   -channel11_acknowledge_data.channel11_acknowledge_data                  |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge data field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb02d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel11_acknowledge_address                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel11_acknowledge_address_type */
	REG_DUMP_PRINT_1("   -channel11_acknowledge_address.channel11_acknowledge_address            |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge address field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb02d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel11_acknowledge_mode                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel11_acknowledge_mode_type */
	/* skip, unused field unused_channel11_acknowledge_mode (channel11_acknowledge_mode) */
	REG_DUMP_PRINT_1("   -channel11_acknowledge_mode.channel11_acknowledge_mode                  |         0x%01X  |  [RW][03:00]""Register holding the value of the acknowledge mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb02d0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel11_global_set_id                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel11_global_set_id_type */
	/* skip, unused field unused_channel11_global_set_id (channel11_global_set_id) */
	REG_DUMP_PRINT_1("   -channel11_global_set_id.channel11_global_set_id                        |         0x%01X  |  [RW][00:00]""Register holding the value of the global set ID field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb02c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel11_padding_mode                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel11_padding_mode_type */
	/* skip, unused field unused_channel11_padding_mode (channel11_padding_mode) */
	REG_DUMP_PRINT_1("   -channel11_padding_mode.channel11_padding_mode                          |         0x%01X  |  [RW][02:00]""Register holding the value of the padding mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0xb02c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel11_element_extend_mode                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel11_element_extend_mode_type */
	/* skip, unused field unused_channel11_element_extend_mode (channel11_element_extend_mode) */
	REG_DUMP_PRINT_1("   -channel11_element_extend_mode.channel11_element_extend_mode            |         0x%01X  |  [RW][00:00]""Register holding the value of the element extend mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb02b8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel10_dirty_status                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel10_dirty_status_type */
	/* skip, unused field unused_channel10_dirty_status (channel10_dirty_status) */
	REG_DUMP_PRINT_1("   -channel10_dirty_status.channel10_dirty_status                          |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb02b4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel10_lock_status                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel10_lock_status_type */
	/* skip, unused field unused_channel10_lock_status (channel10_lock_status) */
	REG_DUMP_PRINT_1("   -channel10_lock_status.channel10_lock_status                            |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb02b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel10_pending_counter                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel10_pending_counter_type */
	/* skip, unused field unused_channel10_pending_counter (channel10_pending_counter) */
	REG_DUMP_PRINT_1("   -channel10_pending_counter.channel10_pending_counter                    |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb02ac);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel10_completed_counter                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel10_completed_counter_type */
	/* skip, unused field unused_channel10_completed_counter (channel10_completed_counter) */
	REG_DUMP_PRINT_1("   -channel10_completed_counter.channel10_completed_counter                |        0x%02X  |  [RW][04:00]""Register keeping track of the number of operations using this channel that have completed and have been acknowledged, since the last time the register was read. When read through the slave interface and the channel is configured for passive acknowledgement, or when an active acknowledgment occurs, this register is automatically reset to 0. The register can written through the control slave interface for the purpose of state restore, typically when switching bank modes while using active acknowledge.""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0xb029c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel10_acknowledge_data                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel10_acknowledge_data_type */
	REG_DUMP_PRINT_1("   -channel10_acknowledge_data.channel10_acknowledge_data                  |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge data field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb0298);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel10_acknowledge_address                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel10_acknowledge_address_type */
	REG_DUMP_PRINT_1("   -channel10_acknowledge_address.channel10_acknowledge_address            |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge address field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb0294);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel10_acknowledge_mode                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel10_acknowledge_mode_type */
	/* skip, unused field unused_channel10_acknowledge_mode (channel10_acknowledge_mode) */
	REG_DUMP_PRINT_1("   -channel10_acknowledge_mode.channel10_acknowledge_mode                  |         0x%01X  |  [RW][03:00]""Register holding the value of the acknowledge mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb0290);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel10_global_set_id                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel10_global_set_id_type */
	/* skip, unused field unused_channel10_global_set_id (channel10_global_set_id) */
	REG_DUMP_PRINT_1("   -channel10_global_set_id.channel10_global_set_id                        |         0x%01X  |  [RW][00:00]""Register holding the value of the global set ID field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0288);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel10_padding_mode                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel10_padding_mode_type */
	/* skip, unused field unused_channel10_padding_mode (channel10_padding_mode) */
	REG_DUMP_PRINT_1("   -channel10_padding_mode.channel10_padding_mode                          |         0x%01X  |  [RW][02:00]""Register holding the value of the padding mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0xb0280);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel10_element_extend_mode                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel10_element_extend_mode_type */
	/* skip, unused field unused_channel10_element_extend_mode (channel10_element_extend_mode) */
	REG_DUMP_PRINT_1("   -channel10_element_extend_mode.channel10_element_extend_mode            |         0x%01X  |  [RW][00:00]""Register holding the value of the element extend mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0278);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel9_dirty_status                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel9_dirty_status_type */
	/* skip, unused field unused_channel9_dirty_status (channel9_dirty_status) */
	REG_DUMP_PRINT_1("   -channel9_dirty_status.channel9_dirty_status                            |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0274);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel9_lock_status                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel9_lock_status_type */
	/* skip, unused field unused_channel9_lock_status (channel9_lock_status) */
	REG_DUMP_PRINT_1("   -channel9_lock_status.channel9_lock_status                              |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0270);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel9_pending_counter                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel9_pending_counter_type */
	/* skip, unused field unused_channel9_pending_counter (channel9_pending_counter) */
	REG_DUMP_PRINT_1("   -channel9_pending_counter.channel9_pending_counter                      |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb026c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel9_completed_counter                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel9_completed_counter_type */
	/* skip, unused field unused_channel9_completed_counter (channel9_completed_counter) */
	REG_DUMP_PRINT_1("   -channel9_completed_counter.channel9_completed_counter                  |        0x%02X  |  [RW][04:00]""Register keeping track of the number of operations using this channel that have completed and have been acknowledged, since the last time the register was read. When read through the slave interface and the channel is configured for passive acknowledgement, or when an active acknowledgment occurs, this register is automatically reset to 0. The register can written through the control slave interface for the purpose of state restore, typically when switching bank modes while using active acknowledge.""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0xb025c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel9_acknowledge_data                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel9_acknowledge_data_type */
	REG_DUMP_PRINT_1("   -channel9_acknowledge_data.channel9_acknowledge_data                    |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge data field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb0258);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel9_acknowledge_address                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel9_acknowledge_address_type */
	REG_DUMP_PRINT_1("   -channel9_acknowledge_address.channel9_acknowledge_address              |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge address field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb0254);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel9_acknowledge_mode                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel9_acknowledge_mode_type */
	/* skip, unused field unused_channel9_acknowledge_mode (channel9_acknowledge_mode) */
	REG_DUMP_PRINT_1("   -channel9_acknowledge_mode.channel9_acknowledge_mode                    |         0x%01X  |  [RW][03:00]""Register holding the value of the acknowledge mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb0250);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel9_global_set_id                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel9_global_set_id_type */
	/* skip, unused field unused_channel9_global_set_id (channel9_global_set_id) */
	REG_DUMP_PRINT_1("   -channel9_global_set_id.channel9_global_set_id                          |         0x%01X  |  [RW][00:00]""Register holding the value of the global set ID field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0248);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel9_padding_mode                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel9_padding_mode_type */
	/* skip, unused field unused_channel9_padding_mode (channel9_padding_mode) */
	REG_DUMP_PRINT_1("   -channel9_padding_mode.channel9_padding_mode                            |         0x%01X  |  [RW][02:00]""Register holding the value of the padding mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0xb0240);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel9_element_extend_mode                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel9_element_extend_mode_type */
	/* skip, unused field unused_channel9_element_extend_mode (channel9_element_extend_mode) */
	REG_DUMP_PRINT_1("   -channel9_element_extend_mode.channel9_element_extend_mode              |         0x%01X  |  [RW][00:00]""Register holding the value of the element extend mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0238);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel8_dirty_status                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel8_dirty_status_type */
	/* skip, unused field unused_channel8_dirty_status (channel8_dirty_status) */
	REG_DUMP_PRINT_1("   -channel8_dirty_status.channel8_dirty_status                            |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0234);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel8_lock_status                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel8_lock_status_type */
	/* skip, unused field unused_channel8_lock_status (channel8_lock_status) */
	REG_DUMP_PRINT_1("   -channel8_lock_status.channel8_lock_status                              |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0230);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel8_pending_counter                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel8_pending_counter_type */
	/* skip, unused field unused_channel8_pending_counter (channel8_pending_counter) */
	REG_DUMP_PRINT_1("   -channel8_pending_counter.channel8_pending_counter                      |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb022c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel8_completed_counter                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel8_completed_counter_type */
	/* skip, unused field unused_channel8_completed_counter (channel8_completed_counter) */
	REG_DUMP_PRINT_1("   -channel8_completed_counter.channel8_completed_counter                  |        0x%02X  |  [RW][04:00]""Register keeping track of the number of operations using this channel that have completed and have been acknowledged, since the last time the register was read. When read through the slave interface and the channel is configured for passive acknowledgement, or when an active acknowledgment occurs, this register is automatically reset to 0. The register can written through the control slave interface for the purpose of state restore, typically when switching bank modes while using active acknowledge.""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0xb021c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel8_acknowledge_data                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel8_acknowledge_data_type */
	REG_DUMP_PRINT_1("   -channel8_acknowledge_data.channel8_acknowledge_data                    |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge data field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb0218);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel8_acknowledge_address                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel8_acknowledge_address_type */
	REG_DUMP_PRINT_1("   -channel8_acknowledge_address.channel8_acknowledge_address              |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge address field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb0214);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel8_acknowledge_mode                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel8_acknowledge_mode_type */
	/* skip, unused field unused_channel8_acknowledge_mode (channel8_acknowledge_mode) */
	REG_DUMP_PRINT_1("   -channel8_acknowledge_mode.channel8_acknowledge_mode                    |         0x%01X  |  [RW][03:00]""Register holding the value of the acknowledge mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb0210);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel8_global_set_id                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel8_global_set_id_type */
	/* skip, unused field unused_channel8_global_set_id (channel8_global_set_id) */
	REG_DUMP_PRINT_1("   -channel8_global_set_id.channel8_global_set_id                          |         0x%01X  |  [RW][00:00]""Register holding the value of the global set ID field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0208);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel8_padding_mode                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel8_padding_mode_type */
	/* skip, unused field unused_channel8_padding_mode (channel8_padding_mode) */
	REG_DUMP_PRINT_1("   -channel8_padding_mode.channel8_padding_mode                            |         0x%01X  |  [RW][02:00]""Register holding the value of the padding mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0xb0200);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel8_element_extend_mode                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel8_element_extend_mode_type */
	/* skip, unused field unused_channel8_element_extend_mode (channel8_element_extend_mode) */
	REG_DUMP_PRINT_1("   -channel8_element_extend_mode.channel8_element_extend_mode              |         0x%01X  |  [RW][00:00]""Register holding the value of the element extend mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb01f8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel7_dirty_status                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel7_dirty_status_type */
	/* skip, unused field unused_channel7_dirty_status (channel7_dirty_status) */
	REG_DUMP_PRINT_1("   -channel7_dirty_status.channel7_dirty_status                            |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb01f4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel7_lock_status                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel7_lock_status_type */
	/* skip, unused field unused_channel7_lock_status (channel7_lock_status) */
	REG_DUMP_PRINT_1("   -channel7_lock_status.channel7_lock_status                              |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb01f0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel7_pending_counter                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel7_pending_counter_type */
	/* skip, unused field unused_channel7_pending_counter (channel7_pending_counter) */
	REG_DUMP_PRINT_1("   -channel7_pending_counter.channel7_pending_counter                      |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb01ec);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel7_completed_counter                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel7_completed_counter_type */
	/* skip, unused field unused_channel7_completed_counter (channel7_completed_counter) */
	REG_DUMP_PRINT_1("   -channel7_completed_counter.channel7_completed_counter                  |        0x%02X  |  [RW][04:00]""Register keeping track of the number of operations using this channel that have completed and have been acknowledged, since the last time the register was read. When read through the slave interface and the channel is configured for passive acknowledgement, or when an active acknowledgment occurs, this register is automatically reset to 0. The register can written through the control slave interface for the purpose of state restore, typically when switching bank modes while using active acknowledge.""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0xb01dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel7_acknowledge_data                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel7_acknowledge_data_type */
	REG_DUMP_PRINT_1("   -channel7_acknowledge_data.channel7_acknowledge_data                    |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge data field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb01d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel7_acknowledge_address                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel7_acknowledge_address_type */
	REG_DUMP_PRINT_1("   -channel7_acknowledge_address.channel7_acknowledge_address              |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge address field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb01d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel7_acknowledge_mode                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel7_acknowledge_mode_type */
	/* skip, unused field unused_channel7_acknowledge_mode (channel7_acknowledge_mode) */
	REG_DUMP_PRINT_1("   -channel7_acknowledge_mode.channel7_acknowledge_mode                    |         0x%01X  |  [RW][03:00]""Register holding the value of the acknowledge mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb01d0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel7_global_set_id                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel7_global_set_id_type */
	/* skip, unused field unused_channel7_global_set_id (channel7_global_set_id) */
	REG_DUMP_PRINT_1("   -channel7_global_set_id.channel7_global_set_id                          |         0x%01X  |  [RW][00:00]""Register holding the value of the global set ID field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb01c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel7_padding_mode                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel7_padding_mode_type */
	/* skip, unused field unused_channel7_padding_mode (channel7_padding_mode) */
	REG_DUMP_PRINT_1("   -channel7_padding_mode.channel7_padding_mode                            |         0x%01X  |  [RW][02:00]""Register holding the value of the padding mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0xb01c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel7_element_extend_mode                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel7_element_extend_mode_type */
	/* skip, unused field unused_channel7_element_extend_mode (channel7_element_extend_mode) */
	REG_DUMP_PRINT_1("   -channel7_element_extend_mode.channel7_element_extend_mode              |         0x%01X  |  [RW][00:00]""Register holding the value of the element extend mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb01b8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel6_dirty_status                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel6_dirty_status_type */
	/* skip, unused field unused_channel6_dirty_status (channel6_dirty_status) */
	REG_DUMP_PRINT_1("   -channel6_dirty_status.channel6_dirty_status                            |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb01b4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel6_lock_status                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel6_lock_status_type */
	/* skip, unused field unused_channel6_lock_status (channel6_lock_status) */
	REG_DUMP_PRINT_1("   -channel6_lock_status.channel6_lock_status                              |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb01b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel6_pending_counter                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel6_pending_counter_type */
	/* skip, unused field unused_channel6_pending_counter (channel6_pending_counter) */
	REG_DUMP_PRINT_1("   -channel6_pending_counter.channel6_pending_counter                      |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb01ac);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel6_completed_counter                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel6_completed_counter_type */
	/* skip, unused field unused_channel6_completed_counter (channel6_completed_counter) */
	REG_DUMP_PRINT_1("   -channel6_completed_counter.channel6_completed_counter                  |        0x%02X  |  [RW][04:00]""Register keeping track of the number of operations using this channel that have completed and have been acknowledged, since the last time the register was read. When read through the slave interface and the channel is configured for passive acknowledgement, or when an active acknowledgment occurs, this register is automatically reset to 0. The register can written through the control slave interface for the purpose of state restore, typically when switching bank modes while using active acknowledge.""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0xb019c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel6_acknowledge_data                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel6_acknowledge_data_type */
	REG_DUMP_PRINT_1("   -channel6_acknowledge_data.channel6_acknowledge_data                    |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge data field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb0198);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel6_acknowledge_address                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel6_acknowledge_address_type */
	REG_DUMP_PRINT_1("   -channel6_acknowledge_address.channel6_acknowledge_address              |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge address field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb0194);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel6_acknowledge_mode                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel6_acknowledge_mode_type */
	/* skip, unused field unused_channel6_acknowledge_mode (channel6_acknowledge_mode) */
	REG_DUMP_PRINT_1("   -channel6_acknowledge_mode.channel6_acknowledge_mode                    |         0x%01X  |  [RW][03:00]""Register holding the value of the acknowledge mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb0190);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel6_global_set_id                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel6_global_set_id_type */
	/* skip, unused field unused_channel6_global_set_id (channel6_global_set_id) */
	REG_DUMP_PRINT_1("   -channel6_global_set_id.channel6_global_set_id                          |         0x%01X  |  [RW][00:00]""Register holding the value of the global set ID field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0188);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel6_padding_mode                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel6_padding_mode_type */
	/* skip, unused field unused_channel6_padding_mode (channel6_padding_mode) */
	REG_DUMP_PRINT_1("   -channel6_padding_mode.channel6_padding_mode                            |         0x%01X  |  [RW][02:00]""Register holding the value of the padding mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0xb0180);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel6_element_extend_mode                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel6_element_extend_mode_type */
	/* skip, unused field unused_channel6_element_extend_mode (channel6_element_extend_mode) */
	REG_DUMP_PRINT_1("   -channel6_element_extend_mode.channel6_element_extend_mode              |         0x%01X  |  [RW][00:00]""Register holding the value of the element extend mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0178);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel5_dirty_status                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel5_dirty_status_type */
	/* skip, unused field unused_channel5_dirty_status (channel5_dirty_status) */
	REG_DUMP_PRINT_1("   -channel5_dirty_status.channel5_dirty_status                            |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0174);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel5_lock_status                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel5_lock_status_type */
	/* skip, unused field unused_channel5_lock_status (channel5_lock_status) */
	REG_DUMP_PRINT_1("   -channel5_lock_status.channel5_lock_status                              |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0170);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel5_pending_counter                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel5_pending_counter_type */
	/* skip, unused field unused_channel5_pending_counter (channel5_pending_counter) */
	REG_DUMP_PRINT_1("   -channel5_pending_counter.channel5_pending_counter                      |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb016c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel5_completed_counter                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel5_completed_counter_type */
	/* skip, unused field unused_channel5_completed_counter (channel5_completed_counter) */
	REG_DUMP_PRINT_1("   -channel5_completed_counter.channel5_completed_counter                  |        0x%02X  |  [RW][04:00]""Register keeping track of the number of operations using this channel that have completed and have been acknowledged, since the last time the register was read. When read through the slave interface and the channel is configured for passive acknowledgement, or when an active acknowledgment occurs, this register is automatically reset to 0. The register can written through the control slave interface for the purpose of state restore, typically when switching bank modes while using active acknowledge.""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0xb015c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel5_acknowledge_data                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel5_acknowledge_data_type */
	REG_DUMP_PRINT_1("   -channel5_acknowledge_data.channel5_acknowledge_data                    |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge data field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb0158);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel5_acknowledge_address                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel5_acknowledge_address_type */
	REG_DUMP_PRINT_1("   -channel5_acknowledge_address.channel5_acknowledge_address              |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge address field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb0154);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel5_acknowledge_mode                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel5_acknowledge_mode_type */
	/* skip, unused field unused_channel5_acknowledge_mode (channel5_acknowledge_mode) */
	REG_DUMP_PRINT_1("   -channel5_acknowledge_mode.channel5_acknowledge_mode                    |         0x%01X  |  [RW][03:00]""Register holding the value of the acknowledge mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb0150);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel5_global_set_id                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel5_global_set_id_type */
	/* skip, unused field unused_channel5_global_set_id (channel5_global_set_id) */
	REG_DUMP_PRINT_1("   -channel5_global_set_id.channel5_global_set_id                          |         0x%01X  |  [RW][00:00]""Register holding the value of the global set ID field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0148);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel5_padding_mode                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel5_padding_mode_type */
	/* skip, unused field unused_channel5_padding_mode (channel5_padding_mode) */
	REG_DUMP_PRINT_1("   -channel5_padding_mode.channel5_padding_mode                            |         0x%01X  |  [RW][02:00]""Register holding the value of the padding mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0xb0140);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel5_element_extend_mode                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel5_element_extend_mode_type */
	/* skip, unused field unused_channel5_element_extend_mode (channel5_element_extend_mode) */
	REG_DUMP_PRINT_1("   -channel5_element_extend_mode.channel5_element_extend_mode              |         0x%01X  |  [RW][00:00]""Register holding the value of the element extend mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0138);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel4_dirty_status                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel4_dirty_status_type */
	/* skip, unused field unused_channel4_dirty_status (channel4_dirty_status) */
	REG_DUMP_PRINT_1("   -channel4_dirty_status.channel4_dirty_status                            |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0134);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel4_lock_status                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel4_lock_status_type */
	/* skip, unused field unused_channel4_lock_status (channel4_lock_status) */
	REG_DUMP_PRINT_1("   -channel4_lock_status.channel4_lock_status                              |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0130);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel4_pending_counter                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel4_pending_counter_type */
	/* skip, unused field unused_channel4_pending_counter (channel4_pending_counter) */
	REG_DUMP_PRINT_1("   -channel4_pending_counter.channel4_pending_counter                      |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb012c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel4_completed_counter                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel4_completed_counter_type */
	/* skip, unused field unused_channel4_completed_counter (channel4_completed_counter) */
	REG_DUMP_PRINT_1("   -channel4_completed_counter.channel4_completed_counter                  |        0x%02X  |  [RW][04:00]""Register keeping track of the number of operations using this channel that have completed and have been acknowledged, since the last time the register was read. When read through the slave interface and the channel is configured for passive acknowledgement, or when an active acknowledgment occurs, this register is automatically reset to 0. The register can written through the control slave interface for the purpose of state restore, typically when switching bank modes while using active acknowledge.""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0xb011c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel4_acknowledge_data                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel4_acknowledge_data_type */
	REG_DUMP_PRINT_1("   -channel4_acknowledge_data.channel4_acknowledge_data                    |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge data field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb0118);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel4_acknowledge_address                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel4_acknowledge_address_type */
	REG_DUMP_PRINT_1("   -channel4_acknowledge_address.channel4_acknowledge_address              |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge address field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb0114);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel4_acknowledge_mode                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel4_acknowledge_mode_type */
	/* skip, unused field unused_channel4_acknowledge_mode (channel4_acknowledge_mode) */
	REG_DUMP_PRINT_1("   -channel4_acknowledge_mode.channel4_acknowledge_mode                    |         0x%01X  |  [RW][03:00]""Register holding the value of the acknowledge mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb0110);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel4_global_set_id                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel4_global_set_id_type */
	/* skip, unused field unused_channel4_global_set_id (channel4_global_set_id) */
	REG_DUMP_PRINT_1("   -channel4_global_set_id.channel4_global_set_id                          |         0x%01X  |  [RW][00:00]""Register holding the value of the global set ID field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0108);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel4_padding_mode                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel4_padding_mode_type */
	/* skip, unused field unused_channel4_padding_mode (channel4_padding_mode) */
	REG_DUMP_PRINT_1("   -channel4_padding_mode.channel4_padding_mode                            |         0x%01X  |  [RW][02:00]""Register holding the value of the padding mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0xb0100);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel4_element_extend_mode                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel4_element_extend_mode_type */
	/* skip, unused field unused_channel4_element_extend_mode (channel4_element_extend_mode) */
	REG_DUMP_PRINT_1("   -channel4_element_extend_mode.channel4_element_extend_mode              |         0x%01X  |  [RW][00:00]""Register holding the value of the element extend mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb00f8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel3_dirty_status                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel3_dirty_status_type */
	/* skip, unused field unused_channel3_dirty_status (channel3_dirty_status) */
	REG_DUMP_PRINT_1("   -channel3_dirty_status.channel3_dirty_status                            |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb00f4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel3_lock_status                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel3_lock_status_type */
	/* skip, unused field unused_channel3_lock_status (channel3_lock_status) */
	REG_DUMP_PRINT_1("   -channel3_lock_status.channel3_lock_status                              |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb00f0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel3_pending_counter                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel3_pending_counter_type */
	/* skip, unused field unused_channel3_pending_counter (channel3_pending_counter) */
	REG_DUMP_PRINT_1("   -channel3_pending_counter.channel3_pending_counter                      |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb00ec);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel3_completed_counter                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel3_completed_counter_type */
	/* skip, unused field unused_channel3_completed_counter (channel3_completed_counter) */
	REG_DUMP_PRINT_1("   -channel3_completed_counter.channel3_completed_counter                  |        0x%02X  |  [RW][04:00]""Register keeping track of the number of operations using this channel that have completed and have been acknowledged, since the last time the register was read. When read through the slave interface and the channel is configured for passive acknowledgement, or when an active acknowledgment occurs, this register is automatically reset to 0. The register can written through the control slave interface for the purpose of state restore, typically when switching bank modes while using active acknowledge.""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0xb00dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel3_acknowledge_data                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel3_acknowledge_data_type */
	REG_DUMP_PRINT_1("   -channel3_acknowledge_data.channel3_acknowledge_data                    |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge data field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb00d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel3_acknowledge_address                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel3_acknowledge_address_type */
	REG_DUMP_PRINT_1("   -channel3_acknowledge_address.channel3_acknowledge_address              |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge address field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb00d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel3_acknowledge_mode                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel3_acknowledge_mode_type */
	/* skip, unused field unused_channel3_acknowledge_mode (channel3_acknowledge_mode) */
	REG_DUMP_PRINT_1("   -channel3_acknowledge_mode.channel3_acknowledge_mode                    |         0x%01X  |  [RW][03:00]""Register holding the value of the acknowledge mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb00d0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel3_global_set_id                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel3_global_set_id_type */
	/* skip, unused field unused_channel3_global_set_id (channel3_global_set_id) */
	REG_DUMP_PRINT_1("   -channel3_global_set_id.channel3_global_set_id                          |         0x%01X  |  [RW][00:00]""Register holding the value of the global set ID field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb00c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel3_padding_mode                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel3_padding_mode_type */
	/* skip, unused field unused_channel3_padding_mode (channel3_padding_mode) */
	REG_DUMP_PRINT_1("   -channel3_padding_mode.channel3_padding_mode                            |         0x%01X  |  [RW][02:00]""Register holding the value of the padding mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0xb00c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel3_element_extend_mode                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel3_element_extend_mode_type */
	/* skip, unused field unused_channel3_element_extend_mode (channel3_element_extend_mode) */
	REG_DUMP_PRINT_1("   -channel3_element_extend_mode.channel3_element_extend_mode              |         0x%01X  |  [RW][00:00]""Register holding the value of the element extend mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb00b8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel2_dirty_status                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel2_dirty_status_type */
	/* skip, unused field unused_channel2_dirty_status (channel2_dirty_status) */
	REG_DUMP_PRINT_1("   -channel2_dirty_status.channel2_dirty_status                            |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb00b4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel2_lock_status                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel2_lock_status_type */
	/* skip, unused field unused_channel2_lock_status (channel2_lock_status) */
	REG_DUMP_PRINT_1("   -channel2_lock_status.channel2_lock_status                              |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb00b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel2_pending_counter                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel2_pending_counter_type */
	/* skip, unused field unused_channel2_pending_counter (channel2_pending_counter) */
	REG_DUMP_PRINT_1("   -channel2_pending_counter.channel2_pending_counter                      |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb00ac);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel2_completed_counter                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel2_completed_counter_type */
	/* skip, unused field unused_channel2_completed_counter (channel2_completed_counter) */
	REG_DUMP_PRINT_1("   -channel2_completed_counter.channel2_completed_counter                  |        0x%02X  |  [RW][04:00]""Register keeping track of the number of operations using this channel that have completed and have been acknowledged, since the last time the register was read. When read through the slave interface and the channel is configured for passive acknowledgement, or when an active acknowledgment occurs, this register is automatically reset to 0. The register can written through the control slave interface for the purpose of state restore, typically when switching bank modes while using active acknowledge.""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0xb009c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel2_acknowledge_data                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel2_acknowledge_data_type */
	REG_DUMP_PRINT_1("   -channel2_acknowledge_data.channel2_acknowledge_data                    |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge data field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb0098);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel2_acknowledge_address                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel2_acknowledge_address_type */
	REG_DUMP_PRINT_1("   -channel2_acknowledge_address.channel2_acknowledge_address              |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge address field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb0094);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel2_acknowledge_mode                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel2_acknowledge_mode_type */
	/* skip, unused field unused_channel2_acknowledge_mode (channel2_acknowledge_mode) */
	REG_DUMP_PRINT_1("   -channel2_acknowledge_mode.channel2_acknowledge_mode                    |         0x%01X  |  [RW][03:00]""Register holding the value of the acknowledge mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb0090);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel2_global_set_id                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel2_global_set_id_type */
	/* skip, unused field unused_channel2_global_set_id (channel2_global_set_id) */
	REG_DUMP_PRINT_1("   -channel2_global_set_id.channel2_global_set_id                          |         0x%01X  |  [RW][00:00]""Register holding the value of the global set ID field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0088);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel2_padding_mode                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel2_padding_mode_type */
	/* skip, unused field unused_channel2_padding_mode (channel2_padding_mode) */
	REG_DUMP_PRINT_1("   -channel2_padding_mode.channel2_padding_mode                            |         0x%01X  |  [RW][02:00]""Register holding the value of the padding mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0xb0080);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel2_element_extend_mode                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel2_element_extend_mode_type */
	/* skip, unused field unused_channel2_element_extend_mode (channel2_element_extend_mode) */
	REG_DUMP_PRINT_1("   -channel2_element_extend_mode.channel2_element_extend_mode              |         0x%01X  |  [RW][00:00]""Register holding the value of the element extend mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0078);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel1_dirty_status                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel1_dirty_status_type */
	/* skip, unused field unused_channel1_dirty_status (channel1_dirty_status) */
	REG_DUMP_PRINT_1("   -channel1_dirty_status.channel1_dirty_status                            |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0074);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel1_lock_status                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel1_lock_status_type */
	/* skip, unused field unused_channel1_lock_status (channel1_lock_status) */
	REG_DUMP_PRINT_1("   -channel1_lock_status.channel1_lock_status                              |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0070);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel1_pending_counter                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel1_pending_counter_type */
	/* skip, unused field unused_channel1_pending_counter (channel1_pending_counter) */
	REG_DUMP_PRINT_1("   -channel1_pending_counter.channel1_pending_counter                      |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb006c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel1_completed_counter                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel1_completed_counter_type */
	/* skip, unused field unused_channel1_completed_counter (channel1_completed_counter) */
	REG_DUMP_PRINT_1("   -channel1_completed_counter.channel1_completed_counter                  |        0x%02X  |  [RW][04:00]""Register keeping track of the number of operations using this channel that have completed and have been acknowledged, since the last time the register was read. When read through the slave interface and the channel is configured for passive acknowledgement, or when an active acknowledgment occurs, this register is automatically reset to 0. The register can written through the control slave interface for the purpose of state restore, typically when switching bank modes while using active acknowledge.""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0xb005c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel1_acknowledge_data                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel1_acknowledge_data_type */
	REG_DUMP_PRINT_1("   -channel1_acknowledge_data.channel1_acknowledge_data                    |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge data field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb0058);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel1_acknowledge_address                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel1_acknowledge_address_type */
	REG_DUMP_PRINT_1("   -channel1_acknowledge_address.channel1_acknowledge_address              |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge address field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb0054);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel1_acknowledge_mode                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel1_acknowledge_mode_type */
	/* skip, unused field unused_channel1_acknowledge_mode (channel1_acknowledge_mode) */
	REG_DUMP_PRINT_1("   -channel1_acknowledge_mode.channel1_acknowledge_mode                    |         0x%01X  |  [RW][03:00]""Register holding the value of the acknowledge mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb0050);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel1_global_set_id                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel1_global_set_id_type */
	/* skip, unused field unused_channel1_global_set_id (channel1_global_set_id) */
	REG_DUMP_PRINT_1("   -channel1_global_set_id.channel1_global_set_id                          |         0x%01X  |  [RW][00:00]""Register holding the value of the global set ID field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0048);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel1_padding_mode                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel1_padding_mode_type */
	/* skip, unused field unused_channel1_padding_mode (channel1_padding_mode) */
	REG_DUMP_PRINT_1("   -channel1_padding_mode.channel1_padding_mode                            |         0x%01X  |  [RW][02:00]""Register holding the value of the padding mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0xb0040);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel1_element_extend_mode                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel1_element_extend_mode_type */
	/* skip, unused field unused_channel1_element_extend_mode (channel1_element_extend_mode) */
	REG_DUMP_PRINT_1("   -channel1_element_extend_mode.channel1_element_extend_mode              |         0x%01X  |  [RW][00:00]""Register holding the value of the element extend mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0038);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel0_dirty_status                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel0_dirty_status_type */
	/* skip, unused field unused_channel0_dirty_status (channel0_dirty_status) */
	REG_DUMP_PRINT_1("   -channel0_dirty_status.channel0_dirty_status                            |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0034);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel0_lock_status                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel0_lock_status_type */
	/* skip, unused field unused_channel0_lock_status (channel0_lock_status) */
	REG_DUMP_PRINT_1("   -channel0_lock_status.channel0_lock_status                              |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0030);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel0_pending_counter                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel0_pending_counter_type */
	/* skip, unused field unused_channel0_pending_counter (channel0_pending_counter) */
	REG_DUMP_PRINT_1("   -channel0_pending_counter.channel0_pending_counter                      |        0x%02X  |  [RO][07:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb002c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel0_completed_counter                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel0_completed_counter_type */
	/* skip, unused field unused_channel0_completed_counter (channel0_completed_counter) */
	REG_DUMP_PRINT_1("   -channel0_completed_counter.channel0_completed_counter                  |        0x%02X  |  [RW][04:00]""Register keeping track of the number of operations using this channel that have completed and have been acknowledged, since the last time the register was read. When read through the slave interface and the channel is configured for passive acknowledgement, or when an active acknowledgment occurs, this register is automatically reset to 0. The register can written through the control slave interface for the purpose of state restore, typically when switching bank modes while using active acknowledge.""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0xb001c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel0_acknowledge_data                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel0_acknowledge_data_type */
	REG_DUMP_PRINT_1("   -channel0_acknowledge_data.channel0_acknowledge_data                    |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge data field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb0018);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel0_acknowledge_address                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel0_acknowledge_address_type */
	REG_DUMP_PRINT_1("   -channel0_acknowledge_address.channel0_acknowledge_address              |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge address field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb0014);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel0_acknowledge_mode                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel0_acknowledge_mode_type */
	/* skip, unused field unused_channel0_acknowledge_mode (channel0_acknowledge_mode) */
	REG_DUMP_PRINT_1("   -channel0_acknowledge_mode.channel0_acknowledge_mode                    |         0x%01X  |  [RW][03:00]""Register holding the value of the acknowledge mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb0010);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel0_global_set_id                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel0_global_set_id_type */
	/* skip, unused field unused_channel0_global_set_id (channel0_global_set_id) */
	REG_DUMP_PRINT_1("   -channel0_global_set_id.channel0_global_set_id                          |         0x%01X  |  [RW][00:00]""Register holding the value of the global set ID field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb0008);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel0_padding_mode                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel0_padding_mode_type */
	/* skip, unused field unused_channel0_padding_mode (channel0_padding_mode) */
	REG_DUMP_PRINT_1("   -channel0_padding_mode.channel0_padding_mode                            |         0x%01X  |  [RW][02:00]""Register holding the value of the padding mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0xb0000);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  dma.channel0_element_extend_mode                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_dma_channel0_element_extend_mode_type */
	/* skip, unused field unused_channel0_element_extend_mode (channel0_element_extend_mode) */
	REG_DUMP_PRINT_1("   -channel0_element_extend_mode.channel0_element_extend_mode              |         0x%01X  |  [RW][00:00]""Register holding the value of the element extend mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
} /* end dma */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_StrmScalPifPixOutConv */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_StrmScalPifPixOutConv(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xafe08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_StrmScalPifPixOutConv.reg_CROP_ROW_CFG_Info  |  0x%08X  |  ""Crop row configuration register (start field - even values only; end field - odd values only)""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_StrmScalPifPixOutConv_reg_CROP_ROW_CFG_Info_type */
	REG_DUMP_PRINT_1("   -reg_CROP_ROW_CFG_Info.crop_row_start                                 |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_CROP_ROW_CFG_Info.crop_row_end                                   |      0x%04X  |  [RW][31:16]""""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xafe04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_StrmScalPifPixOutConv.reg_CROP_COL_CFG_Info  |  0x%08X  |  ""Crop column configuration register (start field - even values only; end field - odd values only)""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_StrmScalPifPixOutConv_reg_CROP_COL_CFG_Info_type */
	REG_DUMP_PRINT_1("   -reg_CROP_COL_CFG_Info.crop_col_start                                 |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_CROP_COL_CFG_Info.crop_col_end                                   |      0x%04X  |  [RW][31:16]""""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xafe00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_StrmScalPifPixOutConv.reg_CROP_EN_Info       |  0x%08X  |  ""Crop enable""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_StrmScalPifPixOutConv_reg_CROP_EN_Info_type */
	/* skip, unused field unused_reg_CROP_EN_Info (reg_CROP_EN_Info) */
	REG_DUMP_PRINT_1("   -reg_CROP_EN_Info.En                                                  |         0x%01X  |  [RW][00:00]""""\n", FIELD_VALUE(val, 0, 0));
} /* end isa_isa_logic_ISA_Cluster_StrmScalPifPixOutConv */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_StrmPifPixOutConv */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_StrmPifPixOutConv(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xafd08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_StrmPifPixOutConv.reg_CROP_ROW_CFG_Info  |  0x%08X  |  ""Crop row configuration register (start field - even values only; end field - odd values only)""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_StrmPifPixOutConv_reg_CROP_ROW_CFG_Info_type */
	REG_DUMP_PRINT_1("   -reg_CROP_ROW_CFG_Info.crop_row_start                             |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_CROP_ROW_CFG_Info.crop_row_end                               |      0x%04X  |  [RW][31:16]""""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xafd04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_StrmPifPixOutConv.reg_CROP_COL_CFG_Info  |  0x%08X  |  ""Crop column configuration register (start field - even values only; end field - odd values only)""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_StrmPifPixOutConv_reg_CROP_COL_CFG_Info_type */
	REG_DUMP_PRINT_1("   -reg_CROP_COL_CFG_Info.crop_col_start                             |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_CROP_COL_CFG_Info.crop_col_end                               |      0x%04X  |  [RW][31:16]""""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xafd00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_StrmPifPixOutConv.reg_CROP_EN_Info       |  0x%08X  |  ""Crop enable""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_StrmPifPixOutConv_reg_CROP_EN_Info_type */
	/* skip, unused field unused_reg_CROP_EN_Info (reg_CROP_EN_Info) */
	REG_DUMP_PRINT_1("   -reg_CROP_EN_Info.En                                              |         0x%01X  |  [RW][00:00]""""\n", FIELD_VALUE(val, 0, 0));
} /* end isa_isa_logic_ISA_Cluster_StrmPifPixOutConv */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Acc_Irq_Ctrl */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Acc_Irq_Ctrl(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xafc14);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Acc_Irq_Ctrl.reg_irq_level_not_pulse  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Acc_Irq_Ctrl_reg_irq_level_not_pulse_type */
	/* skip, unused field unused_reg_irq_level_not_pulse (reg_irq_level_not_pulse) */
	REG_DUMP_PRINT_1("   -reg_irq_level_not_pulse.reg_irq_level_not_pulse               |        0x%02X  |  [RW][06:00]""Indicates for each bit whether an interrupt cause is translated into a pulse (value='0') or into a constant level '1' (value='1') on the IRQ pin""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xafc10);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Acc_Irq_Ctrl.reg_irq_enable           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Acc_Irq_Ctrl_reg_irq_enable_type */
	/* skip, unused field unused_reg_irq_enable (reg_irq_enable) */
	REG_DUMP_PRINT_1("   -reg_irq_enable.reg_irq_enable                                 |        0x%02X  |  [RW][06:00]""Indicates for each bit whether an interrupt cause as monitored by the req_irq_status register also affects the IRQ pin (value='1') or not (value='0')""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xafc08);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Acc_Irq_Ctrl.reg_irq_status           |  0x%08X  |  ""Indicates for each bit whether a non-masked interrupt has been generated (value='1'). Can be cleared by writing a '1' into the the corresponding bit of the req_irq_clear register.""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Acc_Irq_Ctrl_reg_irq_status_type */
	/* skip, unused field unused_reg_irq_status (reg_irq_status) */
	REG_DUMP_PRINT_1("   -reg_irq_status.IRQ_STAT_DPC                                   |         0x%01X  |  [RO][00:00]""Represents the irq status of the irq_out from DPC""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -reg_irq_status.IRQ_STAT_LSC                                   |         0x%01X  |  [RO][01:01]""Represents the irq status of the irq_out from LSC""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -reg_irq_status.IRQ_STAT_SCAL                                  |         0x%01X  |  [RO][02:02]""Represents the irq status of the irq_out from SCAL""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -reg_irq_status.IRQ_STAT_STAT_AWB                              |         0x%01X  |  [RO][03:03]""Represents the irq status of the irq_out from STAT_AWB""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -reg_irq_status.IRQ_STAT_STAT_AF                               |         0x%01X  |  [RO][04:04]""Represents the irq status of the irq_out from STAT_AF""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -reg_irq_status.IRQ_STAT_STAT_AE                               |         0x%01X  |  [RO][05:05]""Represents the irq status of the irq_out from STAT_AE""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -reg_irq_status.IRQ_STAT_IC                                    |         0x%01X  |  [RO][06:06]""Represents the irq status of the irq_out from IC""\n", FIELD_VALUE(val, 6, 6));
	val = REG_DUMP_READ_REGISTER(0xafc04);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Acc_Irq_Ctrl.reg_irq_mask             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Acc_Irq_Ctrl_reg_irq_mask_type */
	/* skip, unused field unused_reg_irq_mask (reg_irq_mask) */
	REG_DUMP_PRINT_1("   -reg_irq_mask.reg_irq_mask                                     |        0x%02X  |  [RW][06:00]""indicates for each bit of irq_di whether it can generate an interrupt request (value='1') or not (value='0'). Setting will affect reg_irq_value as well as IRQ output pin""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xafc00);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Acc_Irq_Ctrl.reg_irq_edge             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Acc_Irq_Ctrl_reg_irq_edge_type */
	/* skip, unused field unused_reg_irq_edge (reg_irq_edge) */
	REG_DUMP_PRINT_1("   -reg_irq_edge.reg_irq_edge                                     |        0x%02X  |  [RW][06:00]""indicates for each bit whether an interrupt request should be generated on a falling edge (value='0') or a rising edge (value='1').""\n", FIELD_VALUE(val, 0, 6));
} /* end isa_isa_logic_ISA_Cluster_Acc_Irq_Ctrl */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_isa_gp_reg */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_isa_gp_reg(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xaf84c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_isa_gp_reg.awbmux_dpc_port_blk         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_isa_gp_reg_awbmux_dpc_port_blk_type */
	/* skip, unused field unused_awbmux_dpc_port_blk (awbmux_dpc_port_blk) */
	REG_DUMP_PRINT_1("   -awbmux_dpc_port_blk.awbmux_dpc_port_blk                        |         0x%01X  |  [RW][00:00]""AWB Mux input correction Port block""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xaf848);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_isa_gp_reg.awbmux_input_corr_port_blk  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_isa_gp_reg_awbmux_input_corr_port_blk_type */
	/* skip, unused field unused_awbmux_input_corr_port_blk (awbmux_input_corr_port_blk) */
	REG_DUMP_PRINT_1("   -awbmux_input_corr_port_blk.awbmux_input_corr_port_blk          |         0x%01X  |  [RW][00:00]""AWB Mux input correction Port block""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xaf844);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_isa_gp_reg.awb_mux_sel                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_isa_gp_reg_awb_mux_sel_type */
	/* skip, unused field unused_awb_mux_sel (awb_mux_sel) */
	REG_DUMP_PRINT_1("   -awb_mux_sel.awb_mux_sel                                        |         0x%01X  |  [RW][00:00]""0 - Input Correction input. 1 - DPC input""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xaf840);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_isa_gp_reg.scaled_out_yuv_mode         |  0x%08X  |  ""Scaled (video) output from ISA is in YUV format.""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_isa_gp_reg_scaled_out_yuv_mode_type */
	/* skip, unused field unused_scaled_out_yuv_mode (scaled_out_yuv_mode) */
	REG_DUMP_PRINT_1("   -scaled_out_yuv_mode.en                                         |         0x%01X  |  [RW][00:00]""""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xaf83c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_isa_gp_reg.spa_full_res_ctrl           |  0x%08X  |  ""SPA configuration""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_isa_gp_reg_spa_full_res_ctrl_type */
	/* skip, unused field unused_spa_full_res_ctrl (spa_full_res_ctrl) */
	REG_DUMP_PRINT_1("   -spa_full_res_ctrl.shift_l_en                                   |         0x%01X  |  [RW][00:00]""""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -spa_full_res_ctrl.shift_val                                    |         0x%01X  |  [RW][03:01]""""\n", FIELD_VALUE(val, 1, 3));
	REG_DUMP_PRINT_1("   -spa_full_res_ctrl.clip_to_pos                                  |         0x%01X  |  [RW][04:04]""""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xaf838);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_isa_gp_reg.spa_scaler_ctrl             |  0x%08X  |  ""SPA configuration""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_isa_gp_reg_spa_scaler_ctrl_type */
	/* skip, unused field unused_spa_scaler_ctrl (spa_scaler_ctrl) */
	REG_DUMP_PRINT_1("   -spa_scaler_ctrl.shift_l_en                                     |         0x%01X  |  [RW][00:00]""""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -spa_scaler_ctrl.shift_val                                      |         0x%01X  |  [RW][03:01]""""\n", FIELD_VALUE(val, 1, 3));
	REG_DUMP_PRINT_1("   -spa_scaler_ctrl.clip_to_pos                                    |         0x%01X  |  [RW][04:04]""""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xaf834);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_isa_gp_reg.isa_portc_blk               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_isa_gp_reg_isa_portc_blk_type */
	/* skip, unused field unused_isa_portc_blk (isa_portc_blk) */
	REG_DUMP_PRINT_1("   -isa_portc_blk.isa_portc_blk                                    |         0x%01X  |  [RW][00:00]""Port blk""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xaf830);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_isa_gp_reg.isa_portb_blk               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_isa_gp_reg_isa_portb_blk_type */
	/* skip, unused field unused_isa_portb_blk (isa_portb_blk) */
	REG_DUMP_PRINT_1("   -isa_portb_blk.isa_portb_blk                                    |         0x%01X  |  [RW][00:00]""Port blk""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xaf82c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_isa_gp_reg.isa_porta_blk               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_isa_gp_reg_isa_porta_blk_type */
	/* skip, unused field unused_isa_porta_blk (isa_porta_blk) */
	REG_DUMP_PRINT_1("   -isa_porta_blk.isa_porta_blk                                    |         0x%01X  |  [RW][00:00]""Port blk""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xaf828);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_isa_gp_reg.isa_mux_sel                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_isa_gp_reg_isa_mux_sel_type */
	/* skip, unused field unused_isa_mux_sel (isa_mux_sel) */
	REG_DUMP_PRINT_1("   -isa_mux_sel.isa_mux_sel                                        |         0x%01X  |  [RW][01:00]""3 Mux Sel""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xaf824);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_isa_gp_reg.dpc_srst_out                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_isa_gp_reg_dpc_srst_out_type */
	/* skip, unused field unused_dpc_srst_out (dpc_srst_out) */
	REG_DUMP_PRINT_1("   -dpc_srst_out.dpc_srst_out                                      |         0x%01X  |  [RW][00:00]""accelerator Soft reset""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xaf820);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_isa_gp_reg.sta_af_srst_out             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_isa_gp_reg_sta_af_srst_out_type */
	/* skip, unused field unused_sta_af_srst_out (sta_af_srst_out) */
	REG_DUMP_PRINT_1("   -sta_af_srst_out.sta_af_srst_out                                |         0x%01X  |  [RW][00:00]""accelerator Soft reset""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xaf81c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_isa_gp_reg.sta_ae_srst_out             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_isa_gp_reg_sta_ae_srst_out_type */
	/* skip, unused field unused_sta_ae_srst_out (sta_ae_srst_out) */
	REG_DUMP_PRINT_1("   -sta_ae_srst_out.sta_ae_srst_out                                |         0x%01X  |  [RW][00:00]""accelerator Soft reset""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xaf818);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_isa_gp_reg.sta_awb_srst_out            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_isa_gp_reg_sta_awb_srst_out_type */
	/* skip, unused field unused_sta_awb_srst_out (sta_awb_srst_out) */
	REG_DUMP_PRINT_1("   -sta_awb_srst_out.sta_awb_srst_out                              |         0x%01X  |  [RW][00:00]""accelerator Soft reset""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xaf814);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_isa_gp_reg.scal_srst_out               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_isa_gp_reg_scal_srst_out_type */
	/* skip, unused field unused_scal_srst_out (scal_srst_out) */
	REG_DUMP_PRINT_1("   -scal_srst_out.scal_srst_out                                    |         0x%01X  |  [RW][00:00]""accelerator Soft reset""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xaf810);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_isa_gp_reg.lsc_srst_out                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_isa_gp_reg_lsc_srst_out_type */
	/* skip, unused field unused_lsc_srst_out (lsc_srst_out) */
	REG_DUMP_PRINT_1("   -lsc_srst_out.lsc_srst_out                                      |         0x%01X  |  [RW][00:00]""accelerator Soft reset""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xaf80c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_isa_gp_reg.ic_srst_out                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_isa_gp_reg_ic_srst_out_type */
	/* skip, unused field unused_ic_srst_out (ic_srst_out) */
	REG_DUMP_PRINT_1("   -ic_srst_out.ic_srst_out                                        |         0x%01X  |  [RW][00:00]""accelerator Soft reset""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xaf808);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_isa_gp_reg.ackbus_srst_out             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_isa_gp_reg_ackbus_srst_out_type */
	/* skip, unused field unused_ackbus_srst_out (ackbus_srst_out) */
	REG_DUMP_PRINT_1("   -ackbus_srst_out.ackbus_srst_out                                |         0x%01X  |  [RW][00:00]""Ack Bus Soft reset""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xaf804);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_isa_gp_reg.scaled_frame_size           |  0x%08X  |  ""scaled frame dim""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_isa_gp_reg_scaled_frame_size_type */
	REG_DUMP_PRINT_1("   -scaled_frame_size.hsize                                        |      0x%04X  |  [RW][15:00]""Hsize""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -scaled_frame_size.vsize                                        |      0x%04X  |  [RW][31:16]""Vsize""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xaf800);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_isa_gp_reg.frame_size                  |  0x%08X  |  ""frame dim""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_isa_gp_reg_frame_size_type */
	REG_DUMP_PRINT_1("   -frame_size.hsize                                               |      0x%04X  |  [RW][15:00]""Hsize""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -frame_size.vsize                                               |      0x%04X  |  [RW][31:16]""Vsize""\n", FIELD_VALUE(val, 16, 31));
} /* end isa_isa_logic_ISA_Cluster_isa_gp_reg */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AckConv */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AckConv(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xaf604);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AckConv.reg_Ack_Addr_Info  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AckConv_reg_Ack_Addr_Info_type */
	REG_DUMP_PRINT_1("   -reg_Ack_Addr_Info.reg_Ack_Addr_Info                               |  0x%08X  |  [RW][31:00]""Ack Addr iNFO register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xaf600);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AckConv.reg_Ack_Cmd_Info   |  0x%08X  |  ""Ack cMD iNFO register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AckConv_reg_Ack_Cmd_Info_type */
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.Message                                          |     0x%05X  |  [RW][18:00]""""\n", FIELD_VALUE(val, 0, 18));
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.CMD                                              |         0x%01X  |  [RO][19:19]""""\n", FIELD_VALUE(val, 19, 19));
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.PID                                              |        0x%02X  |  [RW][25:20]""""\n", FIELD_VALUE(val, 20, 25));
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.SID                                              |        0x%02X  |  [RW][31:26]""""\n", FIELD_VALUE(val, 26, 31));
} /* end isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AckConv */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xaf4bc);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_HW_ASSR_RAW_STAT_Info                  |  0x%08X  |  ""events that took place not gated with the mask register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_HW_ASSR_RAW_STAT_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_RAW_STAT_Info (reg_HW_ASSR_RAW_STAT_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_RAW_STAT_Info.STAT                                                                  |         0x%01X  |  [RO][03:00]""hw assertion raw status""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xaf4b8);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_HW_ASSR_STAT_Info                      |  0x%08X  |  ""events that took place after gated with the mask register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_HW_ASSR_STAT_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_STAT_Info (reg_HW_ASSR_STAT_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_STAT_Info.STAT                                                                      |         0x%01X  |  [RO][03:00]""hw_assertion status""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xaf4b4);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_HW_ASSR_MASK_Info                      |  0x%08X  |  ""hw assertion mask - note status reflects masks assertions as well""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_HW_ASSR_MASK_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_MASK_Info (reg_HW_ASSR_MASK_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_MASK_Info.MASK                                                                      |         0x%01X  |  [RW][03:00]""mask hw assertion bmp""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xaf4b0);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_HW_ASSR_CLEAR_Info                     |  0x%08X  |  ""clear latched event from status register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_HW_ASSR_CLEAR_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_CLEAR_Info (reg_HW_ASSR_CLEAR_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_CLEAR_Info.CLEAR                                                                    |         0x%01X  |  [RW][03:00]""clear hw_assertion""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xaf4ac);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_DFD_DATA_READ_CMD_Info                 |  0x%08X  |  ""DFD read traced data register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_DFD_DATA_READ_CMD_Info_type */
	/* skip, unused field unused_reg_DFD_DATA_READ_CMD_Info (reg_DFD_DATA_READ_CMD_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_DATA_READ_CMD_Info.Fetch                                                                |         0x%01X  |  [RW][00:00]""DFD read traced data register""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xaf4a8);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_DFD_DATA_READ_COMPLETION_Info          |  0x%08X  |  ""DFD data out from egress Fifo read completion indication""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_DFD_DATA_READ_COMPLETION_Info_type */
	/* skip, unused field unused_reg_DFD_DATA_READ_COMPLETION_Info (reg_DFD_DATA_READ_COMPLETION_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_DATA_READ_COMPLETION_Info.Rd_Comp                                                       |         0x%01X  |  [RO][00:00]""DFD traced data out from egress Fifo read completion indication""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xaf4a4);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_DFD_TRACED_DATA_VALID_Info             |  0x%08X  |  ""DFD traced data Valid""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_DFD_TRACED_DATA_VALID_Info_type */
	/* skip, unused field unused_reg_DFD_TRACED_DATA_VALID_Info (reg_DFD_TRACED_DATA_VALID_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_TRACED_DATA_VALID_Info.Data_Valid                                                       |         0x%01X  |  [RO][00:00]""DFD Data VALID""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xaf4a0);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_DFD_TRACED_DATA_Info                   |  0x%08X  |  ""DFD traced data out from egress Fifo - double pixel aligned""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_DFD_TRACED_DATA_Info_type */
	REG_DUMP_PRINT_1("   -reg_DFD_TRACED_DATA_Info.Dfd_Traced_Data                                                        |  0x%08X  |  [RO][31:00]""DFD traced data out from egress Fifo - double pixel aligned.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xaf49c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_DFD_SINGLE_STEP_Info                   |  0x%08X  |  ""Enable FF egress for a single transaction when at DFD post trigger state""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_DFD_SINGLE_STEP_Info_type */
	/* skip, unused field unused_reg_DFD_SINGLE_STEP_Info (reg_DFD_SINGLE_STEP_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_SINGLE_STEP_Info.Single_Step                                                            |         0x%01X  |  [RW][00:00]""Enable FF egress for a single transaction when at DFD post trigger state.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xaf498);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_DFD_EN_Info                            |  0x%08X  |  ""Enable DFD feature. React to acb dfdaction command""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_DFD_EN_Info_type */
	/* skip, unused field unused_reg_DFD_EN_Info (reg_DFD_EN_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_EN_Info.Dfd_En                                                                          |         0x%01X  |  [RW][00:00]""Enable DFD feature. React to acb dfdaction command""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -reg_DFD_EN_Info.Use_Prev_Trig_CHAIN                                                             |         0x%01X  |  [RW][04:04]""Use previous DFD Daisy chanied trace and hw assertion ports""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -reg_DFD_EN_Info.Use_Prev_Trace_CHAIN                                                            |         0x%01X  |  [RW][08:08]""Use previous DFD Daisy chanied trace and hw assertion ports""\n", FIELD_VALUE(val, 8, 8));
	val = REG_DUMP_READ_REGISTER(0xaf494);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_PWR_FEATURE_Info                       |  0x%08X  |  ""Power feature register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_PWR_FEATURE_Info_type */
	/* skip, unused field unused_reg_PWR_FEATURE_Info (reg_PWR_FEATURE_Info) */
	REG_DUMP_PRINT_1("   -reg_PWR_FEATURE_Info.Empty_En                                                                   |         0x%01X  |  [RW][00:00]""""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -reg_PWR_FEATURE_Info.MOL_En                                                                     |         0x%01X  |  [RW][01:01]""""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0xaf490);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_SENSOR_CFG_0_Info         |  0x%08X  |  ""CFA sensor mode""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_SENSOR_CFG_0_Info_type */
	/* skip, unused field unused_reg_FF_AF_AWB_FR_SENSOR_CFG_0_Info (reg_FF_AF_AWB_FR_SENSOR_CFG_0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_SENSOR_CFG_0_Info.Sensor_mode                                                  |         0x%01X  |  [RW][01:00]""""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xaf48c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_NF_Info                   |  0x%08X  |  ""Normilazition factors register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_NF_Info_type */
	/* skip, unused field unused_reg_FF_AF_AWB_FR_NF_Info (reg_FF_AF_AWB_FR_NF_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_NF_Info.Y00_NF                                                                 |         0x%01X  |  [RW][03:00]""""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_NF_Info.Y01_NF                                                                 |         0x%01X  |  [RW][07:04]""""\n", FIELD_VALUE(val, 4, 7));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_NF_Info.Y10_NF                                                                 |         0x%01X  |  [RW][11:08]""""\n", FIELD_VALUE(val, 8, 11));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_NF_Info.Y11_NF                                                                 |         0x%01X  |  [RW][15:12]""""\n", FIELD_VALUE(val, 12, 15));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_NF_Info.R_NF                                                                   |         0x%01X  |  [RW][19:16]""""\n", FIELD_VALUE(val, 16, 19));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_NF_Info.G_NF                                                                   |         0x%01X  |  [RW][23:20]""""\n", FIELD_VALUE(val, 20, 23));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_NF_Info.B_NF                                                                   |         0x%01X  |  [RW][27:24]""""\n", FIELD_VALUE(val, 24, 27));
	val = REG_DUMP_READ_REGISTER(0xaf488);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_B_SIGN_Info               |  0x%08X  |  ""B Filter response sign bits""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_B_SIGN_Info_type */
	/* skip, unused field unused_reg_FF_AF_AWB_FR_B_SIGN_Info (reg_FF_AF_AWB_FR_B_SIGN_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_B_SIGN_Info.Sign_Vec                                                           |       0x%03X  |  [RW][09:00]""""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xaf484);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_B_COEFF_1_Info            |  0x%08X  |  ""B Filter response coefficients""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_B_COEFF_1_Info_type */
	/* skip, unused field unused_reg_FF_AF_AWB_FR_B_COEFF_1_Info (reg_FF_AF_AWB_FR_B_COEFF_1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_B_COEFF_1_Info.A5                                                              |        0x%02X  |  [RW][07:00]""""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_B_COEFF_1_Info.A6                                                              |        0x%02X  |  [RW][15:08]""""\n", FIELD_VALUE(val, 8, 15));
	val = REG_DUMP_READ_REGISTER(0xaf480);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_B_COEFF_0_Info            |  0x%08X  |  ""B Filter response coefficients""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_B_COEFF_0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_B_COEFF_0_Info.A1                                                              |        0x%02X  |  [RW][07:00]""""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_B_COEFF_0_Info.A2                                                              |        0x%02X  |  [RW][15:08]""""\n", FIELD_VALUE(val, 8, 15));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_B_COEFF_0_Info.A3                                                              |        0x%02X  |  [RW][23:16]""""\n", FIELD_VALUE(val, 16, 23));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_B_COEFF_0_Info.A4                                                              |        0x%02X  |  [RW][31:24]""""\n", FIELD_VALUE(val, 24, 31));
	val = REG_DUMP_READ_REGISTER(0xaf47c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_G_SIGN_Info               |  0x%08X  |  ""G Filter response sign bits""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_G_SIGN_Info_type */
	/* skip, unused field unused_reg_FF_AF_AWB_FR_G_SIGN_Info (reg_FF_AF_AWB_FR_G_SIGN_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_G_SIGN_Info.Sign_Vec                                                           |       0x%03X  |  [RW][09:00]""""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xaf478);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_G_COEFF_1_Info            |  0x%08X  |  ""G Filter response coefficients""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_G_COEFF_1_Info_type */
	/* skip, unused field unused_reg_FF_AF_AWB_FR_G_COEFF_1_Info (reg_FF_AF_AWB_FR_G_COEFF_1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_G_COEFF_1_Info.A5                                                              |        0x%02X  |  [RW][07:00]""""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_G_COEFF_1_Info.A6                                                              |        0x%02X  |  [RW][15:08]""""\n", FIELD_VALUE(val, 8, 15));
	val = REG_DUMP_READ_REGISTER(0xaf474);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_G_COEFF_0_Info            |  0x%08X  |  ""G Filter response coefficients""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_G_COEFF_0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_G_COEFF_0_Info.A1                                                              |        0x%02X  |  [RW][07:00]""""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_G_COEFF_0_Info.A2                                                              |        0x%02X  |  [RW][15:08]""""\n", FIELD_VALUE(val, 8, 15));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_G_COEFF_0_Info.A3                                                              |        0x%02X  |  [RW][23:16]""""\n", FIELD_VALUE(val, 16, 23));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_G_COEFF_0_Info.A4                                                              |        0x%02X  |  [RW][31:24]""""\n", FIELD_VALUE(val, 24, 31));
	val = REG_DUMP_READ_REGISTER(0xaf470);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_R_SIGN_Info               |  0x%08X  |  ""R Filter response sign bits""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_R_SIGN_Info_type */
	/* skip, unused field unused_reg_FF_AF_AWB_FR_R_SIGN_Info (reg_FF_AF_AWB_FR_R_SIGN_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_R_SIGN_Info.Sign_Vec                                                           |       0x%03X  |  [RW][09:00]""""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xaf46c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_R_COEFF_1_Info            |  0x%08X  |  ""R Filter response coefficients""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_R_COEFF_1_Info_type */
	/* skip, unused field unused_reg_FF_AF_AWB_FR_R_COEFF_1_Info (reg_FF_AF_AWB_FR_R_COEFF_1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_R_COEFF_1_Info.A5                                                              |        0x%02X  |  [RW][07:00]""""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_R_COEFF_1_Info.A6                                                              |        0x%02X  |  [RW][15:08]""""\n", FIELD_VALUE(val, 8, 15));
	val = REG_DUMP_READ_REGISTER(0xaf468);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_R_COEFF_0_Info            |  0x%08X  |  ""R Filter response coefficients""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_R_COEFF_0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_R_COEFF_0_Info.A1                                                              |        0x%02X  |  [RW][07:00]""""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_R_COEFF_0_Info.A2                                                              |        0x%02X  |  [RW][15:08]""""\n", FIELD_VALUE(val, 8, 15));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_R_COEFF_0_Info.A3                                                              |        0x%02X  |  [RW][23:16]""""\n", FIELD_VALUE(val, 16, 23));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_R_COEFF_0_Info.A4                                                              |        0x%02X  |  [RW][31:24]""""\n", FIELD_VALUE(val, 24, 31));
	val = REG_DUMP_READ_REGISTER(0xaf464);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_Y11_SIGN_Info             |  0x%08X  |  ""Y11 Filter response sign bits""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_Y11_SIGN_Info_type */
	/* skip, unused field unused_reg_FF_AF_AWB_FR_Y11_SIGN_Info (reg_FF_AF_AWB_FR_Y11_SIGN_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y11_SIGN_Info.Sign_Vec                                                         |       0x%03X  |  [RW][09:00]""""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xaf460);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_Y11_COEFF_1_Info          |  0x%08X  |  ""Y11 Filter response coefficients""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_Y11_COEFF_1_Info_type */
	/* skip, unused field unused_reg_FF_AF_AWB_FR_Y11_COEFF_1_Info (reg_FF_AF_AWB_FR_Y11_COEFF_1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y11_COEFF_1_Info.A5                                                            |        0x%02X  |  [RW][07:00]""""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y11_COEFF_1_Info.A6                                                            |        0x%02X  |  [RW][15:08]""""\n", FIELD_VALUE(val, 8, 15));
	val = REG_DUMP_READ_REGISTER(0xaf45c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_Y11_COEFF_0_Info          |  0x%08X  |  ""Y11 Filter response coefficients""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_Y11_COEFF_0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y11_COEFF_0_Info.A1                                                            |        0x%02X  |  [RW][07:00]""""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y11_COEFF_0_Info.A2                                                            |        0x%02X  |  [RW][15:08]""""\n", FIELD_VALUE(val, 8, 15));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y11_COEFF_0_Info.A3                                                            |        0x%02X  |  [RW][23:16]""""\n", FIELD_VALUE(val, 16, 23));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y11_COEFF_0_Info.A4                                                            |        0x%02X  |  [RW][31:24]""""\n", FIELD_VALUE(val, 24, 31));
	val = REG_DUMP_READ_REGISTER(0xaf458);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_Y10_SIGN_Info             |  0x%08X  |  ""Y10 Filter response sign bits""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_Y10_SIGN_Info_type */
	/* skip, unused field unused_reg_FF_AF_AWB_FR_Y10_SIGN_Info (reg_FF_AF_AWB_FR_Y10_SIGN_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y10_SIGN_Info.Sign_Vec                                                         |       0x%03X  |  [RW][09:00]""""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xaf454);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_Y10_COEFF_1_Info          |  0x%08X  |  ""Y10 Filter response coefficients""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_Y10_COEFF_1_Info_type */
	/* skip, unused field unused_reg_FF_AF_AWB_FR_Y10_COEFF_1_Info (reg_FF_AF_AWB_FR_Y10_COEFF_1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y10_COEFF_1_Info.A5                                                            |        0x%02X  |  [RW][07:00]""""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y10_COEFF_1_Info.A6                                                            |        0x%02X  |  [RW][15:08]""""\n", FIELD_VALUE(val, 8, 15));
	val = REG_DUMP_READ_REGISTER(0xaf450);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_Y10_COEFF_0_Info          |  0x%08X  |  ""Y10 Filter response coefficients""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_Y10_COEFF_0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y10_COEFF_0_Info.A1                                                            |        0x%02X  |  [RW][07:00]""""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y10_COEFF_0_Info.A2                                                            |        0x%02X  |  [RW][15:08]""""\n", FIELD_VALUE(val, 8, 15));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y10_COEFF_0_Info.A3                                                            |        0x%02X  |  [RW][23:16]""""\n", FIELD_VALUE(val, 16, 23));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y10_COEFF_0_Info.A4                                                            |        0x%02X  |  [RW][31:24]""""\n", FIELD_VALUE(val, 24, 31));
	val = REG_DUMP_READ_REGISTER(0xaf44c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_Y01_SIGN_Info             |  0x%08X  |  ""Y01 Filter response sign bits""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_Y01_SIGN_Info_type */
	/* skip, unused field unused_reg_FF_AF_AWB_FR_Y01_SIGN_Info (reg_FF_AF_AWB_FR_Y01_SIGN_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y01_SIGN_Info.Sign_Vec                                                         |       0x%03X  |  [RW][09:00]""""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xaf448);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_Y01_COEFF_1_Info          |  0x%08X  |  ""Y01 Filter response coefficients""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_Y01_COEFF_1_Info_type */
	/* skip, unused field unused_reg_FF_AF_AWB_FR_Y01_COEFF_1_Info (reg_FF_AF_AWB_FR_Y01_COEFF_1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y01_COEFF_1_Info.A5                                                            |        0x%02X  |  [RW][07:00]""""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y01_COEFF_1_Info.A6                                                            |        0x%02X  |  [RW][15:08]""""\n", FIELD_VALUE(val, 8, 15));
	val = REG_DUMP_READ_REGISTER(0xaf444);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_Y01_COEFF_0_Info          |  0x%08X  |  ""Y01 Filter response coefficients""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_Y01_COEFF_0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y01_COEFF_0_Info.A1                                                            |        0x%02X  |  [RW][07:00]""""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y01_COEFF_0_Info.A2                                                            |        0x%02X  |  [RW][15:08]""""\n", FIELD_VALUE(val, 8, 15));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y01_COEFF_0_Info.A3                                                            |        0x%02X  |  [RW][23:16]""""\n", FIELD_VALUE(val, 16, 23));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y01_COEFF_0_Info.A4                                                            |        0x%02X  |  [RW][31:24]""""\n", FIELD_VALUE(val, 24, 31));
	val = REG_DUMP_READ_REGISTER(0xaf440);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_Y00_SIGN_Info             |  0x%08X  |  ""Y00 Filter response sign bits""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_Y00_SIGN_Info_type */
	/* skip, unused field unused_reg_FF_AF_AWB_FR_Y00_SIGN_Info (reg_FF_AF_AWB_FR_Y00_SIGN_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y00_SIGN_Info.Sign_Vec                                                         |       0x%03X  |  [RW][09:00]""""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xaf43c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_Y00_COEFF_1_Info          |  0x%08X  |  ""Y00 Filter response coefficients""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_Y00_COEFF_1_Info_type */
	/* skip, unused field unused_reg_FF_AF_AWB_FR_Y00_COEFF_1_Info (reg_FF_AF_AWB_FR_Y00_COEFF_1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y00_COEFF_1_Info.A5                                                            |        0x%02X  |  [RW][07:00]""""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y00_COEFF_1_Info.A6                                                            |        0x%02X  |  [RW][15:08]""""\n", FIELD_VALUE(val, 8, 15));
	val = REG_DUMP_READ_REGISTER(0xaf438);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_Y00_COEFF_0_Info          |  0x%08X  |  ""Y00 Filter response coefficients""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_Y00_COEFF_0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y00_COEFF_0_Info.A1                                                            |        0x%02X  |  [RW][07:00]""""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y00_COEFF_0_Info.A2                                                            |        0x%02X  |  [RW][15:08]""""\n", FIELD_VALUE(val, 8, 15));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y00_COEFF_0_Info.A3                                                            |        0x%02X  |  [RW][23:16]""""\n", FIELD_VALUE(val, 16, 23));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y00_COEFF_0_Info.A4                                                            |        0x%02X  |  [RW][31:24]""""\n", FIELD_VALUE(val, 24, 31));
	val = REG_DUMP_READ_REGISTER(0xaf434);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_B_SELECT_MASK_Info        |  0x%08X  |  ""RGB select control""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_B_SELECT_MASK_Info_type */
	/* skip, unused field unused_reg_FF_AF_AWB_FR_B_SELECT_MASK_Info (reg_FF_AF_AWB_FR_B_SELECT_MASK_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_B_SELECT_MASK_Info.B_Select                                                    |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xaf430);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_RG_SELECT_MASK_Info       |  0x%08X  |  ""RGB select control""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_RG_SELECT_MASK_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_RG_SELECT_MASK_Info.R_Select                                                   |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_RG_SELECT_MASK_Info.G_Select                                                   |      0x%04X  |  [RW][31:16]""""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xaf42c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_Y_EST_NORMALIZATION_Info  |  0x%08X  |  ""Y Estimation Gains""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_Y_EST_NORMALIZATION_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y_EST_NORMALIZATION_Info.ON00_Y0                                               |         0x%01X  |  [RW][03:00]""""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y_EST_NORMALIZATION_Info.ON01_Y0                                               |         0x%01X  |  [RW][07:04]""""\n", FIELD_VALUE(val, 4, 7));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y_EST_NORMALIZATION_Info.ON10_Y0                                               |         0x%01X  |  [RW][11:08]""""\n", FIELD_VALUE(val, 8, 11));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y_EST_NORMALIZATION_Info.ON11_Y0                                               |         0x%01X  |  [RW][15:12]""""\n", FIELD_VALUE(val, 12, 15));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y_EST_NORMALIZATION_Info.ON00_Y1                                               |         0x%01X  |  [RW][19:16]""""\n", FIELD_VALUE(val, 16, 19));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y_EST_NORMALIZATION_Info.ON01_Y1                                               |         0x%01X  |  [RW][23:20]""""\n", FIELD_VALUE(val, 20, 23));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y_EST_NORMALIZATION_Info.ON10_Y1                                               |         0x%01X  |  [RW][27:24]""""\n", FIELD_VALUE(val, 24, 27));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y_EST_NORMALIZATION_Info.ON11_Y1                                               |         0x%01X  |  [RW][31:28]""""\n", FIELD_VALUE(val, 28, 31));
	val = REG_DUMP_READ_REGISTER(0xaf428);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_Y_EST_OUTPUT_ENABLE_Info  |  0x%08X  |  ""Y Estimation Gains""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_Y_EST_OUTPUT_ENABLE_Info_type */
	/* skip, unused field unused_reg_FF_AF_AWB_FR_Y_EST_OUTPUT_ENABLE_Info (reg_FF_AF_AWB_FR_Y_EST_OUTPUT_ENABLE_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y_EST_OUTPUT_ENABLE_Info.OE_Y0                                                 |         0x%01X  |  [RW][03:00]""""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y_EST_OUTPUT_ENABLE_Info.OE_Y1                                                 |         0x%01X  |  [RW][07:04]""""\n", FIELD_VALUE(val, 4, 7));
	val = REG_DUMP_READ_REGISTER(0xaf424);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_Y_EST_MASK_Info           |  0x%08X  |  ""Y Estimation Gains""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_Y_EST_MASK_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y_EST_MASK_Info.MASK_Y0                                                        |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y_EST_MASK_Info.MASK_Y1                                                        |      0x%04X  |  [RW][31:16]""""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xaf420);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_Y_EST_GAIN_3_Info         |  0x%08X  |  ""Y Estimation Gains""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_Y_EST_GAIN_3_Info_type */
	/* skip, unused field unused_reg_FF_AF_AWB_FR_Y_EST_GAIN_3_Info (reg_FF_AF_AWB_FR_Y_EST_GAIN_3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y_EST_GAIN_3_Info.G30                                                          |        0x%02X  |  [RW][05:00]""""\n", FIELD_VALUE(val, 0, 5));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y_EST_GAIN_3_Info.G31                                                          |        0x%02X  |  [RW][13:08]""""\n", FIELD_VALUE(val, 8, 13));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y_EST_GAIN_3_Info.G32                                                          |        0x%02X  |  [RW][21:16]""""\n", FIELD_VALUE(val, 16, 21));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y_EST_GAIN_3_Info.G33                                                          |        0x%02X  |  [RW][29:24]""""\n", FIELD_VALUE(val, 24, 29));
	val = REG_DUMP_READ_REGISTER(0xaf41c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_Y_EST_GAIN_2_Info         |  0x%08X  |  ""Y Estimation Gains""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_Y_EST_GAIN_2_Info_type */
	/* skip, unused field unused_reg_FF_AF_AWB_FR_Y_EST_GAIN_2_Info (reg_FF_AF_AWB_FR_Y_EST_GAIN_2_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y_EST_GAIN_2_Info.G20                                                          |        0x%02X  |  [RW][05:00]""""\n", FIELD_VALUE(val, 0, 5));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y_EST_GAIN_2_Info.G21                                                          |        0x%02X  |  [RW][13:08]""""\n", FIELD_VALUE(val, 8, 13));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y_EST_GAIN_2_Info.G22                                                          |        0x%02X  |  [RW][21:16]""""\n", FIELD_VALUE(val, 16, 21));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y_EST_GAIN_2_Info.G23                                                          |        0x%02X  |  [RW][29:24]""""\n", FIELD_VALUE(val, 24, 29));
	val = REG_DUMP_READ_REGISTER(0xaf418);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_Y_EST_GAIN_1_Info         |  0x%08X  |  ""Y Estimation Gains""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_Y_EST_GAIN_1_Info_type */
	/* skip, unused field unused_reg_FF_AF_AWB_FR_Y_EST_GAIN_1_Info (reg_FF_AF_AWB_FR_Y_EST_GAIN_1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y_EST_GAIN_1_Info.G10                                                          |        0x%02X  |  [RW][05:00]""""\n", FIELD_VALUE(val, 0, 5));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y_EST_GAIN_1_Info.G11                                                          |        0x%02X  |  [RW][13:08]""""\n", FIELD_VALUE(val, 8, 13));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y_EST_GAIN_1_Info.G12                                                          |        0x%02X  |  [RW][21:16]""""\n", FIELD_VALUE(val, 16, 21));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y_EST_GAIN_1_Info.G13                                                          |        0x%02X  |  [RW][29:24]""""\n", FIELD_VALUE(val, 24, 29));
	val = REG_DUMP_READ_REGISTER(0xaf414);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_Y_EST_GAIN_0_Info         |  0x%08X  |  ""Y Estimation Gains""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_Y_EST_GAIN_0_Info_type */
	/* skip, unused field unused_reg_FF_AF_AWB_FR_Y_EST_GAIN_0_Info (reg_FF_AF_AWB_FR_Y_EST_GAIN_0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y_EST_GAIN_0_Info.G00                                                          |        0x%02X  |  [RW][05:00]""""\n", FIELD_VALUE(val, 0, 5));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y_EST_GAIN_0_Info.G01                                                          |        0x%02X  |  [RW][13:08]""""\n", FIELD_VALUE(val, 8, 13));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y_EST_GAIN_0_Info.G02                                                          |        0x%02X  |  [RW][21:16]""""\n", FIELD_VALUE(val, 16, 21));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_Y_EST_GAIN_0_Info.G03                                                          |        0x%02X  |  [RW][29:24]""""\n", FIELD_VALUE(val, 24, 29));
	val = REG_DUMP_READ_REGISTER(0xaf410);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_AVG_SHFT_CTRL_1_Info      |  0x%08X  |  ""Shift control of the statistics meta-data""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_AVG_SHFT_CTRL_1_Info_type */
	/* skip, unused field unused_reg_FF_AF_AWB_FR_AVG_SHFT_CTRL_1_Info (reg_FF_AF_AWB_FR_AVG_SHFT_CTRL_1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_AVG_SHFT_CTRL_1_Info.ShftR_val_R                                               |         0x%01X  |  [RW][03:00]""""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_AVG_SHFT_CTRL_1_Info.ShftR_val_G                                               |         0x%01X  |  [RW][11:08]""""\n", FIELD_VALUE(val, 8, 11));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_AVG_SHFT_CTRL_1_Info.ShftR_val_B                                               |         0x%01X  |  [RW][19:16]""""\n", FIELD_VALUE(val, 16, 19));
	val = REG_DUMP_READ_REGISTER(0xaf40c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_AVG_SHFT_CTRL_0_Info      |  0x%08X  |  ""Shift control of the statistics meta-data""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_AVG_SHFT_CTRL_0_Info_type */
	/* skip, unused field unused_reg_FF_AF_AWB_FR_AVG_SHFT_CTRL_0_Info (reg_FF_AF_AWB_FR_AVG_SHFT_CTRL_0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_AVG_SHFT_CTRL_0_Info.ShftR_val_Y00                                             |         0x%01X  |  [RW][03:00]""""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_AVG_SHFT_CTRL_0_Info.ShftR_val_Y01                                             |         0x%01X  |  [RW][11:08]""""\n", FIELD_VALUE(val, 8, 11));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_AVG_SHFT_CTRL_0_Info.ShftR_val_Y10                                             |         0x%01X  |  [RW][19:16]""""\n", FIELD_VALUE(val, 16, 19));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_AVG_SHFT_CTRL_0_Info.ShftR_val_Y11                                             |         0x%01X  |  [RW][27:24]""""\n", FIELD_VALUE(val, 24, 27));
	val = REG_DUMP_READ_REGISTER(0xaf408);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_GRD_END_Info              |  0x%08X  |  ""AF_GRD CFG""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_GRD_END_Info_type */
	/* skip, unused field unused_reg_FF_AF_AWB_FR_GRD_END_Info (reg_FF_AF_AWB_FR_GRD_END_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_GRD_END_Info.x_end                                                             |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_GRD_END_Info.y_end                                                             |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xaf404);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_GRD_START_Info            |  0x%08X  |  ""AF_GRD CFG""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_GRD_START_Info_type */
	/* skip, unused field unused_reg_FF_AF_AWB_FR_GRD_START_Info (reg_FF_AF_AWB_FR_GRD_START_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_GRD_START_Info.x_start                                                         |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_GRD_START_Info.y_start                                                         |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xaf400);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD.reg_FF_AF_AWB_FR_GRD_CFG_Info              |  0x%08X  |  ""GRD CFG""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_reg_FF_AF_AWB_FR_GRD_CFG_Info_type */
	/* skip, unused field unused_reg_FF_AF_AWB_FR_GRD_CFG_Info (reg_FF_AF_AWB_FR_GRD_CFG_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_GRD_CFG_Info.grid_width                                                        |        0x%02X  |  [RW][06:00]""""\n", FIELD_VALUE(val, 0, 6));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_GRD_CFG_Info.grid_height                                                       |        0x%02X  |  [RW][14:08]""""\n", FIELD_VALUE(val, 8, 14));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_GRD_CFG_Info.block_width                                                       |         0x%01X  |  [RW][19:16]""""\n", FIELD_VALUE(val, 16, 19));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_GRD_CFG_Info.block_height                                                      |         0x%01X  |  [RW][23:20]""""\n", FIELD_VALUE(val, 20, 23));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_GRD_CFG_Info.grid_height_per_slice                                             |         0x%01X  |  [RW][27:24]""""\n", FIELD_VALUE(val, 24, 27));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_GRD_CFG_Info.Y_FR_En                                                           |         0x%01X  |  [RW][28:28]""""\n", FIELD_VALUE(val, 28, 28));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_GRD_CFG_Info.AWB_FR_En                                                         |         0x%01X  |  [RW][29:29]""""\n", FIELD_VALUE(val, 29, 29));
	REG_DUMP_PRINT_1("   -reg_FF_AF_AWB_FR_GRD_CFG_Info.FF_En                                                             |         0x%01X  |  [RW][30:30]""""\n", FIELD_VALUE(val, 30, 30));
} /* end isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_FF_AF_AWB_FR_GRD_RF */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_FF_AF_AWB_FR_GRD_RF(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xaf3fc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_FF_AF_AWB_FR_GRD_RF.stat_awb_rgb_fr_set1_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_FF_AF_AWB_FR_GRD_RF_stat_awb_rgb_fr_set1_last_type */
	REG_DUMP_PRINT_1("   -stat_awb_rgb_fr_set1_last.stat_awb_rgb_fr_set1_last                                                  |  0x%08X  |  [RW][31:00]""STAT_AWB_RGB_FR_SET1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xaf300);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_FF_AF_AWB_FR_GRD_RF.stat_awb_rgb_fr_set1_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_FF_AF_AWB_FR_GRD_RF_stat_awb_rgb_fr_set1_first_type */
	REG_DUMP_PRINT_1("   -stat_awb_rgb_fr_set1_first.stat_awb_rgb_fr_set1_first                                                |  0x%08X  |  [RW][31:00]""STAT_AWB_RGB_FR_SET1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xaf2fc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_FF_AF_AWB_FR_GRD_RF.stat_awb_rgb_fr_set0_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_FF_AF_AWB_FR_GRD_RF_stat_awb_rgb_fr_set0_last_type */
	REG_DUMP_PRINT_1("   -stat_awb_rgb_fr_set0_last.stat_awb_rgb_fr_set0_last                                                  |  0x%08X  |  [RW][31:00]""STAT_AWB_RGB_FR_SET0""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xaf200);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_FF_AF_AWB_FR_GRD_RF.stat_awb_rgb_fr_set0_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_FF_AF_AWB_FR_GRD_RF_stat_awb_rgb_fr_set0_first_type */
	REG_DUMP_PRINT_1("   -stat_awb_rgb_fr_set0_first.stat_awb_rgb_fr_set0_first                                                |  0x%08X  |  [RW][31:00]""STAT_AWB_RGB_FR_SET0""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xaf1fc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_FF_AF_AWB_FR_GRD_RF.stat_af_y_fr_set1_last      |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_FF_AF_AWB_FR_GRD_RF_stat_af_y_fr_set1_last_type */
	REG_DUMP_PRINT_1("   -stat_af_y_fr_set1_last.stat_af_y_fr_set1_last                                                        |  0x%08X  |  [RW][31:00]""STAT_AF_Y_FR_SET1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xaf100);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_FF_AF_AWB_FR_GRD_RF.stat_af_y_fr_set1_first     |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_FF_AF_AWB_FR_GRD_RF_stat_af_y_fr_set1_first_type */
	REG_DUMP_PRINT_1("   -stat_af_y_fr_set1_first.stat_af_y_fr_set1_first                                                      |  0x%08X  |  [RW][31:00]""STAT_AF_Y_FR_SET1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xaf0fc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_FF_AF_AWB_FR_GRD_RF.stat_af_y_fr_set0_last      |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_FF_AF_AWB_FR_GRD_RF_stat_af_y_fr_set0_last_type */
	REG_DUMP_PRINT_1("   -stat_af_y_fr_set0_last.stat_af_y_fr_set0_last                                                        |  0x%08X  |  [RW][31:00]""STAT_AF_Y_FR_SET0""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xaf000);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_FF_AF_AWB_FR_GRD_RF.stat_af_y_fr_set0_first     |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_FF_AF_AWB_FR_GRD_RF_stat_af_y_fr_set0_first_type */
	REG_DUMP_PRINT_1("   -stat_af_y_fr_set0_first.stat_af_y_fr_set0_first                                                      |  0x%08X  |  [RW][31:00]""STAT_AF_Y_FR_SET0""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Stat_AF_AWB_FR_AF_AWB_FR_GRD_FF_AF_AWB_FR_GRD_RF */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Stat_AWB_AckConv */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Stat_AWB_AckConv(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xaee04);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AckConv.reg_Ack_Addr_Info  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AckConv_reg_Ack_Addr_Info_type */
	REG_DUMP_PRINT_1("   -reg_Ack_Addr_Info.reg_Ack_Addr_Info                         |  0x%08X  |  [RW][31:00]""Ack Addr iNFO register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xaee00);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AckConv.reg_Ack_Cmd_Info   |  0x%08X  |  ""Ack cMD iNFO register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AckConv_reg_Ack_Cmd_Info_type */
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.Message                                    |     0x%05X  |  [RW][18:00]""""\n", FIELD_VALUE(val, 0, 18));
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.CMD                                        |         0x%01X  |  [RO][19:19]""""\n", FIELD_VALUE(val, 19, 19));
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.PID                                        |        0x%02X  |  [RW][25:20]""""\n", FIELD_VALUE(val, 20, 25));
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.SID                                        |        0x%02X  |  [RW][31:26]""""\n", FIELD_VALUE(val, 26, 31));
} /* end isa_isa_logic_ISA_Cluster_Stat_AWB_AckConv */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xaeba0);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG.reg_HW_ASSR_RAW_STAT_Info             |  0x%08X  |  ""events that took place not gated with the mask register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_reg_HW_ASSR_RAW_STAT_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_RAW_STAT_Info (reg_HW_ASSR_RAW_STAT_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_RAW_STAT_Info.STAT                                              |         0x%01X  |  [RO][03:00]""hw assertion raw status""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xaeb9c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG.reg_HW_ASSR_STAT_Info                 |  0x%08X  |  ""events that took place after gated with the mask register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_reg_HW_ASSR_STAT_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_STAT_Info (reg_HW_ASSR_STAT_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_STAT_Info.STAT                                                  |         0x%01X  |  [RO][03:00]""hw_assertion status""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xaeb98);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG.reg_HW_ASSR_MASK_Info                 |  0x%08X  |  ""hw assertion mask - note status reflects masks assertions as well""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_reg_HW_ASSR_MASK_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_MASK_Info (reg_HW_ASSR_MASK_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_MASK_Info.MASK                                                  |         0x%01X  |  [RW][03:00]""mask hw assertion bmp""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xaeb94);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG.reg_HW_ASSR_CLEAR_Info                |  0x%08X  |  ""clear latched event from status register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_reg_HW_ASSR_CLEAR_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_CLEAR_Info (reg_HW_ASSR_CLEAR_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_CLEAR_Info.CLEAR                                                |         0x%01X  |  [RW][03:00]""clear hw_assertion""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xaeb90);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG.reg_DFD_DATA_READ_CMD_Info            |  0x%08X  |  ""DFD read traced data register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_reg_DFD_DATA_READ_CMD_Info_type */
	/* skip, unused field unused_reg_DFD_DATA_READ_CMD_Info (reg_DFD_DATA_READ_CMD_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_DATA_READ_CMD_Info.Fetch                                            |         0x%01X  |  [RW][00:00]""DFD read traced data register""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xaeb8c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG.reg_DFD_DATA_READ_COMPLETION_Info     |  0x%08X  |  ""DFD data out from egress Fifo read completion indication""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_reg_DFD_DATA_READ_COMPLETION_Info_type */
	/* skip, unused field unused_reg_DFD_DATA_READ_COMPLETION_Info (reg_DFD_DATA_READ_COMPLETION_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_DATA_READ_COMPLETION_Info.Rd_Comp                                   |         0x%01X  |  [RO][00:00]""DFD traced data out from egress Fifo read completion indication""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xaeb88);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG.reg_DFD_TRACED_DATA_VALID_Info        |  0x%08X  |  ""DFD traced data Valid""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_reg_DFD_TRACED_DATA_VALID_Info_type */
	/* skip, unused field unused_reg_DFD_TRACED_DATA_VALID_Info (reg_DFD_TRACED_DATA_VALID_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_TRACED_DATA_VALID_Info.Data_Valid                                   |         0x%01X  |  [RO][00:00]""DFD Data VALID""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xaeb84);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG.reg_DFD_TRACED_DATA_Info              |  0x%08X  |  ""DFD traced data out from egress Fifo - double pixel aligned""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_reg_DFD_TRACED_DATA_Info_type */
	REG_DUMP_PRINT_1("   -reg_DFD_TRACED_DATA_Info.Dfd_Traced_Data                                    |  0x%08X  |  [RO][31:00]""DFD traced data out from egress Fifo - double pixel aligned.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xaeb80);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG.reg_DFD_SINGLE_STEP_Info              |  0x%08X  |  ""Enable FF egress for a single transaction when at DFD post trigger state""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_reg_DFD_SINGLE_STEP_Info_type */
	/* skip, unused field unused_reg_DFD_SINGLE_STEP_Info (reg_DFD_SINGLE_STEP_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_SINGLE_STEP_Info.Single_Step                                        |         0x%01X  |  [RW][00:00]""Enable FF egress for a single transaction when at DFD post trigger state.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xaeb7c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG.reg_DFD_EN_Info                       |  0x%08X  |  ""Enable DFD feature. React to acb dfdaction command""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_reg_DFD_EN_Info_type */
	/* skip, unused field unused_reg_DFD_EN_Info (reg_DFD_EN_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_EN_Info.Dfd_En                                                      |         0x%01X  |  [RW][00:00]""Enable DFD feature. React to acb dfdaction command""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -reg_DFD_EN_Info.Use_Prev_Trig_CHAIN                                         |         0x%01X  |  [RW][04:04]""Use previous DFD Daisy chanied trace and hw assertion ports""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -reg_DFD_EN_Info.Use_Prev_Trace_CHAIN                                        |         0x%01X  |  [RW][08:08]""Use previous DFD Daisy chanied trace and hw assertion ports""\n", FIELD_VALUE(val, 8, 8));
	val = REG_DUMP_READ_REGISTER(0xaeb78);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG.reg_PWR_FEATURE_Info                  |  0x%08X  |  ""Power feature register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_reg_PWR_FEATURE_Info_type */
	/* skip, unused field unused_reg_PWR_FEATURE_Info (reg_PWR_FEATURE_Info) */
	REG_DUMP_PRINT_1("   -reg_PWR_FEATURE_Info.Empty_En                                               |         0x%01X  |  [RW][00:00]""""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -reg_PWR_FEATURE_Info.MOL_En                                                 |         0x%01X  |  [RW][01:01]""""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0xaeb74);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG.reg_GEN_CTRL_Info                     |  0x%08X  |  ""General control register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_reg_GEN_CTRL_Info_type */
	/* skip, unused field unused_reg_GEN_CTRL_Info (reg_GEN_CTRL_Info) */
	REG_DUMP_PRINT_1("   -reg_GEN_CTRL_Info.En                                                        |         0x%01X  |  [RW][00:00]""""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xaeb70);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG.reg_FF_AWB_RGBS_SAT_SHFT_CTRL_Info    |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_reg_FF_AWB_RGBS_SAT_SHFT_CTRL_Info_type */
	/* skip, unused field unused_reg_FF_AWB_RGBS_SAT_SHFT_CTRL_Info (reg_FF_AWB_RGBS_SAT_SHFT_CTRL_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_SAT_SHFT_CTRL_Info.SHFTR_SAT                                |         0x%01X  |  [RW][02:00]""""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0xaeb6c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG.reg_FF_AWB_RGBS_AVG_SHFT_CTRL_1_Info  |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_reg_FF_AWB_RGBS_AVG_SHFT_CTRL_1_Info_type */
	/* skip, unused field unused_reg_FF_AWB_RGBS_AVG_SHFT_CTRL_1_Info (reg_FF_AWB_RGBS_AVG_SHFT_CTRL_1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_AVG_SHFT_CTRL_1_Info.Shftr_val_c4                           |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_AVG_SHFT_CTRL_1_Info.Shftr_val_c5                           |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_AVG_SHFT_CTRL_1_Info.Shftr_val_c6                           |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_AVG_SHFT_CTRL_1_Info.Shftr_val_c7                           |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	val = REG_DUMP_READ_REGISTER(0xaeb68);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG.reg_FF_AWB_RGBS_AVG_SHFT_CTRL_0_Info  |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_reg_FF_AWB_RGBS_AVG_SHFT_CTRL_0_Info_type */
	/* skip, unused field unused_reg_FF_AWB_RGBS_AVG_SHFT_CTRL_0_Info (reg_FF_AWB_RGBS_AVG_SHFT_CTRL_0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_AVG_SHFT_CTRL_0_Info.Shftr_val_c0                           |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_AVG_SHFT_CTRL_0_Info.Shftr_val_c1                           |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_AVG_SHFT_CTRL_0_Info.Shftr_val_c2                           |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_AVG_SHFT_CTRL_0_Info.Shftr_val_c3                           |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	val = REG_DUMP_READ_REGISTER(0xaeb64);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG.reg_FF_AWB_RGBS_THRSH_3_Info          |  0x%08X  |  ""RGBS threshold value""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_reg_FF_AWB_RGBS_THRSH_3_Info_type */
	/* skip, unused field unused_reg_FF_AWB_RGBS_THRSH_3_Info (reg_FF_AWB_RGBS_THRSH_3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_THRSH_3_Info.Rgbs_thr_c6                                    |       0x%03X  |  [RW][11:00]""C0 RGBS threshold value""\n", FIELD_VALUE(val, 0, 11));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_THRSH_3_Info.Rgbs_thr_c7                                    |       0x%03X  |  [RW][27:16]""C1 RGBS threshold value""\n", FIELD_VALUE(val, 16, 27));
	val = REG_DUMP_READ_REGISTER(0xaeb60);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG.reg_FF_AWB_RGBS_THRSH_2_Info          |  0x%08X  |  ""RGBS threshold value""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_reg_FF_AWB_RGBS_THRSH_2_Info_type */
	/* skip, unused field unused_reg_FF_AWB_RGBS_THRSH_2_Info (reg_FF_AWB_RGBS_THRSH_2_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_THRSH_2_Info.Rgbs_thr_c4                                    |       0x%03X  |  [RW][11:00]""C0 RGBS threshold value""\n", FIELD_VALUE(val, 0, 11));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_THRSH_2_Info.Rgbs_thr_c5                                    |       0x%03X  |  [RW][27:16]""C1 RGBS threshold value""\n", FIELD_VALUE(val, 16, 27));
	val = REG_DUMP_READ_REGISTER(0xaeb5c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG.reg_FF_AWB_RGBS_THRSH_1_Info          |  0x%08X  |  ""RGBS threshold value""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_reg_FF_AWB_RGBS_THRSH_1_Info_type */
	/* skip, unused field unused_reg_FF_AWB_RGBS_THRSH_1_Info (reg_FF_AWB_RGBS_THRSH_1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_THRSH_1_Info.Rgbs_thr_c2                                    |       0x%03X  |  [RW][11:00]""C0 RGBS threshold value""\n", FIELD_VALUE(val, 0, 11));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_THRSH_1_Info.Rgbs_thr_c3                                    |       0x%03X  |  [RW][27:16]""C1 RGBS threshold value""\n", FIELD_VALUE(val, 16, 27));
	val = REG_DUMP_READ_REGISTER(0xaeb58);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG.reg_FF_AWB_RGBS_THRSH_0_Info          |  0x%08X  |  ""RGBS threshold value""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_reg_FF_AWB_RGBS_THRSH_0_Info_type */
	/* skip, unused field unused_reg_FF_AWB_RGBS_THRSH_0_Info (reg_FF_AWB_RGBS_THRSH_0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_THRSH_0_Info.Rgbs_thr_c0                                    |       0x%03X  |  [RW][11:00]""C0 RGBS threshold value""\n", FIELD_VALUE(val, 0, 11));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_THRSH_0_Info.Rgbs_thr_c1                                    |       0x%03X  |  [RW][27:16]""C1 RGBS threshold value""\n", FIELD_VALUE(val, 16, 27));
	val = REG_DUMP_READ_REGISTER(0xaeb54);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG.reg_FF_AWB_RGBS_SENSOR_CFG_2_Info     |  0x%08X  |  ""Defines the Color ID of the pixel in the CFA pattern""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_reg_FF_AWB_RGBS_SENSOR_CFG_2_Info_type */
	/* skip, unused field unused_reg_FF_AWB_RGBS_SENSOR_CFG_2_Info (reg_FF_AWB_RGBS_SENSOR_CFG_2_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_SENSOR_CFG_2_Info.Pat_20                                    |         0x%01X  |  [RW][02:00]""color id of row 2 column 0""\n", FIELD_VALUE(val, 0, 2));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_SENSOR_CFG_2_Info.Pat_21                                    |         0x%01X  |  [RW][06:04]""color id of row 2 column 1""\n", FIELD_VALUE(val, 4, 6));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_SENSOR_CFG_2_Info.Pat_22                                    |         0x%01X  |  [RW][10:08]""color id of row 2 column 2""\n", FIELD_VALUE(val, 8, 10));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_SENSOR_CFG_2_Info.Pat_23                                    |         0x%01X  |  [RW][14:12]""color id of row 2 column 3""\n", FIELD_VALUE(val, 12, 14));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_SENSOR_CFG_2_Info.Pat_30                                    |         0x%01X  |  [RW][18:16]""color id of row 3 column 0""\n", FIELD_VALUE(val, 16, 18));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_SENSOR_CFG_2_Info.Pat_31                                    |         0x%01X  |  [RW][22:20]""color id of row 3 column 1""\n", FIELD_VALUE(val, 20, 22));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_SENSOR_CFG_2_Info.Pat_32                                    |         0x%01X  |  [RW][26:24]""color id of row 3 column 2""\n", FIELD_VALUE(val, 24, 26));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_SENSOR_CFG_2_Info.Pat_33                                    |         0x%01X  |  [RW][30:28]""color id of row 3 column 3""\n", FIELD_VALUE(val, 28, 30));
	val = REG_DUMP_READ_REGISTER(0xaeb50);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG.reg_FF_AWB_RGBS_SENSOR_CFG_1_Info     |  0x%08X  |  ""Defines the Color ID of the pixel in the CFA pattern""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_reg_FF_AWB_RGBS_SENSOR_CFG_1_Info_type */
	/* skip, unused field unused_reg_FF_AWB_RGBS_SENSOR_CFG_1_Info (reg_FF_AWB_RGBS_SENSOR_CFG_1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_SENSOR_CFG_1_Info.Pat_00                                    |         0x%01X  |  [RW][02:00]""color id of row 0 column 0""\n", FIELD_VALUE(val, 0, 2));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_SENSOR_CFG_1_Info.Pat_01                                    |         0x%01X  |  [RW][06:04]""color id of row 0 column 1""\n", FIELD_VALUE(val, 4, 6));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_SENSOR_CFG_1_Info.Pat_02                                    |         0x%01X  |  [RW][10:08]""color id of row 0 column 2""\n", FIELD_VALUE(val, 8, 10));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_SENSOR_CFG_1_Info.Pat_03                                    |         0x%01X  |  [RW][14:12]""color id of row 0 column 3""\n", FIELD_VALUE(val, 12, 14));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_SENSOR_CFG_1_Info.Pat_10                                    |         0x%01X  |  [RW][18:16]""color id of row 1 column 0""\n", FIELD_VALUE(val, 16, 18));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_SENSOR_CFG_1_Info.Pat_11                                    |         0x%01X  |  [RW][22:20]""color id of row 1 column 1""\n", FIELD_VALUE(val, 20, 22));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_SENSOR_CFG_1_Info.Pat_12                                    |         0x%01X  |  [RW][26:24]""color id of row 1 column 2""\n", FIELD_VALUE(val, 24, 26));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_SENSOR_CFG_1_Info.Pat_13                                    |         0x%01X  |  [RW][30:28]""color id of row 1 column 3""\n", FIELD_VALUE(val, 28, 30));
	val = REG_DUMP_READ_REGISTER(0xaeb4c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG.reg_FF_AWB_RGBS_SENSOR_CFG_0_Info     |  0x%08X  |  ""CFA sensor mode""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_reg_FF_AWB_RGBS_SENSOR_CFG_0_Info_type */
	/* skip, unused field unused_reg_FF_AWB_RGBS_SENSOR_CFG_0_Info (reg_FF_AWB_RGBS_SENSOR_CFG_0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_SENSOR_CFG_0_Info.Sensor_mode                               |         0x%01X  |  [RW][01:00]""""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xaeb48);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG.reg_FF_AWB_RGBS_GRD_END_Info          |  0x%08X  |  ""grid end indexes""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_reg_FF_AWB_RGBS_GRD_END_Info_type */
	/* skip, unused field unused_reg_FF_AWB_RGBS_GRD_END_Info (reg_FF_AWB_RGBS_GRD_END_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_GRD_END_Info.x_end                                          |      0x%04X  |  [RW][13:00]""X bottom right corner of the grid""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_GRD_END_Info.y_end                                          |      0x%04X  |  [RW][29:16]""Y buttom right corner of the grid""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xaeb44);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG.reg_FF_AWB_RGBS_GRD_START_Info        |  0x%08X  |  ""grid start indexes""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_reg_FF_AWB_RGBS_GRD_START_Info_type */
	/* skip, unused field unused_reg_FF_AWB_RGBS_GRD_START_Info (reg_FF_AWB_RGBS_GRD_START_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_GRD_START_Info.x_start                                      |      0x%04X  |  [RW][13:00]""X top left corner of the grid""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_GRD_START_Info.y_start                                      |      0x%04X  |  [RW][29:16]""Y top left corner of the grid""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xaeb40);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG.reg_FF_AWB_RGBS_GRD_CFG_Info          |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_reg_FF_AWB_RGBS_GRD_CFG_Info_type */
	/* skip, unused field unused_reg_FF_AWB_RGBS_GRD_CFG_Info (reg_FF_AWB_RGBS_GRD_CFG_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_GRD_CFG_Info.grid_width                                     |        0x%02X  |  [RW][06:00]""number of horizontal grid cells""\n", FIELD_VALUE(val, 0, 6));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_GRD_CFG_Info.grid_height                                    |        0x%02X  |  [RW][14:08]""number of vertical grid cells""\n", FIELD_VALUE(val, 8, 14));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_GRD_CFG_Info.block_width                                    |         0x%01X  |  [RW][18:16]""log2 the width of each cell""\n", FIELD_VALUE(val, 16, 18));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_GRD_CFG_Info.block_height                                   |         0x%01X  |  [RW][21:19]""log2 the height of each cell""\n", FIELD_VALUE(val, 19, 21));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_GRD_CFG_Info.grid_hight_per_slice                           |         0x%01X  |  [RW][25:22]""number of blocks in vertical axis per meta data array""\n", FIELD_VALUE(val, 22, 25));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_GRD_CFG_Info.AWB_En                                         |         0x%01X  |  [RW][28:28]""""\n", FIELD_VALUE(val, 28, 28));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_GRD_CFG_Info.Rgbs_En                                        |         0x%01X  |  [RW][29:29]""""\n", FIELD_VALUE(val, 29, 29));
	REG_DUMP_PRINT_1("   -reg_FF_AWB_RGBS_GRD_CFG_Info.rgbs_incl_sat                                  |         0x%01X  |  [RW][30:30]""""\n", FIELD_VALUE(val, 30, 30));
} /* end isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_ff_3a_awb_rgbs_sat_rf */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_ff_3a_awb_rgbs_sat_rf(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xaeb3c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_ff_3a_awb_rgbs_sat_rf.awb_rgbs_sat_set1_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_ff_3a_awb_rgbs_sat_rf_awb_rgbs_sat_set1_last_type */
	REG_DUMP_PRINT_1("   -awb_rgbs_sat_set1_last.awb_rgbs_sat_set1_last                                        |  0x%08X  |  [RW][31:00]""RGBS_SET1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xaeaa0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_ff_3a_awb_rgbs_sat_rf.awb_rgbs_sat_set1_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_ff_3a_awb_rgbs_sat_rf_awb_rgbs_sat_set1_first_type */
	REG_DUMP_PRINT_1("   -awb_rgbs_sat_set1_first.awb_rgbs_sat_set1_first                                      |  0x%08X  |  [RW][31:00]""RGBS_SET1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xaea9c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_ff_3a_awb_rgbs_sat_rf.awb_rgbs_sat_set0_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_ff_3a_awb_rgbs_sat_rf_awb_rgbs_sat_set0_last_type */
	REG_DUMP_PRINT_1("   -awb_rgbs_sat_set0_last.awb_rgbs_sat_set0_last                                        |  0x%08X  |  [RW][31:00]""RGBS_SET0""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xaea00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_ff_3a_awb_rgbs_sat_rf.awb_rgbs_sat_set0_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_ff_3a_awb_rgbs_sat_rf_awb_rgbs_sat_set0_first_type */
	REG_DUMP_PRINT_1("   -awb_rgbs_sat_set0_first.awb_rgbs_sat_set0_first                                      |  0x%08X  |  [RW][31:00]""RGBS_SET0""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_ff_3a_awb_rgbs_sat_rf */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_ff_3a_awb_rgbs_col_rf */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_ff_3a_awb_rgbs_col_rf(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xae9fc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_ff_3a_awb_rgbs_col_rf.awb_rgbs_col_set1_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_ff_3a_awb_rgbs_col_rf_awb_rgbs_col_set1_last_type */
	REG_DUMP_PRINT_1("   -awb_rgbs_col_set1_last.awb_rgbs_col_set1_last                                        |  0x%08X  |  [RW][31:00]""RGBS_SET1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xae500);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_ff_3a_awb_rgbs_col_rf.awb_rgbs_col_set1_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_ff_3a_awb_rgbs_col_rf_awb_rgbs_col_set1_first_type */
	REG_DUMP_PRINT_1("   -awb_rgbs_col_set1_first.awb_rgbs_col_set1_first                                      |  0x%08X  |  [RW][31:00]""RGBS_SET1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xae4fc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_ff_3a_awb_rgbs_col_rf.awb_rgbs_col_set0_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_ff_3a_awb_rgbs_col_rf_awb_rgbs_col_set0_last_type */
	REG_DUMP_PRINT_1("   -awb_rgbs_col_set0_last.awb_rgbs_col_set0_last                                        |  0x%08X  |  [RW][31:00]""RGBS_SET0""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xae000);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_ff_3a_awb_rgbs_col_rf.awb_rgbs_col_set0_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_ff_3a_awb_rgbs_col_rf_awb_rgbs_col_set0_first_type */
	REG_DUMP_PRINT_1("   -awb_rgbs_col_set0_first.awb_rgbs_col_set0_first                                      |  0x%08X  |  [RW][31:00]""RGBS_SET0""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Stat_AWB_AWRG_ff_3a_awb_rgbs_col_rf */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xadea8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_HW_ASSR_RAW_STAT_Info               |  0x%08X  |  ""events that took place not gated with the mask register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_HW_ASSR_RAW_STAT_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_RAW_STAT_Info (reg_HW_ASSR_RAW_STAT_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_RAW_STAT_Info.STAT                                                 |         0x%01X  |  [RO][03:00]""hw assertion raw status""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xadea4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_HW_ASSR_STAT_Info                   |  0x%08X  |  ""events that took place after gated with the mask register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_HW_ASSR_STAT_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_STAT_Info (reg_HW_ASSR_STAT_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_STAT_Info.STAT                                                     |         0x%01X  |  [RO][03:00]""hw_assertion status""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xadea0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_HW_ASSR_MASK_Info                   |  0x%08X  |  ""hw assertion mask - note status reflects masks assertions as well""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_HW_ASSR_MASK_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_MASK_Info (reg_HW_ASSR_MASK_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_MASK_Info.MASK                                                     |         0x%01X  |  [RW][03:00]""mask hw assertion bmp""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xade9c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_HW_ASSR_CLEAR_Info                  |  0x%08X  |  ""clear latched event from status register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_HW_ASSR_CLEAR_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_CLEAR_Info (reg_HW_ASSR_CLEAR_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_CLEAR_Info.CLEAR                                                   |         0x%01X  |  [RW][03:00]""clear hw_assertion""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xade98);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_DFD_DATA_READ_CMD_Info              |  0x%08X  |  ""DFD read traced data register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_DFD_DATA_READ_CMD_Info_type */
	/* skip, unused field unused_reg_DFD_DATA_READ_CMD_Info (reg_DFD_DATA_READ_CMD_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_DATA_READ_CMD_Info.Fetch                                               |         0x%01X  |  [RW][00:00]""DFD read traced data register""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xade94);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_DFD_DATA_READ_COMPLETION_Info       |  0x%08X  |  ""DFD data out from egress Fifo read completion indication""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_DFD_DATA_READ_COMPLETION_Info_type */
	/* skip, unused field unused_reg_DFD_DATA_READ_COMPLETION_Info (reg_DFD_DATA_READ_COMPLETION_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_DATA_READ_COMPLETION_Info.Rd_Comp                                      |         0x%01X  |  [RO][00:00]""DFD traced data out from egress Fifo read completion indication""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xade90);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_DFD_TRACED_DATA_VALID_Info          |  0x%08X  |  ""DFD traced data Valid""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_DFD_TRACED_DATA_VALID_Info_type */
	/* skip, unused field unused_reg_DFD_TRACED_DATA_VALID_Info (reg_DFD_TRACED_DATA_VALID_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_TRACED_DATA_VALID_Info.Data_Valid                                      |         0x%01X  |  [RO][00:00]""DFD Data VALID""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xade8c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_DFD_TRACED_DATA_Info                |  0x%08X  |  ""DFD traced data out from egress Fifo - double pixel aligned""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_DFD_TRACED_DATA_Info_type */
	REG_DUMP_PRINT_1("   -reg_DFD_TRACED_DATA_Info.Dfd_Traced_Data                                       |  0x%08X  |  [RO][31:00]""DFD traced data out from egress Fifo - double pixel aligned.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xade88);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_DFD_SINGLE_STEP_Info                |  0x%08X  |  ""Enable FF egress for a single transaction when at DFD post trigger state""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_DFD_SINGLE_STEP_Info_type */
	/* skip, unused field unused_reg_DFD_SINGLE_STEP_Info (reg_DFD_SINGLE_STEP_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_SINGLE_STEP_Info.Single_Step                                           |         0x%01X  |  [RW][00:00]""Enable FF egress for a single transaction when at DFD post trigger state.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xade84);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_DFD_EN_Info                         |  0x%08X  |  ""Enable DFD feature. React to acb dfdaction command""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_DFD_EN_Info_type */
	/* skip, unused field unused_reg_DFD_EN_Info (reg_DFD_EN_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_EN_Info.Dfd_En                                                         |         0x%01X  |  [RW][00:00]""Enable DFD feature. React to acb dfdaction command""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -reg_DFD_EN_Info.Use_Prev_Trig_CHAIN                                            |         0x%01X  |  [RW][04:04]""Use previous DFD Daisy chanied trace and hw assertion ports""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -reg_DFD_EN_Info.Use_Prev_Trace_CHAIN                                           |         0x%01X  |  [RW][08:08]""Use previous DFD Daisy chanied trace and hw assertion ports""\n", FIELD_VALUE(val, 8, 8));
	val = REG_DUMP_READ_REGISTER(0xade80);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_PWR_FEATURE_Info                    |  0x%08X  |  ""Power feature register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_PWR_FEATURE_Info_type */
	/* skip, unused field unused_reg_PWR_FEATURE_Info (reg_PWR_FEATURE_Info) */
	REG_DUMP_PRINT_1("   -reg_PWR_FEATURE_Info.Empty_En                                                  |         0x%01X  |  [RW][00:00]""""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -reg_PWR_FEATURE_Info.MOL_En                                                    |         0x%01X  |  [RW][01:01]""""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0xade78);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_FF_AE_CCM_SENSOR_CFG_2_Info         |  0x%08X  |  ""Sensor Cfg""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_FF_AE_CCM_SENSOR_CFG_2_Info_type */
	/* skip, unused field unused_reg_FF_AE_CCM_SENSOR_CFG_2_Info (reg_FF_AE_CCM_SENSOR_CFG_2_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_SENSOR_CFG_2_Info.Pat_20                                         |         0x%01X  |  [RW][02:00]""Pat""\n", FIELD_VALUE(val, 0, 2));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_SENSOR_CFG_2_Info.Pat_21                                         |         0x%01X  |  [RW][06:04]""Pat""\n", FIELD_VALUE(val, 4, 6));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_SENSOR_CFG_2_Info.Pat_22                                         |         0x%01X  |  [RW][10:08]""Pat""\n", FIELD_VALUE(val, 8, 10));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_SENSOR_CFG_2_Info.Pat_23                                         |         0x%01X  |  [RW][14:12]""Pat""\n", FIELD_VALUE(val, 12, 14));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_SENSOR_CFG_2_Info.Pat_30                                         |         0x%01X  |  [RW][18:16]""Pat""\n", FIELD_VALUE(val, 16, 18));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_SENSOR_CFG_2_Info.Pat_31                                         |         0x%01X  |  [RW][22:20]""Pat""\n", FIELD_VALUE(val, 20, 22));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_SENSOR_CFG_2_Info.Pat_32                                         |         0x%01X  |  [RW][26:24]""Pat""\n", FIELD_VALUE(val, 24, 26));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_SENSOR_CFG_2_Info.Pat_33                                         |         0x%01X  |  [RW][30:28]""Pat""\n", FIELD_VALUE(val, 28, 30));
	val = REG_DUMP_READ_REGISTER(0xade74);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_FF_AE_CCM_SENSOR_CFG_1_Info         |  0x%08X  |  ""Sensor Cfg""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_FF_AE_CCM_SENSOR_CFG_1_Info_type */
	/* skip, unused field unused_reg_FF_AE_CCM_SENSOR_CFG_1_Info (reg_FF_AE_CCM_SENSOR_CFG_1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_SENSOR_CFG_1_Info.Pat_00                                         |         0x%01X  |  [RW][02:00]""Pat""\n", FIELD_VALUE(val, 0, 2));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_SENSOR_CFG_1_Info.Pat_01                                         |         0x%01X  |  [RW][06:04]""Pat""\n", FIELD_VALUE(val, 4, 6));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_SENSOR_CFG_1_Info.Pat_02                                         |         0x%01X  |  [RW][10:08]""Pat""\n", FIELD_VALUE(val, 8, 10));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_SENSOR_CFG_1_Info.Pat_03                                         |         0x%01X  |  [RW][14:12]""Pat""\n", FIELD_VALUE(val, 12, 14));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_SENSOR_CFG_1_Info.Pat_10                                         |         0x%01X  |  [RW][18:16]""Pat""\n", FIELD_VALUE(val, 16, 18));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_SENSOR_CFG_1_Info.Pat_11                                         |         0x%01X  |  [RW][22:20]""Pat""\n", FIELD_VALUE(val, 20, 22));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_SENSOR_CFG_1_Info.Pat_12                                         |         0x%01X  |  [RW][26:24]""Pat""\n", FIELD_VALUE(val, 24, 26));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_SENSOR_CFG_1_Info.Pat_13                                         |         0x%01X  |  [RW][30:28]""Pat""\n", FIELD_VALUE(val, 28, 30));
	val = REG_DUMP_READ_REGISTER(0xade70);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_FF_AE_CCM_SENSOR_CFG_0_Info         |  0x%08X  |  ""Sensor Config""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_FF_AE_CCM_SENSOR_CFG_0_Info_type */
	/* skip, unused field unused_reg_FF_AE_CCM_SENSOR_CFG_0_Info (reg_FF_AE_CCM_SENSOR_CFG_0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_SENSOR_CFG_0_Info.Sensor_mode                                    |         0x%01X  |  [RW][01:00]""Sensor Mode""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_SENSOR_CFG_0_Info.CCM_YCALC_EN                                   |         0x%01X  |  [RW][04:04]""CCM_YCALC_EN""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xade6c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_FF_AE_CCM_Y3_CALC_MAT_COEFF_3_Info  |  0x%08X  |  ""Y3_CALC_COEFF_""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_FF_AE_CCM_Y3_CALC_MAT_COEFF_3_Info_type */
	/* skip, unused field unused_reg_FF_AE_CCM_Y3_CALC_MAT_COEFF_3_Info (reg_FF_AE_CCM_Y3_CALC_MAT_COEFF_3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_Y3_CALC_MAT_COEFF_3_Info.C36                                     |       0x%03X  |  [RW][09:00]""C""\n", FIELD_VALUE(val, 0, 9));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_Y3_CALC_MAT_COEFF_3_Info.C37                                     |       0x%03X  |  [RW][25:16]""C""\n", FIELD_VALUE(val, 16, 25));
	val = REG_DUMP_READ_REGISTER(0xade68);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_FF_AE_CCM_Y3_CALC_MAT_COEFF_2_Info  |  0x%08X  |  ""Y3_CALC_COEFF_2""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_FF_AE_CCM_Y3_CALC_MAT_COEFF_2_Info_type */
	/* skip, unused field unused_reg_FF_AE_CCM_Y3_CALC_MAT_COEFF_2_Info (reg_FF_AE_CCM_Y3_CALC_MAT_COEFF_2_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_Y3_CALC_MAT_COEFF_2_Info.C34                                     |       0x%03X  |  [RW][09:00]""C""\n", FIELD_VALUE(val, 0, 9));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_Y3_CALC_MAT_COEFF_2_Info.C35                                     |       0x%03X  |  [RW][25:16]""C""\n", FIELD_VALUE(val, 16, 25));
	val = REG_DUMP_READ_REGISTER(0xade64);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_FF_AE_CCM_Y3_CALC_MAT_COEFF_1_Info  |  0x%08X  |  ""Y3_CALC_COEFF_1""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_FF_AE_CCM_Y3_CALC_MAT_COEFF_1_Info_type */
	/* skip, unused field unused_reg_FF_AE_CCM_Y3_CALC_MAT_COEFF_1_Info (reg_FF_AE_CCM_Y3_CALC_MAT_COEFF_1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_Y3_CALC_MAT_COEFF_1_Info.C32                                     |       0x%03X  |  [RW][09:00]""C""\n", FIELD_VALUE(val, 0, 9));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_Y3_CALC_MAT_COEFF_1_Info.C33                                     |       0x%03X  |  [RW][25:16]""C""\n", FIELD_VALUE(val, 16, 25));
	val = REG_DUMP_READ_REGISTER(0xade60);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_FF_AE_CCM_Y3_CALC_MAT_COEFF_0_Info  |  0x%08X  |  ""Y3_CALC_COEFF_0""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_FF_AE_CCM_Y3_CALC_MAT_COEFF_0_Info_type */
	/* skip, unused field unused_reg_FF_AE_CCM_Y3_CALC_MAT_COEFF_0_Info (reg_FF_AE_CCM_Y3_CALC_MAT_COEFF_0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_Y3_CALC_MAT_COEFF_0_Info.C30                                     |       0x%03X  |  [RW][09:00]""C""\n", FIELD_VALUE(val, 0, 9));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_Y3_CALC_MAT_COEFF_0_Info.C31                                     |       0x%03X  |  [RW][25:16]""C""\n", FIELD_VALUE(val, 16, 25));
	val = REG_DUMP_READ_REGISTER(0xade5c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_FF_AE_CCM_Y2_CALC_MAT_COEFF_3_Info  |  0x%08X  |  ""Y2_CALC_COEFF_""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_FF_AE_CCM_Y2_CALC_MAT_COEFF_3_Info_type */
	/* skip, unused field unused_reg_FF_AE_CCM_Y2_CALC_MAT_COEFF_3_Info (reg_FF_AE_CCM_Y2_CALC_MAT_COEFF_3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_Y2_CALC_MAT_COEFF_3_Info.C26                                     |       0x%03X  |  [RW][09:00]""C""\n", FIELD_VALUE(val, 0, 9));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_Y2_CALC_MAT_COEFF_3_Info.C27                                     |       0x%03X  |  [RW][25:16]""C""\n", FIELD_VALUE(val, 16, 25));
	val = REG_DUMP_READ_REGISTER(0xade58);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_FF_AE_CCM_Y2_CALC_MAT_COEFF_2_Info  |  0x%08X  |  ""Y2_CALC_COEFF_2""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_FF_AE_CCM_Y2_CALC_MAT_COEFF_2_Info_type */
	/* skip, unused field unused_reg_FF_AE_CCM_Y2_CALC_MAT_COEFF_2_Info (reg_FF_AE_CCM_Y2_CALC_MAT_COEFF_2_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_Y2_CALC_MAT_COEFF_2_Info.C24                                     |       0x%03X  |  [RW][09:00]""C""\n", FIELD_VALUE(val, 0, 9));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_Y2_CALC_MAT_COEFF_2_Info.C25                                     |       0x%03X  |  [RW][25:16]""C""\n", FIELD_VALUE(val, 16, 25));
	val = REG_DUMP_READ_REGISTER(0xade54);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_FF_AE_CCM_Y2_CALC_MAT_COEFF_1_Info  |  0x%08X  |  ""Y2_CALC_COEFF_1""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_FF_AE_CCM_Y2_CALC_MAT_COEFF_1_Info_type */
	/* skip, unused field unused_reg_FF_AE_CCM_Y2_CALC_MAT_COEFF_1_Info (reg_FF_AE_CCM_Y2_CALC_MAT_COEFF_1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_Y2_CALC_MAT_COEFF_1_Info.C22                                     |       0x%03X  |  [RW][09:00]""C""\n", FIELD_VALUE(val, 0, 9));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_Y2_CALC_MAT_COEFF_1_Info.C23                                     |       0x%03X  |  [RW][25:16]""C""\n", FIELD_VALUE(val, 16, 25));
	val = REG_DUMP_READ_REGISTER(0xade50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_FF_AE_CCM_Y2_CALC_MAT_COEFF_0_Info  |  0x%08X  |  ""Y2_CALC_COEFF_0""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_FF_AE_CCM_Y2_CALC_MAT_COEFF_0_Info_type */
	/* skip, unused field unused_reg_FF_AE_CCM_Y2_CALC_MAT_COEFF_0_Info (reg_FF_AE_CCM_Y2_CALC_MAT_COEFF_0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_Y2_CALC_MAT_COEFF_0_Info.C20                                     |       0x%03X  |  [RW][09:00]""C""\n", FIELD_VALUE(val, 0, 9));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_Y2_CALC_MAT_COEFF_0_Info.C21                                     |       0x%03X  |  [RW][25:16]""C""\n", FIELD_VALUE(val, 16, 25));
	val = REG_DUMP_READ_REGISTER(0xade4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_FF_AE_CCM_Y1_CALC_MAT_COEFF_3_Info  |  0x%08X  |  ""Y1_CALC_COEFF_""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_FF_AE_CCM_Y1_CALC_MAT_COEFF_3_Info_type */
	/* skip, unused field unused_reg_FF_AE_CCM_Y1_CALC_MAT_COEFF_3_Info (reg_FF_AE_CCM_Y1_CALC_MAT_COEFF_3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_Y1_CALC_MAT_COEFF_3_Info.C16                                     |       0x%03X  |  [RW][09:00]""C""\n", FIELD_VALUE(val, 0, 9));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_Y1_CALC_MAT_COEFF_3_Info.C17                                     |       0x%03X  |  [RW][25:16]""C""\n", FIELD_VALUE(val, 16, 25));
	val = REG_DUMP_READ_REGISTER(0xade48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_FF_AE_CCM_Y1_CALC_MAT_COEFF_2_Info  |  0x%08X  |  ""Y1_CALC_COEFF_2""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_FF_AE_CCM_Y1_CALC_MAT_COEFF_2_Info_type */
	/* skip, unused field unused_reg_FF_AE_CCM_Y1_CALC_MAT_COEFF_2_Info (reg_FF_AE_CCM_Y1_CALC_MAT_COEFF_2_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_Y1_CALC_MAT_COEFF_2_Info.C14                                     |       0x%03X  |  [RW][09:00]""C""\n", FIELD_VALUE(val, 0, 9));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_Y1_CALC_MAT_COEFF_2_Info.C15                                     |       0x%03X  |  [RW][25:16]""C""\n", FIELD_VALUE(val, 16, 25));
	val = REG_DUMP_READ_REGISTER(0xade44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_FF_AE_CCM_Y1_CALC_MAT_COEFF_1_Info  |  0x%08X  |  ""Y1_CALC_COEFF_1""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_FF_AE_CCM_Y1_CALC_MAT_COEFF_1_Info_type */
	/* skip, unused field unused_reg_FF_AE_CCM_Y1_CALC_MAT_COEFF_1_Info (reg_FF_AE_CCM_Y1_CALC_MAT_COEFF_1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_Y1_CALC_MAT_COEFF_1_Info.C12                                     |       0x%03X  |  [RW][09:00]""C""\n", FIELD_VALUE(val, 0, 9));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_Y1_CALC_MAT_COEFF_1_Info.C13                                     |       0x%03X  |  [RW][25:16]""C""\n", FIELD_VALUE(val, 16, 25));
	val = REG_DUMP_READ_REGISTER(0xade40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_FF_AE_CCM_Y1_CALC_MAT_COEFF_0_Info  |  0x%08X  |  ""Y1_CALC_COEFF_0""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_FF_AE_CCM_Y1_CALC_MAT_COEFF_0_Info_type */
	/* skip, unused field unused_reg_FF_AE_CCM_Y1_CALC_MAT_COEFF_0_Info (reg_FF_AE_CCM_Y1_CALC_MAT_COEFF_0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_Y1_CALC_MAT_COEFF_0_Info.C10                                     |       0x%03X  |  [RW][09:00]""C""\n", FIELD_VALUE(val, 0, 9));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_Y1_CALC_MAT_COEFF_0_Info.C11                                     |       0x%03X  |  [RW][25:16]""C""\n", FIELD_VALUE(val, 16, 25));
	val = REG_DUMP_READ_REGISTER(0xade3c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_FF_AE_CCM_Y0_CALC_MAT_COEFF_3_Info  |  0x%08X  |  ""Y0_CALC_COEFF_""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_FF_AE_CCM_Y0_CALC_MAT_COEFF_3_Info_type */
	/* skip, unused field unused_reg_FF_AE_CCM_Y0_CALC_MAT_COEFF_3_Info (reg_FF_AE_CCM_Y0_CALC_MAT_COEFF_3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_Y0_CALC_MAT_COEFF_3_Info.C06                                     |       0x%03X  |  [RW][09:00]""C""\n", FIELD_VALUE(val, 0, 9));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_Y0_CALC_MAT_COEFF_3_Info.C07                                     |       0x%03X  |  [RW][25:16]""C""\n", FIELD_VALUE(val, 16, 25));
	val = REG_DUMP_READ_REGISTER(0xade38);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_FF_AE_CCM_Y0_CALC_MAT_COEFF_2_Info  |  0x%08X  |  ""Y0_CALC_COEFF_2""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_FF_AE_CCM_Y0_CALC_MAT_COEFF_2_Info_type */
	/* skip, unused field unused_reg_FF_AE_CCM_Y0_CALC_MAT_COEFF_2_Info (reg_FF_AE_CCM_Y0_CALC_MAT_COEFF_2_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_Y0_CALC_MAT_COEFF_2_Info.C04                                     |       0x%03X  |  [RW][09:00]""C""\n", FIELD_VALUE(val, 0, 9));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_Y0_CALC_MAT_COEFF_2_Info.C05                                     |       0x%03X  |  [RW][25:16]""C""\n", FIELD_VALUE(val, 16, 25));
	val = REG_DUMP_READ_REGISTER(0xade34);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_FF_AE_CCM_Y0_CALC_MAT_COEFF_1_Info  |  0x%08X  |  ""Y0_CALC_COEFF_1""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_FF_AE_CCM_Y0_CALC_MAT_COEFF_1_Info_type */
	/* skip, unused field unused_reg_FF_AE_CCM_Y0_CALC_MAT_COEFF_1_Info (reg_FF_AE_CCM_Y0_CALC_MAT_COEFF_1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_Y0_CALC_MAT_COEFF_1_Info.C02                                     |       0x%03X  |  [RW][09:00]""C""\n", FIELD_VALUE(val, 0, 9));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_Y0_CALC_MAT_COEFF_1_Info.C03                                     |       0x%03X  |  [RW][25:16]""C""\n", FIELD_VALUE(val, 16, 25));
	val = REG_DUMP_READ_REGISTER(0xade30);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_FF_AE_CCM_Y0_CALC_MAT_COEFF_0_Info  |  0x%08X  |  ""Y0_CALC_COEFF_0""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_FF_AE_CCM_Y0_CALC_MAT_COEFF_0_Info_type */
	/* skip, unused field unused_reg_FF_AE_CCM_Y0_CALC_MAT_COEFF_0_Info (reg_FF_AE_CCM_Y0_CALC_MAT_COEFF_0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_Y0_CALC_MAT_COEFF_0_Info.C00                                     |       0x%03X  |  [RW][09:00]""C""\n", FIELD_VALUE(val, 0, 9));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_Y0_CALC_MAT_COEFF_0_Info.C01                                     |       0x%03X  |  [RW][25:16]""C""\n", FIELD_VALUE(val, 16, 25));
	val = REG_DUMP_READ_REGISTER(0xade24);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_FF_AE_CCM_CCM_MAT_COEFF_5_Info      |  0x%08X  |  ""MAT_COEFF_5""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_FF_AE_CCM_CCM_MAT_COEFF_5_Info_type */
	/* skip, unused field unused_reg_FF_AE_CCM_CCM_MAT_COEFF_5_Info (reg_FF_AE_CCM_CCM_MAT_COEFF_5_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_CCM_MAT_COEFF_5_Info.M33                                         |       0x%03X  |  [RW][09:00]""M33""\n", FIELD_VALUE(val, 0, 9));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_CCM_MAT_COEFF_5_Info.M34                                         |       0x%03X  |  [RW][25:16]""M34""\n", FIELD_VALUE(val, 16, 25));
	val = REG_DUMP_READ_REGISTER(0xade20);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_FF_AE_CCM_CCM_MAT_COEFF_4_Info      |  0x%08X  |  ""MAT_COEFF_""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_FF_AE_CCM_CCM_MAT_COEFF_4_Info_type */
	/* skip, unused field unused_reg_FF_AE_CCM_CCM_MAT_COEFF_4_Info (reg_FF_AE_CCM_CCM_MAT_COEFF_4_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_CCM_MAT_COEFF_4_Info.M31                                         |       0x%03X  |  [RW][09:00]""M31""\n", FIELD_VALUE(val, 0, 9));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_CCM_MAT_COEFF_4_Info.M32                                         |       0x%03X  |  [RW][25:16]""M32""\n", FIELD_VALUE(val, 16, 25));
	val = REG_DUMP_READ_REGISTER(0xade1c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_FF_AE_CCM_CCM_MAT_COEFF_3_Info      |  0x%08X  |  ""MAT_COEFF_""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_FF_AE_CCM_CCM_MAT_COEFF_3_Info_type */
	/* skip, unused field unused_reg_FF_AE_CCM_CCM_MAT_COEFF_3_Info (reg_FF_AE_CCM_CCM_MAT_COEFF_3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_CCM_MAT_COEFF_3_Info.M23                                         |       0x%03X  |  [RW][09:00]""M23""\n", FIELD_VALUE(val, 0, 9));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_CCM_MAT_COEFF_3_Info.M24                                         |       0x%03X  |  [RW][25:16]""M24""\n", FIELD_VALUE(val, 16, 25));
	val = REG_DUMP_READ_REGISTER(0xade18);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_FF_AE_CCM_CCM_MAT_COEFF_2_Info      |  0x%08X  |  ""MAT_COEFF_""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_FF_AE_CCM_CCM_MAT_COEFF_2_Info_type */
	/* skip, unused field unused_reg_FF_AE_CCM_CCM_MAT_COEFF_2_Info (reg_FF_AE_CCM_CCM_MAT_COEFF_2_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_CCM_MAT_COEFF_2_Info.M21                                         |       0x%03X  |  [RW][09:00]""M21""\n", FIELD_VALUE(val, 0, 9));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_CCM_MAT_COEFF_2_Info.M22                                         |       0x%03X  |  [RW][25:16]""M22""\n", FIELD_VALUE(val, 16, 25));
	val = REG_DUMP_READ_REGISTER(0xade14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_FF_AE_CCM_CCM_MAT_COEFF_1_Info      |  0x%08X  |  ""MAT_COEFF_1""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_FF_AE_CCM_CCM_MAT_COEFF_1_Info_type */
	/* skip, unused field unused_reg_FF_AE_CCM_CCM_MAT_COEFF_1_Info (reg_FF_AE_CCM_CCM_MAT_COEFF_1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_CCM_MAT_COEFF_1_Info.M13                                         |       0x%03X  |  [RW][09:00]""M13""\n", FIELD_VALUE(val, 0, 9));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_CCM_MAT_COEFF_1_Info.M14                                         |       0x%03X  |  [RW][25:16]""M14""\n", FIELD_VALUE(val, 16, 25));
	val = REG_DUMP_READ_REGISTER(0xade10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_FF_AE_CCM_CCM_MAT_COEFF_0_Info      |  0x%08X  |  ""MAT_COEFF_0""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_FF_AE_CCM_CCM_MAT_COEFF_0_Info_type */
	/* skip, unused field unused_reg_FF_AE_CCM_CCM_MAT_COEFF_0_Info (reg_FF_AE_CCM_CCM_MAT_COEFF_0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_CCM_MAT_COEFF_0_Info.M11                                         |       0x%03X  |  [RW][09:00]""M11""\n", FIELD_VALUE(val, 0, 9));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_CCM_MAT_COEFF_0_Info.M12                                         |       0x%03X  |  [RW][25:16]""M12""\n", FIELD_VALUE(val, 16, 25));
	val = REG_DUMP_READ_REGISTER(0xade0c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_FF_AE_CCM_WB_COEFF_3_Info           |  0x%08X  |  ""WB_COEFF_3""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_FF_AE_CCM_WB_COEFF_3_Info_type */
	/* skip, unused field unused_reg_FF_AE_CCM_WB_COEFF_3_Info (reg_FF_AE_CCM_WB_COEFF_3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_WB_COEFF_3_Info.gain_c6                                          |       0x%03X  |  [RW][10:00]""gain_c6""\n", FIELD_VALUE(val, 0, 10));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_WB_COEFF_3_Info.gain_c7                                          |       0x%03X  |  [RW][26:16]""gain_c7""\n", FIELD_VALUE(val, 16, 26));
	val = REG_DUMP_READ_REGISTER(0xade08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_FF_AE_CCM_WB_COEFF_2_Info           |  0x%08X  |  ""WB_COEFF_2""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_FF_AE_CCM_WB_COEFF_2_Info_type */
	/* skip, unused field unused_reg_FF_AE_CCM_WB_COEFF_2_Info (reg_FF_AE_CCM_WB_COEFF_2_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_WB_COEFF_2_Info.gain_c4                                          |       0x%03X  |  [RW][10:00]""gain_c4""\n", FIELD_VALUE(val, 0, 10));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_WB_COEFF_2_Info.gain_c5                                          |       0x%03X  |  [RW][26:16]""gain_c5""\n", FIELD_VALUE(val, 16, 26));
	val = REG_DUMP_READ_REGISTER(0xade04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_FF_AE_CCM_WB_COEFF_1_Info           |  0x%08X  |  ""WB_COEFF_1""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_FF_AE_CCM_WB_COEFF_1_Info_type */
	/* skip, unused field unused_reg_FF_AE_CCM_WB_COEFF_1_Info (reg_FF_AE_CCM_WB_COEFF_1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_WB_COEFF_1_Info.gain_c2                                          |       0x%03X  |  [RW][10:00]""gain_c2""\n", FIELD_VALUE(val, 0, 10));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_WB_COEFF_1_Info.gain_c3                                          |       0x%03X  |  [RW][26:16]""gain_c3""\n", FIELD_VALUE(val, 16, 26));
	val = REG_DUMP_READ_REGISTER(0xade00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM.reg_FF_AE_CCM_WB_COEFF_0_Info           |  0x%08X  |  ""WB_COEFF_0""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM_reg_FF_AE_CCM_WB_COEFF_0_Info_type */
	/* skip, unused field unused_reg_FF_AE_CCM_WB_COEFF_0_Info (reg_FF_AE_CCM_WB_COEFF_0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_WB_COEFF_0_Info.gain_c0                                          |       0x%03X  |  [RW][10:00]""gain_c0""\n", FIELD_VALUE(val, 0, 10));
	REG_DUMP_PRINT_1("   -reg_FF_AE_CCM_WB_COEFF_0_Info.gain_c1                                          |       0x%03X  |  [RW][26:16]""gain_c1""\n", FIELD_VALUE(val, 16, 26));
} /* end isa_isa_logic_ISA_Cluster_Stat_AE_AE_CCM */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Stat_AE_AckConv */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Stat_AE_AckConv(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xadc04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AckConv.reg_Ack_Addr_Info  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AckConv_reg_Ack_Addr_Info_type */
	REG_DUMP_PRINT_1("   -reg_Ack_Addr_Info.reg_Ack_Addr_Info                        |  0x%08X  |  [RW][31:00]""Ack Addr iNFO register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xadc00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_AckConv.reg_Ack_Cmd_Info   |  0x%08X  |  ""Ack cMD iNFO register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_AckConv_reg_Ack_Cmd_Info_type */
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.Message                                   |     0x%05X  |  [RW][18:00]""""\n", FIELD_VALUE(val, 0, 18));
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.CMD                                       |         0x%01X  |  [RO][19:19]""""\n", FIELD_VALUE(val, 19, 19));
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.PID                                       |        0x%02X  |  [RW][25:20]""""\n", FIELD_VALUE(val, 20, 25));
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.SID                                       |        0x%02X  |  [RW][31:26]""""\n", FIELD_VALUE(val, 26, 31));
} /* end isa_isa_logic_ISA_Cluster_Stat_AE_AckConv */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xad1fc);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist.ae_glb_hist_c7_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist_ae_glb_hist_c7_last_type */
	REG_DUMP_PRINT_1("   -ae_glb_hist_c7_last.ae_glb_hist_c7_last                                         |  0x%08X  |  [RW][31:00]""AE_GLB_HIST_C7""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xace00);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist.ae_glb_hist_c7_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist_ae_glb_hist_c7_first_type */
	REG_DUMP_PRINT_1("   -ae_glb_hist_c7_first.ae_glb_hist_c7_first                                       |  0x%08X  |  [RW][31:00]""AE_GLB_HIST_C7""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xacdfc);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist.ae_glb_hist_c6_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist_ae_glb_hist_c6_last_type */
	REG_DUMP_PRINT_1("   -ae_glb_hist_c6_last.ae_glb_hist_c6_last                                         |  0x%08X  |  [RW][31:00]""AE_GLB_HIST_C6""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xaca00);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist.ae_glb_hist_c6_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist_ae_glb_hist_c6_first_type */
	REG_DUMP_PRINT_1("   -ae_glb_hist_c6_first.ae_glb_hist_c6_first                                       |  0x%08X  |  [RW][31:00]""AE_GLB_HIST_C6""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xac9fc);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist.ae_glb_hist_c5_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist_ae_glb_hist_c5_last_type */
	REG_DUMP_PRINT_1("   -ae_glb_hist_c5_last.ae_glb_hist_c5_last                                         |  0x%08X  |  [RW][31:00]""AE_GLB_HIST_C5""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xac600);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist.ae_glb_hist_c5_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist_ae_glb_hist_c5_first_type */
	REG_DUMP_PRINT_1("   -ae_glb_hist_c5_first.ae_glb_hist_c5_first                                       |  0x%08X  |  [RW][31:00]""AE_GLB_HIST_C5""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xac5fc);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist.ae_glb_hist_c4_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist_ae_glb_hist_c4_last_type */
	REG_DUMP_PRINT_1("   -ae_glb_hist_c4_last.ae_glb_hist_c4_last                                         |  0x%08X  |  [RW][31:00]""AE_GLB_HIST_C4""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xac200);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist.ae_glb_hist_c4_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist_ae_glb_hist_c4_first_type */
	REG_DUMP_PRINT_1("   -ae_glb_hist_c4_first.ae_glb_hist_c4_first                                       |  0x%08X  |  [RW][31:00]""AE_GLB_HIST_C4""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xac1fc);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist.ae_glb_hist_c3_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist_ae_glb_hist_c3_last_type */
	REG_DUMP_PRINT_1("   -ae_glb_hist_c3_last.ae_glb_hist_c3_last                                         |  0x%08X  |  [RW][31:00]""AE_GLB_HIST_C3""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xabe00);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist.ae_glb_hist_c3_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist_ae_glb_hist_c3_first_type */
	REG_DUMP_PRINT_1("   -ae_glb_hist_c3_first.ae_glb_hist_c3_first                                       |  0x%08X  |  [RW][31:00]""AE_GLB_HIST_C3""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xabdfc);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist.ae_glb_hist_c2_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist_ae_glb_hist_c2_last_type */
	REG_DUMP_PRINT_1("   -ae_glb_hist_c2_last.ae_glb_hist_c2_last                                         |  0x%08X  |  [RW][31:00]""AE_GLB_HIST_C2""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xaba00);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist.ae_glb_hist_c2_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist_ae_glb_hist_c2_first_type */
	REG_DUMP_PRINT_1("   -ae_glb_hist_c2_first.ae_glb_hist_c2_first                                       |  0x%08X  |  [RW][31:00]""AE_GLB_HIST_C2""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xab9fc);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist.ae_glb_hist_c1_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist_ae_glb_hist_c1_last_type */
	REG_DUMP_PRINT_1("   -ae_glb_hist_c1_last.ae_glb_hist_c1_last                                         |  0x%08X  |  [RW][31:00]""AE_GLB_HIST_C1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xab600);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist.ae_glb_hist_c1_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist_ae_glb_hist_c1_first_type */
	REG_DUMP_PRINT_1("   -ae_glb_hist_c1_first.ae_glb_hist_c1_first                                       |  0x%08X  |  [RW][31:00]""AE_GLB_HIST_C1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xab5fc);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist.ae_glb_hist_c0_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist_ae_glb_hist_c0_last_type */
	REG_DUMP_PRINT_1("   -ae_glb_hist_c0_last.ae_glb_hist_c0_last                                         |  0x%08X  |  [RW][31:00]""AE_GLB_HIST_C0""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xab200);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist.ae_glb_hist_c0_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist_ae_glb_hist_c0_first_type */
	REG_DUMP_PRINT_1("   -ae_glb_hist_c0_first.ae_glb_hist_c0_first                                       |  0x%08X  |  [RW][31:00]""AE_GLB_HIST_C0""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_hist */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xab1fc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST.reg_PWR_FEATURE_Info               |  0x%08X  |  ""Power feature register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_reg_PWR_FEATURE_Info_type */
	/* skip, unused field unused_reg_PWR_FEATURE_Info (reg_PWR_FEATURE_Info) */
	REG_DUMP_PRINT_1("   -reg_PWR_FEATURE_Info.Empty_En                                                |         0x%01X  |  [RW][00:00]""""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -reg_PWR_FEATURE_Info.MOL_En                                                  |         0x%01X  |  [RW][01:01]""""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0xab1bc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST.reg_HW_ASSR_RAW_STAT_Info          |  0x%08X  |  ""events that took place not gated with the mask register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_reg_HW_ASSR_RAW_STAT_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_RAW_STAT_Info (reg_HW_ASSR_RAW_STAT_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_RAW_STAT_Info.STAT                                               |         0x%01X  |  [RO][03:00]""hw assertion raw status""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xab1b8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST.reg_HW_ASSR_STAT_Info              |  0x%08X  |  ""events that took place after gated with the mask register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_reg_HW_ASSR_STAT_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_STAT_Info (reg_HW_ASSR_STAT_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_STAT_Info.STAT                                                   |         0x%01X  |  [RO][03:00]""hw_assertion status""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xab1b4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST.reg_HW_ASSR_MASK_Info              |  0x%08X  |  ""hw assertion mask - note status reflects masks assertions as well""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_reg_HW_ASSR_MASK_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_MASK_Info (reg_HW_ASSR_MASK_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_MASK_Info.MASK                                                   |         0x%01X  |  [RW][03:00]""mask hw assertion bmp""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xab1b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST.reg_HW_ASSR_CLEAR_Info             |  0x%08X  |  ""clear latched event from status register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_reg_HW_ASSR_CLEAR_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_CLEAR_Info (reg_HW_ASSR_CLEAR_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_CLEAR_Info.CLEAR                                                 |         0x%01X  |  [RW][03:00]""clear hw_assertion""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xab1ac);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST.reg_DFD_DATA_READ_CMD_Info         |  0x%08X  |  ""DFD read traced data register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_reg_DFD_DATA_READ_CMD_Info_type */
	/* skip, unused field unused_reg_DFD_DATA_READ_CMD_Info (reg_DFD_DATA_READ_CMD_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_DATA_READ_CMD_Info.Fetch                                             |         0x%01X  |  [RW][00:00]""DFD read traced data register""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xab1a8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST.reg_DFD_DATA_READ_COMPLETION_Info  |  0x%08X  |  ""DFD data out from egress Fifo read completion indication""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_reg_DFD_DATA_READ_COMPLETION_Info_type */
	/* skip, unused field unused_reg_DFD_DATA_READ_COMPLETION_Info (reg_DFD_DATA_READ_COMPLETION_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_DATA_READ_COMPLETION_Info.Rd_Comp                                    |         0x%01X  |  [RO][00:00]""DFD traced data out from egress Fifo read completion indication""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xab1a4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST.reg_DFD_TRACED_DATA_VALID_Info     |  0x%08X  |  ""DFD traced data Valid""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_reg_DFD_TRACED_DATA_VALID_Info_type */
	/* skip, unused field unused_reg_DFD_TRACED_DATA_VALID_Info (reg_DFD_TRACED_DATA_VALID_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_TRACED_DATA_VALID_Info.Data_Valid                                    |         0x%01X  |  [RO][00:00]""DFD Data VALID""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xab1a0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST.reg_DFD_TRACED_DATA_Info           |  0x%08X  |  ""DFD traced data out from egress Fifo - double pixel aligned""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_reg_DFD_TRACED_DATA_Info_type */
	REG_DUMP_PRINT_1("   -reg_DFD_TRACED_DATA_Info.Dfd_Traced_Data                                     |  0x%08X  |  [RO][31:00]""DFD traced data out from egress Fifo - double pixel aligned.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xab19c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST.reg_DFD_SINGLE_STEP_Info           |  0x%08X  |  ""Enable FF egress for a single transaction when at DFD post trigger state""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_reg_DFD_SINGLE_STEP_Info_type */
	/* skip, unused field unused_reg_DFD_SINGLE_STEP_Info (reg_DFD_SINGLE_STEP_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_SINGLE_STEP_Info.Single_Step                                         |         0x%01X  |  [RW][00:00]""Enable FF egress for a single transaction when at DFD post trigger state.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xab198);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST.reg_DFD_EN_Info                    |  0x%08X  |  ""Enable DFD feature. React to acb dfdaction command""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_reg_DFD_EN_Info_type */
	/* skip, unused field unused_reg_DFD_EN_Info (reg_DFD_EN_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_EN_Info.Dfd_En                                                       |         0x%01X  |  [RW][00:00]""Enable DFD feature. React to acb dfdaction command""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -reg_DFD_EN_Info.Use_Prev_Trig_CHAIN                                          |         0x%01X  |  [RW][04:04]""Use previous DFD Daisy chanied trace and hw assertion ports""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -reg_DFD_EN_Info.Use_Prev_Trace_CHAIN                                         |         0x%01X  |  [RW][08:08]""Use previous DFD Daisy chanied trace and hw assertion ports""\n", FIELD_VALUE(val, 8, 8));
	val = REG_DUMP_READ_REGISTER(0xab194);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST.reg_FF_AE_SENSOR_CFG_2_Info        |  0x%08X  |  ""Sensor Cfg""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_reg_FF_AE_SENSOR_CFG_2_Info_type */
	/* skip, unused field unused_reg_FF_AE_SENSOR_CFG_2_Info (reg_FF_AE_SENSOR_CFG_2_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_SENSOR_CFG_2_Info.Pat_20                                           |         0x%01X  |  [RW][02:00]""Pat""\n", FIELD_VALUE(val, 0, 2));
	REG_DUMP_PRINT_1("   -reg_FF_AE_SENSOR_CFG_2_Info.Pat_21                                           |         0x%01X  |  [RW][06:04]""Pat""\n", FIELD_VALUE(val, 4, 6));
	REG_DUMP_PRINT_1("   -reg_FF_AE_SENSOR_CFG_2_Info.Pat_22                                           |         0x%01X  |  [RW][10:08]""Pat""\n", FIELD_VALUE(val, 8, 10));
	REG_DUMP_PRINT_1("   -reg_FF_AE_SENSOR_CFG_2_Info.Pat_23                                           |         0x%01X  |  [RW][14:12]""Pat""\n", FIELD_VALUE(val, 12, 14));
	REG_DUMP_PRINT_1("   -reg_FF_AE_SENSOR_CFG_2_Info.Pat_30                                           |         0x%01X  |  [RW][18:16]""Pat""\n", FIELD_VALUE(val, 16, 18));
	REG_DUMP_PRINT_1("   -reg_FF_AE_SENSOR_CFG_2_Info.Pat_31                                           |         0x%01X  |  [RW][22:20]""Pat""\n", FIELD_VALUE(val, 20, 22));
	REG_DUMP_PRINT_1("   -reg_FF_AE_SENSOR_CFG_2_Info.Pat_32                                           |         0x%01X  |  [RW][26:24]""Pat""\n", FIELD_VALUE(val, 24, 26));
	REG_DUMP_PRINT_1("   -reg_FF_AE_SENSOR_CFG_2_Info.Pat_33                                           |         0x%01X  |  [RW][30:28]""Pat""\n", FIELD_VALUE(val, 28, 30));
	val = REG_DUMP_READ_REGISTER(0xab190);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST.reg_FF_AE_SENSOR_CFG_1_Info        |  0x%08X  |  ""Sensor Cfg""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_reg_FF_AE_SENSOR_CFG_1_Info_type */
	/* skip, unused field unused_reg_FF_AE_SENSOR_CFG_1_Info (reg_FF_AE_SENSOR_CFG_1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_SENSOR_CFG_1_Info.Pat_00                                           |         0x%01X  |  [RW][02:00]""Pat""\n", FIELD_VALUE(val, 0, 2));
	REG_DUMP_PRINT_1("   -reg_FF_AE_SENSOR_CFG_1_Info.Pat_01                                           |         0x%01X  |  [RW][06:04]""Pat""\n", FIELD_VALUE(val, 4, 6));
	REG_DUMP_PRINT_1("   -reg_FF_AE_SENSOR_CFG_1_Info.Pat_02                                           |         0x%01X  |  [RW][10:08]""Pat""\n", FIELD_VALUE(val, 8, 10));
	REG_DUMP_PRINT_1("   -reg_FF_AE_SENSOR_CFG_1_Info.Pat_03                                           |         0x%01X  |  [RW][14:12]""Pat""\n", FIELD_VALUE(val, 12, 14));
	REG_DUMP_PRINT_1("   -reg_FF_AE_SENSOR_CFG_1_Info.Pat_10                                           |         0x%01X  |  [RW][18:16]""Pat""\n", FIELD_VALUE(val, 16, 18));
	REG_DUMP_PRINT_1("   -reg_FF_AE_SENSOR_CFG_1_Info.Pat_11                                           |         0x%01X  |  [RW][22:20]""Pat""\n", FIELD_VALUE(val, 20, 22));
	REG_DUMP_PRINT_1("   -reg_FF_AE_SENSOR_CFG_1_Info.Pat_12                                           |         0x%01X  |  [RW][26:24]""Pat""\n", FIELD_VALUE(val, 24, 26));
	REG_DUMP_PRINT_1("   -reg_FF_AE_SENSOR_CFG_1_Info.Pat_13                                           |         0x%01X  |  [RW][30:28]""Pat""\n", FIELD_VALUE(val, 28, 30));
	val = REG_DUMP_READ_REGISTER(0xab18c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST.reg_FF_AE_SENSOR_CFG_0_Info        |  0x%08X  |  ""Sensor Config""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_reg_FF_AE_SENSOR_CFG_0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_AE_SENSOR_CFG_0_Info.Sensor_mode                                      |         0x%01X  |  [RW][01:00]""Sensor Mode ""\n", FIELD_VALUE(val, 0, 1));
	/* skip, WO field Dummy */
	val = REG_DUMP_READ_REGISTER(0xab188);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST.reg_FF_AE_GLB_HIST_GRD_END_Info    |  0x%08X  |  ""Global Histogram Cfg""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_reg_FF_AE_GLB_HIST_GRD_END_Info_type */
	/* skip, unused field unused_reg_FF_AE_GLB_HIST_GRD_END_Info (reg_FF_AE_GLB_HIST_GRD_END_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_GLB_HIST_GRD_END_Info.x_end                                        |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_AE_GLB_HIST_GRD_END_Info.y_end                                        |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xab184);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST.reg_FF_AE_GLB_HIST_GRD_OFFST_Info  |  0x%08X  |  ""Global Histogram Cfg""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_reg_FF_AE_GLB_HIST_GRD_OFFST_Info_type */
	/* skip, unused field unused_reg_FF_AE_GLB_HIST_GRD_OFFST_Info (reg_FF_AE_GLB_HIST_GRD_OFFST_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_AE_GLB_HIST_GRD_OFFST_Info.x_start                                    |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_AE_GLB_HIST_GRD_OFFST_Info.y_start                                    |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xab180);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST.reg_FF_AE_GLB_HIST_GRD_CFG_Info    |  0x%08X  |  ""Global Histogram Cfg""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_reg_FF_AE_GLB_HIST_GRD_CFG_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_AE_GLB_HIST_GRD_CFG_Info.grid_width                                   |        0x%02X  |  [RW][07:00]""""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -reg_FF_AE_GLB_HIST_GRD_CFG_Info.grid_height                                  |        0x%02X  |  [RW][15:08]""""\n", FIELD_VALUE(val, 8, 15));
	REG_DUMP_PRINT_1("   -reg_FF_AE_GLB_HIST_GRD_CFG_Info.block_width                                  |         0x%01X  |  [RW][19:16]""""\n", FIELD_VALUE(val, 16, 19));
	REG_DUMP_PRINT_1("   -reg_FF_AE_GLB_HIST_GRD_CFG_Info.block_height                                 |         0x%01X  |  [RW][23:20]""""\n", FIELD_VALUE(val, 20, 23));
	REG_DUMP_PRINT_1("   -reg_FF_AE_GLB_HIST_GRD_CFG_Info.AE_EN                                        |         0x%01X  |  [RW][29:29]""""\n", FIELD_VALUE(val, 29, 29));
	/* skip, WO field rst_hist_array */
	REG_DUMP_PRINT_1("   -reg_FF_AE_GLB_HIST_GRD_CFG_Info.done_rst_hist_array                          |         0x%01X  |  [RO][31:31]""""\n", FIELD_VALUE(val, 31, 31));
} /* end isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_lut */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_lut(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xab17c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_lut.ae_weight_grid_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_lut_ae_weight_grid_last_type */
	REG_DUMP_PRINT_1("   -ae_weight_grid_last.ae_weight_grid_last                                        |  0x%08X  |  [RW][31:00]""AE_WEIGHT_GRD""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xab000);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_lut.ae_weight_grid_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_lut_ae_weight_grid_first_type */
	REG_DUMP_PRINT_1("   -ae_weight_grid_first.ae_weight_grid_first                                      |  0x%08X  |  [RW][31:00]""AE_WEIGHT_GRD""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Stat_AE_WGHT_HIST_ff_ae_hist_lut */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Bayer_Scaler_AckConv */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Bayer_Scaler_AckConv(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xaa804);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_AckConv.reg_Ack_Addr_Info  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_AckConv_reg_Ack_Addr_Info_type */
	REG_DUMP_PRINT_1("   -reg_Ack_Addr_Info.reg_Ack_Addr_Info                             |  0x%08X  |  [RW][31:00]""Ack Addr iNFO register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xaa800);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_AckConv.reg_Ack_Cmd_Info   |  0x%08X  |  ""Ack cMD iNFO register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_AckConv_reg_Ack_Cmd_Info_type */
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.Message                                        |     0x%05X  |  [RW][18:00]""""\n", FIELD_VALUE(val, 0, 18));
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.CMD                                            |         0x%01X  |  [RO][19:19]""""\n", FIELD_VALUE(val, 19, 19));
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.PID                                            |        0x%02X  |  [RW][25:20]""""\n", FIELD_VALUE(val, 20, 25));
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.SID                                            |        0x%02X  |  [RW][31:26]""""\n", FIELD_VALUE(val, 26, 31));
} /* end isa_isa_logic_ISA_Cluster_Bayer_Scaler_AckConv */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa7294);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_CSC_T1_Info                                   |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_CSC_T1_Info_type */
	/* skip, unused field unused_reg_CSC_T1_Info (reg_CSC_T1_Info) */
	REG_DUMP_PRINT_1("   -reg_CSC_T1_Info.T2                                                                            |      0x%04X  |  [RW][15:00]""CSC matrix offset""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xa7290);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_CSC_T0_Info                                   |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_CSC_T0_Info_type */
	REG_DUMP_PRINT_1("   -reg_CSC_T0_Info.T0                                                                            |      0x%04X  |  [RW][15:00]""CSC matrix offset""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_CSC_T0_Info.T1                                                                            |      0x%04X  |  [RW][31:16]""CSC matrix offset""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xa728c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_CSC_COEF5_Info                                |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_CSC_COEF5_Info_type */
	/* skip, unused field unused_reg_CSC_COEF5_Info (reg_CSC_COEF5_Info) */
	REG_DUMP_PRINT_1("   -reg_CSC_COEF5_Info.C22                                                                        |       0x%03X  |  [RW][10:00]""CSC matrix coef""\n", FIELD_VALUE(val, 0, 10));
	REG_DUMP_PRINT_1("   -reg_CSC_COEF5_Info.C23                                                                        |       0x%03X  |  [RW][26:16]""CSC matrix coef""\n", FIELD_VALUE(val, 16, 26));
	val = REG_DUMP_READ_REGISTER(0xa7288);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_CSC_COEF4_Info                                |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_CSC_COEF4_Info_type */
	/* skip, unused field unused_reg_CSC_COEF4_Info (reg_CSC_COEF4_Info) */
	REG_DUMP_PRINT_1("   -reg_CSC_COEF4_Info.C20                                                                        |       0x%03X  |  [RW][10:00]""CSC matrix coef""\n", FIELD_VALUE(val, 0, 10));
	REG_DUMP_PRINT_1("   -reg_CSC_COEF4_Info.C21                                                                        |       0x%03X  |  [RW][26:16]""CSC matrix coef""\n", FIELD_VALUE(val, 16, 26));
	val = REG_DUMP_READ_REGISTER(0xa7284);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_CSC_COEF3_Info                                |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_CSC_COEF3_Info_type */
	/* skip, unused field unused_reg_CSC_COEF3_Info (reg_CSC_COEF3_Info) */
	REG_DUMP_PRINT_1("   -reg_CSC_COEF3_Info.C12                                                                        |       0x%03X  |  [RW][10:00]""CSC matrix coef""\n", FIELD_VALUE(val, 0, 10));
	REG_DUMP_PRINT_1("   -reg_CSC_COEF3_Info.C13                                                                        |       0x%03X  |  [RW][26:16]""CSC matrix coef""\n", FIELD_VALUE(val, 16, 26));
	val = REG_DUMP_READ_REGISTER(0xa7280);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_CSC_COEF2_Info                                |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_CSC_COEF2_Info_type */
	/* skip, unused field unused_reg_CSC_COEF2_Info (reg_CSC_COEF2_Info) */
	REG_DUMP_PRINT_1("   -reg_CSC_COEF2_Info.C10                                                                        |       0x%03X  |  [RW][10:00]""CSC matrix coef""\n", FIELD_VALUE(val, 0, 10));
	REG_DUMP_PRINT_1("   -reg_CSC_COEF2_Info.C11                                                                        |       0x%03X  |  [RW][26:16]""CSC matrix coef""\n", FIELD_VALUE(val, 16, 26));
	val = REG_DUMP_READ_REGISTER(0xa727c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_CSC_COEF1_Info                                |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_CSC_COEF1_Info_type */
	/* skip, unused field unused_reg_CSC_COEF1_Info (reg_CSC_COEF1_Info) */
	REG_DUMP_PRINT_1("   -reg_CSC_COEF1_Info.C02                                                                        |       0x%03X  |  [RW][10:00]""CSC matrix coef""\n", FIELD_VALUE(val, 0, 10));
	REG_DUMP_PRINT_1("   -reg_CSC_COEF1_Info.C03                                                                        |       0x%03X  |  [RW][26:16]""CSC matrix coef""\n", FIELD_VALUE(val, 16, 26));
	val = REG_DUMP_READ_REGISTER(0xa7278);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_CSC_COEF0_Info                                |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_CSC_COEF0_Info_type */
	/* skip, unused field unused_reg_CSC_COEF0_Info (reg_CSC_COEF0_Info) */
	REG_DUMP_PRINT_1("   -reg_CSC_COEF0_Info.C00                                                                        |       0x%03X  |  [RW][10:00]""CSC matrix coef""\n", FIELD_VALUE(val, 0, 10));
	REG_DUMP_PRINT_1("   -reg_CSC_COEF0_Info.C01                                                                        |       0x%03X  |  [RW][26:16]""CSC matrix coef""\n", FIELD_VALUE(val, 16, 26));
	val = REG_DUMP_READ_REGISTER(0xa7274);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_VCSC_CONFIG_Info                              |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_VCSC_CONFIG_Info_type */
	/* skip, unused field unused_reg_VCSC_CONFIG_Info (reg_VCSC_CONFIG_Info) */
	REG_DUMP_PRINT_1("   -reg_VCSC_CONFIG_Info.mode_select                                                              |         0x%01X  |  [RW][00:00]""Global output mode: 0-Bayer 1-YUV""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -reg_VCSC_CONFIG_Info.CSC_gain                                                                 |         0x%01X  |  [RW][04:02]""CSC Matrix gain""\n", FIELD_VALUE(val, 2, 4));
	REG_DUMP_PRINT_1("   -reg_VCSC_CONFIG_Info.FIR_alpha_h                                                              |       0x%03X  |  [RW][16:06]""Hor FIR coeff""\n", FIELD_VALUE(val, 6, 16));
	REG_DUMP_PRINT_1("   -reg_VCSC_CONFIG_Info.FIR_alpha_v                                                              |       0x%03X  |  [RW][27:17]""Ver FIR coeff""\n", FIELD_VALUE(val, 17, 27));
	val = REG_DUMP_READ_REGISTER(0xa7270);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_INVX_CU_B_SLOPES_6_Info             |  0x%08X  |  ""slopes for linearization""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_INVX_CU_B_SLOPES_6_Info_type */
	/* skip, unused field unused_reg_SCALER_DM_INVX_CU_B_SLOPES_6_Info (reg_SCALER_DM_INVX_CU_B_SLOPES_6_Info) */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_B_SLOPES_6_Info.m_cu_B_slopes_10                                        |       0x%03X  |  [RW][11:00]""""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xa726c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_INVX_CU_B_SLOPES_5_Info             |  0x%08X  |  ""slopes for linearization""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_INVX_CU_B_SLOPES_5_Info_type */
	/* skip, unused field unused_reg_SCALER_DM_INVX_CU_B_SLOPES_5_Info (reg_SCALER_DM_INVX_CU_B_SLOPES_5_Info) */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_B_SLOPES_5_Info.m_cu_B_slopes_8                                         |       0x%03X  |  [RW][11:00]""""\n", FIELD_VALUE(val, 0, 11));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_B_SLOPES_5_Info.m_cu_B_slopes_9                                         |       0x%03X  |  [RW][23:12]""""\n", FIELD_VALUE(val, 12, 23));
	val = REG_DUMP_READ_REGISTER(0xa7268);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_INVX_CU_B_SLOPES_4_Info             |  0x%08X  |  ""slopes for linearization""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_INVX_CU_B_SLOPES_4_Info_type */
	/* skip, unused field unused_reg_SCALER_DM_INVX_CU_B_SLOPES_4_Info (reg_SCALER_DM_INVX_CU_B_SLOPES_4_Info) */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_B_SLOPES_4_Info.m_cu_B_slopes_6                                         |       0x%03X  |  [RW][11:00]""""\n", FIELD_VALUE(val, 0, 11));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_B_SLOPES_4_Info.m_cu_B_slopes_7                                         |       0x%03X  |  [RW][23:12]""""\n", FIELD_VALUE(val, 12, 23));
	val = REG_DUMP_READ_REGISTER(0xa7264);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_INVX_CU_B_SLOPES_3_Info             |  0x%08X  |  ""slopes for linearization""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_INVX_CU_B_SLOPES_3_Info_type */
	/* skip, unused field unused_reg_SCALER_DM_INVX_CU_B_SLOPES_3_Info (reg_SCALER_DM_INVX_CU_B_SLOPES_3_Info) */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_B_SLOPES_3_Info.m_cu_B_slopes_4                                         |       0x%03X  |  [RW][11:00]""""\n", FIELD_VALUE(val, 0, 11));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_B_SLOPES_3_Info.m_cu_B_slopes_5                                         |       0x%03X  |  [RW][23:12]""""\n", FIELD_VALUE(val, 12, 23));
	val = REG_DUMP_READ_REGISTER(0xa7260);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_INVX_CU_B_SLOPES_2_Info             |  0x%08X  |  ""slopes for linearization""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_INVX_CU_B_SLOPES_2_Info_type */
	/* skip, unused field unused_reg_SCALER_DM_INVX_CU_B_SLOPES_2_Info (reg_SCALER_DM_INVX_CU_B_SLOPES_2_Info) */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_B_SLOPES_2_Info.m_cu_B_slopes_2                                         |       0x%03X  |  [RW][11:00]""""\n", FIELD_VALUE(val, 0, 11));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_B_SLOPES_2_Info.m_cu_B_slopes_3                                         |       0x%03X  |  [RW][23:12]""""\n", FIELD_VALUE(val, 12, 23));
	val = REG_DUMP_READ_REGISTER(0xa725c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_INVX_CU_B_SLOPES_1_Info             |  0x%08X  |  ""slopes for linearization""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_INVX_CU_B_SLOPES_1_Info_type */
	/* skip, unused field unused_reg_SCALER_DM_INVX_CU_B_SLOPES_1_Info (reg_SCALER_DM_INVX_CU_B_SLOPES_1_Info) */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_B_SLOPES_1_Info.m_cu_B_slopes_0                                         |       0x%03X  |  [RW][11:00]""""\n", FIELD_VALUE(val, 0, 11));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_B_SLOPES_1_Info.m_cu_B_slopes_1                                         |       0x%03X  |  [RW][23:12]""""\n", FIELD_VALUE(val, 12, 23));
	val = REG_DUMP_READ_REGISTER(0xa7258);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_INVX_CU_A_SLOPES_6_Info             |  0x%08X  |  ""slopes for linearization""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_INVX_CU_A_SLOPES_6_Info_type */
	/* skip, unused field unused_reg_SCALER_DM_INVX_CU_A_SLOPES_6_Info (reg_SCALER_DM_INVX_CU_A_SLOPES_6_Info) */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_A_SLOPES_6_Info.m_cu_A_slopes_10                                        |       0x%03X  |  [RW][11:00]""""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xa7254);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_INVX_CU_A_SLOPES_5_Info             |  0x%08X  |  ""slopes for linearization""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_INVX_CU_A_SLOPES_5_Info_type */
	/* skip, unused field unused_reg_SCALER_DM_INVX_CU_A_SLOPES_5_Info (reg_SCALER_DM_INVX_CU_A_SLOPES_5_Info) */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_A_SLOPES_5_Info.m_cu_A_slopes_8                                         |       0x%03X  |  [RW][11:00]""""\n", FIELD_VALUE(val, 0, 11));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_A_SLOPES_5_Info.m_cu_A_slopes_9                                         |       0x%03X  |  [RW][23:12]""""\n", FIELD_VALUE(val, 12, 23));
	val = REG_DUMP_READ_REGISTER(0xa7250);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_INVX_CU_A_SLOPES_4_Info             |  0x%08X  |  ""slopes for linearization""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_INVX_CU_A_SLOPES_4_Info_type */
	/* skip, unused field unused_reg_SCALER_DM_INVX_CU_A_SLOPES_4_Info (reg_SCALER_DM_INVX_CU_A_SLOPES_4_Info) */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_A_SLOPES_4_Info.m_cu_A_slopes_6                                         |       0x%03X  |  [RW][11:00]""""\n", FIELD_VALUE(val, 0, 11));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_A_SLOPES_4_Info.m_cu_A_slopes_7                                         |       0x%03X  |  [RW][23:12]""""\n", FIELD_VALUE(val, 12, 23));
	val = REG_DUMP_READ_REGISTER(0xa724c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_INVX_CU_A_SLOPES_3_Info             |  0x%08X  |  ""slopes for linearization""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_INVX_CU_A_SLOPES_3_Info_type */
	/* skip, unused field unused_reg_SCALER_DM_INVX_CU_A_SLOPES_3_Info (reg_SCALER_DM_INVX_CU_A_SLOPES_3_Info) */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_A_SLOPES_3_Info.m_cu_A_slopes_4                                         |       0x%03X  |  [RW][11:00]""""\n", FIELD_VALUE(val, 0, 11));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_A_SLOPES_3_Info.m_cu_A_slopes_5                                         |       0x%03X  |  [RW][23:12]""""\n", FIELD_VALUE(val, 12, 23));
	val = REG_DUMP_READ_REGISTER(0xa7248);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_INVX_CU_A_SLOPES_2_Info             |  0x%08X  |  ""slopes for linearization""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_INVX_CU_A_SLOPES_2_Info_type */
	/* skip, unused field unused_reg_SCALER_DM_INVX_CU_A_SLOPES_2_Info (reg_SCALER_DM_INVX_CU_A_SLOPES_2_Info) */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_A_SLOPES_2_Info.m_cu_A_slopes_2                                         |       0x%03X  |  [RW][11:00]""""\n", FIELD_VALUE(val, 0, 11));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_A_SLOPES_2_Info.m_cu_A_slopes_3                                         |       0x%03X  |  [RW][23:12]""""\n", FIELD_VALUE(val, 12, 23));
	val = REG_DUMP_READ_REGISTER(0xa7244);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_INVX_CU_A_SLOPES_1_Info             |  0x%08X  |  ""slopes for linearization""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_INVX_CU_A_SLOPES_1_Info_type */
	/* skip, unused field unused_reg_SCALER_DM_INVX_CU_A_SLOPES_1_Info (reg_SCALER_DM_INVX_CU_A_SLOPES_1_Info) */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_A_SLOPES_1_Info.m_cu_A_slopes_0                                         |       0x%03X  |  [RW][11:00]""""\n", FIELD_VALUE(val, 0, 11));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_A_SLOPES_1_Info.m_cu_A_slopes_1                                         |       0x%03X  |  [RW][23:12]""""\n", FIELD_VALUE(val, 12, 23));
	val = REG_DUMP_READ_REGISTER(0xa7240);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_INVX_CU_N_POINTS_6_Info             |  0x%08X  |  ""points for linearization""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_INVX_CU_N_POINTS_6_Info_type */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_N_POINTS_6_Info.m_cu_n_points_10                                        |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_N_POINTS_6_Info.m_cu_n_points_11                                        |      0x%04X  |  [RW][31:16]""""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xa723c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_INVX_CU_N_POINTS_5_Info             |  0x%08X  |  ""points for linearization""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_INVX_CU_N_POINTS_5_Info_type */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_N_POINTS_5_Info.m_cu_n_points_8                                         |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_N_POINTS_5_Info.m_cu_n_points_9                                         |      0x%04X  |  [RW][31:16]""""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xa7238);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_INVX_CU_N_POINTS_4_Info             |  0x%08X  |  ""points for linearization""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_INVX_CU_N_POINTS_4_Info_type */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_N_POINTS_4_Info.m_cu_n_points_6                                         |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_N_POINTS_4_Info.m_cu_n_points_7                                         |      0x%04X  |  [RW][31:16]""""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xa7234);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_INVX_CU_N_POINTS_3_Info             |  0x%08X  |  ""points for linearization""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_INVX_CU_N_POINTS_3_Info_type */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_N_POINTS_3_Info.m_cu_n_points_4                                         |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_N_POINTS_3_Info.m_cu_n_points_5                                         |      0x%04X  |  [RW][31:16]""""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xa7230);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_INVX_CU_N_POINTS_2_Info             |  0x%08X  |  ""points for linearization""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_INVX_CU_N_POINTS_2_Info_type */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_N_POINTS_2_Info.m_cu_n_points_2                                         |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_N_POINTS_2_Info.m_cu_n_points_3                                         |      0x%04X  |  [RW][31:16]""""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xa722c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_INVX_CU_N_POINTS_1_Info             |  0x%08X  |  ""points for linearization""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_INVX_CU_N_POINTS_1_Info_type */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_N_POINTS_1_Info.m_cu_n_points_0                                         |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_INVX_CU_N_POINTS_1_Info.m_cu_n_points_1                                         |      0x%04X  |  [RW][31:16]""""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xa7228);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_ROOT_LUT_FLAGS_Info                 |  0x%08X  |  ""QNN_LUT FLAGS""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_ROOT_LUT_FLAGS_Info_type */
	/* skip, unused field unused_reg_SCALER_DM_ROOT_LUT_FLAGS_Info (reg_SCALER_DM_ROOT_LUT_FLAGS_Info) */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_FLAGS_Info.m_root_sub_flag_0                                           |         0x%01X  |  [RW][00:00]""""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_FLAGS_Info.m_root_sub_flag_1                                           |         0x%01X  |  [RW][01:01]""""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_FLAGS_Info.m_root_sub_flag_2                                           |         0x%01X  |  [RW][02:02]""""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_FLAGS_Info.m_root_sub_flag_3                                           |         0x%01X  |  [RW][03:03]""""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_FLAGS_Info.m_root_sub_flag_4                                           |         0x%01X  |  [RW][04:04]""""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_FLAGS_Info.m_root_sub_flag_5                                           |         0x%01X  |  [RW][05:05]""""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_FLAGS_Info.m_root_sub_flag_6                                           |         0x%01X  |  [RW][06:06]""""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_FLAGS_Info.m_root_sub_flag_7                                           |         0x%01X  |  [RW][07:07]""""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_FLAGS_Info.m_root_sub_flag_8                                           |         0x%01X  |  [RW][08:08]""""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_FLAGS_Info.m_root_sub_flag_9                                           |         0x%01X  |  [RW][09:09]""""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_FLAGS_Info.m_root_sub_flag_10                                          |         0x%01X  |  [RW][10:10]""""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_FLAGS_Info.m_root_sub_flag_11                                          |         0x%01X  |  [RW][11:11]""""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_FLAGS_Info.m_root_sub_flag_12                                          |         0x%01X  |  [RW][12:12]""""\n", FIELD_VALUE(val, 12, 12));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_FLAGS_Info.m_root_sub_flag_13                                          |         0x%01X  |  [RW][13:13]""""\n", FIELD_VALUE(val, 13, 13));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_FLAGS_Info.m_root_sub_flag_14                                          |         0x%01X  |  [RW][14:14]""""\n", FIELD_VALUE(val, 14, 14));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_FLAGS_Info.m_root_sub_flag_15                                          |         0x%01X  |  [RW][15:15]""""\n", FIELD_VALUE(val, 15, 15));
	val = REG_DUMP_READ_REGISTER(0xa7224);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_ROOT_LUT_EID_15_Info                |  0x%08X  |  ""dm root lut cfg""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_ROOT_LUT_EID_15_Info_type */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_15_Info.m_root_in_val_15                                           |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_15_Info.m_root_shiftA_15                                           |         0x%01X  |  [RW][19:16]""""\n", FIELD_VALUE(val, 16, 19));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_15_Info.m_root_shiftB_15                                           |         0x%01X  |  [RW][23:20]""""\n", FIELD_VALUE(val, 20, 23));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_15_Info.m_root_out                                                 |        0x%02X  |  [RW][31:24]""""\n", FIELD_VALUE(val, 24, 31));
	val = REG_DUMP_READ_REGISTER(0xa7220);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_ROOT_LUT_EID_14_Info                |  0x%08X  |  ""dm root lut cfg""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_ROOT_LUT_EID_14_Info_type */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_14_Info.m_root_in_val_14                                           |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_14_Info.m_root_shiftA_14                                           |         0x%01X  |  [RW][19:16]""""\n", FIELD_VALUE(val, 16, 19));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_14_Info.m_root_shiftB_14                                           |         0x%01X  |  [RW][23:20]""""\n", FIELD_VALUE(val, 20, 23));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_14_Info.m_root_out                                                 |        0x%02X  |  [RW][31:24]""""\n", FIELD_VALUE(val, 24, 31));
	val = REG_DUMP_READ_REGISTER(0xa721c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_ROOT_LUT_EID_13_Info                |  0x%08X  |  ""dm root lut cfg""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_ROOT_LUT_EID_13_Info_type */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_13_Info.m_root_in_val_13                                           |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_13_Info.m_root_shiftA_13                                           |         0x%01X  |  [RW][19:16]""""\n", FIELD_VALUE(val, 16, 19));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_13_Info.m_root_shiftB_13                                           |         0x%01X  |  [RW][23:20]""""\n", FIELD_VALUE(val, 20, 23));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_13_Info.m_root_out                                                 |        0x%02X  |  [RW][31:24]""""\n", FIELD_VALUE(val, 24, 31));
	val = REG_DUMP_READ_REGISTER(0xa7218);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_ROOT_LUT_EID_12_Info                |  0x%08X  |  ""dm root lut cfg""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_ROOT_LUT_EID_12_Info_type */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_12_Info.m_root_in_val_12                                           |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_12_Info.m_root_shiftA_12                                           |         0x%01X  |  [RW][19:16]""""\n", FIELD_VALUE(val, 16, 19));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_12_Info.m_root_shiftB_12                                           |         0x%01X  |  [RW][23:20]""""\n", FIELD_VALUE(val, 20, 23));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_12_Info.m_root_out                                                 |        0x%02X  |  [RW][31:24]""""\n", FIELD_VALUE(val, 24, 31));
	val = REG_DUMP_READ_REGISTER(0xa7214);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_ROOT_LUT_EID_11_Info                |  0x%08X  |  ""dm root lut cfg""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_ROOT_LUT_EID_11_Info_type */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_11_Info.m_root_in_val_11                                           |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_11_Info.m_root_shiftA_11                                           |         0x%01X  |  [RW][19:16]""""\n", FIELD_VALUE(val, 16, 19));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_11_Info.m_root_shiftB_11                                           |         0x%01X  |  [RW][23:20]""""\n", FIELD_VALUE(val, 20, 23));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_11_Info.m_root_out                                                 |        0x%02X  |  [RW][31:24]""""\n", FIELD_VALUE(val, 24, 31));
	val = REG_DUMP_READ_REGISTER(0xa7210);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_ROOT_LUT_EID_10_Info                |  0x%08X  |  ""dm root lut cfg""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_ROOT_LUT_EID_10_Info_type */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_10_Info.m_root_in_val_10                                           |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_10_Info.m_root_shiftA_10                                           |         0x%01X  |  [RW][19:16]""""\n", FIELD_VALUE(val, 16, 19));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_10_Info.m_root_shiftB_10                                           |         0x%01X  |  [RW][23:20]""""\n", FIELD_VALUE(val, 20, 23));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_10_Info.m_root_out                                                 |        0x%02X  |  [RW][31:24]""""\n", FIELD_VALUE(val, 24, 31));
	val = REG_DUMP_READ_REGISTER(0xa720c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_ROOT_LUT_EID_9_Info                 |  0x%08X  |  ""dm root lut cfg""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_ROOT_LUT_EID_9_Info_type */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_9_Info.m_root_in_val_9                                             |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_9_Info.m_root_shiftA_9                                             |         0x%01X  |  [RW][19:16]""""\n", FIELD_VALUE(val, 16, 19));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_9_Info.m_root_shiftB_9                                             |         0x%01X  |  [RW][23:20]""""\n", FIELD_VALUE(val, 20, 23));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_9_Info.m_root_out                                                  |        0x%02X  |  [RW][31:24]""""\n", FIELD_VALUE(val, 24, 31));
	val = REG_DUMP_READ_REGISTER(0xa7208);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_ROOT_LUT_EID_8_Info                 |  0x%08X  |  ""dm root lut cfg""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_ROOT_LUT_EID_8_Info_type */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_8_Info.m_root_in_val_8                                             |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_8_Info.m_root_shiftA_8                                             |         0x%01X  |  [RW][19:16]""""\n", FIELD_VALUE(val, 16, 19));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_8_Info.m_root_shiftB_8                                             |         0x%01X  |  [RW][23:20]""""\n", FIELD_VALUE(val, 20, 23));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_8_Info.m_root_out                                                  |        0x%02X  |  [RW][31:24]""""\n", FIELD_VALUE(val, 24, 31));
	val = REG_DUMP_READ_REGISTER(0xa7204);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_ROOT_LUT_EID_7_Info                 |  0x%08X  |  ""dm root lut cfg""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_ROOT_LUT_EID_7_Info_type */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_7_Info.m_root_in_val_7                                             |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_7_Info.m_root_shiftA_7                                             |         0x%01X  |  [RW][19:16]""""\n", FIELD_VALUE(val, 16, 19));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_7_Info.m_root_shiftB_7                                             |         0x%01X  |  [RW][23:20]""""\n", FIELD_VALUE(val, 20, 23));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_7_Info.m_root_out                                                  |        0x%02X  |  [RW][31:24]""""\n", FIELD_VALUE(val, 24, 31));
	val = REG_DUMP_READ_REGISTER(0xa7200);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_ROOT_LUT_EID_6_Info                 |  0x%08X  |  ""dm root lut cfg""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_ROOT_LUT_EID_6_Info_type */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_6_Info.m_root_in_val_6                                             |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_6_Info.m_root_shiftA_6                                             |         0x%01X  |  [RW][19:16]""""\n", FIELD_VALUE(val, 16, 19));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_6_Info.m_root_shiftB_6                                             |         0x%01X  |  [RW][23:20]""""\n", FIELD_VALUE(val, 20, 23));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_6_Info.m_root_out                                                  |        0x%02X  |  [RW][31:24]""""\n", FIELD_VALUE(val, 24, 31));
	val = REG_DUMP_READ_REGISTER(0xa71fc);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_ROOT_LUT_EID_5_Info                 |  0x%08X  |  ""dm root lut cfg""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_ROOT_LUT_EID_5_Info_type */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_5_Info.m_root_in_val_5                                             |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_5_Info.m_root_shiftA_5                                             |         0x%01X  |  [RW][19:16]""""\n", FIELD_VALUE(val, 16, 19));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_5_Info.m_root_shiftB_5                                             |         0x%01X  |  [RW][23:20]""""\n", FIELD_VALUE(val, 20, 23));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_5_Info.m_root_out                                                  |        0x%02X  |  [RW][31:24]""""\n", FIELD_VALUE(val, 24, 31));
	val = REG_DUMP_READ_REGISTER(0xa71f8);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_ROOT_LUT_EID_4_Info                 |  0x%08X  |  ""dm root lut cfg""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_ROOT_LUT_EID_4_Info_type */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_4_Info.m_root_in_val_4                                             |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_4_Info.m_root_shiftA_4                                             |         0x%01X  |  [RW][19:16]""""\n", FIELD_VALUE(val, 16, 19));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_4_Info.m_root_shiftB_4                                             |         0x%01X  |  [RW][23:20]""""\n", FIELD_VALUE(val, 20, 23));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_4_Info.m_root_out                                                  |        0x%02X  |  [RW][31:24]""""\n", FIELD_VALUE(val, 24, 31));
	val = REG_DUMP_READ_REGISTER(0xa71f4);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_ROOT_LUT_EID_3_Info                 |  0x%08X  |  ""dm root lut cfg""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_ROOT_LUT_EID_3_Info_type */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_3_Info.m_root_in_val_3                                             |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_3_Info.m_root_shiftA_3                                             |         0x%01X  |  [RW][19:16]""""\n", FIELD_VALUE(val, 16, 19));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_3_Info.m_root_shiftB_3                                             |         0x%01X  |  [RW][23:20]""""\n", FIELD_VALUE(val, 20, 23));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_3_Info.m_root_out                                                  |        0x%02X  |  [RW][31:24]""""\n", FIELD_VALUE(val, 24, 31));
	val = REG_DUMP_READ_REGISTER(0xa71f0);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_ROOT_LUT_EID_2_Info                 |  0x%08X  |  ""dm root lut cfg""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_ROOT_LUT_EID_2_Info_type */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_2_Info.m_root_in_val_2                                             |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_2_Info.m_root_shiftA_2                                             |         0x%01X  |  [RW][19:16]""""\n", FIELD_VALUE(val, 16, 19));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_2_Info.m_root_shiftB_2                                             |         0x%01X  |  [RW][23:20]""""\n", FIELD_VALUE(val, 20, 23));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_2_Info.m_root_out                                                  |        0x%02X  |  [RW][31:24]""""\n", FIELD_VALUE(val, 24, 31));
	val = REG_DUMP_READ_REGISTER(0xa71ec);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_ROOT_LUT_EID_1_Info                 |  0x%08X  |  ""dm root lut cfg""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_ROOT_LUT_EID_1_Info_type */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_1_Info.m_root_in_val_1                                             |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_1_Info.m_root_shiftA_1                                             |         0x%01X  |  [RW][19:16]""""\n", FIELD_VALUE(val, 16, 19));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_1_Info.m_root_shiftB_1                                             |         0x%01X  |  [RW][23:20]""""\n", FIELD_VALUE(val, 20, 23));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_1_Info.m_root_out                                                  |        0x%02X  |  [RW][31:24]""""\n", FIELD_VALUE(val, 24, 31));
	val = REG_DUMP_READ_REGISTER(0xa71e8);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_SCALER_DM_ROOT_LUT_EID_0_Info                 |  0x%08X  |  ""dm root lut cfg""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_SCALER_DM_ROOT_LUT_EID_0_Info_type */
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_0_Info.m_root_in_val_0                                             |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_0_Info.m_root_shiftA_0                                             |         0x%01X  |  [RW][19:16]""""\n", FIELD_VALUE(val, 16, 19));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_0_Info.m_root_shiftB_0                                             |         0x%01X  |  [RW][23:20]""""\n", FIELD_VALUE(val, 20, 23));
	REG_DUMP_PRINT_1("   -reg_SCALER_DM_ROOT_LUT_EID_0_Info.m_root_out                                                  |        0x%02X  |  [RW][31:24]""""\n", FIELD_VALUE(val, 24, 31));
	val = REG_DUMP_READ_REGISTER(0xa71e4);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_B_Pos_Weight_1_Vec_15_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_B_Pos_Weight_1_Vec_15_Info_type */
	/* skip, unused field unused_reg_DM_B_Pos_Weight_1_Vec_15_Info (reg_DM_B_Pos_Weight_1_Vec_15_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_15_Info.pos_4                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_15_Info.weight_4                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_15_Info.pos_5                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_15_Info.weight_5                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa71e0);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_B_Pos_Weight_1_Vec_14_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_B_Pos_Weight_1_Vec_14_Info_type */
	/* skip, unused field unused_reg_DM_B_Pos_Weight_1_Vec_14_Info (reg_DM_B_Pos_Weight_1_Vec_14_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_14_Info.pos_4                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_14_Info.weight_4                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_14_Info.pos_5                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_14_Info.weight_5                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa71dc);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_B_Pos_Weight_1_Vec_13_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_B_Pos_Weight_1_Vec_13_Info_type */
	/* skip, unused field unused_reg_DM_B_Pos_Weight_1_Vec_13_Info (reg_DM_B_Pos_Weight_1_Vec_13_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_13_Info.pos_4                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_13_Info.weight_4                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_13_Info.pos_5                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_13_Info.weight_5                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa71d8);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_B_Pos_Weight_1_Vec_12_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_B_Pos_Weight_1_Vec_12_Info_type */
	/* skip, unused field unused_reg_DM_B_Pos_Weight_1_Vec_12_Info (reg_DM_B_Pos_Weight_1_Vec_12_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_12_Info.pos_4                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_12_Info.weight_4                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_12_Info.pos_5                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_12_Info.weight_5                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa71d4);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_B_Pos_Weight_1_Vec_11_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_B_Pos_Weight_1_Vec_11_Info_type */
	/* skip, unused field unused_reg_DM_B_Pos_Weight_1_Vec_11_Info (reg_DM_B_Pos_Weight_1_Vec_11_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_11_Info.pos_4                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_11_Info.weight_4                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_11_Info.pos_5                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_11_Info.weight_5                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa71d0);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_B_Pos_Weight_1_Vec_10_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_B_Pos_Weight_1_Vec_10_Info_type */
	/* skip, unused field unused_reg_DM_B_Pos_Weight_1_Vec_10_Info (reg_DM_B_Pos_Weight_1_Vec_10_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_10_Info.pos_4                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_10_Info.weight_4                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_10_Info.pos_5                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_10_Info.weight_5                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa71cc);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_B_Pos_Weight_1_Vec_9_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_B_Pos_Weight_1_Vec_9_Info_type */
	/* skip, unused field unused_reg_DM_B_Pos_Weight_1_Vec_9_Info (reg_DM_B_Pos_Weight_1_Vec_9_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_9_Info.pos_4                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_9_Info.weight_4                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_9_Info.pos_5                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_9_Info.weight_5                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa71c8);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_B_Pos_Weight_1_Vec_8_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_B_Pos_Weight_1_Vec_8_Info_type */
	/* skip, unused field unused_reg_DM_B_Pos_Weight_1_Vec_8_Info (reg_DM_B_Pos_Weight_1_Vec_8_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_8_Info.pos_4                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_8_Info.weight_4                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_8_Info.pos_5                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_8_Info.weight_5                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa71c4);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_B_Pos_Weight_1_Vec_7_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_B_Pos_Weight_1_Vec_7_Info_type */
	/* skip, unused field unused_reg_DM_B_Pos_Weight_1_Vec_7_Info (reg_DM_B_Pos_Weight_1_Vec_7_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_7_Info.pos_4                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_7_Info.weight_4                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_7_Info.pos_5                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_7_Info.weight_5                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa71c0);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_B_Pos_Weight_1_Vec_6_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_B_Pos_Weight_1_Vec_6_Info_type */
	/* skip, unused field unused_reg_DM_B_Pos_Weight_1_Vec_6_Info (reg_DM_B_Pos_Weight_1_Vec_6_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_6_Info.pos_4                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_6_Info.weight_4                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_6_Info.pos_5                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_6_Info.weight_5                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa71bc);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_B_Pos_Weight_1_Vec_5_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_B_Pos_Weight_1_Vec_5_Info_type */
	/* skip, unused field unused_reg_DM_B_Pos_Weight_1_Vec_5_Info (reg_DM_B_Pos_Weight_1_Vec_5_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_5_Info.pos_4                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_5_Info.weight_4                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_5_Info.pos_5                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_5_Info.weight_5                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa71b8);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_B_Pos_Weight_1_Vec_4_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_B_Pos_Weight_1_Vec_4_Info_type */
	/* skip, unused field unused_reg_DM_B_Pos_Weight_1_Vec_4_Info (reg_DM_B_Pos_Weight_1_Vec_4_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_4_Info.pos_4                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_4_Info.weight_4                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_4_Info.pos_5                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_4_Info.weight_5                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa71b4);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_B_Pos_Weight_1_Vec_3_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_B_Pos_Weight_1_Vec_3_Info_type */
	/* skip, unused field unused_reg_DM_B_Pos_Weight_1_Vec_3_Info (reg_DM_B_Pos_Weight_1_Vec_3_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_3_Info.pos_4                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_3_Info.weight_4                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_3_Info.pos_5                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_3_Info.weight_5                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa71b0);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_B_Pos_Weight_1_Vec_2_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_B_Pos_Weight_1_Vec_2_Info_type */
	/* skip, unused field unused_reg_DM_B_Pos_Weight_1_Vec_2_Info (reg_DM_B_Pos_Weight_1_Vec_2_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_2_Info.pos_4                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_2_Info.weight_4                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_2_Info.pos_5                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_2_Info.weight_5                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa71ac);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_B_Pos_Weight_1_Vec_1_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_B_Pos_Weight_1_Vec_1_Info_type */
	/* skip, unused field unused_reg_DM_B_Pos_Weight_1_Vec_1_Info (reg_DM_B_Pos_Weight_1_Vec_1_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_1_Info.pos_4                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_1_Info.weight_4                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_1_Info.pos_5                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_1_Info.weight_5                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa71a8);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_B_Pos_Weight_1_Vec_0_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_B_Pos_Weight_1_Vec_0_Info_type */
	/* skip, unused field unused_reg_DM_B_Pos_Weight_1_Vec_0_Info (reg_DM_B_Pos_Weight_1_Vec_0_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_0_Info.pos_4                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_0_Info.weight_4                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_0_Info.pos_5                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_1_Vec_0_Info.weight_5                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa71a4);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_B_Pos_Weight_0_Vec_15_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_B_Pos_Weight_0_Vec_15_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_15_Info.pos_0                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_15_Info.weight_0                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_15_Info.pos_1                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_15_Info.weight_1                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_15_Info.pos_2                                                       |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_15_Info.weight_2                                                    |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_15_Info.pos_3                                                       |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_15_Info.weight_3                                                    |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa71a0);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_B_Pos_Weight_0_Vec_14_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_B_Pos_Weight_0_Vec_14_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_14_Info.pos_0                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_14_Info.weight_0                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_14_Info.pos_1                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_14_Info.weight_1                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_14_Info.pos_2                                                       |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_14_Info.weight_2                                                    |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_14_Info.pos_3                                                       |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_14_Info.weight_3                                                    |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa719c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_B_Pos_Weight_0_Vec_13_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_B_Pos_Weight_0_Vec_13_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_13_Info.pos_0                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_13_Info.weight_0                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_13_Info.pos_1                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_13_Info.weight_1                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_13_Info.pos_2                                                       |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_13_Info.weight_2                                                    |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_13_Info.pos_3                                                       |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_13_Info.weight_3                                                    |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa7198);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_B_Pos_Weight_0_Vec_12_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_B_Pos_Weight_0_Vec_12_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_12_Info.pos_0                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_12_Info.weight_0                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_12_Info.pos_1                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_12_Info.weight_1                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_12_Info.pos_2                                                       |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_12_Info.weight_2                                                    |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_12_Info.pos_3                                                       |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_12_Info.weight_3                                                    |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa7194);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_B_Pos_Weight_0_Vec_11_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_B_Pos_Weight_0_Vec_11_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_11_Info.pos_0                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_11_Info.weight_0                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_11_Info.pos_1                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_11_Info.weight_1                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_11_Info.pos_2                                                       |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_11_Info.weight_2                                                    |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_11_Info.pos_3                                                       |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_11_Info.weight_3                                                    |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa7190);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_B_Pos_Weight_0_Vec_10_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_B_Pos_Weight_0_Vec_10_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_10_Info.pos_0                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_10_Info.weight_0                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_10_Info.pos_1                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_10_Info.weight_1                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_10_Info.pos_2                                                       |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_10_Info.weight_2                                                    |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_10_Info.pos_3                                                       |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_10_Info.weight_3                                                    |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa718c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_B_Pos_Weight_0_Vec_9_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_B_Pos_Weight_0_Vec_9_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_9_Info.pos_0                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_9_Info.weight_0                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_9_Info.pos_1                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_9_Info.weight_1                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_9_Info.pos_2                                                        |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_9_Info.weight_2                                                     |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_9_Info.pos_3                                                        |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_9_Info.weight_3                                                     |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa7188);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_B_Pos_Weight_0_Vec_8_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_B_Pos_Weight_0_Vec_8_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_8_Info.pos_0                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_8_Info.weight_0                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_8_Info.pos_1                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_8_Info.weight_1                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_8_Info.pos_2                                                        |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_8_Info.weight_2                                                     |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_8_Info.pos_3                                                        |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_8_Info.weight_3                                                     |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa7184);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_B_Pos_Weight_0_Vec_7_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_B_Pos_Weight_0_Vec_7_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_7_Info.pos_0                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_7_Info.weight_0                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_7_Info.pos_1                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_7_Info.weight_1                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_7_Info.pos_2                                                        |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_7_Info.weight_2                                                     |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_7_Info.pos_3                                                        |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_7_Info.weight_3                                                     |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa7180);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_B_Pos_Weight_0_Vec_6_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_B_Pos_Weight_0_Vec_6_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_6_Info.pos_0                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_6_Info.weight_0                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_6_Info.pos_1                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_6_Info.weight_1                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_6_Info.pos_2                                                        |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_6_Info.weight_2                                                     |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_6_Info.pos_3                                                        |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_6_Info.weight_3                                                     |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa717c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_B_Pos_Weight_0_Vec_5_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_B_Pos_Weight_0_Vec_5_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_5_Info.pos_0                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_5_Info.weight_0                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_5_Info.pos_1                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_5_Info.weight_1                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_5_Info.pos_2                                                        |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_5_Info.weight_2                                                     |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_5_Info.pos_3                                                        |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_5_Info.weight_3                                                     |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa7178);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_B_Pos_Weight_0_Vec_4_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_B_Pos_Weight_0_Vec_4_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_4_Info.pos_0                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_4_Info.weight_0                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_4_Info.pos_1                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_4_Info.weight_1                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_4_Info.pos_2                                                        |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_4_Info.weight_2                                                     |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_4_Info.pos_3                                                        |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_4_Info.weight_3                                                     |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa7174);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_B_Pos_Weight_0_Vec_3_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_B_Pos_Weight_0_Vec_3_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_3_Info.pos_0                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_3_Info.weight_0                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_3_Info.pos_1                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_3_Info.weight_1                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_3_Info.pos_2                                                        |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_3_Info.weight_2                                                     |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_3_Info.pos_3                                                        |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_3_Info.weight_3                                                     |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa7170);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_B_Pos_Weight_0_Vec_2_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_B_Pos_Weight_0_Vec_2_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_2_Info.pos_0                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_2_Info.weight_0                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_2_Info.pos_1                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_2_Info.weight_1                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_2_Info.pos_2                                                        |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_2_Info.weight_2                                                     |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_2_Info.pos_3                                                        |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_2_Info.weight_3                                                     |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa716c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_B_Pos_Weight_0_Vec_1_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_B_Pos_Weight_0_Vec_1_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_1_Info.pos_0                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_1_Info.weight_0                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_1_Info.pos_1                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_1_Info.weight_1                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_1_Info.pos_2                                                        |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_1_Info.weight_2                                                     |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_1_Info.pos_3                                                        |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_1_Info.weight_3                                                     |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa7168);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_B_Pos_Weight_0_Vec_0_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_B_Pos_Weight_0_Vec_0_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_0_Info.pos_0                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_0_Info.weight_0                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_0_Info.pos_1                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_0_Info.weight_1                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_0_Info.pos_2                                                        |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_0_Info.weight_2                                                     |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_0_Info.pos_3                                                        |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_B_Pos_Weight_0_Vec_0_Info.weight_3                                                     |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa7164);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_G_Pos_Weight_1_Vec_15_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_G_Pos_Weight_1_Vec_15_Info_type */
	/* skip, unused field unused_reg_DM_G_Pos_Weight_1_Vec_15_Info (reg_DM_G_Pos_Weight_1_Vec_15_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_15_Info.pos_4                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_15_Info.weight_4                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_15_Info.pos_5                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_15_Info.weight_5                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa7160);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_G_Pos_Weight_1_Vec_14_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_G_Pos_Weight_1_Vec_14_Info_type */
	/* skip, unused field unused_reg_DM_G_Pos_Weight_1_Vec_14_Info (reg_DM_G_Pos_Weight_1_Vec_14_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_14_Info.pos_4                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_14_Info.weight_4                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_14_Info.pos_5                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_14_Info.weight_5                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa715c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_G_Pos_Weight_1_Vec_13_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_G_Pos_Weight_1_Vec_13_Info_type */
	/* skip, unused field unused_reg_DM_G_Pos_Weight_1_Vec_13_Info (reg_DM_G_Pos_Weight_1_Vec_13_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_13_Info.pos_4                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_13_Info.weight_4                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_13_Info.pos_5                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_13_Info.weight_5                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa7158);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_G_Pos_Weight_1_Vec_12_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_G_Pos_Weight_1_Vec_12_Info_type */
	/* skip, unused field unused_reg_DM_G_Pos_Weight_1_Vec_12_Info (reg_DM_G_Pos_Weight_1_Vec_12_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_12_Info.pos_4                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_12_Info.weight_4                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_12_Info.pos_5                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_12_Info.weight_5                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa7154);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_G_Pos_Weight_1_Vec_11_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_G_Pos_Weight_1_Vec_11_Info_type */
	/* skip, unused field unused_reg_DM_G_Pos_Weight_1_Vec_11_Info (reg_DM_G_Pos_Weight_1_Vec_11_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_11_Info.pos_4                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_11_Info.weight_4                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_11_Info.pos_5                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_11_Info.weight_5                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa7150);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_G_Pos_Weight_1_Vec_10_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_G_Pos_Weight_1_Vec_10_Info_type */
	/* skip, unused field unused_reg_DM_G_Pos_Weight_1_Vec_10_Info (reg_DM_G_Pos_Weight_1_Vec_10_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_10_Info.pos_4                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_10_Info.weight_4                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_10_Info.pos_5                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_10_Info.weight_5                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa714c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_G_Pos_Weight_1_Vec_9_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_G_Pos_Weight_1_Vec_9_Info_type */
	/* skip, unused field unused_reg_DM_G_Pos_Weight_1_Vec_9_Info (reg_DM_G_Pos_Weight_1_Vec_9_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_9_Info.pos_4                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_9_Info.weight_4                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_9_Info.pos_5                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_9_Info.weight_5                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa7148);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_G_Pos_Weight_1_Vec_8_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_G_Pos_Weight_1_Vec_8_Info_type */
	/* skip, unused field unused_reg_DM_G_Pos_Weight_1_Vec_8_Info (reg_DM_G_Pos_Weight_1_Vec_8_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_8_Info.pos_4                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_8_Info.weight_4                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_8_Info.pos_5                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_8_Info.weight_5                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa7144);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_G_Pos_Weight_1_Vec_7_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_G_Pos_Weight_1_Vec_7_Info_type */
	/* skip, unused field unused_reg_DM_G_Pos_Weight_1_Vec_7_Info (reg_DM_G_Pos_Weight_1_Vec_7_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_7_Info.pos_4                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_7_Info.weight_4                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_7_Info.pos_5                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_7_Info.weight_5                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa7140);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_G_Pos_Weight_1_Vec_6_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_G_Pos_Weight_1_Vec_6_Info_type */
	/* skip, unused field unused_reg_DM_G_Pos_Weight_1_Vec_6_Info (reg_DM_G_Pos_Weight_1_Vec_6_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_6_Info.pos_4                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_6_Info.weight_4                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_6_Info.pos_5                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_6_Info.weight_5                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa713c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_G_Pos_Weight_1_Vec_5_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_G_Pos_Weight_1_Vec_5_Info_type */
	/* skip, unused field unused_reg_DM_G_Pos_Weight_1_Vec_5_Info (reg_DM_G_Pos_Weight_1_Vec_5_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_5_Info.pos_4                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_5_Info.weight_4                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_5_Info.pos_5                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_5_Info.weight_5                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa7138);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_G_Pos_Weight_1_Vec_4_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_G_Pos_Weight_1_Vec_4_Info_type */
	/* skip, unused field unused_reg_DM_G_Pos_Weight_1_Vec_4_Info (reg_DM_G_Pos_Weight_1_Vec_4_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_4_Info.pos_4                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_4_Info.weight_4                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_4_Info.pos_5                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_4_Info.weight_5                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa7134);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_G_Pos_Weight_1_Vec_3_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_G_Pos_Weight_1_Vec_3_Info_type */
	/* skip, unused field unused_reg_DM_G_Pos_Weight_1_Vec_3_Info (reg_DM_G_Pos_Weight_1_Vec_3_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_3_Info.pos_4                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_3_Info.weight_4                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_3_Info.pos_5                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_3_Info.weight_5                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa7130);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_G_Pos_Weight_1_Vec_2_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_G_Pos_Weight_1_Vec_2_Info_type */
	/* skip, unused field unused_reg_DM_G_Pos_Weight_1_Vec_2_Info (reg_DM_G_Pos_Weight_1_Vec_2_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_2_Info.pos_4                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_2_Info.weight_4                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_2_Info.pos_5                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_2_Info.weight_5                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa712c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_G_Pos_Weight_1_Vec_1_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_G_Pos_Weight_1_Vec_1_Info_type */
	/* skip, unused field unused_reg_DM_G_Pos_Weight_1_Vec_1_Info (reg_DM_G_Pos_Weight_1_Vec_1_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_1_Info.pos_4                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_1_Info.weight_4                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_1_Info.pos_5                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_1_Info.weight_5                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa7128);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_G_Pos_Weight_1_Vec_0_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_G_Pos_Weight_1_Vec_0_Info_type */
	/* skip, unused field unused_reg_DM_G_Pos_Weight_1_Vec_0_Info (reg_DM_G_Pos_Weight_1_Vec_0_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_0_Info.pos_4                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_0_Info.weight_4                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_0_Info.pos_5                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_1_Vec_0_Info.weight_5                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa7124);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_G_Pos_Weight_0_Vec_15_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_G_Pos_Weight_0_Vec_15_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_15_Info.pos_0                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_15_Info.weight_0                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_15_Info.pos_1                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_15_Info.weight_1                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_15_Info.pos_2                                                       |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_15_Info.weight_2                                                    |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_15_Info.pos_3                                                       |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_15_Info.weight_3                                                    |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa7120);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_G_Pos_Weight_0_Vec_14_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_G_Pos_Weight_0_Vec_14_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_14_Info.pos_0                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_14_Info.weight_0                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_14_Info.pos_1                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_14_Info.weight_1                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_14_Info.pos_2                                                       |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_14_Info.weight_2                                                    |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_14_Info.pos_3                                                       |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_14_Info.weight_3                                                    |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa711c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_G_Pos_Weight_0_Vec_13_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_G_Pos_Weight_0_Vec_13_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_13_Info.pos_0                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_13_Info.weight_0                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_13_Info.pos_1                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_13_Info.weight_1                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_13_Info.pos_2                                                       |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_13_Info.weight_2                                                    |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_13_Info.pos_3                                                       |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_13_Info.weight_3                                                    |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa7118);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_G_Pos_Weight_0_Vec_12_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_G_Pos_Weight_0_Vec_12_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_12_Info.pos_0                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_12_Info.weight_0                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_12_Info.pos_1                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_12_Info.weight_1                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_12_Info.pos_2                                                       |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_12_Info.weight_2                                                    |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_12_Info.pos_3                                                       |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_12_Info.weight_3                                                    |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa7114);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_G_Pos_Weight_0_Vec_11_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_G_Pos_Weight_0_Vec_11_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_11_Info.pos_0                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_11_Info.weight_0                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_11_Info.pos_1                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_11_Info.weight_1                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_11_Info.pos_2                                                       |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_11_Info.weight_2                                                    |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_11_Info.pos_3                                                       |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_11_Info.weight_3                                                    |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa7110);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_G_Pos_Weight_0_Vec_10_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_G_Pos_Weight_0_Vec_10_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_10_Info.pos_0                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_10_Info.weight_0                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_10_Info.pos_1                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_10_Info.weight_1                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_10_Info.pos_2                                                       |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_10_Info.weight_2                                                    |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_10_Info.pos_3                                                       |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_10_Info.weight_3                                                    |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa710c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_G_Pos_Weight_0_Vec_9_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_G_Pos_Weight_0_Vec_9_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_9_Info.pos_0                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_9_Info.weight_0                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_9_Info.pos_1                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_9_Info.weight_1                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_9_Info.pos_2                                                        |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_9_Info.weight_2                                                     |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_9_Info.pos_3                                                        |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_9_Info.weight_3                                                     |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa7108);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_G_Pos_Weight_0_Vec_8_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_G_Pos_Weight_0_Vec_8_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_8_Info.pos_0                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_8_Info.weight_0                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_8_Info.pos_1                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_8_Info.weight_1                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_8_Info.pos_2                                                        |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_8_Info.weight_2                                                     |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_8_Info.pos_3                                                        |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_8_Info.weight_3                                                     |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa7104);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_G_Pos_Weight_0_Vec_7_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_G_Pos_Weight_0_Vec_7_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_7_Info.pos_0                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_7_Info.weight_0                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_7_Info.pos_1                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_7_Info.weight_1                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_7_Info.pos_2                                                        |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_7_Info.weight_2                                                     |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_7_Info.pos_3                                                        |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_7_Info.weight_3                                                     |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa7100);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_G_Pos_Weight_0_Vec_6_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_G_Pos_Weight_0_Vec_6_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_6_Info.pos_0                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_6_Info.weight_0                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_6_Info.pos_1                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_6_Info.weight_1                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_6_Info.pos_2                                                        |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_6_Info.weight_2                                                     |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_6_Info.pos_3                                                        |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_6_Info.weight_3                                                     |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa70fc);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_G_Pos_Weight_0_Vec_5_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_G_Pos_Weight_0_Vec_5_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_5_Info.pos_0                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_5_Info.weight_0                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_5_Info.pos_1                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_5_Info.weight_1                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_5_Info.pos_2                                                        |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_5_Info.weight_2                                                     |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_5_Info.pos_3                                                        |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_5_Info.weight_3                                                     |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa70f8);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_G_Pos_Weight_0_Vec_4_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_G_Pos_Weight_0_Vec_4_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_4_Info.pos_0                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_4_Info.weight_0                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_4_Info.pos_1                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_4_Info.weight_1                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_4_Info.pos_2                                                        |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_4_Info.weight_2                                                     |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_4_Info.pos_3                                                        |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_4_Info.weight_3                                                     |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa70f4);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_G_Pos_Weight_0_Vec_3_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_G_Pos_Weight_0_Vec_3_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_3_Info.pos_0                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_3_Info.weight_0                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_3_Info.pos_1                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_3_Info.weight_1                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_3_Info.pos_2                                                        |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_3_Info.weight_2                                                     |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_3_Info.pos_3                                                        |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_3_Info.weight_3                                                     |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa70f0);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_G_Pos_Weight_0_Vec_2_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_G_Pos_Weight_0_Vec_2_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_2_Info.pos_0                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_2_Info.weight_0                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_2_Info.pos_1                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_2_Info.weight_1                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_2_Info.pos_2                                                        |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_2_Info.weight_2                                                     |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_2_Info.pos_3                                                        |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_2_Info.weight_3                                                     |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa70ec);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_G_Pos_Weight_0_Vec_1_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_G_Pos_Weight_0_Vec_1_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_1_Info.pos_0                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_1_Info.weight_0                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_1_Info.pos_1                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_1_Info.weight_1                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_1_Info.pos_2                                                        |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_1_Info.weight_2                                                     |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_1_Info.pos_3                                                        |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_1_Info.weight_3                                                     |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa70e8);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_G_Pos_Weight_0_Vec_0_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_G_Pos_Weight_0_Vec_0_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_0_Info.pos_0                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_0_Info.weight_0                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_0_Info.pos_1                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_0_Info.weight_1                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_0_Info.pos_2                                                        |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_0_Info.weight_2                                                     |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_0_Info.pos_3                                                        |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_G_Pos_Weight_0_Vec_0_Info.weight_3                                                     |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa70e4);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_R_Pos_Weight_1_Vec_15_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_R_Pos_Weight_1_Vec_15_Info_type */
	/* skip, unused field unused_reg_DM_R_Pos_Weight_1_Vec_15_Info (reg_DM_R_Pos_Weight_1_Vec_15_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_15_Info.pos_4                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_15_Info.weight_4                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_15_Info.pos_5                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_15_Info.weight_5                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa70e0);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_R_Pos_Weight_1_Vec_14_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_R_Pos_Weight_1_Vec_14_Info_type */
	/* skip, unused field unused_reg_DM_R_Pos_Weight_1_Vec_14_Info (reg_DM_R_Pos_Weight_1_Vec_14_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_14_Info.pos_4                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_14_Info.weight_4                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_14_Info.pos_5                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_14_Info.weight_5                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa70dc);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_R_Pos_Weight_1_Vec_13_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_R_Pos_Weight_1_Vec_13_Info_type */
	/* skip, unused field unused_reg_DM_R_Pos_Weight_1_Vec_13_Info (reg_DM_R_Pos_Weight_1_Vec_13_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_13_Info.pos_4                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_13_Info.weight_4                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_13_Info.pos_5                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_13_Info.weight_5                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa70d8);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_R_Pos_Weight_1_Vec_12_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_R_Pos_Weight_1_Vec_12_Info_type */
	/* skip, unused field unused_reg_DM_R_Pos_Weight_1_Vec_12_Info (reg_DM_R_Pos_Weight_1_Vec_12_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_12_Info.pos_4                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_12_Info.weight_4                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_12_Info.pos_5                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_12_Info.weight_5                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa70d4);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_R_Pos_Weight_1_Vec_11_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_R_Pos_Weight_1_Vec_11_Info_type */
	/* skip, unused field unused_reg_DM_R_Pos_Weight_1_Vec_11_Info (reg_DM_R_Pos_Weight_1_Vec_11_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_11_Info.pos_4                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_11_Info.weight_4                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_11_Info.pos_5                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_11_Info.weight_5                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa70d0);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_R_Pos_Weight_1_Vec_10_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_R_Pos_Weight_1_Vec_10_Info_type */
	/* skip, unused field unused_reg_DM_R_Pos_Weight_1_Vec_10_Info (reg_DM_R_Pos_Weight_1_Vec_10_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_10_Info.pos_4                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_10_Info.weight_4                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_10_Info.pos_5                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_10_Info.weight_5                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa70cc);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_R_Pos_Weight_1_Vec_9_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_R_Pos_Weight_1_Vec_9_Info_type */
	/* skip, unused field unused_reg_DM_R_Pos_Weight_1_Vec_9_Info (reg_DM_R_Pos_Weight_1_Vec_9_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_9_Info.pos_4                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_9_Info.weight_4                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_9_Info.pos_5                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_9_Info.weight_5                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa70c8);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_R_Pos_Weight_1_Vec_8_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_R_Pos_Weight_1_Vec_8_Info_type */
	/* skip, unused field unused_reg_DM_R_Pos_Weight_1_Vec_8_Info (reg_DM_R_Pos_Weight_1_Vec_8_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_8_Info.pos_4                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_8_Info.weight_4                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_8_Info.pos_5                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_8_Info.weight_5                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa70c4);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_R_Pos_Weight_1_Vec_7_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_R_Pos_Weight_1_Vec_7_Info_type */
	/* skip, unused field unused_reg_DM_R_Pos_Weight_1_Vec_7_Info (reg_DM_R_Pos_Weight_1_Vec_7_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_7_Info.pos_4                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_7_Info.weight_4                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_7_Info.pos_5                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_7_Info.weight_5                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa70c0);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_R_Pos_Weight_1_Vec_6_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_R_Pos_Weight_1_Vec_6_Info_type */
	/* skip, unused field unused_reg_DM_R_Pos_Weight_1_Vec_6_Info (reg_DM_R_Pos_Weight_1_Vec_6_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_6_Info.pos_4                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_6_Info.weight_4                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_6_Info.pos_5                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_6_Info.weight_5                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa70bc);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_R_Pos_Weight_1_Vec_5_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_R_Pos_Weight_1_Vec_5_Info_type */
	/* skip, unused field unused_reg_DM_R_Pos_Weight_1_Vec_5_Info (reg_DM_R_Pos_Weight_1_Vec_5_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_5_Info.pos_4                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_5_Info.weight_4                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_5_Info.pos_5                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_5_Info.weight_5                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa70b8);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_R_Pos_Weight_1_Vec_4_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_R_Pos_Weight_1_Vec_4_Info_type */
	/* skip, unused field unused_reg_DM_R_Pos_Weight_1_Vec_4_Info (reg_DM_R_Pos_Weight_1_Vec_4_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_4_Info.pos_4                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_4_Info.weight_4                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_4_Info.pos_5                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_4_Info.weight_5                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa70b4);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_R_Pos_Weight_1_Vec_3_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_R_Pos_Weight_1_Vec_3_Info_type */
	/* skip, unused field unused_reg_DM_R_Pos_Weight_1_Vec_3_Info (reg_DM_R_Pos_Weight_1_Vec_3_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_3_Info.pos_4                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_3_Info.weight_4                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_3_Info.pos_5                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_3_Info.weight_5                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa70b0);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_R_Pos_Weight_1_Vec_2_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_R_Pos_Weight_1_Vec_2_Info_type */
	/* skip, unused field unused_reg_DM_R_Pos_Weight_1_Vec_2_Info (reg_DM_R_Pos_Weight_1_Vec_2_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_2_Info.pos_4                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_2_Info.weight_4                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_2_Info.pos_5                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_2_Info.weight_5                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa70ac);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_R_Pos_Weight_1_Vec_1_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_R_Pos_Weight_1_Vec_1_Info_type */
	/* skip, unused field unused_reg_DM_R_Pos_Weight_1_Vec_1_Info (reg_DM_R_Pos_Weight_1_Vec_1_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_1_Info.pos_4                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_1_Info.weight_4                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_1_Info.pos_5                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_1_Info.weight_5                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa70a8);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_R_Pos_Weight_1_Vec_0_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_R_Pos_Weight_1_Vec_0_Info_type */
	/* skip, unused field unused_reg_DM_R_Pos_Weight_1_Vec_0_Info (reg_DM_R_Pos_Weight_1_Vec_0_Info) */
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_0_Info.pos_4                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_0_Info.weight_4                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_0_Info.pos_5                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_1_Vec_0_Info.weight_5                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	val = REG_DUMP_READ_REGISTER(0xa70a4);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_R_Pos_Weight_0_Vec_15_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_R_Pos_Weight_0_Vec_15_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_15_Info.pos_0                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_15_Info.weight_0                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_15_Info.pos_1                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_15_Info.weight_1                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_15_Info.pos_2                                                       |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_15_Info.weight_2                                                    |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_15_Info.pos_3                                                       |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_15_Info.weight_3                                                    |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa70a0);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_R_Pos_Weight_0_Vec_14_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_R_Pos_Weight_0_Vec_14_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_14_Info.pos_0                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_14_Info.weight_0                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_14_Info.pos_1                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_14_Info.weight_1                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_14_Info.pos_2                                                       |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_14_Info.weight_2                                                    |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_14_Info.pos_3                                                       |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_14_Info.weight_3                                                    |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa709c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_R_Pos_Weight_0_Vec_13_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_R_Pos_Weight_0_Vec_13_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_13_Info.pos_0                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_13_Info.weight_0                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_13_Info.pos_1                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_13_Info.weight_1                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_13_Info.pos_2                                                       |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_13_Info.weight_2                                                    |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_13_Info.pos_3                                                       |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_13_Info.weight_3                                                    |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa7098);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_R_Pos_Weight_0_Vec_12_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_R_Pos_Weight_0_Vec_12_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_12_Info.pos_0                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_12_Info.weight_0                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_12_Info.pos_1                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_12_Info.weight_1                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_12_Info.pos_2                                                       |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_12_Info.weight_2                                                    |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_12_Info.pos_3                                                       |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_12_Info.weight_3                                                    |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa7094);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_R_Pos_Weight_0_Vec_11_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_R_Pos_Weight_0_Vec_11_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_11_Info.pos_0                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_11_Info.weight_0                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_11_Info.pos_1                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_11_Info.weight_1                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_11_Info.pos_2                                                       |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_11_Info.weight_2                                                    |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_11_Info.pos_3                                                       |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_11_Info.weight_3                                                    |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa7090);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_R_Pos_Weight_0_Vec_10_Info                 |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_R_Pos_Weight_0_Vec_10_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_10_Info.pos_0                                                       |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_10_Info.weight_0                                                    |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_10_Info.pos_1                                                       |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_10_Info.weight_1                                                    |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_10_Info.pos_2                                                       |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_10_Info.weight_2                                                    |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_10_Info.pos_3                                                       |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_10_Info.weight_3                                                    |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa708c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_R_Pos_Weight_0_Vec_9_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_R_Pos_Weight_0_Vec_9_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_9_Info.pos_0                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_9_Info.weight_0                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_9_Info.pos_1                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_9_Info.weight_1                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_9_Info.pos_2                                                        |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_9_Info.weight_2                                                     |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_9_Info.pos_3                                                        |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_9_Info.weight_3                                                     |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa7088);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_R_Pos_Weight_0_Vec_8_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_R_Pos_Weight_0_Vec_8_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_8_Info.pos_0                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_8_Info.weight_0                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_8_Info.pos_1                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_8_Info.weight_1                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_8_Info.pos_2                                                        |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_8_Info.weight_2                                                     |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_8_Info.pos_3                                                        |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_8_Info.weight_3                                                     |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa7084);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_R_Pos_Weight_0_Vec_7_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_R_Pos_Weight_0_Vec_7_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_7_Info.pos_0                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_7_Info.weight_0                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_7_Info.pos_1                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_7_Info.weight_1                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_7_Info.pos_2                                                        |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_7_Info.weight_2                                                     |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_7_Info.pos_3                                                        |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_7_Info.weight_3                                                     |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa7080);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_R_Pos_Weight_0_Vec_6_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_R_Pos_Weight_0_Vec_6_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_6_Info.pos_0                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_6_Info.weight_0                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_6_Info.pos_1                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_6_Info.weight_1                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_6_Info.pos_2                                                        |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_6_Info.weight_2                                                     |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_6_Info.pos_3                                                        |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_6_Info.weight_3                                                     |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa707c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_R_Pos_Weight_0_Vec_5_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_R_Pos_Weight_0_Vec_5_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_5_Info.pos_0                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_5_Info.weight_0                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_5_Info.pos_1                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_5_Info.weight_1                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_5_Info.pos_2                                                        |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_5_Info.weight_2                                                     |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_5_Info.pos_3                                                        |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_5_Info.weight_3                                                     |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa7078);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_R_Pos_Weight_0_Vec_4_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_R_Pos_Weight_0_Vec_4_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_4_Info.pos_0                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_4_Info.weight_0                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_4_Info.pos_1                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_4_Info.weight_1                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_4_Info.pos_2                                                        |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_4_Info.weight_2                                                     |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_4_Info.pos_3                                                        |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_4_Info.weight_3                                                     |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa7074);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_R_Pos_Weight_0_Vec_3_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_R_Pos_Weight_0_Vec_3_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_3_Info.pos_0                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_3_Info.weight_0                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_3_Info.pos_1                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_3_Info.weight_1                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_3_Info.pos_2                                                        |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_3_Info.weight_2                                                     |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_3_Info.pos_3                                                        |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_3_Info.weight_3                                                     |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa7070);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_R_Pos_Weight_0_Vec_2_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_R_Pos_Weight_0_Vec_2_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_2_Info.pos_0                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_2_Info.weight_0                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_2_Info.pos_1                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_2_Info.weight_1                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_2_Info.pos_2                                                        |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_2_Info.weight_2                                                     |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_2_Info.pos_3                                                        |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_2_Info.weight_3                                                     |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa706c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_R_Pos_Weight_0_Vec_1_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_R_Pos_Weight_0_Vec_1_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_1_Info.pos_0                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_1_Info.weight_0                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_1_Info.pos_1                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_1_Info.weight_1                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_1_Info.pos_2                                                        |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_1_Info.weight_2                                                     |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_1_Info.pos_3                                                        |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_1_Info.weight_3                                                     |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa7068);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DM_R_Pos_Weight_0_Vec_0_Info                  |  0x%08X  |  ""position vector""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DM_R_Pos_Weight_0_Vec_0_Info_type */
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_0_Info.pos_0                                                        |        0x%02X  |  [RW][04:00]""""\n", FIELD_VALUE(val, 0, 4));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_0_Info.weight_0                                                     |         0x%01X  |  [RW][07:05]""""\n", FIELD_VALUE(val, 5, 7));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_0_Info.pos_1                                                        |        0x%02X  |  [RW][12:08]""""\n", FIELD_VALUE(val, 8, 12));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_0_Info.weight_1                                                     |         0x%01X  |  [RW][15:13]""""\n", FIELD_VALUE(val, 13, 15));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_0_Info.pos_2                                                        |        0x%02X  |  [RW][20:16]""""\n", FIELD_VALUE(val, 16, 20));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_0_Info.weight_2                                                     |         0x%01X  |  [RW][23:21]""""\n", FIELD_VALUE(val, 21, 23));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_0_Info.pos_3                                                        |        0x%02X  |  [RW][28:24]""""\n", FIELD_VALUE(val, 24, 28));
	REG_DUMP_PRINT_1("   -reg_DM_R_Pos_Weight_0_Vec_0_Info.weight_3                                                     |         0x%01X  |  [RW][31:29]""""\n", FIELD_VALUE(val, 29, 31));
	val = REG_DUMP_READ_REGISTER(0xa7064);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_G_W_FILTER_C_Info                             |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_G_W_FILTER_C_Info_type */
	/* skip, unused field unused_reg_G_W_FILTER_C_Info (reg_G_W_FILTER_C_Info) */
	REG_DUMP_PRINT_1("   -reg_G_W_FILTER_C_Info.C6_Gain                                                                 |         0x%01X  |  [RW][03:00]""Gain (Signed)""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xa7060);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_G_W_FILTER_B_Info                             |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_G_W_FILTER_B_Info_type */
	/* skip, unused field unused_reg_G_W_FILTER_B_Info (reg_G_W_FILTER_B_Info) */
	REG_DUMP_PRINT_1("   -reg_G_W_FILTER_B_Info.C3_Gain                                                                 |       0x%03X  |  [RW][09:00]""Gain (Signed)""\n", FIELD_VALUE(val, 0, 9));
	REG_DUMP_PRINT_1("   -reg_G_W_FILTER_B_Info.C4_Gain                                                                 |       0x%03X  |  [RW][19:10]""Gain (Signed)""\n", FIELD_VALUE(val, 10, 19));
	REG_DUMP_PRINT_1("   -reg_G_W_FILTER_B_Info.C5_Gain                                                                 |       0x%03X  |  [RW][29:20]""Gain (Signed)""\n", FIELD_VALUE(val, 20, 29));
	val = REG_DUMP_READ_REGISTER(0xa705c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_G_W_FILTER_A_Info                             |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_G_W_FILTER_A_Info_type */
	/* skip, unused field unused_reg_G_W_FILTER_A_Info (reg_G_W_FILTER_A_Info) */
	REG_DUMP_PRINT_1("   -reg_G_W_FILTER_A_Info.C0_Gain                                                                 |       0x%03X  |  [RW][09:00]""Gain (Signed)""\n", FIELD_VALUE(val, 0, 9));
	REG_DUMP_PRINT_1("   -reg_G_W_FILTER_A_Info.C1_Gain                                                                 |       0x%03X  |  [RW][19:10]""Gain (Signed)""\n", FIELD_VALUE(val, 10, 19));
	REG_DUMP_PRINT_1("   -reg_G_W_FILTER_A_Info.C2_Gain                                                                 |       0x%03X  |  [RW][29:20]""Gain (Signed)""\n", FIELD_VALUE(val, 20, 29));
	val = REG_DUMP_READ_REGISTER(0xa7058);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_WB_MATRIX_Info                                |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_WB_MATRIX_Info_type */
	REG_DUMP_PRINT_1("   -reg_WB_MATRIX_Info.Pix_0_0                                                                    |         0x%01X  |  [RW][01:00]""Determine Pix Gain ""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -reg_WB_MATRIX_Info.Pix_0_1                                                                    |         0x%01X  |  [RW][03:02]""Determine Pix Gain ""\n", FIELD_VALUE(val, 2, 3));
	REG_DUMP_PRINT_1("   -reg_WB_MATRIX_Info.Pix_0_2                                                                    |         0x%01X  |  [RW][05:04]""Determine Pix Gain ""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -reg_WB_MATRIX_Info.Pix_0_3                                                                    |         0x%01X  |  [RW][07:06]""Determine Pix Gain ""\n", FIELD_VALUE(val, 6, 7));
	REG_DUMP_PRINT_1("   -reg_WB_MATRIX_Info.Pix_1_0                                                                    |         0x%01X  |  [RW][09:08]""Determine Pix Gain ""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -reg_WB_MATRIX_Info.Pix_1_1                                                                    |         0x%01X  |  [RW][11:10]""Determine Pix Gain ""\n", FIELD_VALUE(val, 10, 11));
	REG_DUMP_PRINT_1("   -reg_WB_MATRIX_Info.Pix_1_2                                                                    |         0x%01X  |  [RW][13:12]""Determine Pix Gain ""\n", FIELD_VALUE(val, 12, 13));
	REG_DUMP_PRINT_1("   -reg_WB_MATRIX_Info.Pix_1_3                                                                    |         0x%01X  |  [RW][15:14]""Determine Pix Gain ""\n", FIELD_VALUE(val, 14, 15));
	REG_DUMP_PRINT_1("   -reg_WB_MATRIX_Info.Pix_2_0                                                                    |         0x%01X  |  [RW][17:16]""Determine Pix Gain ""\n", FIELD_VALUE(val, 16, 17));
	REG_DUMP_PRINT_1("   -reg_WB_MATRIX_Info.Pix_2_1                                                                    |         0x%01X  |  [RW][19:18]""Determine Pix Gain ""\n", FIELD_VALUE(val, 18, 19));
	REG_DUMP_PRINT_1("   -reg_WB_MATRIX_Info.Pix_2_2                                                                    |         0x%01X  |  [RW][21:20]""Determine Pix Gain ""\n", FIELD_VALUE(val, 20, 21));
	REG_DUMP_PRINT_1("   -reg_WB_MATRIX_Info.Pix_2_3                                                                    |         0x%01X  |  [RW][23:22]""Determine Pix Gain ""\n", FIELD_VALUE(val, 22, 23));
	REG_DUMP_PRINT_1("   -reg_WB_MATRIX_Info.Pix_3_0                                                                    |         0x%01X  |  [RW][25:24]""Determine Pix Gain ""\n", FIELD_VALUE(val, 24, 25));
	REG_DUMP_PRINT_1("   -reg_WB_MATRIX_Info.Pix_3_1                                                                    |         0x%01X  |  [RW][27:26]""Determine Pix Gain ""\n", FIELD_VALUE(val, 26, 27));
	REG_DUMP_PRINT_1("   -reg_WB_MATRIX_Info.Pix_3_2                                                                    |         0x%01X  |  [RW][29:28]""Determine Pix Gain ""\n", FIELD_VALUE(val, 28, 29));
	REG_DUMP_PRINT_1("   -reg_WB_MATRIX_Info.Pix_3_3                                                                    |         0x%01X  |  [RW][31:30]""Determine Pix Gain ""\n", FIELD_VALUE(val, 30, 31));
	val = REG_DUMP_READ_REGISTER(0xa7054);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_WB_GB_GAINS_Info                              |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_WB_GB_GAINS_Info_type */
	REG_DUMP_PRINT_1("   -reg_WB_GB_GAINS_Info.G_Gain                                                                   |      0x%04X  |  [RW][15:00]""Unsign Gain""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_WB_GB_GAINS_Info.B_Gain                                                                   |      0x%04X  |  [RW][31:16]""Unsign Gain""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xa7050);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_WB_R_GAIN_Info                                |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_WB_R_GAIN_Info_type */
	/* skip, unused field unused_reg_WB_R_GAIN_Info (reg_WB_R_GAIN_Info) */
	REG_DUMP_PRINT_1("   -reg_WB_R_GAIN_Info.R_Gain                                                                     |      0x%04X  |  [RW][15:00]""Unsign Gain""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xa704c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_HW_ASSR_RAW_STAT_Info                         |  0x%08X  |  ""events that took place not gated with the mask register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_HW_ASSR_RAW_STAT_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_RAW_STAT_Info (reg_HW_ASSR_RAW_STAT_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_RAW_STAT_Info.STAT                                                                |         0x%01X  |  [RO][03:00]""hw assertion raw status""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xa7048);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_HW_ASSR_STAT_Info                             |  0x%08X  |  ""events that took place after gated with the mask register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_HW_ASSR_STAT_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_STAT_Info (reg_HW_ASSR_STAT_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_STAT_Info.STAT                                                                    |         0x%01X  |  [RO][03:00]""hw_assertion status""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xa7044);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_HW_ASSR_MASK_Info                             |  0x%08X  |  ""hw assertion mask - note status reflects masks assertions as well""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_HW_ASSR_MASK_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_MASK_Info (reg_HW_ASSR_MASK_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_MASK_Info.MASK                                                                    |         0x%01X  |  [RW][03:00]""mask hw assertion bmp""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xa7040);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_HW_ASSR_CLEAR_Info                            |  0x%08X  |  ""clear latched event from status register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_HW_ASSR_CLEAR_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_CLEAR_Info (reg_HW_ASSR_CLEAR_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_CLEAR_Info.CLEAR                                                                  |         0x%01X  |  [RW][03:00]""clear hw_assertion""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xa703c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DFD_DATA_READ_CMD_Info                        |  0x%08X  |  ""DFD read traced data register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DFD_DATA_READ_CMD_Info_type */
	/* skip, unused field unused_reg_DFD_DATA_READ_CMD_Info (reg_DFD_DATA_READ_CMD_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_DATA_READ_CMD_Info.Fetch                                                              |         0x%01X  |  [RW][00:00]""DFD read traced data register""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xa7038);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DFD_DATA_READ_COMPLETION_Info                 |  0x%08X  |  ""DFD data out from egress Fifo read completion indication""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DFD_DATA_READ_COMPLETION_Info_type */
	/* skip, unused field unused_reg_DFD_DATA_READ_COMPLETION_Info (reg_DFD_DATA_READ_COMPLETION_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_DATA_READ_COMPLETION_Info.Rd_Comp                                                     |         0x%01X  |  [RO][00:00]""DFD traced data out from egress Fifo read completion indication""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xa7034);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DFD_TRACED_DATA_VALID_Info                    |  0x%08X  |  ""DFD traced data Valid""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DFD_TRACED_DATA_VALID_Info_type */
	/* skip, unused field unused_reg_DFD_TRACED_DATA_VALID_Info (reg_DFD_TRACED_DATA_VALID_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_TRACED_DATA_VALID_Info.Data_Valid                                                     |         0x%01X  |  [RO][00:00]""DFD Data VALID""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xa7030);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DFD_TRACED_DATA_Info                          |  0x%08X  |  ""DFD traced data out from egress Fifo - double pixel aligned""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DFD_TRACED_DATA_Info_type */
	REG_DUMP_PRINT_1("   -reg_DFD_TRACED_DATA_Info.Dfd_Traced_Data                                                      |  0x%08X  |  [RO][31:00]""DFD traced data out from egress Fifo - double pixel aligned.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa702c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DFD_SINGLE_STEP_Info                          |  0x%08X  |  ""Enable FF egress for a single transaction when at DFD post trigger state""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DFD_SINGLE_STEP_Info_type */
	/* skip, unused field unused_reg_DFD_SINGLE_STEP_Info (reg_DFD_SINGLE_STEP_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_SINGLE_STEP_Info.Single_Step                                                          |         0x%01X  |  [RW][00:00]""Enable FF egress for a single transaction when at DFD post trigger state.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xa7028);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_DFD_EN_Info                                   |  0x%08X  |  ""Enable DFD feature. React to acb dfdaction command""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_DFD_EN_Info_type */
	/* skip, unused field unused_reg_DFD_EN_Info (reg_DFD_EN_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_EN_Info.Dfd_En                                                                        |         0x%01X  |  [RW][00:00]""Enable DFD feature. React to acb dfdaction command""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -reg_DFD_EN_Info.Use_Prev_Trig_CHAIN                                                           |         0x%01X  |  [RW][04:04]""Use previous DFD Daisy chanied trace and hw assertion ports""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -reg_DFD_EN_Info.Use_Prev_Trace_CHAIN                                                          |         0x%01X  |  [RW][08:08]""Use previous DFD Daisy chanied trace and hw assertion ports""\n", FIELD_VALUE(val, 8, 8));
	val = REG_DUMP_READ_REGISTER(0xa7024);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_PWR_FEATURE_Info                              |  0x%08X  |  ""Power feature register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_PWR_FEATURE_Info_type */
	/* skip, unused field unused_reg_PWR_FEATURE_Info (reg_PWR_FEATURE_Info) */
	REG_DUMP_PRINT_1("   -reg_PWR_FEATURE_Info.Empty_En                                                                 |         0x%01X  |  [RW][00:00]""""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -reg_PWR_FEATURE_Info.MOL_En                                                                   |         0x%01X  |  [RW][01:01]""""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0xa7020);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_FF_SCALER_OUTPUT_FORMATTER_SENSOR_CFG_2_Info  |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_FF_SCALER_OUTPUT_FORMATTER_SENSOR_CFG_2_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_SCALER_OUTPUT_FORMATTER_SENSOR_CFG_2_Info.Pat                                          |  0x%08X  |  [RW][31:00]""ColorID of pixel in CFA pattern Pat_20 - Pat_33 3bit each 4bit alligned""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa701c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_FF_SCALER_OUTPUT_FORMATTER_SENSOR_CFG_1_Info  |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_FF_SCALER_OUTPUT_FORMATTER_SENSOR_CFG_1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_SCALER_OUTPUT_FORMATTER_SENSOR_CFG_1_Info.Pat                                          |  0x%08X  |  [RW][31:00]""ColorID of pixel in CFA pattern Pat_00 - Pat_13 3bit each 4bit alligned""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa7018);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_FF_SCALER_OUTPUT_FORMATTER_SENSOR_CFG_0_Info  |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_FF_SCALER_OUTPUT_FORMATTER_SENSOR_CFG_0_Info_type */
	/* skip, unused field unused_reg_FF_SCALER_OUTPUT_FORMATTER_SENSOR_CFG_0_Info (reg_FF_SCALER_OUTPUT_FORMATTER_SENSOR_CFG_0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_SCALER_OUTPUT_FORMATTER_SENSOR_CFG_0_Info.Sensor_mode_in                               |         0x%01X  |  [RW][01:00]""In CFA Sensor: 0-1x1, 1-2x2, 2-4x4""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -reg_FF_SCALER_OUTPUT_FORMATTER_SENSOR_CFG_0_Info.Sensor_mode_out                              |         0x%01X  |  [RW][05:04]""Out CFA Sensor: 0-1x1, 1-2x2, 2-4x4""\n", FIELD_VALUE(val, 4, 5));
	val = REG_DUMP_READ_REGISTER(0xa7014);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_FF_SCALER_DEMOSAIC_CTRL_0_Info                |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_FF_SCALER_DEMOSAIC_CTRL_0_Info_type */
	/* skip, unused field unused_reg_FF_SCALER_DEMOSAIC_CTRL_0_Info (reg_FF_SCALER_DEMOSAIC_CTRL_0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_SCALER_DEMOSAIC_CTRL_0_Info.WG_Is_First                                                |         0x%01X  |  [RW][00:00]""""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xa7010);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_FF_SCALER_INPUT_FRAME_SIZE_Info               |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_FF_SCALER_INPUT_FRAME_SIZE_Info_type */
	/* skip, unused field unused_reg_FF_SCALER_INPUT_FRAME_SIZE_Info (reg_FF_SCALER_INPUT_FRAME_SIZE_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_SCALER_INPUT_FRAME_SIZE_Info.Input_Frame_Width                                         |      0x%04X  |  [RW][12:00]""Input Frame Width for HW only""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xa700c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_FF_SCALER_OUTPUT_FRAME_SIZE_Info              |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_FF_SCALER_OUTPUT_FRAME_SIZE_Info_type */
	/* skip, unused field unused_reg_FF_SCALER_OUTPUT_FRAME_SIZE_Info (reg_FF_SCALER_OUTPUT_FRAME_SIZE_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_SCALER_OUTPUT_FRAME_SIZE_Info.Output_Frame_Width                                       |      0x%04X  |  [RW][12:00]""Output Frame Width after Box Filter""\n", FIELD_VALUE(val, 0, 12));
	REG_DUMP_PRINT_1("   -reg_FF_SCALER_OUTPUT_FRAME_SIZE_Info.Output_Frame_Height                                      |      0x%04X  |  [RW][28:16]""Output Frame Height after Box Filter""\n", FIELD_VALUE(val, 16, 28));
	val = REG_DUMP_READ_REGISTER(0xa7008);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_FF_SCALER_NORMALIZATION_Info                  |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_FF_SCALER_NORMALIZATION_Info_type */
	/* skip, unused field unused_reg_FF_SCALER_NORMALIZATION_Info (reg_FF_SCALER_NORMALIZATION_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_SCALER_NORMALIZATION_Info.Norm_Mul_Output                                              |        0x%02X  |  [RW][07:00]""""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -reg_FF_SCALER_NORMALIZATION_Info.Norm_Shift_Output                                            |        0x%02X  |  [RW][15:08]""""\n", FIELD_VALUE(val, 8, 15));
	REG_DUMP_PRINT_1("   -reg_FF_SCALER_NORMALIZATION_Info.Norm_Shift_ToLB                                              |         0x%01X  |  [RW][19:16]""""\n", FIELD_VALUE(val, 16, 19));
	val = REG_DUMP_READ_REGISTER(0xa7004);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_FF_SCALER_FACTOR_CTRL_Info                    |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_FF_SCALER_FACTOR_CTRL_Info_type */
	/* skip, unused field unused_reg_FF_SCALER_FACTOR_CTRL_Info (reg_FF_SCALER_FACTOR_CTRL_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_SCALER_FACTOR_CTRL_Info.Scale_factor_numerator_H                                       |        0x%02X  |  [RW][05:00]""""\n", FIELD_VALUE(val, 0, 5));
	REG_DUMP_PRINT_1("   -reg_FF_SCALER_FACTOR_CTRL_Info.Scale_factor_denominator_H                                     |        0x%02X  |  [RW][13:08]""""\n", FIELD_VALUE(val, 8, 13));
	REG_DUMP_PRINT_1("   -reg_FF_SCALER_FACTOR_CTRL_Info.Scale_factor_numerator_V                                       |        0x%02X  |  [RW][21:16]""""\n", FIELD_VALUE(val, 16, 21));
	REG_DUMP_PRINT_1("   -reg_FF_SCALER_FACTOR_CTRL_Info.Scale_factor_denominator_V                                     |        0x%02X  |  [RW][29:24]""""\n", FIELD_VALUE(val, 24, 29));
	val = REG_DUMP_READ_REGISTER(0xa7000);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER.reg_FF_SCALER_GEN_CTRL_Info                       |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER_reg_FF_SCALER_GEN_CTRL_Info_type */
	/* skip, unused field unused_reg_FF_SCALER_GEN_CTRL_Info (reg_FF_SCALER_GEN_CTRL_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_SCALER_GEN_CTRL_Info.FF_En                                                             |         0x%01X  |  [RW][00:00]""Fixed function enabled""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -reg_FF_SCALER_GEN_CTRL_Info.DM_En                                                             |         0x%01X  |  [RW][01:01]""Demosaic enabled""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -reg_FF_SCALER_GEN_CTRL_Info.Box_En                                                            |         0x%01X  |  [RW][02:02]""Box filter enabled""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -reg_FF_SCALER_GEN_CTRL_Info.Input_Is_Bayer                                                    |         0x%01X  |  [RW][03:03]""0-Input is RGBC, 1-Input is Bayer""\n", FIELD_VALUE(val, 3, 3));
} /* end isa_isa_logic_ISA_Cluster_Bayer_Scaler_SCALER */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Input_Corr_INL */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_INL(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa6a30);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_INL.reg_HW_ASSR_RAW_STAT_Info          |  0x%08X  |  ""events that took place not gated with the mask register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_INL_reg_HW_ASSR_RAW_STAT_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_RAW_STAT_Info (reg_HW_ASSR_RAW_STAT_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_RAW_STAT_Info.STAT                                            |         0x%01X  |  [RO][03:00]""hw assertion raw status""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xa6a2c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_INL.reg_HW_ASSR_STAT_Info              |  0x%08X  |  ""events that took place after gated with the mask register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_INL_reg_HW_ASSR_STAT_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_STAT_Info (reg_HW_ASSR_STAT_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_STAT_Info.STAT                                                |         0x%01X  |  [RO][03:00]""hw_assertion status""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xa6a28);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_INL.reg_HW_ASSR_MASK_Info              |  0x%08X  |  ""hw assertion mask - note status reflects masks assertions as well""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_INL_reg_HW_ASSR_MASK_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_MASK_Info (reg_HW_ASSR_MASK_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_MASK_Info.MASK                                                |         0x%01X  |  [RW][03:00]""mask hw assertion bmp""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xa6a24);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_INL.reg_HW_ASSR_CLEAR_Info             |  0x%08X  |  ""clear latched event from status register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_INL_reg_HW_ASSR_CLEAR_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_CLEAR_Info (reg_HW_ASSR_CLEAR_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_CLEAR_Info.CLEAR                                              |         0x%01X  |  [RW][03:00]""clear hw_assertion""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xa6a20);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_INL.reg_DFD_DATA_READ_CMD_Info         |  0x%08X  |  ""DFD read traced data register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_INL_reg_DFD_DATA_READ_CMD_Info_type */
	/* skip, unused field unused_reg_DFD_DATA_READ_CMD_Info (reg_DFD_DATA_READ_CMD_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_DATA_READ_CMD_Info.Fetch                                          |         0x%01X  |  [RW][00:00]""DFD read traced data register""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xa6a1c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_INL.reg_DFD_DATA_READ_COMPLETION_Info  |  0x%08X  |  ""DFD data out from egress Fifo read completion indication""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_INL_reg_DFD_DATA_READ_COMPLETION_Info_type */
	/* skip, unused field unused_reg_DFD_DATA_READ_COMPLETION_Info (reg_DFD_DATA_READ_COMPLETION_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_DATA_READ_COMPLETION_Info.Rd_Comp                                 |         0x%01X  |  [RO][00:00]""DFD traced data out from egress Fifo read completion indication""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xa6a18);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_INL.reg_DFD_TRACED_DATA_VALID_Info     |  0x%08X  |  ""DFD traced data Valid""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_INL_reg_DFD_TRACED_DATA_VALID_Info_type */
	/* skip, unused field unused_reg_DFD_TRACED_DATA_VALID_Info (reg_DFD_TRACED_DATA_VALID_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_TRACED_DATA_VALID_Info.Data_Valid                                 |         0x%01X  |  [RO][00:00]""DFD Data VALID""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xa6a14);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_INL.reg_DFD_TRACED_DATA_Info           |  0x%08X  |  ""DFD traced data out from egress Fifo - double pixel aligned""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_INL_reg_DFD_TRACED_DATA_Info_type */
	REG_DUMP_PRINT_1("   -reg_DFD_TRACED_DATA_Info.Dfd_Traced_Data                                  |  0x%08X  |  [RO][31:00]""DFD traced data out from egress Fifo - double pixel aligned.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa6a10);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_INL.reg_DFD_SINGLE_STEP_Info           |  0x%08X  |  ""Enable FF egress for a single transaction when at DFD post trigger state""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_INL_reg_DFD_SINGLE_STEP_Info_type */
	/* skip, unused field unused_reg_DFD_SINGLE_STEP_Info (reg_DFD_SINGLE_STEP_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_SINGLE_STEP_Info.Single_Step                                      |         0x%01X  |  [RW][00:00]""Enable FF egress for a single transaction when at DFD post trigger state.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xa6a0c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_INL.reg_DFD_EN_Info                    |  0x%08X  |  ""Enable DFD feature. React to acb dfdaction command""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_INL_reg_DFD_EN_Info_type */
	/* skip, unused field unused_reg_DFD_EN_Info (reg_DFD_EN_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_EN_Info.Dfd_En                                                    |         0x%01X  |  [RW][00:00]""Enable DFD feature. React to acb dfdaction command""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -reg_DFD_EN_Info.Use_Prev_Trig_CHAIN                                       |         0x%01X  |  [RW][04:04]""Use previous DFD Daisy chanied trace and hw assertion ports""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -reg_DFD_EN_Info.Use_Prev_Trace_CHAIN                                      |         0x%01X  |  [RW][08:08]""Use previous DFD Daisy chanied trace and hw assertion ports""\n", FIELD_VALUE(val, 8, 8));
	val = REG_DUMP_READ_REGISTER(0xa6a08);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_INL.reg_PWR_FEATURE_Info               |  0x%08X  |  ""Power feature register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_INL_reg_PWR_FEATURE_Info_type */
	/* skip, unused field unused_reg_PWR_FEATURE_Info (reg_PWR_FEATURE_Info) */
	REG_DUMP_PRINT_1("   -reg_PWR_FEATURE_Info.Empty_En                                             |         0x%01X  |  [RW][00:00]""""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -reg_PWR_FEATURE_Info.MOL_En                                               |         0x%01X  |  [RW][01:01]""""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0xa6a04);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_INL.reg_FF_INL_CTRL_Info               |  0x%08X  |  ""FF_INL Control""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_INL_reg_FF_INL_CTRL_Info_type */
	/* skip, unused field unused_reg_FF_INL_CTRL_Info (reg_FF_INL_CTRL_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_INL_CTRL_Info.Lin_En                                               |         0x%01X  |  [RW][00:00]""Linearization Enable""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -reg_FF_INL_CTRL_Info.Val_Bypass                                           |         0x%01X  |  [RW][01:01]""Disable entire FF_INL""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -reg_FF_INL_CTRL_Info.ShiftLDepth                                          |         0x%01X  |  [RW][07:04]""The size of normalization shift. Signed. Range [-3,7]""\n", FIELD_VALUE(val, 4, 7));
	val = REG_DUMP_READ_REGISTER(0xa6a00);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_INL.reg_FF_INL_LUT_256_Info            |  0x%08X  |  ""Normalization LUT Entry 256""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_INL_reg_FF_INL_LUT_256_Info_type */
	/* skip, unused field unused_reg_FF_INL_LUT_256_Info (reg_FF_INL_LUT_256_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_INL_LUT_256_Info.Entry_256                                         |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
} /* end isa_isa_logic_ISA_Cluster_Input_Corr_INL */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Input_Corr_INL_ff_inl_evenodd_lut */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_INL_ff_inl_evenodd_lut(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa69fc);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_INL_ff_inl_evenodd_lut.ff_inl_evenodd_lut_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_INL_ff_inl_evenodd_lut_ff_inl_evenodd_lut_last_type */
	REG_DUMP_PRINT_1("   -ff_inl_evenodd_lut_last.ff_inl_evenodd_lut_last                                     |  0x%08X  |  [RW][31:00]""FF_INL_EVENODD_LUT""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa6800);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_INL_ff_inl_evenodd_lut.ff_inl_evenodd_lut_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_INL_ff_inl_evenodd_lut_ff_inl_evenodd_lut_first_type */
	REG_DUMP_PRINT_1("   -ff_inl_evenodd_lut_first.ff_inl_evenodd_lut_first                                   |  0x%08X  |  [RW][31:00]""FF_INL_EVENODD_LUT""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Input_Corr_INL_ff_inl_evenodd_lut */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Input_Corr_AckConv */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_AckConv(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa6704);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_AckConv.reg_Ack_Addr_Info  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_AckConv_reg_Ack_Addr_Info_type */
	REG_DUMP_PRINT_1("   -reg_Ack_Addr_Info.reg_Ack_Addr_Info                           |  0x%08X  |  [RW][31:00]""Ack Addr iNFO register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa6700);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_AckConv.reg_Ack_Cmd_Info   |  0x%08X  |  ""Ack cMD iNFO register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_AckConv_reg_Ack_Cmd_Info_type */
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.Message                                      |     0x%05X  |  [RW][18:00]""""\n", FIELD_VALUE(val, 0, 18));
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.CMD                                          |         0x%01X  |  [RO][19:19]""""\n", FIELD_VALUE(val, 19, 19));
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.PID                                          |        0x%02X  |  [RW][25:20]""""\n", FIELD_VALUE(val, 20, 25));
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.SID                                          |        0x%02X  |  [RW][31:26]""""\n", FIELD_VALUE(val, 26, 31));
} /* end isa_isa_logic_ISA_Cluster_Input_Corr_AckConv */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Input_Corr_PCLN */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa654c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN.reg_HW_ASSR_RAW_STAT_Info          |  0x%08X  |  ""events that took place not gated with the mask register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_reg_HW_ASSR_RAW_STAT_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_RAW_STAT_Info (reg_HW_ASSR_RAW_STAT_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_RAW_STAT_Info.STAT                                             |         0x%01X  |  [RO][03:00]""hw assertion raw status""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xa6548);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN.reg_HW_ASSR_STAT_Info              |  0x%08X  |  ""events that took place after gated with the mask register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_reg_HW_ASSR_STAT_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_STAT_Info (reg_HW_ASSR_STAT_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_STAT_Info.STAT                                                 |         0x%01X  |  [RO][03:00]""hw_assertion status""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xa6544);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN.reg_HW_ASSR_MASK_Info              |  0x%08X  |  ""hw assertion mask - note status reflects masks assertions as well""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_reg_HW_ASSR_MASK_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_MASK_Info (reg_HW_ASSR_MASK_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_MASK_Info.MASK                                                 |         0x%01X  |  [RW][03:00]""mask hw assertion bmp""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xa6540);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN.reg_HW_ASSR_CLEAR_Info             |  0x%08X  |  ""clear latched event from status register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_reg_HW_ASSR_CLEAR_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_CLEAR_Info (reg_HW_ASSR_CLEAR_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_CLEAR_Info.CLEAR                                               |         0x%01X  |  [RW][03:00]""clear hw_assertion""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xa653c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN.reg_DFD_DATA_READ_CMD_Info         |  0x%08X  |  ""DFD read traced data register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_reg_DFD_DATA_READ_CMD_Info_type */
	/* skip, unused field unused_reg_DFD_DATA_READ_CMD_Info (reg_DFD_DATA_READ_CMD_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_DATA_READ_CMD_Info.Fetch                                           |         0x%01X  |  [RW][00:00]""DFD read traced data register""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xa6538);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN.reg_DFD_DATA_READ_COMPLETION_Info  |  0x%08X  |  ""DFD data out from egress Fifo read completion indication""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_reg_DFD_DATA_READ_COMPLETION_Info_type */
	/* skip, unused field unused_reg_DFD_DATA_READ_COMPLETION_Info (reg_DFD_DATA_READ_COMPLETION_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_DATA_READ_COMPLETION_Info.Rd_Comp                                  |         0x%01X  |  [RO][00:00]""DFD traced data out from egress Fifo read completion indication""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xa6534);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN.reg_DFD_TRACED_DATA_VALID_Info     |  0x%08X  |  ""DFD traced data Valid""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_reg_DFD_TRACED_DATA_VALID_Info_type */
	/* skip, unused field unused_reg_DFD_TRACED_DATA_VALID_Info (reg_DFD_TRACED_DATA_VALID_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_TRACED_DATA_VALID_Info.Data_Valid                                  |         0x%01X  |  [RO][00:00]""DFD Data VALID""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xa6530);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN.reg_DFD_TRACED_DATA_Info           |  0x%08X  |  ""DFD traced data out from egress Fifo - double pixel aligned""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_reg_DFD_TRACED_DATA_Info_type */
	REG_DUMP_PRINT_1("   -reg_DFD_TRACED_DATA_Info.Dfd_Traced_Data                                   |  0x%08X  |  [RO][31:00]""DFD traced data out from egress Fifo - double pixel aligned.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa652c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN.reg_DFD_SINGLE_STEP_Info           |  0x%08X  |  ""Enable FF egress for a single transaction when at DFD post trigger state""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_reg_DFD_SINGLE_STEP_Info_type */
	/* skip, unused field unused_reg_DFD_SINGLE_STEP_Info (reg_DFD_SINGLE_STEP_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_SINGLE_STEP_Info.Single_Step                                       |         0x%01X  |  [RW][00:00]""Enable FF egress for a single transaction when at DFD post trigger state.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xa6528);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN.reg_DFD_EN_Info                    |  0x%08X  |  ""Enable DFD feature. React to acb dfdaction command""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_reg_DFD_EN_Info_type */
	/* skip, unused field unused_reg_DFD_EN_Info (reg_DFD_EN_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_EN_Info.Dfd_En                                                     |         0x%01X  |  [RW][00:00]""Enable DFD feature. React to acb dfdaction command""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -reg_DFD_EN_Info.Use_Prev_Trig_CHAIN                                        |         0x%01X  |  [RW][04:04]""Use previous DFD Daisy chanied trace and hw assertion ports""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -reg_DFD_EN_Info.Use_Prev_Trace_CHAIN                                       |         0x%01X  |  [RW][08:08]""Use previous DFD Daisy chanied trace and hw assertion ports""\n", FIELD_VALUE(val, 8, 8));
	val = REG_DUMP_READ_REGISTER(0xa6524);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN.reg_PWR_FEATURE_Info               |  0x%08X  |  ""Power feature register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_reg_PWR_FEATURE_Info_type */
	/* skip, unused field unused_reg_PWR_FEATURE_Info (reg_PWR_FEATURE_Info) */
	REG_DUMP_PRINT_1("   -reg_PWR_FEATURE_Info.Empty_En                                              |         0x%01X  |  [RW][00:00]""""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -reg_PWR_FEATURE_Info.MOL_En                                                |         0x%01X  |  [RW][01:01]""""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0xa6520);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN.reg_FF_PCLN_CTRL_Info              |  0x%08X  |  ""FF_PCLN Control""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_reg_FF_PCLN_CTRL_Info_type */
	/* skip, unused field unused_reg_FF_PCLN_CTRL_Info (reg_FF_PCLN_CTRL_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_PCLN_CTRL_Info.PCLN_En                                              |         0x%01X  |  [RW][00:00]""PCLN Enable""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -reg_FF_PCLN_CTRL_Info.Sensor_mode                                          |         0x%01X  |  [RW][05:04]""CFA Sensor: 0-1x1, 1-2x2, 2-4x4""\n", FIELD_VALUE(val, 4, 5));
	val = REG_DUMP_READ_REGISTER(0xa651c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN.reg_FF_PCLN_LUT_64_ID7_Info        |  0x%08X  |  ""NFF_PCLN LUT_ID7 Entry 64""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_reg_FF_PCLN_LUT_64_ID7_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_PCLN_LUT_64_ID7_Info.Entry_64                                       |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa6518);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN.reg_FF_PCLN_LUT_64_ID6_Info        |  0x%08X  |  ""NFF_PCLN LUT_ID6 Entry 64""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_reg_FF_PCLN_LUT_64_ID6_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_PCLN_LUT_64_ID6_Info.Entry_64                                       |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa6514);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN.reg_FF_PCLN_LUT_64_ID5_Info        |  0x%08X  |  ""NFF_PCLN LUT_ID5 Entry 64""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_reg_FF_PCLN_LUT_64_ID5_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_PCLN_LUT_64_ID5_Info.Entry_64                                       |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa6510);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN.reg_FF_PCLN_LUT_64_ID4_Info        |  0x%08X  |  ""NFF_PCLN LUT_ID4 Entry 64""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_reg_FF_PCLN_LUT_64_ID4_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_PCLN_LUT_64_ID4_Info.Entry_64                                       |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa650c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN.reg_FF_PCLN_LUT_64_ID3_Info        |  0x%08X  |  ""NFF_PCLN LUT_ID3 Entry 64""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_reg_FF_PCLN_LUT_64_ID3_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_PCLN_LUT_64_ID3_Info.Entry_64                                       |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa6508);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN.reg_FF_PCLN_LUT_64_ID2_Info        |  0x%08X  |  ""NFF_PCLN LUT_ID2 Entry 64""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_reg_FF_PCLN_LUT_64_ID2_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_PCLN_LUT_64_ID2_Info.Entry_64                                       |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa6504);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN.reg_FF_PCLN_LUT_64_ID1_Info        |  0x%08X  |  ""NFF_PCLN LUT_ID1 Entry 64""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_reg_FF_PCLN_LUT_64_ID1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_PCLN_LUT_64_ID1_Info.Entry_64                                       |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa6500);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN.reg_FF_PCLN_LUT_64_ID0_Info        |  0x%08X  |  ""NFF_PCLN LUT_ID0 Entry 64""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_reg_FF_PCLN_LUT_64_ID0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_PCLN_LUT_64_ID0_Info.Entry_64                                       |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Input_Corr_PCLN */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id15 */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id15(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa64fc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id15.ff_pcln_lut_id15_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id15_ff_pcln_lut_id15_last_type */
	REG_DUMP_PRINT_1("   -ff_pcln_lut_id15_last.ff_pcln_lut_id15_last                                      |  0x%08X  |  [RW][31:00]""FF_PCLN_LUT_ID15""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa6480);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id15.ff_pcln_lut_id15_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id15_ff_pcln_lut_id15_first_type */
	REG_DUMP_PRINT_1("   -ff_pcln_lut_id15_first.ff_pcln_lut_id15_first                                    |  0x%08X  |  [RW][31:00]""FF_PCLN_LUT_ID15""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id15 */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id14 */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id14(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa647c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id14.ff_pcln_lut_id14_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id14_ff_pcln_lut_id14_last_type */
	REG_DUMP_PRINT_1("   -ff_pcln_lut_id14_last.ff_pcln_lut_id14_last                                      |  0x%08X  |  [RW][31:00]""FF_PCLN_LUT_ID14""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa6400);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id14.ff_pcln_lut_id14_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id14_ff_pcln_lut_id14_first_type */
	REG_DUMP_PRINT_1("   -ff_pcln_lut_id14_first.ff_pcln_lut_id14_first                                    |  0x%08X  |  [RW][31:00]""FF_PCLN_LUT_ID14""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id14 */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id13 */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id13(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa63fc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id13.ff_pcln_lut_id13_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id13_ff_pcln_lut_id13_last_type */
	REG_DUMP_PRINT_1("   -ff_pcln_lut_id13_last.ff_pcln_lut_id13_last                                      |  0x%08X  |  [RW][31:00]""FF_PCLN_LUT_ID13""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa6380);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id13.ff_pcln_lut_id13_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id13_ff_pcln_lut_id13_first_type */
	REG_DUMP_PRINT_1("   -ff_pcln_lut_id13_first.ff_pcln_lut_id13_first                                    |  0x%08X  |  [RW][31:00]""FF_PCLN_LUT_ID13""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id13 */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id12 */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id12(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa637c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id12.ff_pcln_lut_id12_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id12_ff_pcln_lut_id12_last_type */
	REG_DUMP_PRINT_1("   -ff_pcln_lut_id12_last.ff_pcln_lut_id12_last                                      |  0x%08X  |  [RW][31:00]""FF_PCLN_LUT_ID12""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa6300);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id12.ff_pcln_lut_id12_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id12_ff_pcln_lut_id12_first_type */
	REG_DUMP_PRINT_1("   -ff_pcln_lut_id12_first.ff_pcln_lut_id12_first                                    |  0x%08X  |  [RW][31:00]""FF_PCLN_LUT_ID12""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id12 */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id11 */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id11(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa62fc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id11.ff_pcln_lut_id11_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id11_ff_pcln_lut_id11_last_type */
	REG_DUMP_PRINT_1("   -ff_pcln_lut_id11_last.ff_pcln_lut_id11_last                                      |  0x%08X  |  [RW][31:00]""FF_PCLN_LUT_ID11""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa6280);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id11.ff_pcln_lut_id11_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id11_ff_pcln_lut_id11_first_type */
	REG_DUMP_PRINT_1("   -ff_pcln_lut_id11_first.ff_pcln_lut_id11_first                                    |  0x%08X  |  [RW][31:00]""FF_PCLN_LUT_ID11""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id11 */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id10 */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id10(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa627c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id10.ff_pcln_lut_id10_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id10_ff_pcln_lut_id10_last_type */
	REG_DUMP_PRINT_1("   -ff_pcln_lut_id10_last.ff_pcln_lut_id10_last                                      |  0x%08X  |  [RW][31:00]""FF_PCLN_LUT_ID10""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa6200);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id10.ff_pcln_lut_id10_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id10_ff_pcln_lut_id10_first_type */
	REG_DUMP_PRINT_1("   -ff_pcln_lut_id10_first.ff_pcln_lut_id10_first                                    |  0x%08X  |  [RW][31:00]""FF_PCLN_LUT_ID10""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id10 */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id9 */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id9(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa61fc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id9.ff_pcln_lut_id9_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id9_ff_pcln_lut_id9_last_type */
	REG_DUMP_PRINT_1("   -ff_pcln_lut_id9_last.ff_pcln_lut_id9_last                                      |  0x%08X  |  [RW][31:00]""FF_PCLN_LUT_ID9""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa6180);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id9.ff_pcln_lut_id9_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id9_ff_pcln_lut_id9_first_type */
	REG_DUMP_PRINT_1("   -ff_pcln_lut_id9_first.ff_pcln_lut_id9_first                                    |  0x%08X  |  [RW][31:00]""FF_PCLN_LUT_ID9""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id9 */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id8 */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id8(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa617c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id8.ff_pcln_lut_id8_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id8_ff_pcln_lut_id8_last_type */
	REG_DUMP_PRINT_1("   -ff_pcln_lut_id8_last.ff_pcln_lut_id8_last                                      |  0x%08X  |  [RW][31:00]""FF_PCLN_LUT_ID8""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa6100);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id8.ff_pcln_lut_id8_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id8_ff_pcln_lut_id8_first_type */
	REG_DUMP_PRINT_1("   -ff_pcln_lut_id8_first.ff_pcln_lut_id8_first                                    |  0x%08X  |  [RW][31:00]""FF_PCLN_LUT_ID8""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id8 */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id7 */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id7(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa60fc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id7.ff_pcln_lut_id7_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id7_ff_pcln_lut_id7_last_type */
	REG_DUMP_PRINT_1("   -ff_pcln_lut_id7_last.ff_pcln_lut_id7_last                                      |  0x%08X  |  [RW][31:00]""FF_PCLN_LUT_ID7""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa6080);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id7.ff_pcln_lut_id7_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id7_ff_pcln_lut_id7_first_type */
	REG_DUMP_PRINT_1("   -ff_pcln_lut_id7_first.ff_pcln_lut_id7_first                                    |  0x%08X  |  [RW][31:00]""FF_PCLN_LUT_ID7""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id7 */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id6 */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id6(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa607c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id6.ff_pcln_lut_id6_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id6_ff_pcln_lut_id6_last_type */
	REG_DUMP_PRINT_1("   -ff_pcln_lut_id6_last.ff_pcln_lut_id6_last                                      |  0x%08X  |  [RW][31:00]""FF_PCLN_LUT_ID6""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa6000);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id6.ff_pcln_lut_id6_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id6_ff_pcln_lut_id6_first_type */
	REG_DUMP_PRINT_1("   -ff_pcln_lut_id6_first.ff_pcln_lut_id6_first                                    |  0x%08X  |  [RW][31:00]""FF_PCLN_LUT_ID6""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id6 */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id5 */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id5(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa5ffc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id5.ff_pcln_lut_id5_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id5_ff_pcln_lut_id5_last_type */
	REG_DUMP_PRINT_1("   -ff_pcln_lut_id5_last.ff_pcln_lut_id5_last                                      |  0x%08X  |  [RW][31:00]""FF_PCLN_LUT_ID5""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa5f80);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id5.ff_pcln_lut_id5_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id5_ff_pcln_lut_id5_first_type */
	REG_DUMP_PRINT_1("   -ff_pcln_lut_id5_first.ff_pcln_lut_id5_first                                    |  0x%08X  |  [RW][31:00]""FF_PCLN_LUT_ID5""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id5 */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id4 */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id4(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa5f7c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id4.ff_pcln_lut_id4_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id4_ff_pcln_lut_id4_last_type */
	REG_DUMP_PRINT_1("   -ff_pcln_lut_id4_last.ff_pcln_lut_id4_last                                      |  0x%08X  |  [RW][31:00]""FF_PCLN_LUT_ID4""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa5f00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id4.ff_pcln_lut_id4_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id4_ff_pcln_lut_id4_first_type */
	REG_DUMP_PRINT_1("   -ff_pcln_lut_id4_first.ff_pcln_lut_id4_first                                    |  0x%08X  |  [RW][31:00]""FF_PCLN_LUT_ID4""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id4 */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id3 */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id3(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa5efc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id3.ff_pcln_lut_id3_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id3_ff_pcln_lut_id3_last_type */
	REG_DUMP_PRINT_1("   -ff_pcln_lut_id3_last.ff_pcln_lut_id3_last                                      |  0x%08X  |  [RW][31:00]""FF_PCLN_LUT_ID3""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa5e80);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id3.ff_pcln_lut_id3_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id3_ff_pcln_lut_id3_first_type */
	REG_DUMP_PRINT_1("   -ff_pcln_lut_id3_first.ff_pcln_lut_id3_first                                    |  0x%08X  |  [RW][31:00]""FF_PCLN_LUT_ID3""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id3 */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id2 */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id2(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa5e7c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id2.ff_pcln_lut_id2_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id2_ff_pcln_lut_id2_last_type */
	REG_DUMP_PRINT_1("   -ff_pcln_lut_id2_last.ff_pcln_lut_id2_last                                      |  0x%08X  |  [RW][31:00]""FF_PCLN_LUT_ID2""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa5e00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id2.ff_pcln_lut_id2_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id2_ff_pcln_lut_id2_first_type */
	REG_DUMP_PRINT_1("   -ff_pcln_lut_id2_first.ff_pcln_lut_id2_first                                    |  0x%08X  |  [RW][31:00]""FF_PCLN_LUT_ID2""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id2 */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id1 */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id1(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa5dfc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id1.ff_pcln_lut_id1_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id1_ff_pcln_lut_id1_last_type */
	REG_DUMP_PRINT_1("   -ff_pcln_lut_id1_last.ff_pcln_lut_id1_last                                      |  0x%08X  |  [RW][31:00]""FF_PCLN_LUT_ID1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa5d80);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id1.ff_pcln_lut_id1_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id1_ff_pcln_lut_id1_first_type */
	REG_DUMP_PRINT_1("   -ff_pcln_lut_id1_first.ff_pcln_lut_id1_first                                    |  0x%08X  |  [RW][31:00]""FF_PCLN_LUT_ID1""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id1 */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id0 */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id0(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa5d7c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id0.ff_pcln_lut_id0_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id0_ff_pcln_lut_id0_last_type */
	REG_DUMP_PRINT_1("   -ff_pcln_lut_id0_last.ff_pcln_lut_id0_last                                      |  0x%08X  |  [RW][31:00]""FF_PCLN_LUT_ID0""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa5d00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id0.ff_pcln_lut_id0_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id0_ff_pcln_lut_id0_first_type */
	REG_DUMP_PRINT_1("   -ff_pcln_lut_id0_first.ff_pcln_lut_id0_first                                    |  0x%08X  |  [RW][31:00]""FF_PCLN_LUT_ID0""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Input_Corr_PCLN_ff_pcln_lut_id0 */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Input_Corr_GBL */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_GBL(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa5c54);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL.reg_HW_ASSR_RAW_STAT_Info          |  0x%08X  |  ""events that took place not gated with the mask register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_reg_HW_ASSR_RAW_STAT_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_RAW_STAT_Info (reg_HW_ASSR_RAW_STAT_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_RAW_STAT_Info.STAT                                            |         0x%01X  |  [RO][03:00]""hw assertion raw status""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xa5c50);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL.reg_HW_ASSR_STAT_Info              |  0x%08X  |  ""events that took place after gated with the mask register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_reg_HW_ASSR_STAT_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_STAT_Info (reg_HW_ASSR_STAT_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_STAT_Info.STAT                                                |         0x%01X  |  [RO][03:00]""hw_assertion status""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xa5c4c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL.reg_HW_ASSR_MASK_Info              |  0x%08X  |  ""hw assertion mask - note status reflects masks assertions as well""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_reg_HW_ASSR_MASK_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_MASK_Info (reg_HW_ASSR_MASK_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_MASK_Info.MASK                                                |         0x%01X  |  [RW][03:00]""mask hw assertion bmp""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xa5c48);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL.reg_HW_ASSR_CLEAR_Info             |  0x%08X  |  ""clear latched event from status register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_reg_HW_ASSR_CLEAR_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_CLEAR_Info (reg_HW_ASSR_CLEAR_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_CLEAR_Info.CLEAR                                              |         0x%01X  |  [RW][03:00]""clear hw_assertion""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xa5c44);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL.reg_DFD_DATA_READ_CMD_Info         |  0x%08X  |  ""DFD read traced data register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_reg_DFD_DATA_READ_CMD_Info_type */
	/* skip, unused field unused_reg_DFD_DATA_READ_CMD_Info (reg_DFD_DATA_READ_CMD_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_DATA_READ_CMD_Info.Fetch                                          |         0x%01X  |  [RW][00:00]""DFD read traced data register""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xa5c40);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL.reg_DFD_DATA_READ_COMPLETION_Info  |  0x%08X  |  ""DFD data out from egress Fifo read completion indication""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_reg_DFD_DATA_READ_COMPLETION_Info_type */
	/* skip, unused field unused_reg_DFD_DATA_READ_COMPLETION_Info (reg_DFD_DATA_READ_COMPLETION_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_DATA_READ_COMPLETION_Info.Rd_Comp                                 |         0x%01X  |  [RO][00:00]""DFD traced data out from egress Fifo read completion indication""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xa5c3c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL.reg_DFD_TRACED_DATA_VALID_Info     |  0x%08X  |  ""DFD traced data Valid""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_reg_DFD_TRACED_DATA_VALID_Info_type */
	/* skip, unused field unused_reg_DFD_TRACED_DATA_VALID_Info (reg_DFD_TRACED_DATA_VALID_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_TRACED_DATA_VALID_Info.Data_Valid                                 |         0x%01X  |  [RO][00:00]""DFD Data VALID""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xa5c38);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL.reg_DFD_TRACED_DATA_Info           |  0x%08X  |  ""DFD traced data out from egress Fifo - double pixel aligned""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_reg_DFD_TRACED_DATA_Info_type */
	REG_DUMP_PRINT_1("   -reg_DFD_TRACED_DATA_Info.Dfd_Traced_Data                                  |  0x%08X  |  [RO][31:00]""DFD traced data out from egress Fifo - double pixel aligned.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa5c34);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL.reg_DFD_SINGLE_STEP_Info           |  0x%08X  |  ""Enable FF egress for a single transaction when at DFD post trigger state""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_reg_DFD_SINGLE_STEP_Info_type */
	/* skip, unused field unused_reg_DFD_SINGLE_STEP_Info (reg_DFD_SINGLE_STEP_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_SINGLE_STEP_Info.Single_Step                                      |         0x%01X  |  [RW][00:00]""Enable FF egress for a single transaction when at DFD post trigger state.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xa5c30);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL.reg_DFD_EN_Info                    |  0x%08X  |  ""Enable DFD feature. React to acb dfdaction command""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_reg_DFD_EN_Info_type */
	/* skip, unused field unused_reg_DFD_EN_Info (reg_DFD_EN_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_EN_Info.Dfd_En                                                    |         0x%01X  |  [RW][00:00]""Enable DFD feature. React to acb dfdaction command""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -reg_DFD_EN_Info.Use_Prev_Trig_CHAIN                                       |         0x%01X  |  [RW][04:04]""Use previous DFD Daisy chanied trace and hw assertion ports""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -reg_DFD_EN_Info.Use_Prev_Trace_CHAIN                                      |         0x%01X  |  [RW][08:08]""Use previous DFD Daisy chanied trace and hw assertion ports""\n", FIELD_VALUE(val, 8, 8));
	val = REG_DUMP_READ_REGISTER(0xa5c2c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL.reg_PWR_FEATURE_Info               |  0x%08X  |  ""Power feature register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_reg_PWR_FEATURE_Info_type */
	/* skip, unused field unused_reg_PWR_FEATURE_Info (reg_PWR_FEATURE_Info) */
	REG_DUMP_PRINT_1("   -reg_PWR_FEATURE_Info.Empty_En                                             |         0x%01X  |  [RW][00:00]""""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -reg_PWR_FEATURE_Info.MOL_En                                               |         0x%01X  |  [RW][01:01]""""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0xa5c28);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL.reg_FF_GLOBAL_BL_BIAS_7_Info       |  0x%08X  |  ""FF_GLOBAL_BL Bias 7""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_reg_FF_GLOBAL_BL_BIAS_7_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GLOBAL_BL_BIAS_7_Info.FixObC32                                     |      0x%04X  |  [RW][15:00]""Global BL Bias for Channel ID 32""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_FF_GLOBAL_BL_BIAS_7_Info.FixObC33                                     |      0x%04X  |  [RW][31:16]""Global BL Bias for Channel ID 33""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xa5c24);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL.reg_FF_GLOBAL_BL_BIAS_6_Info       |  0x%08X  |  ""FF_GLOBAL_BL Bias 6""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_reg_FF_GLOBAL_BL_BIAS_6_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GLOBAL_BL_BIAS_6_Info.FixObC30                                     |      0x%04X  |  [RW][15:00]""Global BL Bias for Channel ID 30""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_FF_GLOBAL_BL_BIAS_6_Info.FixObC31                                     |      0x%04X  |  [RW][31:16]""Global BL Bias for Channel ID 31""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xa5c20);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL.reg_FF_GLOBAL_BL_BIAS_5_Info       |  0x%08X  |  ""FF_GLOBAL_BL Bias 5""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_reg_FF_GLOBAL_BL_BIAS_5_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GLOBAL_BL_BIAS_5_Info.FixObC22                                     |      0x%04X  |  [RW][15:00]""Global BL Bias for Channel ID 22""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_FF_GLOBAL_BL_BIAS_5_Info.FixObC23                                     |      0x%04X  |  [RW][31:16]""Global BL Bias for Channel ID 23""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xa5c1c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL.reg_FF_GLOBAL_BL_BIAS_4_Info       |  0x%08X  |  ""FF_GLOBAL_BL Bias 4""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_reg_FF_GLOBAL_BL_BIAS_4_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GLOBAL_BL_BIAS_4_Info.FixObC20                                     |      0x%04X  |  [RW][15:00]""Global BL Bias for Channel ID 20""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_FF_GLOBAL_BL_BIAS_4_Info.FixObC21                                     |      0x%04X  |  [RW][31:16]""Global BL Bias for Channel ID 21""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xa5c18);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL.reg_FF_GLOBAL_BL_BIAS_3_Info       |  0x%08X  |  ""FF_GLOBAL_BL Bias 3""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_reg_FF_GLOBAL_BL_BIAS_3_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GLOBAL_BL_BIAS_3_Info.FixObC12                                     |      0x%04X  |  [RW][15:00]""Global BL Bias for Channel ID 12""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_FF_GLOBAL_BL_BIAS_3_Info.FixObC13                                     |      0x%04X  |  [RW][31:16]""Global BL Bias for Channel ID 13""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xa5c14);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL.reg_FF_GLOBAL_BL_BIAS_2_Info       |  0x%08X  |  ""FF_GLOBAL_BL Bias 2""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_reg_FF_GLOBAL_BL_BIAS_2_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GLOBAL_BL_BIAS_2_Info.FixObC10                                     |      0x%04X  |  [RW][15:00]""Global BL Bias for Channel ID 10""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_FF_GLOBAL_BL_BIAS_2_Info.FixObC11                                     |      0x%04X  |  [RW][31:16]""Global BL Bias for Channel ID 11""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xa5c10);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL.reg_FF_GLOBAL_BL_BIAS_1_Info       |  0x%08X  |  ""FF_GLOBAL_BL Bias 1""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_reg_FF_GLOBAL_BL_BIAS_1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GLOBAL_BL_BIAS_1_Info.FixObC02                                     |      0x%04X  |  [RW][15:00]""Global BL Bias for Channel ID 02""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_FF_GLOBAL_BL_BIAS_1_Info.FixObC03                                     |      0x%04X  |  [RW][31:16]""Global BL Bias for Channel ID 04""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xa5c0c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL.reg_FF_GLOBAL_BL_BIAS_0_Info       |  0x%08X  |  ""FF_GLOBAL_BL Bias 0""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_reg_FF_GLOBAL_BL_BIAS_0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GLOBAL_BL_BIAS_0_Info.FixObC00                                     |      0x%04X  |  [RW][15:00]""Global BL Bias for Channel ID 00""\n", FIELD_VALUE(val, 0, 15));
	REG_DUMP_PRINT_1("   -reg_FF_GLOBAL_BL_BIAS_0_Info.FixObC01                                     |      0x%04X  |  [RW][31:16]""Global BL Bias for Channel ID 01""\n", FIELD_VALUE(val, 16, 31));
	val = REG_DUMP_READ_REGISTER(0xa5c08);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL.reg_FF_GBL_GRD_CFG2_Info           |  0x%08X  |  ""FF_GBL Grid config 2""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_reg_FF_GBL_GRD_CFG2_Info_type */
	/* skip, unused field unused_reg_FF_GBL_GRD_CFG2_Info (reg_FF_GBL_GRD_CFG2_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GBL_GRD_CFG2_Info.init_set_vrt_offst_ul                            |        0x%02X  |  [RW][07:00]""The initial SetVrtOffstUL of the frame""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -reg_FF_GBL_GRD_CFG2_Info.Grid_BL_En                                       |         0x%01X  |  [RW][08:08]""Enable bit for the gird BL""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -reg_FF_GBL_GRD_CFG2_Info.Global_BL_En                                     |         0x%01X  |  [RW][09:09]""Enable bit for the global BL""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -reg_FF_GBL_GRD_CFG2_Info.FF_En                                            |         0x%01X  |  [RW][10:10]""Enable bit for the Fixed function enable""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -reg_FF_GBL_GRD_CFG2_Info.Sensor_mode                                      |         0x%01X  |  [RW][17:16]""CFA Sensor: 0-1x1, 1-2x2, 2-4x4""\n", FIELD_VALUE(val, 16, 17));
	REG_DUMP_PRINT_1("   -reg_FF_GBL_GRD_CFG2_Info.SOL_BUBBLE_DISABLE_CB                            |         0x%01X  |  [RW][20:20]""""\n", FIELD_VALUE(val, 20, 20));
	REG_DUMP_PRINT_1("   -reg_FF_GBL_GRD_CFG2_Info.EOL_BUBBLE_DISABLE_CB                            |         0x%01X  |  [RW][21:21]""""\n", FIELD_VALUE(val, 21, 21));
	val = REG_DUMP_READ_REGISTER(0xa5c04);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL.reg_FF_GBL_GRD_CFG1_Info           |  0x%08X  |  ""FF_GBL Grid config 1""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_reg_FF_GBL_GRD_CFG1_Info_type */
	/* skip, unused field unused_reg_FF_GBL_GRD_CFG1_Info (reg_FF_GBL_GRD_CFG1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GBL_GRD_CFG1_Info.x_start                                          |      0x%04X  |  [RW][14:00]""X top left corner of the grid in relation to the top left pixel of the frame""\n", FIELD_VALUE(val, 0, 14));
	REG_DUMP_PRINT_1("   -reg_FF_GBL_GRD_CFG1_Info.y_start                                          |      0x%04X  |  [RW][30:16]""Y top left corner of the grid in relation to the top left pixel of the frame""\n", FIELD_VALUE(val, 16, 30));
	val = REG_DUMP_READ_REGISTER(0xa5c00);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL.reg_FF_GBL_GRD_CFG0_Info           |  0x%08X  |  ""FF_GBL Grid config 0""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_reg_FF_GBL_GRD_CFG0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GBL_GRD_CFG0_Info.grid_width                                       |        0x%02X  |  [RW][07:00]""Indicates number of grid vertices on the horizontal axis""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -reg_FF_GBL_GRD_CFG0_Info.grid_height                                      |        0x%02X  |  [RW][15:08]""Indicates number of grid vertices on the vertical axis""\n", FIELD_VALUE(val, 8, 15));
	REG_DUMP_PRINT_1("   -reg_FF_GBL_GRD_CFG0_Info.block_width                                      |         0x%01X  |  [RW][19:16]""Log2 of the cell's width""\n", FIELD_VALUE(val, 16, 19));
	REG_DUMP_PRINT_1("   -reg_FF_GBL_GRD_CFG0_Info.block_height                                     |         0x%01X  |  [RW][23:20]""Log2 of the cell's height""\n", FIELD_VALUE(val, 20, 23));
	REG_DUMP_PRINT_1("   -reg_FF_GBL_GRD_CFG0_Info.grid_height_per_slice                            |        0x%02X  |  [RW][31:24]""Indicates number of vertices in the vertical axis per configuration set""\n", FIELD_VALUE(val, 24, 31));
} /* end isa_isa_logic_ISA_Cluster_Input_Corr_GBL */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch3 */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch3(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa5bfc);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch3.lut_ch3_set2_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch3_lut_ch3_set2_last_type */
	REG_DUMP_PRINT_1("   -lut_ch3_set2_last.lut_ch3_set2_last                                       |  0x%08X  |  [RW][31:00]""LUT_SET2""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa5b00);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch3.lut_ch3_set2_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch3_lut_ch3_set2_first_type */
	REG_DUMP_PRINT_1("   -lut_ch3_set2_first.lut_ch3_set2_first                                     |  0x%08X  |  [RW][31:00]""LUT_SET2""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa5afc);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch3.lut_ch3_set1_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch3_lut_ch3_set1_last_type */
	REG_DUMP_PRINT_1("   -lut_ch3_set1_last.lut_ch3_set1_last                                       |  0x%08X  |  [RW][31:00]""LUT_SET1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa5a00);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch3.lut_ch3_set1_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch3_lut_ch3_set1_first_type */
	REG_DUMP_PRINT_1("   -lut_ch3_set1_first.lut_ch3_set1_first                                     |  0x%08X  |  [RW][31:00]""LUT_SET1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa59fc);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch3.lut_ch3_set0_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch3_lut_ch3_set0_last_type */
	REG_DUMP_PRINT_1("   -lut_ch3_set0_last.lut_ch3_set0_last                                       |  0x%08X  |  [RW][31:00]""LUT_SET0""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa5900);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch3.lut_ch3_set0_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch3_lut_ch3_set0_first_type */
	REG_DUMP_PRINT_1("   -lut_ch3_set0_first.lut_ch3_set0_first                                     |  0x%08X  |  [RW][31:00]""LUT_SET0""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch3 */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch2 */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch2(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa58fc);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch2.lut_ch2_set2_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch2_lut_ch2_set2_last_type */
	REG_DUMP_PRINT_1("   -lut_ch2_set2_last.lut_ch2_set2_last                                       |  0x%08X  |  [RW][31:00]""LUT_SET2""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa5800);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch2.lut_ch2_set2_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch2_lut_ch2_set2_first_type */
	REG_DUMP_PRINT_1("   -lut_ch2_set2_first.lut_ch2_set2_first                                     |  0x%08X  |  [RW][31:00]""LUT_SET2""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa57fc);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch2.lut_ch2_set1_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch2_lut_ch2_set1_last_type */
	REG_DUMP_PRINT_1("   -lut_ch2_set1_last.lut_ch2_set1_last                                       |  0x%08X  |  [RW][31:00]""LUT_SET1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa5700);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch2.lut_ch2_set1_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch2_lut_ch2_set1_first_type */
	REG_DUMP_PRINT_1("   -lut_ch2_set1_first.lut_ch2_set1_first                                     |  0x%08X  |  [RW][31:00]""LUT_SET1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa56fc);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch2.lut_ch2_set0_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch2_lut_ch2_set0_last_type */
	REG_DUMP_PRINT_1("   -lut_ch2_set0_last.lut_ch2_set0_last                                       |  0x%08X  |  [RW][31:00]""LUT_SET0""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa5600);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch2.lut_ch2_set0_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch2_lut_ch2_set0_first_type */
	REG_DUMP_PRINT_1("   -lut_ch2_set0_first.lut_ch2_set0_first                                     |  0x%08X  |  [RW][31:00]""LUT_SET0""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch2 */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch1 */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch1(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa55fc);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch1.lut_ch1_set2_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch1_lut_ch1_set2_last_type */
	REG_DUMP_PRINT_1("   -lut_ch1_set2_last.lut_ch1_set2_last                                       |  0x%08X  |  [RW][31:00]""LUT_SET2""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa5500);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch1.lut_ch1_set2_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch1_lut_ch1_set2_first_type */
	REG_DUMP_PRINT_1("   -lut_ch1_set2_first.lut_ch1_set2_first                                     |  0x%08X  |  [RW][31:00]""LUT_SET2""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa54fc);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch1.lut_ch1_set1_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch1_lut_ch1_set1_last_type */
	REG_DUMP_PRINT_1("   -lut_ch1_set1_last.lut_ch1_set1_last                                       |  0x%08X  |  [RW][31:00]""LUT_SET1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa5400);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch1.lut_ch1_set1_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch1_lut_ch1_set1_first_type */
	REG_DUMP_PRINT_1("   -lut_ch1_set1_first.lut_ch1_set1_first                                     |  0x%08X  |  [RW][31:00]""LUT_SET1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa53fc);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch1.lut_ch1_set0_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch1_lut_ch1_set0_last_type */
	REG_DUMP_PRINT_1("   -lut_ch1_set0_last.lut_ch1_set0_last                                       |  0x%08X  |  [RW][31:00]""LUT_SET0""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa5300);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch1.lut_ch1_set0_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch1_lut_ch1_set0_first_type */
	REG_DUMP_PRINT_1("   -lut_ch1_set0_first.lut_ch1_set0_first                                     |  0x%08X  |  [RW][31:00]""LUT_SET0""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch1 */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch0 */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch0(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa52fc);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch0.lut_ch0_set2_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch0_lut_ch0_set2_last_type */
	REG_DUMP_PRINT_1("   -lut_ch0_set2_last.lut_ch0_set2_last                                       |  0x%08X  |  [RW][31:00]""LUT_SET2""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa5200);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch0.lut_ch0_set2_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch0_lut_ch0_set2_first_type */
	REG_DUMP_PRINT_1("   -lut_ch0_set2_first.lut_ch0_set2_first                                     |  0x%08X  |  [RW][31:00]""LUT_SET2""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa51fc);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch0.lut_ch0_set1_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch0_lut_ch0_set1_last_type */
	REG_DUMP_PRINT_1("   -lut_ch0_set1_last.lut_ch0_set1_last                                       |  0x%08X  |  [RW][31:00]""LUT_SET1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa5100);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch0.lut_ch0_set1_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch0_lut_ch0_set1_first_type */
	REG_DUMP_PRINT_1("   -lut_ch0_set1_first.lut_ch0_set1_first                                     |  0x%08X  |  [RW][31:00]""LUT_SET1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa50fc);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch0.lut_ch0_set0_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch0_lut_ch0_set0_last_type */
	REG_DUMP_PRINT_1("   -lut_ch0_set0_last.lut_ch0_set0_last                                       |  0x%08X  |  [RW][31:00]""LUT_SET0""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa5000);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch0.lut_ch0_set0_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch0_lut_ch0_set0_first_type */
	REG_DUMP_PRINT_1("   -lut_ch0_set0_first.lut_ch0_set0_first                                     |  0x%08X  |  [RW][31:00]""LUT_SET0""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Input_Corr_GBL_ff_gbl_lut_ch0 */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Bayer_Lsc_AckConv */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Bayer_Lsc_AckConv(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa4e04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_AckConv.reg_Ack_Addr_Info  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_AckConv_reg_Ack_Addr_Info_type */
	REG_DUMP_PRINT_1("   -reg_Ack_Addr_Info.reg_Ack_Addr_Info                          |  0x%08X  |  [RW][31:00]""Ack Addr iNFO register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa4e00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_AckConv.reg_Ack_Cmd_Info   |  0x%08X  |  ""Ack cMD iNFO register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_AckConv_reg_Ack_Cmd_Info_type */
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.Message                                     |     0x%05X  |  [RW][18:00]""""\n", FIELD_VALUE(val, 0, 18));
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.CMD                                         |         0x%01X  |  [RO][19:19]""""\n", FIELD_VALUE(val, 19, 19));
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.PID                                         |        0x%02X  |  [RW][25:20]""""\n", FIELD_VALUE(val, 20, 25));
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.SID                                         |        0x%02X  |  [RW][31:26]""""\n", FIELD_VALUE(val, 26, 31));
} /* end isa_isa_logic_ISA_Cluster_Bayer_Lsc_AckConv */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa4c34);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC.reg_HW_ASSR_RAW_STAT_Info          |  0x%08X  |  ""events that took place not gated with the mask register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_reg_HW_ASSR_RAW_STAT_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_RAW_STAT_Info (reg_HW_ASSR_RAW_STAT_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_RAW_STAT_Info.STAT                                           |         0x%01X  |  [RO][03:00]""hw assertion raw status""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xa4c30);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC.reg_HW_ASSR_STAT_Info              |  0x%08X  |  ""events that took place after gated with the mask register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_reg_HW_ASSR_STAT_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_STAT_Info (reg_HW_ASSR_STAT_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_STAT_Info.STAT                                               |         0x%01X  |  [RO][03:00]""hw_assertion status""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xa4c2c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC.reg_HW_ASSR_MASK_Info              |  0x%08X  |  ""hw assertion mask - note status reflects masks assertions as well""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_reg_HW_ASSR_MASK_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_MASK_Info (reg_HW_ASSR_MASK_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_MASK_Info.MASK                                               |         0x%01X  |  [RW][03:00]""mask hw assertion bmp""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xa4c28);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC.reg_HW_ASSR_CLEAR_Info             |  0x%08X  |  ""clear latched event from status register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_reg_HW_ASSR_CLEAR_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_CLEAR_Info (reg_HW_ASSR_CLEAR_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_CLEAR_Info.CLEAR                                             |         0x%01X  |  [RW][03:00]""clear hw_assertion""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xa4c24);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC.reg_DFD_DATA_READ_CMD_Info         |  0x%08X  |  ""DFD read traced data register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_reg_DFD_DATA_READ_CMD_Info_type */
	/* skip, unused field unused_reg_DFD_DATA_READ_CMD_Info (reg_DFD_DATA_READ_CMD_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_DATA_READ_CMD_Info.Fetch                                         |         0x%01X  |  [RW][00:00]""DFD read traced data register""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xa4c20);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC.reg_DFD_DATA_READ_COMPLETION_Info  |  0x%08X  |  ""DFD data out from egress Fifo read completion indication""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_reg_DFD_DATA_READ_COMPLETION_Info_type */
	/* skip, unused field unused_reg_DFD_DATA_READ_COMPLETION_Info (reg_DFD_DATA_READ_COMPLETION_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_DATA_READ_COMPLETION_Info.Rd_Comp                                |         0x%01X  |  [RO][00:00]""DFD traced data out from egress Fifo read completion indication""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xa4c1c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC.reg_DFD_TRACED_DATA_VALID_Info     |  0x%08X  |  ""DFD traced data Valid""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_reg_DFD_TRACED_DATA_VALID_Info_type */
	/* skip, unused field unused_reg_DFD_TRACED_DATA_VALID_Info (reg_DFD_TRACED_DATA_VALID_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_TRACED_DATA_VALID_Info.Data_Valid                                |         0x%01X  |  [RO][00:00]""DFD Data VALID""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xa4c18);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC.reg_DFD_TRACED_DATA_Info           |  0x%08X  |  ""DFD traced data out from egress Fifo - double pixel aligned""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_reg_DFD_TRACED_DATA_Info_type */
	REG_DUMP_PRINT_1("   -reg_DFD_TRACED_DATA_Info.Dfd_Traced_Data                                 |  0x%08X  |  [RO][31:00]""DFD traced data out from egress Fifo - double pixel aligned.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa4c14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC.reg_DFD_SINGLE_STEP_Info           |  0x%08X  |  ""Enable FF egress for a single transaction when at DFD post trigger state""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_reg_DFD_SINGLE_STEP_Info_type */
	/* skip, unused field unused_reg_DFD_SINGLE_STEP_Info (reg_DFD_SINGLE_STEP_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_SINGLE_STEP_Info.Single_Step                                     |         0x%01X  |  [RW][00:00]""Enable FF egress for a single transaction when at DFD post trigger state.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xa4c10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC.reg_DFD_EN_Info                    |  0x%08X  |  ""Enable DFD feature. React to acb dfdaction command""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_reg_DFD_EN_Info_type */
	/* skip, unused field unused_reg_DFD_EN_Info (reg_DFD_EN_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_EN_Info.Dfd_En                                                   |         0x%01X  |  [RW][00:00]""Enable DFD feature. React to acb dfdaction command""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -reg_DFD_EN_Info.Use_Prev_Trig_CHAIN                                      |         0x%01X  |  [RW][04:04]""Use previous DFD Daisy chanied trace and hw assertion ports""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -reg_DFD_EN_Info.Use_Prev_Trace_CHAIN                                     |         0x%01X  |  [RW][08:08]""Use previous DFD Daisy chanied trace and hw assertion ports""\n", FIELD_VALUE(val, 8, 8));
	val = REG_DUMP_READ_REGISTER(0xa4c0c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC.reg_PWR_FEATURE_Info               |  0x%08X  |  ""Power feature register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_reg_PWR_FEATURE_Info_type */
	/* skip, unused field unused_reg_PWR_FEATURE_Info (reg_PWR_FEATURE_Info) */
	REG_DUMP_PRINT_1("   -reg_PWR_FEATURE_Info.Empty_En                                            |         0x%01X  |  [RW][00:00]""""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -reg_PWR_FEATURE_Info.MOL_En                                              |         0x%01X  |  [RW][01:01]""""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0xa4c08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC.reg_FF_LSC_GRD_CFG2_Info           |  0x%08X  |  ""FF_LSC Grid config 2""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_reg_FF_LSC_GRD_CFG2_Info_type */
	/* skip, unused field unused_reg_FF_LSC_GRD_CFG2_Info (reg_FF_LSC_GRD_CFG2_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_LSC_GRD_CFG2_Info.init_set_vrt_offst_ul                           |        0x%02X  |  [RW][07:00]""The initial SetVrtOffstUL of the frame""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -reg_FF_LSC_GRD_CFG2_Info.LSC_En                                          |         0x%01X  |  [RW][08:08]""Enable bit for the gird BL""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -reg_FF_LSC_GRD_CFG2_Info.LSC_Exp                                         |         0x%01X  |  [RW][14:12]""Common exponent of LSC tables""\n", FIELD_VALUE(val, 12, 14));
	REG_DUMP_PRINT_1("   -reg_FF_LSC_GRD_CFG2_Info.Sensor_mode                                     |         0x%01X  |  [RW][17:16]""CFA Sensor: 0-1x1, 1-2x2, 2-4x4""\n", FIELD_VALUE(val, 16, 17));
	REG_DUMP_PRINT_1("   -reg_FF_LSC_GRD_CFG2_Info.SOL_BUBBLE_DISABLE_CB                           |         0x%01X  |  [RW][20:20]""""\n", FIELD_VALUE(val, 20, 20));
	REG_DUMP_PRINT_1("   -reg_FF_LSC_GRD_CFG2_Info.EOL_BUBBLE_DISABLE_CB                           |         0x%01X  |  [RW][21:21]""""\n", FIELD_VALUE(val, 21, 21));
	val = REG_DUMP_READ_REGISTER(0xa4c04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC.reg_FF_LSC_GRD_CFG1_Info           |  0x%08X  |  ""FF_LSC Grid config 1""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_reg_FF_LSC_GRD_CFG1_Info_type */
	/* skip, unused field unused_reg_FF_LSC_GRD_CFG1_Info (reg_FF_LSC_GRD_CFG1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_LSC_GRD_CFG1_Info.x_start                                         |      0x%04X  |  [RW][14:00]""X top left corner of the grid in relation to the top left pixel of the frame""\n", FIELD_VALUE(val, 0, 14));
	REG_DUMP_PRINT_1("   -reg_FF_LSC_GRD_CFG1_Info.y_start                                         |      0x%04X  |  [RW][30:16]""Y top left corner of the grid in relation to the top left pixel of the frame""\n", FIELD_VALUE(val, 16, 30));
	val = REG_DUMP_READ_REGISTER(0xa4c00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC.reg_FF_LSC_GRD_CFG0_Info           |  0x%08X  |  ""FF_LSC Grid config 0""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_reg_FF_LSC_GRD_CFG0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_LSC_GRD_CFG0_Info.grid_width                                      |        0x%02X  |  [RW][07:00]""Indicates number of grid vertices on the horizontal axis""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -reg_FF_LSC_GRD_CFG0_Info.grid_height                                     |        0x%02X  |  [RW][15:08]""Indicates number of grid vertices on the vertical axis""\n", FIELD_VALUE(val, 8, 15));
	REG_DUMP_PRINT_1("   -reg_FF_LSC_GRD_CFG0_Info.block_width                                     |         0x%01X  |  [RW][19:16]""Log2 of the cell's width""\n", FIELD_VALUE(val, 16, 19));
	REG_DUMP_PRINT_1("   -reg_FF_LSC_GRD_CFG0_Info.block_height                                    |         0x%01X  |  [RW][23:20]""Log2 of the cell's height""\n", FIELD_VALUE(val, 20, 23));
	REG_DUMP_PRINT_1("   -reg_FF_LSC_GRD_CFG0_Info.grid_height_per_slice                           |        0x%02X  |  [RW][31:24]""Indicates number of vertices in the vertical axis per configuration set""\n", FIELD_VALUE(val, 24, 31));
} /* end isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch3 */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch3(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa4bfc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch3.lut_ch3_set2_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch3_lut_ch3_set2_last_type */
	REG_DUMP_PRINT_1("   -lut_ch3_set2_last.lut_ch3_set2_last                                      |  0x%08X  |  [RW][31:00]""LUT_SET2""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa4b00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch3.lut_ch3_set2_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch3_lut_ch3_set2_first_type */
	REG_DUMP_PRINT_1("   -lut_ch3_set2_first.lut_ch3_set2_first                                    |  0x%08X  |  [RW][31:00]""LUT_SET2""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa4afc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch3.lut_ch3_set1_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch3_lut_ch3_set1_last_type */
	REG_DUMP_PRINT_1("   -lut_ch3_set1_last.lut_ch3_set1_last                                      |  0x%08X  |  [RW][31:00]""LUT_SET1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa4a00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch3.lut_ch3_set1_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch3_lut_ch3_set1_first_type */
	REG_DUMP_PRINT_1("   -lut_ch3_set1_first.lut_ch3_set1_first                                    |  0x%08X  |  [RW][31:00]""LUT_SET1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa49fc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch3.lut_ch3_set0_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch3_lut_ch3_set0_last_type */
	REG_DUMP_PRINT_1("   -lut_ch3_set0_last.lut_ch3_set0_last                                      |  0x%08X  |  [RW][31:00]""LUT_SET0""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa4900);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch3.lut_ch3_set0_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch3_lut_ch3_set0_first_type */
	REG_DUMP_PRINT_1("   -lut_ch3_set0_first.lut_ch3_set0_first                                    |  0x%08X  |  [RW][31:00]""LUT_SET0""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch3 */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch2 */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch2(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa48fc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch2.lut_ch2_set2_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch2_lut_ch2_set2_last_type */
	REG_DUMP_PRINT_1("   -lut_ch2_set2_last.lut_ch2_set2_last                                      |  0x%08X  |  [RW][31:00]""LUT_SET2""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa4800);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch2.lut_ch2_set2_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch2_lut_ch2_set2_first_type */
	REG_DUMP_PRINT_1("   -lut_ch2_set2_first.lut_ch2_set2_first                                    |  0x%08X  |  [RW][31:00]""LUT_SET2""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa47fc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch2.lut_ch2_set1_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch2_lut_ch2_set1_last_type */
	REG_DUMP_PRINT_1("   -lut_ch2_set1_last.lut_ch2_set1_last                                      |  0x%08X  |  [RW][31:00]""LUT_SET1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa4700);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch2.lut_ch2_set1_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch2_lut_ch2_set1_first_type */
	REG_DUMP_PRINT_1("   -lut_ch2_set1_first.lut_ch2_set1_first                                    |  0x%08X  |  [RW][31:00]""LUT_SET1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa46fc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch2.lut_ch2_set0_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch2_lut_ch2_set0_last_type */
	REG_DUMP_PRINT_1("   -lut_ch2_set0_last.lut_ch2_set0_last                                      |  0x%08X  |  [RW][31:00]""LUT_SET0""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa4600);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch2.lut_ch2_set0_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch2_lut_ch2_set0_first_type */
	REG_DUMP_PRINT_1("   -lut_ch2_set0_first.lut_ch2_set0_first                                    |  0x%08X  |  [RW][31:00]""LUT_SET0""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch2 */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch1 */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch1(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa45fc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch1.lut_ch1_set2_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch1_lut_ch1_set2_last_type */
	REG_DUMP_PRINT_1("   -lut_ch1_set2_last.lut_ch1_set2_last                                      |  0x%08X  |  [RW][31:00]""LUT_SET2""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa4500);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch1.lut_ch1_set2_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch1_lut_ch1_set2_first_type */
	REG_DUMP_PRINT_1("   -lut_ch1_set2_first.lut_ch1_set2_first                                    |  0x%08X  |  [RW][31:00]""LUT_SET2""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa44fc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch1.lut_ch1_set1_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch1_lut_ch1_set1_last_type */
	REG_DUMP_PRINT_1("   -lut_ch1_set1_last.lut_ch1_set1_last                                      |  0x%08X  |  [RW][31:00]""LUT_SET1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa4400);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch1.lut_ch1_set1_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch1_lut_ch1_set1_first_type */
	REG_DUMP_PRINT_1("   -lut_ch1_set1_first.lut_ch1_set1_first                                    |  0x%08X  |  [RW][31:00]""LUT_SET1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa43fc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch1.lut_ch1_set0_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch1_lut_ch1_set0_last_type */
	REG_DUMP_PRINT_1("   -lut_ch1_set0_last.lut_ch1_set0_last                                      |  0x%08X  |  [RW][31:00]""LUT_SET0""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa4300);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch1.lut_ch1_set0_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch1_lut_ch1_set0_first_type */
	REG_DUMP_PRINT_1("   -lut_ch1_set0_first.lut_ch1_set0_first                                    |  0x%08X  |  [RW][31:00]""LUT_SET0""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch1 */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch0 */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch0(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa42fc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch0.lut_ch0_set2_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch0_lut_ch0_set2_last_type */
	REG_DUMP_PRINT_1("   -lut_ch0_set2_last.lut_ch0_set2_last                                      |  0x%08X  |  [RW][31:00]""LUT_SET2""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa4200);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch0.lut_ch0_set2_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch0_lut_ch0_set2_first_type */
	REG_DUMP_PRINT_1("   -lut_ch0_set2_first.lut_ch0_set2_first                                    |  0x%08X  |  [RW][31:00]""LUT_SET2""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa41fc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch0.lut_ch0_set1_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch0_lut_ch0_set1_last_type */
	REG_DUMP_PRINT_1("   -lut_ch0_set1_last.lut_ch0_set1_last                                      |  0x%08X  |  [RW][31:00]""LUT_SET1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa4100);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch0.lut_ch0_set1_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch0_lut_ch0_set1_first_type */
	REG_DUMP_PRINT_1("   -lut_ch0_set1_first.lut_ch0_set1_first                                    |  0x%08X  |  [RW][31:00]""LUT_SET1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa40fc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch0.lut_ch0_set0_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch0_lut_ch0_set0_last_type */
	REG_DUMP_PRINT_1("   -lut_ch0_set0_last.lut_ch0_set0_last                                      |  0x%08X  |  [RW][31:00]""LUT_SET0""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa4000);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch0.lut_ch0_set0_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch0_lut_ch0_set0_first_type */
	REG_DUMP_PRINT_1("   -lut_ch0_set0_first.lut_ch0_set0_first                                    |  0x%08X  |  [RW][31:00]""LUT_SET0""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Bayer_Lsc_LSC_ff_lsc_lut_ch0 */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa349c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_HW_ASSR_RAW_STAT_Info                    |  0x%08X  |  ""events that took place not gated with the mask register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_HW_ASSR_RAW_STAT_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_RAW_STAT_Info (reg_HW_ASSR_RAW_STAT_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_RAW_STAT_Info.STAT                                                       |         0x%01X  |  [RO][03:00]""hw assertion raw status""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xa3498);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_HW_ASSR_STAT_Info                        |  0x%08X  |  ""events that took place after gated with the mask register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_HW_ASSR_STAT_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_STAT_Info (reg_HW_ASSR_STAT_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_STAT_Info.STAT                                                           |         0x%01X  |  [RO][03:00]""hw_assertion status""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xa3494);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_HW_ASSR_MASK_Info                        |  0x%08X  |  ""hw assertion mask - note status reflects masks assertions as well""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_HW_ASSR_MASK_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_MASK_Info (reg_HW_ASSR_MASK_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_MASK_Info.MASK                                                           |         0x%01X  |  [RW][03:00]""mask hw assertion bmp""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xa3490);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_HW_ASSR_CLEAR_Info                       |  0x%08X  |  ""clear latched event from status register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_HW_ASSR_CLEAR_Info_type */
	/* skip, unused field unused_reg_HW_ASSR_CLEAR_Info (reg_HW_ASSR_CLEAR_Info) */
	REG_DUMP_PRINT_1("   -reg_HW_ASSR_CLEAR_Info.CLEAR                                                         |         0x%01X  |  [RW][03:00]""clear hw_assertion""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xa348c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_DFD_DATA_READ_CMD_Info                   |  0x%08X  |  ""DFD read traced data register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_DFD_DATA_READ_CMD_Info_type */
	/* skip, unused field unused_reg_DFD_DATA_READ_CMD_Info (reg_DFD_DATA_READ_CMD_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_DATA_READ_CMD_Info.Fetch                                                     |         0x%01X  |  [RW][00:00]""DFD read traced data register""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xa3488);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_DFD_DATA_READ_COMPLETION_Info            |  0x%08X  |  ""DFD data out from egress Fifo read completion indication""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_DFD_DATA_READ_COMPLETION_Info_type */
	/* skip, unused field unused_reg_DFD_DATA_READ_COMPLETION_Info (reg_DFD_DATA_READ_COMPLETION_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_DATA_READ_COMPLETION_Info.Rd_Comp                                            |         0x%01X  |  [RO][00:00]""DFD traced data out from egress Fifo read completion indication""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xa3484);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_DFD_TRACED_DATA_VALID_Info               |  0x%08X  |  ""DFD traced data Valid""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_DFD_TRACED_DATA_VALID_Info_type */
	/* skip, unused field unused_reg_DFD_TRACED_DATA_VALID_Info (reg_DFD_TRACED_DATA_VALID_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_TRACED_DATA_VALID_Info.Data_Valid                                            |         0x%01X  |  [RO][00:00]""DFD Data VALID""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xa3480);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_DFD_TRACED_DATA_Info                     |  0x%08X  |  ""DFD traced data out from egress Fifo - double pixel aligned""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_DFD_TRACED_DATA_Info_type */
	REG_DUMP_PRINT_1("   -reg_DFD_TRACED_DATA_Info.Dfd_Traced_Data                                             |  0x%08X  |  [RO][31:00]""DFD traced data out from egress Fifo - double pixel aligned.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa347c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_DFD_SINGLE_STEP_Info                     |  0x%08X  |  ""Enable FF egress for a single transaction when at DFD post trigger state""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_DFD_SINGLE_STEP_Info_type */
	/* skip, unused field unused_reg_DFD_SINGLE_STEP_Info (reg_DFD_SINGLE_STEP_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_SINGLE_STEP_Info.Single_Step                                                 |         0x%01X  |  [RW][00:00]""Enable FF egress for a single transaction when at DFD post trigger state.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xa3478);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_DFD_EN_Info                              |  0x%08X  |  ""Enable DFD feature. React to acb dfdaction command""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_DFD_EN_Info_type */
	/* skip, unused field unused_reg_DFD_EN_Info (reg_DFD_EN_Info) */
	REG_DUMP_PRINT_1("   -reg_DFD_EN_Info.Dfd_En                                                               |         0x%01X  |  [RW][00:00]""Enable DFD feature. React to acb dfdaction command""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -reg_DFD_EN_Info.Use_Prev_Trig_CHAIN                                                  |         0x%01X  |  [RW][04:04]""Use previous DFD Daisy chanied trace and hw assertion ports""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -reg_DFD_EN_Info.Use_Prev_Trace_CHAIN                                                 |         0x%01X  |  [RW][08:08]""Use previous DFD Daisy chanied trace and hw assertion ports""\n", FIELD_VALUE(val, 8, 8));
	val = REG_DUMP_READ_REGISTER(0xa3474);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_PWR_FEATURE_Info                         |  0x%08X  |  ""Power feature register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_PWR_FEATURE_Info_type */
	/* skip, unused field unused_reg_PWR_FEATURE_Info (reg_PWR_FEATURE_Info) */
	REG_DUMP_PRINT_1("   -reg_PWR_FEATURE_Info.Empty_En                                                        |         0x%01X  |  [RW][00:00]""""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -reg_PWR_FEATURE_Info.MOL_En                                                          |         0x%01X  |  [RW][01:01]""""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0xa3470);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_AF_LUT_LIMIT_SET1_Info      |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_AF_LUT_LIMIT_SET1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_AF_LUT_LIMIT_SET1_Info (reg_FF_GDDPC_DPC_AF_LUT_LIMIT_SET1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_LUT_LIMIT_SET1_Info.Limit_Set1                                   |       0x%03X  |  [RO][10:00]""""\n", FIELD_VALUE(val, 0, 10));
	val = REG_DUMP_READ_REGISTER(0xa346c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_AF_LUT_LIMIT_SET0_Info      |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_AF_LUT_LIMIT_SET0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_AF_LUT_LIMIT_SET0_Info (reg_FF_GDDPC_DPC_AF_LUT_LIMIT_SET0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_LUT_LIMIT_SET0_Info.Limit_Set0                                   |       0x%03X  |  [RO][10:00]""""\n", FIELD_VALUE(val, 0, 10));
	val = REG_DUMP_READ_REGISTER(0xa3468);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_AF_GRID_ENABLE_Info             |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_AF_GRID_ENABLE_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_AF_GRID_ENABLE_Info (reg_FF_GDDPC_AF_GRID_ENABLE_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_AF_GRID_ENABLE_Info.GridIdx_En                                          |        0x%02X  |  [RW][07:00]""Enable AF Grid Idx bitwise""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xa3464);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET7_Info    |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET7_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET7_Info (reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET7_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET7_Info.Factor0                                    |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET7_Info.Factor1                                    |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xa3460);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET6_Info    |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET6_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET6_Info (reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET6_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET6_Info.Factor0                                    |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET6_Info.Factor1                                    |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xa345c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET5_Info    |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET5_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET5_Info (reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET5_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET5_Info.Factor0                                    |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET5_Info.Factor1                                    |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xa3458);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET4_Info    |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET4_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET4_Info (reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET4_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET4_Info.Factor0                                    |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET4_Info.Factor1                                    |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xa3454);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET3_Info    |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET3_Info (reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET3_Info.Factor0                                    |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET3_Info.Factor1                                    |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xa3450);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET2_Info    |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET2_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET2_Info (reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET2_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET2_Info.Factor0                                    |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET2_Info.Factor1                                    |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xa344c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET1_Info    |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET1_Info (reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET1_Info.Factor0                                    |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET1_Info.Factor1                                    |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xa3448);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET0_Info    |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET0_Info (reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET0_Info.Factor0                                    |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_HDR_INV_FACTOR_SET0_Info.Factor1                                    |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xa3444);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_HDR_FACTOR_SET7_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_HDR_FACTOR_SET7_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_HDR_FACTOR_SET7_Info (reg_FF_GDDPC_DPC_HDR_FACTOR_SET7_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_HDR_FACTOR_SET7_Info.Factor0                                        |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_HDR_FACTOR_SET7_Info.Factor1                                        |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xa3440);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_HDR_FACTOR_SET6_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_HDR_FACTOR_SET6_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_HDR_FACTOR_SET6_Info (reg_FF_GDDPC_DPC_HDR_FACTOR_SET6_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_HDR_FACTOR_SET6_Info.Factor0                                        |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_HDR_FACTOR_SET6_Info.Factor1                                        |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xa343c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_HDR_FACTOR_SET5_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_HDR_FACTOR_SET5_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_HDR_FACTOR_SET5_Info (reg_FF_GDDPC_DPC_HDR_FACTOR_SET5_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_HDR_FACTOR_SET5_Info.Factor0                                        |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_HDR_FACTOR_SET5_Info.Factor1                                        |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xa3438);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_HDR_FACTOR_SET4_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_HDR_FACTOR_SET4_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_HDR_FACTOR_SET4_Info (reg_FF_GDDPC_DPC_HDR_FACTOR_SET4_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_HDR_FACTOR_SET4_Info.Factor0                                        |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_HDR_FACTOR_SET4_Info.Factor1                                        |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xa3434);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_HDR_FACTOR_SET3_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_HDR_FACTOR_SET3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_HDR_FACTOR_SET3_Info (reg_FF_GDDPC_DPC_HDR_FACTOR_SET3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_HDR_FACTOR_SET3_Info.Factor0                                        |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_HDR_FACTOR_SET3_Info.Factor1                                        |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xa3430);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_HDR_FACTOR_SET2_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_HDR_FACTOR_SET2_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_HDR_FACTOR_SET2_Info (reg_FF_GDDPC_DPC_HDR_FACTOR_SET2_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_HDR_FACTOR_SET2_Info.Factor0                                        |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_HDR_FACTOR_SET2_Info.Factor1                                        |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xa342c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_HDR_FACTOR_SET1_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_HDR_FACTOR_SET1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_HDR_FACTOR_SET1_Info (reg_FF_GDDPC_DPC_HDR_FACTOR_SET1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_HDR_FACTOR_SET1_Info.Factor0                                        |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_HDR_FACTOR_SET1_Info.Factor1                                        |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xa3428);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_HDR_FACTOR_SET0_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_HDR_FACTOR_SET0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_HDR_FACTOR_SET0_Info (reg_FF_GDDPC_DPC_HDR_FACTOR_SET0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_HDR_FACTOR_SET0_Info.Factor0                                        |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_HDR_FACTOR_SET0_Info.Factor1                                        |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xa3424);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_AF_SET3_PERIOD_Y_Info       |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_AF_SET3_PERIOD_Y_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_AF_SET3_PERIOD_Y_Info (reg_FF_GDDPC_DPC_AF_SET3_PERIOD_Y_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_SET3_PERIOD_Y_Info.Period0                                       |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_SET3_PERIOD_Y_Info.Period1                                       |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xa3420);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_AF_SET3_PERIOD_X_Info       |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_AF_SET3_PERIOD_X_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_AF_SET3_PERIOD_X_Info (reg_FF_GDDPC_DPC_AF_SET3_PERIOD_X_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_SET3_PERIOD_X_Info.Period0                                       |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_SET3_PERIOD_X_Info.Period1                                       |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xa341c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_AF_SET3_OFFSET_Y_Info       |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_AF_SET3_OFFSET_Y_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_AF_SET3_OFFSET_Y_Info (reg_FF_GDDPC_DPC_AF_SET3_OFFSET_Y_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_SET3_OFFSET_Y_Info.Offset0                                       |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_SET3_OFFSET_Y_Info.Offset1                                       |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xa3418);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_AF_SET3_OFFSET_X_Info       |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_AF_SET3_OFFSET_X_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_AF_SET3_OFFSET_X_Info (reg_FF_GDDPC_DPC_AF_SET3_OFFSET_X_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_SET3_OFFSET_X_Info.Offset0                                       |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_SET3_OFFSET_X_Info.Offset1                                       |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xa3414);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_AF_SET2_PERIOD_Y_Info       |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_AF_SET2_PERIOD_Y_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_AF_SET2_PERIOD_Y_Info (reg_FF_GDDPC_DPC_AF_SET2_PERIOD_Y_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_SET2_PERIOD_Y_Info.Period0                                       |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_SET2_PERIOD_Y_Info.Period1                                       |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xa3410);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_AF_SET2_PERIOD_X_Info       |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_AF_SET2_PERIOD_X_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_AF_SET2_PERIOD_X_Info (reg_FF_GDDPC_DPC_AF_SET2_PERIOD_X_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_SET2_PERIOD_X_Info.Period0                                       |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_SET2_PERIOD_X_Info.Period1                                       |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xa340c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_AF_SET2_OFFSET_Y_Info       |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_AF_SET2_OFFSET_Y_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_AF_SET2_OFFSET_Y_Info (reg_FF_GDDPC_DPC_AF_SET2_OFFSET_Y_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_SET2_OFFSET_Y_Info.Offset0                                       |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_SET2_OFFSET_Y_Info.Offset1                                       |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xa3408);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_AF_SET2_OFFSET_X_Info       |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_AF_SET2_OFFSET_X_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_AF_SET2_OFFSET_X_Info (reg_FF_GDDPC_DPC_AF_SET2_OFFSET_X_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_SET2_OFFSET_X_Info.Offset0                                       |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_SET2_OFFSET_X_Info.Offset1                                       |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xa3404);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_AF_SET1_PERIOD_Y_Info       |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_AF_SET1_PERIOD_Y_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_AF_SET1_PERIOD_Y_Info (reg_FF_GDDPC_DPC_AF_SET1_PERIOD_Y_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_SET1_PERIOD_Y_Info.Period0                                       |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_SET1_PERIOD_Y_Info.Period1                                       |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xa3400);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_AF_SET1_PERIOD_X_Info       |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_AF_SET1_PERIOD_X_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_AF_SET1_PERIOD_X_Info (reg_FF_GDDPC_DPC_AF_SET1_PERIOD_X_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_SET1_PERIOD_X_Info.Period0                                       |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_SET1_PERIOD_X_Info.Period1                                       |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xa33fc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_AF_SET1_OFFSET_Y_Info       |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_AF_SET1_OFFSET_Y_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_AF_SET1_OFFSET_Y_Info (reg_FF_GDDPC_DPC_AF_SET1_OFFSET_Y_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_SET1_OFFSET_Y_Info.Offset0                                       |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_SET1_OFFSET_Y_Info.Offset1                                       |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xa33f8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_AF_SET1_OFFSET_X_Info       |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_AF_SET1_OFFSET_X_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_AF_SET1_OFFSET_X_Info (reg_FF_GDDPC_DPC_AF_SET1_OFFSET_X_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_SET1_OFFSET_X_Info.Offset0                                       |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_SET1_OFFSET_X_Info.Offset1                                       |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xa33f4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_AF_SET0_PERIOD_Y_Info       |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_AF_SET0_PERIOD_Y_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_AF_SET0_PERIOD_Y_Info (reg_FF_GDDPC_DPC_AF_SET0_PERIOD_Y_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_SET0_PERIOD_Y_Info.Period0                                       |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_SET0_PERIOD_Y_Info.Period1                                       |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xa33f0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_AF_SET0_PERIOD_X_Info       |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_AF_SET0_PERIOD_X_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_AF_SET0_PERIOD_X_Info (reg_FF_GDDPC_DPC_AF_SET0_PERIOD_X_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_SET0_PERIOD_X_Info.Period0                                       |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_SET0_PERIOD_X_Info.Period1                                       |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xa33ec);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_AF_SET0_OFFSET_Y_Info       |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_AF_SET0_OFFSET_Y_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_AF_SET0_OFFSET_Y_Info (reg_FF_GDDPC_DPC_AF_SET0_OFFSET_Y_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_SET0_OFFSET_Y_Info.Offset0                                       |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_SET0_OFFSET_Y_Info.Offset1                                       |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xa33e8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_AF_SET0_OFFSET_X_Info       |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_AF_SET0_OFFSET_X_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_AF_SET0_OFFSET_X_Info (reg_FF_GDDPC_DPC_AF_SET0_OFFSET_X_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_SET0_OFFSET_X_Info.Offset0                                       |      0x%04X  |  [RW][13:00]""""\n", FIELD_VALUE(val, 0, 13));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_AF_SET0_OFFSET_X_Info.Offset1                                       |      0x%04X  |  [RW][29:16]""""\n", FIELD_VALUE(val, 16, 29));
	val = REG_DUMP_READ_REGISTER(0xa33e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_STATIC_LUT_LIMIT_Set1_Info  |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_STATIC_LUT_LIMIT_Set1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_STATIC_LUT_LIMIT_Set1_Info (reg_FF_GDDPC_DPC_STATIC_LUT_LIMIT_Set1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_STATIC_LUT_LIMIT_Set1_Info.Limit_Set1                               |       0x%03X  |  [RW][10:00]""""\n", FIELD_VALUE(val, 0, 10));
	val = REG_DUMP_READ_REGISTER(0xa33e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_STATIC_LUT_LIMIT_Set0_Info  |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_STATIC_LUT_LIMIT_Set0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_STATIC_LUT_LIMIT_Set0_Info (reg_FF_GDDPC_DPC_STATIC_LUT_LIMIT_Set0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_STATIC_LUT_LIMIT_Set0_Info.Limit_Set0                               |       0x%03X  |  [RW][10:00]""""\n", FIELD_VALUE(val, 0, 10));
	val = REG_DUMP_READ_REGISTER(0xa33dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_DPC_CONTROL_Info                |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_DPC_CONTROL_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_DPC_CONTROL_Info (reg_FF_GDDPC_DPC_CONTROL_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_CONTROL_Info.DPC_En                                                 |         0x%01X  |  [RW][00:00]""""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_CONTROL_Info.Dynamic_En                                             |         0x%01X  |  [RW][01:01]""""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_CONTROL_Info.Static_En                                              |         0x%01X  |  [RW][02:02]""""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_CONTROL_Info.AF_En                                                  |         0x%01X  |  [RW][03:03]""""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_CONTROL_Info.BitReduceShift                                         |         0x%01X  |  [RW][07:04]""""\n", FIELD_VALUE(val, 4, 7));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_DPC_CONTROL_Info.FrameWidth                                             |      0x%04X  |  [RW][28:16]""""\n", FIELD_VALUE(val, 16, 28));
	val = REG_DUMP_READ_REGISTER(0xa33d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_GDC_CONTROL_Info                |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_GDC_CONTROL_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_GDC_CONTROL_Info (reg_FF_GDDPC_GDC_CONTROL_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_GDC_CONTROL_Info.Global_En                                              |         0x%01X  |  [RW][00:00]""""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_GDC_CONTROL_Info.GDC_En                                                 |         0x%01X  |  [RW][01:01]""""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_GDC_CONTROL_Info.Gr_Pos                                                 |         0x%01X  |  [RW][03:02]""""\n", FIELD_VALUE(val, 2, 3));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_GDC_CONTROL_Info.InvScale                                               |         0x%01X  |  [RW][07:04]""""\n", FIELD_VALUE(val, 4, 7));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_GDC_CONTROL_Info.LCDEDetailsPres                                        |       0x%03X  |  [RW][16:08]""""\n", FIELD_VALUE(val, 8, 16));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_GDC_CONTROL_Info.AFBubble_Disable_CB                                    |         0x%01X  |  [RW][17:17]""""\n", FIELD_VALUE(val, 17, 17));
	val = REG_DUMP_READ_REGISTER(0xa33d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID10_SLOPEB3_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID10_SLOPEB3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGUNT_ID10_SLOPEB3_Info (reg_FF_GDDPC_CFGUNT_ID10_SLOPEB3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID10_SLOPEB3_Info.SlopeB_Values                                  |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xa33d0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID10_SLOPEB2_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID10_SLOPEB2_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID10_SLOPEB2_Info.SlopeB_Values                                  |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa33cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID10_SLOPEB1_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID10_SLOPEB1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID10_SLOPEB1_Info.SlopeB_Values                                  |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa33c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID10_SLOPEB0_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID10_SLOPEB0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID10_SLOPEB0_Info.SlopeB_Values                                  |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa33c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID10_SLOPEA3_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID10_SLOPEA3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGUNT_ID10_SLOPEA3_Info (reg_FF_GDDPC_CFGUNT_ID10_SLOPEA3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID10_SLOPEA3_Info.SlopeA_Values                                  |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xa33c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID10_SLOPEA2_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID10_SLOPEA2_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID10_SLOPEA2_Info.SlopeA_Values                                  |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa33bc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID10_SLOPEA1_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID10_SLOPEA1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID10_SLOPEA1_Info.SlopeA_Values                                  |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa33b8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID10_SLOPEA0_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID10_SLOPEA0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID10_SLOPEA0_Info.SlopeA_Values                                  |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa33b4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID10_FIXEDX1_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID10_FIXEDX1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID10_FIXEDX1_Info.FixedX_Values                                  |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa33b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID10_FIXEDX0_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID10_FIXEDX0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID10_FIXEDX0_Info.FixedX_Values                                  |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa33ac);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID9_SLOPEB3_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID9_SLOPEB3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGUNT_ID9_SLOPEB3_Info (reg_FF_GDDPC_CFGUNT_ID9_SLOPEB3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID9_SLOPEB3_Info.SlopeB_Values                                   |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xa33a8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID9_SLOPEB2_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID9_SLOPEB2_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID9_SLOPEB2_Info.SlopeB_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa33a4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID9_SLOPEB1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID9_SLOPEB1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID9_SLOPEB1_Info.SlopeB_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa33a0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID9_SLOPEB0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID9_SLOPEB0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID9_SLOPEB0_Info.SlopeB_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa339c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID9_SLOPEA3_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID9_SLOPEA3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGUNT_ID9_SLOPEA3_Info (reg_FF_GDDPC_CFGUNT_ID9_SLOPEA3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID9_SLOPEA3_Info.SlopeA_Values                                   |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xa3398);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID9_SLOPEA2_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID9_SLOPEA2_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID9_SLOPEA2_Info.SlopeA_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3394);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID9_SLOPEA1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID9_SLOPEA1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID9_SLOPEA1_Info.SlopeA_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3390);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID9_SLOPEA0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID9_SLOPEA0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID9_SLOPEA0_Info.SlopeA_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa338c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID9_FIXEDX1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID9_FIXEDX1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID9_FIXEDX1_Info.FixedX_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3388);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID9_FIXEDX0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID9_FIXEDX0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID9_FIXEDX0_Info.FixedX_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3384);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID8_SLOPEB3_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID8_SLOPEB3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGUNT_ID8_SLOPEB3_Info (reg_FF_GDDPC_CFGUNT_ID8_SLOPEB3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID8_SLOPEB3_Info.SlopeB_Values                                   |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xa3380);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID8_SLOPEB2_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID8_SLOPEB2_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID8_SLOPEB2_Info.SlopeB_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa337c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID8_SLOPEB1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID8_SLOPEB1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID8_SLOPEB1_Info.SlopeB_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3378);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID8_SLOPEB0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID8_SLOPEB0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID8_SLOPEB0_Info.SlopeB_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3374);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID8_SLOPEA3_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID8_SLOPEA3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGUNT_ID8_SLOPEA3_Info (reg_FF_GDDPC_CFGUNT_ID8_SLOPEA3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID8_SLOPEA3_Info.SlopeA_Values                                   |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xa3370);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID8_SLOPEA2_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID8_SLOPEA2_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID8_SLOPEA2_Info.SlopeA_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa336c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID8_SLOPEA1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID8_SLOPEA1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID8_SLOPEA1_Info.SlopeA_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3368);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID8_SLOPEA0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID8_SLOPEA0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID8_SLOPEA0_Info.SlopeA_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3364);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID8_FIXEDX1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID8_FIXEDX1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID8_FIXEDX1_Info.FixedX_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3360);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID8_FIXEDX0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID8_FIXEDX0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID8_FIXEDX0_Info.FixedX_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa335c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID7_SLOPEB3_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID7_SLOPEB3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGUNT_ID7_SLOPEB3_Info (reg_FF_GDDPC_CFGUNT_ID7_SLOPEB3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID7_SLOPEB3_Info.SlopeB_Values                                   |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xa3358);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID7_SLOPEB2_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID7_SLOPEB2_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID7_SLOPEB2_Info.SlopeB_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3354);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID7_SLOPEB1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID7_SLOPEB1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID7_SLOPEB1_Info.SlopeB_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3350);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID7_SLOPEB0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID7_SLOPEB0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID7_SLOPEB0_Info.SlopeB_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa334c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID7_SLOPEA3_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID7_SLOPEA3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGUNT_ID7_SLOPEA3_Info (reg_FF_GDDPC_CFGUNT_ID7_SLOPEA3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID7_SLOPEA3_Info.SlopeA_Values                                   |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xa3348);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID7_SLOPEA2_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID7_SLOPEA2_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID7_SLOPEA2_Info.SlopeA_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3344);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID7_SLOPEA1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID7_SLOPEA1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID7_SLOPEA1_Info.SlopeA_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3340);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID7_SLOPEA0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID7_SLOPEA0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID7_SLOPEA0_Info.SlopeA_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa333c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID7_FIXEDX1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID7_FIXEDX1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID7_FIXEDX1_Info.FixedX_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3338);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID7_FIXEDX0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID7_FIXEDX0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID7_FIXEDX0_Info.FixedX_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3334);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID6_SLOPEB3_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID6_SLOPEB3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGUNT_ID6_SLOPEB3_Info (reg_FF_GDDPC_CFGUNT_ID6_SLOPEB3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID6_SLOPEB3_Info.SlopeB_Values                                   |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xa3330);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID6_SLOPEB2_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID6_SLOPEB2_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID6_SLOPEB2_Info.SlopeB_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa332c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID6_SLOPEB1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID6_SLOPEB1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID6_SLOPEB1_Info.SlopeB_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3328);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID6_SLOPEB0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID6_SLOPEB0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID6_SLOPEB0_Info.SlopeB_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3324);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID6_SLOPEA3_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID6_SLOPEA3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGUNT_ID6_SLOPEA3_Info (reg_FF_GDDPC_CFGUNT_ID6_SLOPEA3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID6_SLOPEA3_Info.SlopeA_Values                                   |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xa3320);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID6_SLOPEA2_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID6_SLOPEA2_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID6_SLOPEA2_Info.SlopeA_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa331c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID6_SLOPEA1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID6_SLOPEA1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID6_SLOPEA1_Info.SlopeA_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3318);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID6_SLOPEA0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID6_SLOPEA0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID6_SLOPEA0_Info.SlopeA_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3314);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID6_FIXEDX1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID6_FIXEDX1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID6_FIXEDX1_Info.FixedX_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3310);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID6_FIXEDX0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID6_FIXEDX0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID6_FIXEDX0_Info.FixedX_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa330c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID5_SLOPEB3_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID5_SLOPEB3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGUNT_ID5_SLOPEB3_Info (reg_FF_GDDPC_CFGUNT_ID5_SLOPEB3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID5_SLOPEB3_Info.SlopeB_Values                                   |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xa3308);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID5_SLOPEB2_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID5_SLOPEB2_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID5_SLOPEB2_Info.SlopeB_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3304);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID5_SLOPEB1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID5_SLOPEB1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID5_SLOPEB1_Info.SlopeB_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3300);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID5_SLOPEB0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID5_SLOPEB0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID5_SLOPEB0_Info.SlopeB_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa32fc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID5_SLOPEA3_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID5_SLOPEA3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGUNT_ID5_SLOPEA3_Info (reg_FF_GDDPC_CFGUNT_ID5_SLOPEA3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID5_SLOPEA3_Info.SlopeA_Values                                   |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xa32f8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID5_SLOPEA2_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID5_SLOPEA2_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID5_SLOPEA2_Info.SlopeA_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa32f4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID5_SLOPEA1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID5_SLOPEA1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID5_SLOPEA1_Info.SlopeA_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa32f0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID5_SLOPEA0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID5_SLOPEA0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID5_SLOPEA0_Info.SlopeA_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa32ec);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID5_FIXEDX1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID5_FIXEDX1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID5_FIXEDX1_Info.FixedX_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa32e8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID5_FIXEDX0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID5_FIXEDX0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID5_FIXEDX0_Info.FixedX_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa32e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID4_SLOPEB3_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID4_SLOPEB3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGUNT_ID4_SLOPEB3_Info (reg_FF_GDDPC_CFGUNT_ID4_SLOPEB3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID4_SLOPEB3_Info.SlopeB_Values                                   |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xa32e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID4_SLOPEB2_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID4_SLOPEB2_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID4_SLOPEB2_Info.SlopeB_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa32dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID4_SLOPEB1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID4_SLOPEB1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID4_SLOPEB1_Info.SlopeB_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa32d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID4_SLOPEB0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID4_SLOPEB0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID4_SLOPEB0_Info.SlopeB_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa32d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID4_SLOPEA3_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID4_SLOPEA3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGUNT_ID4_SLOPEA3_Info (reg_FF_GDDPC_CFGUNT_ID4_SLOPEA3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID4_SLOPEA3_Info.SlopeA_Values                                   |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xa32d0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID4_SLOPEA2_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID4_SLOPEA2_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID4_SLOPEA2_Info.SlopeA_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa32cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID4_SLOPEA1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID4_SLOPEA1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID4_SLOPEA1_Info.SlopeA_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa32c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID4_SLOPEA0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID4_SLOPEA0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID4_SLOPEA0_Info.SlopeA_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa32c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID4_FIXEDX1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID4_FIXEDX1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID4_FIXEDX1_Info.FixedX_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa32c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID4_FIXEDX0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID4_FIXEDX0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID4_FIXEDX0_Info.FixedX_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa32bc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID3_SLOPEB3_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID3_SLOPEB3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGUNT_ID3_SLOPEB3_Info (reg_FF_GDDPC_CFGUNT_ID3_SLOPEB3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID3_SLOPEB3_Info.SlopeB_Values                                   |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xa32b8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID3_SLOPEB2_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID3_SLOPEB2_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID3_SLOPEB2_Info.SlopeB_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa32b4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID3_SLOPEB1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID3_SLOPEB1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID3_SLOPEB1_Info.SlopeB_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa32b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID3_SLOPEB0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID3_SLOPEB0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID3_SLOPEB0_Info.SlopeB_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa32ac);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID3_SLOPEA3_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID3_SLOPEA3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGUNT_ID3_SLOPEA3_Info (reg_FF_GDDPC_CFGUNT_ID3_SLOPEA3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID3_SLOPEA3_Info.SlopeA_Values                                   |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xa32a8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID3_SLOPEA2_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID3_SLOPEA2_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID3_SLOPEA2_Info.SlopeA_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa32a4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID3_SLOPEA1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID3_SLOPEA1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID3_SLOPEA1_Info.SlopeA_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa32a0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID3_SLOPEA0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID3_SLOPEA0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID3_SLOPEA0_Info.SlopeA_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa329c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID3_FIXEDX1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID3_FIXEDX1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID3_FIXEDX1_Info.FixedX_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3298);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID3_FIXEDX0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID3_FIXEDX0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID3_FIXEDX0_Info.FixedX_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3294);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID2_SLOPEB3_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID2_SLOPEB3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGUNT_ID2_SLOPEB3_Info (reg_FF_GDDPC_CFGUNT_ID2_SLOPEB3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID2_SLOPEB3_Info.SlopeB_Values                                   |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xa3290);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID2_SLOPEB2_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID2_SLOPEB2_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID2_SLOPEB2_Info.SlopeB_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa328c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID2_SLOPEB1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID2_SLOPEB1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID2_SLOPEB1_Info.SlopeB_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3288);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID2_SLOPEB0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID2_SLOPEB0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID2_SLOPEB0_Info.SlopeB_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3284);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID2_SLOPEA3_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID2_SLOPEA3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGUNT_ID2_SLOPEA3_Info (reg_FF_GDDPC_CFGUNT_ID2_SLOPEA3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID2_SLOPEA3_Info.SlopeA_Values                                   |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xa3280);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID2_SLOPEA2_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID2_SLOPEA2_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID2_SLOPEA2_Info.SlopeA_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa327c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID2_SLOPEA1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID2_SLOPEA1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID2_SLOPEA1_Info.SlopeA_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3278);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID2_SLOPEA0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID2_SLOPEA0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID2_SLOPEA0_Info.SlopeA_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3274);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID2_FIXEDX1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID2_FIXEDX1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID2_FIXEDX1_Info.FixedX_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3270);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID2_FIXEDX0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID2_FIXEDX0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID2_FIXEDX0_Info.FixedX_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa326c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID1_SLOPEB3_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID1_SLOPEB3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGUNT_ID1_SLOPEB3_Info (reg_FF_GDDPC_CFGUNT_ID1_SLOPEB3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID1_SLOPEB3_Info.SlopeB_Values                                   |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xa3268);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID1_SLOPEB2_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID1_SLOPEB2_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID1_SLOPEB2_Info.SlopeB_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3264);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID1_SLOPEB1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID1_SLOPEB1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID1_SLOPEB1_Info.SlopeB_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3260);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID1_SLOPEB0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID1_SLOPEB0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID1_SLOPEB0_Info.SlopeB_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa325c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID1_SLOPEA3_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID1_SLOPEA3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGUNT_ID1_SLOPEA3_Info (reg_FF_GDDPC_CFGUNT_ID1_SLOPEA3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID1_SLOPEA3_Info.SlopeA_Values                                   |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xa3258);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID1_SLOPEA2_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID1_SLOPEA2_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID1_SLOPEA2_Info.SlopeA_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3254);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID1_SLOPEA1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID1_SLOPEA1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID1_SLOPEA1_Info.SlopeA_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3250);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID1_SLOPEA0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID1_SLOPEA0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID1_SLOPEA0_Info.SlopeA_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa324c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID1_FIXEDX1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID1_FIXEDX1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID1_FIXEDX1_Info.FixedX_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3248);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID1_FIXEDX0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID1_FIXEDX0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID1_FIXEDX0_Info.FixedX_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3244);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID0_SLOPEB3_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID0_SLOPEB3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGUNT_ID0_SLOPEB3_Info (reg_FF_GDDPC_CFGUNT_ID0_SLOPEB3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID0_SLOPEB3_Info.SlopeB_Values                                   |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xa3240);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID0_SLOPEB2_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID0_SLOPEB2_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID0_SLOPEB2_Info.SlopeB_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa323c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID0_SLOPEB1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID0_SLOPEB1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID0_SLOPEB1_Info.SlopeB_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3238);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID0_SLOPEB0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID0_SLOPEB0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID0_SLOPEB0_Info.SlopeB_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3234);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID0_SLOPEA3_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID0_SLOPEA3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGUNT_ID0_SLOPEA3_Info (reg_FF_GDDPC_CFGUNT_ID0_SLOPEA3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID0_SLOPEA3_Info.SlopeA_Values                                   |      0x%04X  |  [RW][15:00]""""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xa3230);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID0_SLOPEA2_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID0_SLOPEA2_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID0_SLOPEA2_Info.SlopeA_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa322c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID0_SLOPEA1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID0_SLOPEA1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID0_SLOPEA1_Info.SlopeA_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3228);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID0_SLOPEA0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID0_SLOPEA0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID0_SLOPEA0_Info.SlopeA_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3224);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID0_FIXEDX1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID0_FIXEDX1_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID0_FIXEDX1_Info.FixedX_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa3220);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGUNT_ID0_FIXEDX0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGUNT_ID0_FIXEDX0_Info_type */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGUNT_ID0_FIXEDX0_Info.FixedX_Values                                   |  0x%08X  |  [RW][31:00]""""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa321c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID15_DMASK0_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID15_DMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID15_DMASK0_Info (reg_FF_GDDPC_CFGTAB_EID15_DMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID15_DMASK0_Info.D_Mask                                         |      0x%04X  |  [RW][14:00]""""\n", FIELD_VALUE(val, 0, 14));
	val = REG_DUMP_READ_REGISTER(0xa3218);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID15_PMASK3_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID15_PMASK3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID15_PMASK3_Info (reg_FF_GDDPC_CFGTAB_EID15_PMASK3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID15_PMASK3_Info.P_Mask                                         |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa3214);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID15_PMASK2_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID15_PMASK2_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID15_PMASK2_Info (reg_FF_GDDPC_CFGTAB_EID15_PMASK2_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID15_PMASK2_Info.P_Mask                                         |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa3210);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID15_PMASK1_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID15_PMASK1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID15_PMASK1_Info (reg_FF_GDDPC_CFGTAB_EID15_PMASK1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID15_PMASK1_Info.P_Mask                                         |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa320c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID15_PMASK0_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID15_PMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID15_PMASK0_Info (reg_FF_GDDPC_CFGTAB_EID15_PMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID15_PMASK0_Info.P_Mask                                         |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa3208);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID15_BMASK1_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID15_BMASK1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID15_BMASK1_Info (reg_FF_GDDPC_CFGTAB_EID15_BMASK1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID15_BMASK1_Info.UB_Mask                                        |     0x%05X  |  [RW][19:00]""""\n", FIELD_VALUE(val, 0, 19));
	val = REG_DUMP_READ_REGISTER(0xa3204);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID15_BMASK0_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID15_BMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID15_BMASK0_Info (reg_FF_GDDPC_CFGTAB_EID15_BMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID15_BMASK0_Info.LB_Est_Type                                    |         0x%01X  |  [RW][01:00]""""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID15_BMASK0_Info.UB_Est_Type                                    |         0x%01X  |  [RW][03:02]""""\n", FIELD_VALUE(val, 2, 3));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID15_BMASK0_Info.Pel_Est_Type                                   |         0x%01X  |  [RW][07:04]""""\n", FIELD_VALUE(val, 4, 7));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID15_BMASK0_Info.PD_Est_Type                                    |         0x%01X  |  [RW][09:08]""""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID15_BMASK0_Info.LB_Mask                                        |     0x%05X  |  [RW][29:10]""""\n", FIELD_VALUE(val, 10, 29));
	val = REG_DUMP_READ_REGISTER(0xa3200);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID14_DMASK0_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID14_DMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID14_DMASK0_Info (reg_FF_GDDPC_CFGTAB_EID14_DMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID14_DMASK0_Info.D_Mask                                         |      0x%04X  |  [RW][14:00]""""\n", FIELD_VALUE(val, 0, 14));
	val = REG_DUMP_READ_REGISTER(0xa31fc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID14_PMASK3_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID14_PMASK3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID14_PMASK3_Info (reg_FF_GDDPC_CFGTAB_EID14_PMASK3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID14_PMASK3_Info.P_Mask                                         |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa31f8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID14_PMASK2_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID14_PMASK2_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID14_PMASK2_Info (reg_FF_GDDPC_CFGTAB_EID14_PMASK2_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID14_PMASK2_Info.P_Mask                                         |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa31f4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID14_PMASK1_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID14_PMASK1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID14_PMASK1_Info (reg_FF_GDDPC_CFGTAB_EID14_PMASK1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID14_PMASK1_Info.P_Mask                                         |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa31f0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID14_PMASK0_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID14_PMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID14_PMASK0_Info (reg_FF_GDDPC_CFGTAB_EID14_PMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID14_PMASK0_Info.P_Mask                                         |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa31ec);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID14_BMASK1_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID14_BMASK1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID14_BMASK1_Info (reg_FF_GDDPC_CFGTAB_EID14_BMASK1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID14_BMASK1_Info.UB_Mask                                        |     0x%05X  |  [RW][19:00]""""\n", FIELD_VALUE(val, 0, 19));
	val = REG_DUMP_READ_REGISTER(0xa31e8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID14_BMASK0_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID14_BMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID14_BMASK0_Info (reg_FF_GDDPC_CFGTAB_EID14_BMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID14_BMASK0_Info.LB_Est_Type                                    |         0x%01X  |  [RW][01:00]""""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID14_BMASK0_Info.UB_Est_Type                                    |         0x%01X  |  [RW][03:02]""""\n", FIELD_VALUE(val, 2, 3));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID14_BMASK0_Info.Pel_Est_Type                                   |         0x%01X  |  [RW][07:04]""""\n", FIELD_VALUE(val, 4, 7));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID14_BMASK0_Info.PD_Est_Type                                    |         0x%01X  |  [RW][09:08]""""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID14_BMASK0_Info.LB_Mask                                        |     0x%05X  |  [RW][29:10]""""\n", FIELD_VALUE(val, 10, 29));
	val = REG_DUMP_READ_REGISTER(0xa31e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID13_DMASK0_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID13_DMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID13_DMASK0_Info (reg_FF_GDDPC_CFGTAB_EID13_DMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID13_DMASK0_Info.D_Mask                                         |      0x%04X  |  [RW][14:00]""""\n", FIELD_VALUE(val, 0, 14));
	val = REG_DUMP_READ_REGISTER(0xa31e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID13_PMASK3_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID13_PMASK3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID13_PMASK3_Info (reg_FF_GDDPC_CFGTAB_EID13_PMASK3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID13_PMASK3_Info.P_Mask                                         |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa31dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID13_PMASK2_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID13_PMASK2_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID13_PMASK2_Info (reg_FF_GDDPC_CFGTAB_EID13_PMASK2_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID13_PMASK2_Info.P_Mask                                         |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa31d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID13_PMASK1_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID13_PMASK1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID13_PMASK1_Info (reg_FF_GDDPC_CFGTAB_EID13_PMASK1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID13_PMASK1_Info.P_Mask                                         |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa31d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID13_PMASK0_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID13_PMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID13_PMASK0_Info (reg_FF_GDDPC_CFGTAB_EID13_PMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID13_PMASK0_Info.P_Mask                                         |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa31d0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID13_BMASK1_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID13_BMASK1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID13_BMASK1_Info (reg_FF_GDDPC_CFGTAB_EID13_BMASK1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID13_BMASK1_Info.UB_Mask                                        |     0x%05X  |  [RW][19:00]""""\n", FIELD_VALUE(val, 0, 19));
	val = REG_DUMP_READ_REGISTER(0xa31cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID13_BMASK0_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID13_BMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID13_BMASK0_Info (reg_FF_GDDPC_CFGTAB_EID13_BMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID13_BMASK0_Info.LB_Est_Type                                    |         0x%01X  |  [RW][01:00]""""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID13_BMASK0_Info.UB_Est_Type                                    |         0x%01X  |  [RW][03:02]""""\n", FIELD_VALUE(val, 2, 3));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID13_BMASK0_Info.Pel_Est_Type                                   |         0x%01X  |  [RW][07:04]""""\n", FIELD_VALUE(val, 4, 7));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID13_BMASK0_Info.PD_Est_Type                                    |         0x%01X  |  [RW][09:08]""""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID13_BMASK0_Info.LB_Mask                                        |     0x%05X  |  [RW][29:10]""""\n", FIELD_VALUE(val, 10, 29));
	val = REG_DUMP_READ_REGISTER(0xa31c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID12_DMASK0_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID12_DMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID12_DMASK0_Info (reg_FF_GDDPC_CFGTAB_EID12_DMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID12_DMASK0_Info.D_Mask                                         |      0x%04X  |  [RW][14:00]""""\n", FIELD_VALUE(val, 0, 14));
	val = REG_DUMP_READ_REGISTER(0xa31c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID12_PMASK3_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID12_PMASK3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID12_PMASK3_Info (reg_FF_GDDPC_CFGTAB_EID12_PMASK3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID12_PMASK3_Info.P_Mask                                         |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa31c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID12_PMASK2_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID12_PMASK2_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID12_PMASK2_Info (reg_FF_GDDPC_CFGTAB_EID12_PMASK2_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID12_PMASK2_Info.P_Mask                                         |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa31bc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID12_PMASK1_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID12_PMASK1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID12_PMASK1_Info (reg_FF_GDDPC_CFGTAB_EID12_PMASK1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID12_PMASK1_Info.P_Mask                                         |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa31b8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID12_PMASK0_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID12_PMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID12_PMASK0_Info (reg_FF_GDDPC_CFGTAB_EID12_PMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID12_PMASK0_Info.P_Mask                                         |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa31b4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID12_BMASK1_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID12_BMASK1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID12_BMASK1_Info (reg_FF_GDDPC_CFGTAB_EID12_BMASK1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID12_BMASK1_Info.UB_Mask                                        |     0x%05X  |  [RW][19:00]""""\n", FIELD_VALUE(val, 0, 19));
	val = REG_DUMP_READ_REGISTER(0xa31b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID12_BMASK0_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID12_BMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID12_BMASK0_Info (reg_FF_GDDPC_CFGTAB_EID12_BMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID12_BMASK0_Info.LB_Est_Type                                    |         0x%01X  |  [RW][01:00]""""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID12_BMASK0_Info.UB_Est_Type                                    |         0x%01X  |  [RW][03:02]""""\n", FIELD_VALUE(val, 2, 3));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID12_BMASK0_Info.Pel_Est_Type                                   |         0x%01X  |  [RW][07:04]""""\n", FIELD_VALUE(val, 4, 7));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID12_BMASK0_Info.PD_Est_Type                                    |         0x%01X  |  [RW][09:08]""""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID12_BMASK0_Info.LB_Mask                                        |     0x%05X  |  [RW][29:10]""""\n", FIELD_VALUE(val, 10, 29));
	val = REG_DUMP_READ_REGISTER(0xa31ac);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID11_DMASK0_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID11_DMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID11_DMASK0_Info (reg_FF_GDDPC_CFGTAB_EID11_DMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID11_DMASK0_Info.D_Mask                                         |      0x%04X  |  [RW][14:00]""""\n", FIELD_VALUE(val, 0, 14));
	val = REG_DUMP_READ_REGISTER(0xa31a8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID11_PMASK3_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID11_PMASK3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID11_PMASK3_Info (reg_FF_GDDPC_CFGTAB_EID11_PMASK3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID11_PMASK3_Info.P_Mask                                         |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa31a4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID11_PMASK2_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID11_PMASK2_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID11_PMASK2_Info (reg_FF_GDDPC_CFGTAB_EID11_PMASK2_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID11_PMASK2_Info.P_Mask                                         |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa31a0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID11_PMASK1_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID11_PMASK1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID11_PMASK1_Info (reg_FF_GDDPC_CFGTAB_EID11_PMASK1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID11_PMASK1_Info.P_Mask                                         |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa319c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID11_PMASK0_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID11_PMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID11_PMASK0_Info (reg_FF_GDDPC_CFGTAB_EID11_PMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID11_PMASK0_Info.P_Mask                                         |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa3198);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID11_BMASK1_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID11_BMASK1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID11_BMASK1_Info (reg_FF_GDDPC_CFGTAB_EID11_BMASK1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID11_BMASK1_Info.UB_Mask                                        |     0x%05X  |  [RW][19:00]""""\n", FIELD_VALUE(val, 0, 19));
	val = REG_DUMP_READ_REGISTER(0xa3194);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID11_BMASK0_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID11_BMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID11_BMASK0_Info (reg_FF_GDDPC_CFGTAB_EID11_BMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID11_BMASK0_Info.LB_Est_Type                                    |         0x%01X  |  [RW][01:00]""""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID11_BMASK0_Info.UB_Est_Type                                    |         0x%01X  |  [RW][03:02]""""\n", FIELD_VALUE(val, 2, 3));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID11_BMASK0_Info.Pel_Est_Type                                   |         0x%01X  |  [RW][07:04]""""\n", FIELD_VALUE(val, 4, 7));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID11_BMASK0_Info.PD_Est_Type                                    |         0x%01X  |  [RW][09:08]""""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID11_BMASK0_Info.LB_Mask                                        |     0x%05X  |  [RW][29:10]""""\n", FIELD_VALUE(val, 10, 29));
	val = REG_DUMP_READ_REGISTER(0xa3190);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID10_DMASK0_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID10_DMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID10_DMASK0_Info (reg_FF_GDDPC_CFGTAB_EID10_DMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID10_DMASK0_Info.D_Mask                                         |      0x%04X  |  [RW][14:00]""""\n", FIELD_VALUE(val, 0, 14));
	val = REG_DUMP_READ_REGISTER(0xa318c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID10_PMASK3_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID10_PMASK3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID10_PMASK3_Info (reg_FF_GDDPC_CFGTAB_EID10_PMASK3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID10_PMASK3_Info.P_Mask                                         |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa3188);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID10_PMASK2_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID10_PMASK2_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID10_PMASK2_Info (reg_FF_GDDPC_CFGTAB_EID10_PMASK2_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID10_PMASK2_Info.P_Mask                                         |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa3184);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID10_PMASK1_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID10_PMASK1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID10_PMASK1_Info (reg_FF_GDDPC_CFGTAB_EID10_PMASK1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID10_PMASK1_Info.P_Mask                                         |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa3180);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID10_PMASK0_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID10_PMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID10_PMASK0_Info (reg_FF_GDDPC_CFGTAB_EID10_PMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID10_PMASK0_Info.P_Mask                                         |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa317c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID10_BMASK1_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID10_BMASK1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID10_BMASK1_Info (reg_FF_GDDPC_CFGTAB_EID10_BMASK1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID10_BMASK1_Info.UB_Mask                                        |     0x%05X  |  [RW][19:00]""""\n", FIELD_VALUE(val, 0, 19));
	val = REG_DUMP_READ_REGISTER(0xa3178);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID10_BMASK0_Info        |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID10_BMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID10_BMASK0_Info (reg_FF_GDDPC_CFGTAB_EID10_BMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID10_BMASK0_Info.LB_Est_Type                                    |         0x%01X  |  [RW][01:00]""""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID10_BMASK0_Info.UB_Est_Type                                    |         0x%01X  |  [RW][03:02]""""\n", FIELD_VALUE(val, 2, 3));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID10_BMASK0_Info.Pel_Est_Type                                   |         0x%01X  |  [RW][07:04]""""\n", FIELD_VALUE(val, 4, 7));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID10_BMASK0_Info.PD_Est_Type                                    |         0x%01X  |  [RW][09:08]""""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID10_BMASK0_Info.LB_Mask                                        |     0x%05X  |  [RW][29:10]""""\n", FIELD_VALUE(val, 10, 29));
	val = REG_DUMP_READ_REGISTER(0xa3174);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID9_DMASK0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID9_DMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID9_DMASK0_Info (reg_FF_GDDPC_CFGTAB_EID9_DMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID9_DMASK0_Info.D_Mask                                          |      0x%04X  |  [RW][14:00]""""\n", FIELD_VALUE(val, 0, 14));
	val = REG_DUMP_READ_REGISTER(0xa3170);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID9_PMASK3_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID9_PMASK3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID9_PMASK3_Info (reg_FF_GDDPC_CFGTAB_EID9_PMASK3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID9_PMASK3_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa316c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID9_PMASK2_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID9_PMASK2_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID9_PMASK2_Info (reg_FF_GDDPC_CFGTAB_EID9_PMASK2_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID9_PMASK2_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa3168);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID9_PMASK1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID9_PMASK1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID9_PMASK1_Info (reg_FF_GDDPC_CFGTAB_EID9_PMASK1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID9_PMASK1_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa3164);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID9_PMASK0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID9_PMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID9_PMASK0_Info (reg_FF_GDDPC_CFGTAB_EID9_PMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID9_PMASK0_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa3160);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID9_BMASK1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID9_BMASK1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID9_BMASK1_Info (reg_FF_GDDPC_CFGTAB_EID9_BMASK1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID9_BMASK1_Info.UB_Mask                                         |     0x%05X  |  [RW][19:00]""""\n", FIELD_VALUE(val, 0, 19));
	val = REG_DUMP_READ_REGISTER(0xa315c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID9_BMASK0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID9_BMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID9_BMASK0_Info (reg_FF_GDDPC_CFGTAB_EID9_BMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID9_BMASK0_Info.LB_Est_Type                                     |         0x%01X  |  [RW][01:00]""""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID9_BMASK0_Info.UB_Est_Type                                     |         0x%01X  |  [RW][03:02]""""\n", FIELD_VALUE(val, 2, 3));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID9_BMASK0_Info.Pel_Est_Type                                    |         0x%01X  |  [RW][07:04]""""\n", FIELD_VALUE(val, 4, 7));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID9_BMASK0_Info.PD_Est_Type                                     |         0x%01X  |  [RW][09:08]""""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID9_BMASK0_Info.LB_Mask                                         |     0x%05X  |  [RW][29:10]""""\n", FIELD_VALUE(val, 10, 29));
	val = REG_DUMP_READ_REGISTER(0xa3158);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID8_DMASK0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID8_DMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID8_DMASK0_Info (reg_FF_GDDPC_CFGTAB_EID8_DMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID8_DMASK0_Info.D_Mask                                          |      0x%04X  |  [RW][14:00]""""\n", FIELD_VALUE(val, 0, 14));
	val = REG_DUMP_READ_REGISTER(0xa3154);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID8_PMASK3_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID8_PMASK3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID8_PMASK3_Info (reg_FF_GDDPC_CFGTAB_EID8_PMASK3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID8_PMASK3_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa3150);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID8_PMASK2_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID8_PMASK2_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID8_PMASK2_Info (reg_FF_GDDPC_CFGTAB_EID8_PMASK2_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID8_PMASK2_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa314c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID8_PMASK1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID8_PMASK1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID8_PMASK1_Info (reg_FF_GDDPC_CFGTAB_EID8_PMASK1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID8_PMASK1_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa3148);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID8_PMASK0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID8_PMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID8_PMASK0_Info (reg_FF_GDDPC_CFGTAB_EID8_PMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID8_PMASK0_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa3144);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID8_BMASK1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID8_BMASK1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID8_BMASK1_Info (reg_FF_GDDPC_CFGTAB_EID8_BMASK1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID8_BMASK1_Info.UB_Mask                                         |     0x%05X  |  [RW][19:00]""""\n", FIELD_VALUE(val, 0, 19));
	val = REG_DUMP_READ_REGISTER(0xa3140);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID8_BMASK0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID8_BMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID8_BMASK0_Info (reg_FF_GDDPC_CFGTAB_EID8_BMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID8_BMASK0_Info.LB_Est_Type                                     |         0x%01X  |  [RW][01:00]""""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID8_BMASK0_Info.UB_Est_Type                                     |         0x%01X  |  [RW][03:02]""""\n", FIELD_VALUE(val, 2, 3));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID8_BMASK0_Info.Pel_Est_Type                                    |         0x%01X  |  [RW][07:04]""""\n", FIELD_VALUE(val, 4, 7));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID8_BMASK0_Info.PD_Est_Type                                     |         0x%01X  |  [RW][09:08]""""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID8_BMASK0_Info.LB_Mask                                         |     0x%05X  |  [RW][29:10]""""\n", FIELD_VALUE(val, 10, 29));
	val = REG_DUMP_READ_REGISTER(0xa313c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID7_DMASK0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID7_DMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID7_DMASK0_Info (reg_FF_GDDPC_CFGTAB_EID7_DMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID7_DMASK0_Info.D_Mask                                          |      0x%04X  |  [RW][14:00]""""\n", FIELD_VALUE(val, 0, 14));
	val = REG_DUMP_READ_REGISTER(0xa3138);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID7_PMASK3_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID7_PMASK3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID7_PMASK3_Info (reg_FF_GDDPC_CFGTAB_EID7_PMASK3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID7_PMASK3_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa3134);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID7_PMASK2_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID7_PMASK2_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID7_PMASK2_Info (reg_FF_GDDPC_CFGTAB_EID7_PMASK2_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID7_PMASK2_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa3130);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID7_PMASK1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID7_PMASK1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID7_PMASK1_Info (reg_FF_GDDPC_CFGTAB_EID7_PMASK1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID7_PMASK1_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa312c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID7_PMASK0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID7_PMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID7_PMASK0_Info (reg_FF_GDDPC_CFGTAB_EID7_PMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID7_PMASK0_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa3128);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID7_BMASK1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID7_BMASK1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID7_BMASK1_Info (reg_FF_GDDPC_CFGTAB_EID7_BMASK1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID7_BMASK1_Info.UB_Mask                                         |     0x%05X  |  [RW][19:00]""""\n", FIELD_VALUE(val, 0, 19));
	val = REG_DUMP_READ_REGISTER(0xa3124);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID7_BMASK0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID7_BMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID7_BMASK0_Info (reg_FF_GDDPC_CFGTAB_EID7_BMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID7_BMASK0_Info.LB_Est_Type                                     |         0x%01X  |  [RW][01:00]""""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID7_BMASK0_Info.UB_Est_Type                                     |         0x%01X  |  [RW][03:02]""""\n", FIELD_VALUE(val, 2, 3));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID7_BMASK0_Info.Pel_Est_Type                                    |         0x%01X  |  [RW][07:04]""""\n", FIELD_VALUE(val, 4, 7));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID7_BMASK0_Info.PD_Est_Type                                     |         0x%01X  |  [RW][09:08]""""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID7_BMASK0_Info.LB_Mask                                         |     0x%05X  |  [RW][29:10]""""\n", FIELD_VALUE(val, 10, 29));
	val = REG_DUMP_READ_REGISTER(0xa3120);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID6_DMASK0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID6_DMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID6_DMASK0_Info (reg_FF_GDDPC_CFGTAB_EID6_DMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID6_DMASK0_Info.D_Mask                                          |      0x%04X  |  [RW][14:00]""""\n", FIELD_VALUE(val, 0, 14));
	val = REG_DUMP_READ_REGISTER(0xa311c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID6_PMASK3_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID6_PMASK3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID6_PMASK3_Info (reg_FF_GDDPC_CFGTAB_EID6_PMASK3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID6_PMASK3_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa3118);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID6_PMASK2_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID6_PMASK2_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID6_PMASK2_Info (reg_FF_GDDPC_CFGTAB_EID6_PMASK2_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID6_PMASK2_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa3114);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID6_PMASK1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID6_PMASK1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID6_PMASK1_Info (reg_FF_GDDPC_CFGTAB_EID6_PMASK1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID6_PMASK1_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa3110);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID6_PMASK0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID6_PMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID6_PMASK0_Info (reg_FF_GDDPC_CFGTAB_EID6_PMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID6_PMASK0_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa310c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID6_BMASK1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID6_BMASK1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID6_BMASK1_Info (reg_FF_GDDPC_CFGTAB_EID6_BMASK1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID6_BMASK1_Info.UB_Mask                                         |     0x%05X  |  [RW][19:00]""""\n", FIELD_VALUE(val, 0, 19));
	val = REG_DUMP_READ_REGISTER(0xa3108);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID6_BMASK0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID6_BMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID6_BMASK0_Info (reg_FF_GDDPC_CFGTAB_EID6_BMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID6_BMASK0_Info.LB_Est_Type                                     |         0x%01X  |  [RW][01:00]""""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID6_BMASK0_Info.UB_Est_Type                                     |         0x%01X  |  [RW][03:02]""""\n", FIELD_VALUE(val, 2, 3));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID6_BMASK0_Info.Pel_Est_Type                                    |         0x%01X  |  [RW][07:04]""""\n", FIELD_VALUE(val, 4, 7));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID6_BMASK0_Info.PD_Est_Type                                     |         0x%01X  |  [RW][09:08]""""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID6_BMASK0_Info.LB_Mask                                         |     0x%05X  |  [RW][29:10]""""\n", FIELD_VALUE(val, 10, 29));
	val = REG_DUMP_READ_REGISTER(0xa3104);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID5_DMASK0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID5_DMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID5_DMASK0_Info (reg_FF_GDDPC_CFGTAB_EID5_DMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID5_DMASK0_Info.D_Mask                                          |      0x%04X  |  [RW][14:00]""""\n", FIELD_VALUE(val, 0, 14));
	val = REG_DUMP_READ_REGISTER(0xa3100);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID5_PMASK3_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID5_PMASK3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID5_PMASK3_Info (reg_FF_GDDPC_CFGTAB_EID5_PMASK3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID5_PMASK3_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa30fc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID5_PMASK2_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID5_PMASK2_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID5_PMASK2_Info (reg_FF_GDDPC_CFGTAB_EID5_PMASK2_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID5_PMASK2_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa30f8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID5_PMASK1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID5_PMASK1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID5_PMASK1_Info (reg_FF_GDDPC_CFGTAB_EID5_PMASK1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID5_PMASK1_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa30f4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID5_PMASK0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID5_PMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID5_PMASK0_Info (reg_FF_GDDPC_CFGTAB_EID5_PMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID5_PMASK0_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa30f0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID5_BMASK1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID5_BMASK1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID5_BMASK1_Info (reg_FF_GDDPC_CFGTAB_EID5_BMASK1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID5_BMASK1_Info.UB_Mask                                         |     0x%05X  |  [RW][19:00]""""\n", FIELD_VALUE(val, 0, 19));
	val = REG_DUMP_READ_REGISTER(0xa30ec);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID5_BMASK0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID5_BMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID5_BMASK0_Info (reg_FF_GDDPC_CFGTAB_EID5_BMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID5_BMASK0_Info.LB_Est_Type                                     |         0x%01X  |  [RW][01:00]""""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID5_BMASK0_Info.UB_Est_Type                                     |         0x%01X  |  [RW][03:02]""""\n", FIELD_VALUE(val, 2, 3));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID5_BMASK0_Info.Pel_Est_Type                                    |         0x%01X  |  [RW][07:04]""""\n", FIELD_VALUE(val, 4, 7));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID5_BMASK0_Info.PD_Est_Type                                     |         0x%01X  |  [RW][09:08]""""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID5_BMASK0_Info.LB_Mask                                         |     0x%05X  |  [RW][29:10]""""\n", FIELD_VALUE(val, 10, 29));
	val = REG_DUMP_READ_REGISTER(0xa30e8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID4_DMASK0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID4_DMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID4_DMASK0_Info (reg_FF_GDDPC_CFGTAB_EID4_DMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID4_DMASK0_Info.D_Mask                                          |      0x%04X  |  [RW][14:00]""""\n", FIELD_VALUE(val, 0, 14));
	val = REG_DUMP_READ_REGISTER(0xa30e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID4_PMASK3_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID4_PMASK3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID4_PMASK3_Info (reg_FF_GDDPC_CFGTAB_EID4_PMASK3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID4_PMASK3_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa30e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID4_PMASK2_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID4_PMASK2_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID4_PMASK2_Info (reg_FF_GDDPC_CFGTAB_EID4_PMASK2_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID4_PMASK2_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa30dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID4_PMASK1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID4_PMASK1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID4_PMASK1_Info (reg_FF_GDDPC_CFGTAB_EID4_PMASK1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID4_PMASK1_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa30d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID4_PMASK0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID4_PMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID4_PMASK0_Info (reg_FF_GDDPC_CFGTAB_EID4_PMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID4_PMASK0_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa30d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID4_BMASK1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID4_BMASK1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID4_BMASK1_Info (reg_FF_GDDPC_CFGTAB_EID4_BMASK1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID4_BMASK1_Info.UB_Mask                                         |     0x%05X  |  [RW][19:00]""""\n", FIELD_VALUE(val, 0, 19));
	val = REG_DUMP_READ_REGISTER(0xa30d0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID4_BMASK0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID4_BMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID4_BMASK0_Info (reg_FF_GDDPC_CFGTAB_EID4_BMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID4_BMASK0_Info.LB_Est_Type                                     |         0x%01X  |  [RW][01:00]""""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID4_BMASK0_Info.UB_Est_Type                                     |         0x%01X  |  [RW][03:02]""""\n", FIELD_VALUE(val, 2, 3));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID4_BMASK0_Info.Pel_Est_Type                                    |         0x%01X  |  [RW][07:04]""""\n", FIELD_VALUE(val, 4, 7));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID4_BMASK0_Info.PD_Est_Type                                     |         0x%01X  |  [RW][09:08]""""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID4_BMASK0_Info.LB_Mask                                         |     0x%05X  |  [RW][29:10]""""\n", FIELD_VALUE(val, 10, 29));
	val = REG_DUMP_READ_REGISTER(0xa30cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID3_DMASK0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID3_DMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID3_DMASK0_Info (reg_FF_GDDPC_CFGTAB_EID3_DMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID3_DMASK0_Info.D_Mask                                          |      0x%04X  |  [RW][14:00]""""\n", FIELD_VALUE(val, 0, 14));
	val = REG_DUMP_READ_REGISTER(0xa30c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID3_PMASK3_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID3_PMASK3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID3_PMASK3_Info (reg_FF_GDDPC_CFGTAB_EID3_PMASK3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID3_PMASK3_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa30c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID3_PMASK2_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID3_PMASK2_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID3_PMASK2_Info (reg_FF_GDDPC_CFGTAB_EID3_PMASK2_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID3_PMASK2_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa30c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID3_PMASK1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID3_PMASK1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID3_PMASK1_Info (reg_FF_GDDPC_CFGTAB_EID3_PMASK1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID3_PMASK1_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa30bc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID3_PMASK0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID3_PMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID3_PMASK0_Info (reg_FF_GDDPC_CFGTAB_EID3_PMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID3_PMASK0_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa30b8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID3_BMASK1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID3_BMASK1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID3_BMASK1_Info (reg_FF_GDDPC_CFGTAB_EID3_BMASK1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID3_BMASK1_Info.UB_Mask                                         |     0x%05X  |  [RW][19:00]""""\n", FIELD_VALUE(val, 0, 19));
	val = REG_DUMP_READ_REGISTER(0xa30b4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID3_BMASK0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID3_BMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID3_BMASK0_Info (reg_FF_GDDPC_CFGTAB_EID3_BMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID3_BMASK0_Info.LB_Est_Type                                     |         0x%01X  |  [RW][01:00]""""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID3_BMASK0_Info.UB_Est_Type                                     |         0x%01X  |  [RW][03:02]""""\n", FIELD_VALUE(val, 2, 3));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID3_BMASK0_Info.Pel_Est_Type                                    |         0x%01X  |  [RW][07:04]""""\n", FIELD_VALUE(val, 4, 7));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID3_BMASK0_Info.PD_Est_Type                                     |         0x%01X  |  [RW][09:08]""""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID3_BMASK0_Info.LB_Mask                                         |     0x%05X  |  [RW][29:10]""""\n", FIELD_VALUE(val, 10, 29));
	val = REG_DUMP_READ_REGISTER(0xa30b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID2_DMASK0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID2_DMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID2_DMASK0_Info (reg_FF_GDDPC_CFGTAB_EID2_DMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID2_DMASK0_Info.D_Mask                                          |      0x%04X  |  [RW][14:00]""""\n", FIELD_VALUE(val, 0, 14));
	val = REG_DUMP_READ_REGISTER(0xa30ac);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID2_PMASK3_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID2_PMASK3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID2_PMASK3_Info (reg_FF_GDDPC_CFGTAB_EID2_PMASK3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID2_PMASK3_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa30a8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID2_PMASK2_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID2_PMASK2_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID2_PMASK2_Info (reg_FF_GDDPC_CFGTAB_EID2_PMASK2_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID2_PMASK2_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa30a4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID2_PMASK1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID2_PMASK1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID2_PMASK1_Info (reg_FF_GDDPC_CFGTAB_EID2_PMASK1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID2_PMASK1_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa30a0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID2_PMASK0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID2_PMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID2_PMASK0_Info (reg_FF_GDDPC_CFGTAB_EID2_PMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID2_PMASK0_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa309c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID2_BMASK1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID2_BMASK1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID2_BMASK1_Info (reg_FF_GDDPC_CFGTAB_EID2_BMASK1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID2_BMASK1_Info.UB_Mask                                         |     0x%05X  |  [RW][19:00]""""\n", FIELD_VALUE(val, 0, 19));
	val = REG_DUMP_READ_REGISTER(0xa3098);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID2_BMASK0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID2_BMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID2_BMASK0_Info (reg_FF_GDDPC_CFGTAB_EID2_BMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID2_BMASK0_Info.LB_Est_Type                                     |         0x%01X  |  [RW][01:00]""""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID2_BMASK0_Info.UB_Est_Type                                     |         0x%01X  |  [RW][03:02]""""\n", FIELD_VALUE(val, 2, 3));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID2_BMASK0_Info.Pel_Est_Type                                    |         0x%01X  |  [RW][07:04]""""\n", FIELD_VALUE(val, 4, 7));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID2_BMASK0_Info.PD_Est_Type                                     |         0x%01X  |  [RW][09:08]""""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID2_BMASK0_Info.LB_Mask                                         |     0x%05X  |  [RW][29:10]""""\n", FIELD_VALUE(val, 10, 29));
	val = REG_DUMP_READ_REGISTER(0xa3094);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID1_DMASK0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID1_DMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID1_DMASK0_Info (reg_FF_GDDPC_CFGTAB_EID1_DMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID1_DMASK0_Info.D_Mask                                          |      0x%04X  |  [RW][14:00]""""\n", FIELD_VALUE(val, 0, 14));
	val = REG_DUMP_READ_REGISTER(0xa3090);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID1_PMASK3_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID1_PMASK3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID1_PMASK3_Info (reg_FF_GDDPC_CFGTAB_EID1_PMASK3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID1_PMASK3_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa308c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID1_PMASK2_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID1_PMASK2_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID1_PMASK2_Info (reg_FF_GDDPC_CFGTAB_EID1_PMASK2_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID1_PMASK2_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa3088);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID1_PMASK1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID1_PMASK1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID1_PMASK1_Info (reg_FF_GDDPC_CFGTAB_EID1_PMASK1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID1_PMASK1_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa3084);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID1_PMASK0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID1_PMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID1_PMASK0_Info (reg_FF_GDDPC_CFGTAB_EID1_PMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID1_PMASK0_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa3080);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID1_BMASK1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID1_BMASK1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID1_BMASK1_Info (reg_FF_GDDPC_CFGTAB_EID1_BMASK1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID1_BMASK1_Info.UB_Mask                                         |     0x%05X  |  [RW][19:00]""""\n", FIELD_VALUE(val, 0, 19));
	val = REG_DUMP_READ_REGISTER(0xa307c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID1_BMASK0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID1_BMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID1_BMASK0_Info (reg_FF_GDDPC_CFGTAB_EID1_BMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID1_BMASK0_Info.LB_Est_Type                                     |         0x%01X  |  [RW][01:00]""""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID1_BMASK0_Info.UB_Est_Type                                     |         0x%01X  |  [RW][03:02]""""\n", FIELD_VALUE(val, 2, 3));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID1_BMASK0_Info.Pel_Est_Type                                    |         0x%01X  |  [RW][07:04]""""\n", FIELD_VALUE(val, 4, 7));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID1_BMASK0_Info.PD_Est_Type                                     |         0x%01X  |  [RW][09:08]""""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID1_BMASK0_Info.LB_Mask                                         |     0x%05X  |  [RW][29:10]""""\n", FIELD_VALUE(val, 10, 29));
	val = REG_DUMP_READ_REGISTER(0xa3078);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID0_DMASK0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID0_DMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID0_DMASK0_Info (reg_FF_GDDPC_CFGTAB_EID0_DMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID0_DMASK0_Info.D_Mask                                          |      0x%04X  |  [RW][14:00]""""\n", FIELD_VALUE(val, 0, 14));
	val = REG_DUMP_READ_REGISTER(0xa3074);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID0_PMASK3_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID0_PMASK3_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID0_PMASK3_Info (reg_FF_GDDPC_CFGTAB_EID0_PMASK3_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID0_PMASK3_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa3070);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID0_PMASK2_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID0_PMASK2_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID0_PMASK2_Info (reg_FF_GDDPC_CFGTAB_EID0_PMASK2_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID0_PMASK2_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa306c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID0_PMASK1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID0_PMASK1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID0_PMASK1_Info (reg_FF_GDDPC_CFGTAB_EID0_PMASK1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID0_PMASK1_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa3068);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID0_PMASK0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID0_PMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID0_PMASK0_Info (reg_FF_GDDPC_CFGTAB_EID0_PMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID0_PMASK0_Info.P_Mask                                          |  0x%08X  |  [RW][29:00]""""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xa3064);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID0_BMASK1_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID0_BMASK1_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID0_BMASK1_Info (reg_FF_GDDPC_CFGTAB_EID0_BMASK1_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID0_BMASK1_Info.UB_Mask                                         |     0x%05X  |  [RW][19:00]""""\n", FIELD_VALUE(val, 0, 19));
	val = REG_DUMP_READ_REGISTER(0xa3060);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC.reg_FF_GDDPC_CFGTAB_EID0_BMASK0_Info         |  0x%08X  |  """"\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_reg_FF_GDDPC_CFGTAB_EID0_BMASK0_Info_type */
	/* skip, unused field unused_reg_FF_GDDPC_CFGTAB_EID0_BMASK0_Info (reg_FF_GDDPC_CFGTAB_EID0_BMASK0_Info) */
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID0_BMASK0_Info.LB_Est_Type                                     |         0x%01X  |  [RW][01:00]""""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID0_BMASK0_Info.UB_Est_Type                                     |         0x%01X  |  [RW][03:02]""""\n", FIELD_VALUE(val, 2, 3));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID0_BMASK0_Info.Pel_Est_Type                                    |         0x%01X  |  [RW][07:04]""""\n", FIELD_VALUE(val, 4, 7));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID0_BMASK0_Info.PD_Est_Type                                     |         0x%01X  |  [RW][09:08]""""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -reg_FF_GDDPC_CFGTAB_EID0_BMASK0_Info.LB_Mask                                         |     0x%05X  |  [RW][29:10]""""\n", FIELD_VALUE(val, 10, 29));
} /* end isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_ff_gddpc_afpix */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_ff_gddpc_afpix(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa305c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_ff_gddpc_afpix.afpix_set1_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_ff_gddpc_afpix_afpix_set1_last_type */
	REG_DUMP_PRINT_1("   -afpix_set1_last.afpix_set1_last                                          |  0x%08X  |  [RW][31:00]""afpix_set1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa2860);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_ff_gddpc_afpix.afpix_set1_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_ff_gddpc_afpix_afpix_set1_first_type */
	REG_DUMP_PRINT_1("   -afpix_set1_first.afpix_set1_first                                        |  0x%08X  |  [RW][31:00]""afpix_set1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa285c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_ff_gddpc_afpix.afpix_set0_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_ff_gddpc_afpix_afpix_set0_last_type */
	REG_DUMP_PRINT_1("   -afpix_set0_last.afpix_set0_last                                          |  0x%08X  |  [RW][31:00]""afpix_set0""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa2060);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_ff_gddpc_afpix.afpix_set0_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_ff_gddpc_afpix_afpix_set0_first_type */
	REG_DUMP_PRINT_1("   -afpix_set0_first.afpix_set0_first                                        |  0x%08X  |  [RW][31:00]""afpix_set0""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_ff_gddpc_afpix */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_ff_gddpc_dplut_set1 */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_ff_gddpc_dplut_set1(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa205c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_ff_gddpc_dplut_set1.dplut_set1_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_ff_gddpc_dplut_set1_dplut_set1_last_type */
	REG_DUMP_PRINT_1("   -dplut_set1_last.dplut_set1_last                                               |  0x%08X  |  [RW][31:00]""dplut_set1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa1060);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_ff_gddpc_dplut_set1.dplut_set1_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_ff_gddpc_dplut_set1_dplut_set1_first_type */
	REG_DUMP_PRINT_1("   -dplut_set1_first.dplut_set1_first                                             |  0x%08X  |  [RW][31:00]""dplut_set1""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_ff_gddpc_dplut_set1 */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_ff_gddpc_dplut_set0 */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_ff_gddpc_dplut_set0(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa105c);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_ff_gddpc_dplut_set0.dplut_set0_last   |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_ff_gddpc_dplut_set0_dplut_set0_last_type */
	REG_DUMP_PRINT_1("   -dplut_set0_last.dplut_set0_last                                               |  0x%08X  |  [RW][31:00]""dplut_set0""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa0060);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_ff_gddpc_dplut_set0.dplut_set0_first  |  0x%08X  |  \n", val);
/* reg_type: mem_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_ff_gddpc_dplut_set0_dplut_set0_first_type */
	REG_DUMP_PRINT_1("   -dplut_set0_first.dplut_set0_first                                             |  0x%08X  |  [RW][31:00]""dplut_set0""\n", FIELD_VALUE(val, 0, 31));
} /* end isa_isa_logic_ISA_Cluster_Bayer_Dpc_GDDPC_ff_gddpc_dplut_set0 */

/* Generated Debug Code: Device isa_isa_logic_ISA_Cluster_Bayer_Dpc_AckConv */
void ia_css_debug_dump_isa_isa_logic_ISA_Cluster_Bayer_Dpc_AckConv(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa0054);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_AckConv.reg_Ack_Addr_Info  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_AckConv_reg_Ack_Addr_Info_type */
	REG_DUMP_PRINT_1("   -reg_Ack_Addr_Info.reg_Ack_Addr_Info                          |  0x%08X  |  [RW][31:00]""Ack Addr iNFO register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xa0050);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  isa_isa_logic_ISA_Cluster_Bayer_Dpc_AckConv.reg_Ack_Cmd_Info   |  0x%08X  |  ""Ack cMD iNFO register""\n", val);
/* reg_type: reg_input_system_is_a_logic_isa_isa_logic_ISA_Cluster_Bayer_Dpc_AckConv_reg_Ack_Cmd_Info_type */
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.Message                                     |     0x%05X  |  [RW][18:00]""""\n", FIELD_VALUE(val, 0, 18));
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.CMD                                         |         0x%01X  |  [RO][19:19]""""\n", FIELD_VALUE(val, 19, 19));
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.PID                                         |        0x%02X  |  [RW][25:20]""""\n", FIELD_VALUE(val, 20, 25));
	REG_DUMP_PRINT_1("   -reg_Ack_Cmd_Info.SID                                         |        0x%02X  |  [RW][31:26]""""\n", FIELD_VALUE(val, 26, 31));
} /* end isa_isa_logic_ISA_Cluster_Bayer_Dpc_AckConv */

/* Generated Debug Code: Device trace_unit */
void ia_css_debug_dump_trace_unit(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x7d024);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  trace_unit.read_pointer_reg            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_trace_unit_read_pointer_reg_type */
	/* skip, unused field unused_read_pointer_reg (read_pointer_reg) */
	REG_DUMP_PRINT_1("   -read_pointer_reg.read_pointer_reg    |        0x%02X  |  [RO][05:00]""Register file read pointer.""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x7d020);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  trace_unit.write_pointer_reg           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_trace_unit_write_pointer_reg_type */
	/* skip, unused field unused_write_pointer_reg (write_pointer_reg) */
	REG_DUMP_PRINT_1("   -write_pointer_reg.write_pointer_reg  |        0x%02X  |  [RO][05:00]""Register file write pointer.""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x7d01c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  trace_unit.local_timer1_reg            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_trace_unit_local_timer1_reg_type */
	REG_DUMP_PRINT_1("   -local_timer1_reg.local_timer1_reg    |  0x%08X  |  [RO][31:00]""Local timer1 register.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x7d018);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  trace_unit.local_timer0_reg            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_trace_unit_local_timer0_reg_type */
	REG_DUMP_PRINT_1("   -local_timer0_reg.local_timer0_reg    |  0x%08X  |  [RO][31:00]""Local timer0 register.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x7d014);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  trace_unit.ddr_end_addr_reg            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_trace_unit_ddr_end_addr_reg_type */
	REG_DUMP_PRINT_1("   -ddr_end_addr_reg.ddr_end_addr_reg    |  0x%08X  |  [RW][31:00]""End address of DDR.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x7d010);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  trace_unit.ddr_base_addr_reg           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_trace_unit_ddr_base_addr_reg_type */
	REG_DUMP_PRINT_1("   -ddr_base_addr_reg.ddr_base_addr_reg  |  0x%08X  |  [RW][31:00]""Base address of DDR.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x7d00c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  trace_unit.npk_addr_reg                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_trace_unit_npk_addr_reg_type */
	REG_DUMP_PRINT_1("   -npk_addr_reg.npk_addr_reg            |  0x%08X  |  [RW][31:00]""NPK programmable address register.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x7d008);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  trace_unit.ddr_info_reg                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_trace_unit_ddr_info_reg_type */
	/* skip, unused field unused_ddr_info_reg (ddr_info_reg) */
	REG_DUMP_PRINT_1("   -ddr_info_reg.ddr_info_reg            |       0x%03X  |  [RW][09:00]""DDR info value register.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x7d004);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  trace_unit.npk_enable_reg              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_trace_unit_npk_enable_reg_type */
	/* skip, unused field unused_npk_enable_reg (npk_enable_reg) */
	REG_DUMP_PRINT_1("   -npk_enable_reg.npk_enable_reg        |         0x%01X  |  [RW][00:00]""NPK enable register.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x7d000);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  trace_unit.ddr_enable_reg              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_trace_unit_ddr_enable_reg_type */
	/* skip, unused field unused_ddr_enable_reg (ddr_enable_reg) */
	REG_DUMP_PRINT_1("   -ddr_enable_reg.ddr_enable_reg        |         0x%01X  |  [RW][00:00]""DDR enable register.""\n", FIELD_VALUE(val, 0, 0));
} /* end trace_unit */

/* Generated Debug Code: Device c_gpio */
void ia_css_debug_dump_c_gpio(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x7c640);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  c_gpio.reg_gpio_di                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_c_gpio_reg_gpio_di_type */
	/* skip, unused field unused_reg_gpio_di (reg_gpio_di) */
	REG_DUMP_PRINT_1("   -reg_gpio_di.reg_gpio_di                                |       0x%03X  |  [RO][11:00]""contains the values of all debounced, active level compensated inputs""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x7c63c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  c_gpio.reg_gpio_di_activelevel                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_c_gpio_reg_gpio_di_activelevel_type */
	/* skip, unused field unused_reg_gpio_di_activelevel (reg_gpio_di_activelevel) */
	REG_DUMP_PRINT_1("   -reg_gpio_di_activelevel.reg_gpio_di_activelevel        |       0x%03X  |  [RW][11:00]""indicates for each bit whether it is intended to be active low (value='0') or active high (value='1').""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x7c638);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  c_gpio.reg_gpio_di_debounce_cnt3                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_c_gpio_reg_gpio_di_debounce_cnt3_type */
	REG_DUMP_PRINT_1("   -reg_gpio_di_debounce_cnt3.reg_gpio_di_debounce_cnt3    |  0x%08X  |  [RW][31:00]""Indicates the period an input has to be stable before passing its value to the output""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x7c634);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  c_gpio.reg_gpio_di_debounce_cnt2                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_c_gpio_reg_gpio_di_debounce_cnt2_type */
	REG_DUMP_PRINT_1("   -reg_gpio_di_debounce_cnt2.reg_gpio_di_debounce_cnt2    |  0x%08X  |  [RW][31:00]""Indicates the period an input has to be stable before passing its value to the output""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x7c630);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  c_gpio.reg_gpio_di_debounce_cnt1                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_c_gpio_reg_gpio_di_debounce_cnt1_type */
	REG_DUMP_PRINT_1("   -reg_gpio_di_debounce_cnt1.reg_gpio_di_debounce_cnt1    |  0x%08X  |  [RW][31:00]""Indicates the period an input has to be stable before passing its value to the output*""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x7c62c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  c_gpio.reg_gpio_di_debounce_cnt0                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_c_gpio_reg_gpio_di_debounce_cnt0_type */
	REG_DUMP_PRINT_1("   -reg_gpio_di_debounce_cnt0.reg_gpio_di_debounce_cnt0    |  0x%08X  |  [RW][31:00]""Indicates the period  an input has to be stable before passing its value to the output*""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x7c628);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  c_gpio.reg_gpio_di_debouncemethod                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_c_gpio_reg_gpio_di_debouncemethod_type */
	/* skip, unused field unused_reg_gpio_di_debouncemethod (reg_gpio_di_debouncemethod) */
	REG_DUMP_PRINT_1("   -reg_gpio_di_debouncemethod.reg_gpio_di_debouncemethod  |    0x%06X  |  [RW][23:00]""indicates for each input bit which debouncing counter value is chosen: '00': debounce_cnt0, '01': debounce_cnt1, '10': debounce_cnt2, '11': debounce_cnt3'""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x7c624);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  c_gpio.reg_gpio_do_pwm_enable                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_c_gpio_reg_gpio_do_pwm_enable_type */
	/* skip, unused field unused_reg_gpio_do_pwm_enable (reg_gpio_do_pwm_enable) */
	REG_DUMP_PRINT_1("   -reg_gpio_do_pwm_enable.reg_gpio_do_pwm_enable          |       0x%03X  |  [RW][11:00]""indicates per bit whether PWM is on (value='1') or output is fixed '0' (value='0')""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x7c620);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  c_gpio.reg_gpio_do_pwm_main_cnt                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_c_gpio_reg_gpio_do_pwm_main_cnt_type */
	/* skip, unused field unused_reg_gpio_do_pwm_main_cnt (reg_gpio_do_pwm_main_cnt) */
	REG_DUMP_PRINT_1("   -reg_gpio_do_pwm_main_cnt.reg_gpio_do_pwm_main_cnt      |     0x%05X  |  [RW][19:00]""indicates wrapping value for PWM main counter""\n", FIELD_VALUE(val, 0, 19));
	val = REG_DUMP_READ_REGISTER(0x7c61c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  c_gpio.reg_gpio_do_pwm_cnt_3                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_c_gpio_reg_gpio_do_pwm_cnt_3_type */
	/* skip, unused field unused_reg_gpio_do_pwm_cnt_3 (reg_gpio_do_pwm_cnt_3) */
	REG_DUMP_PRINT_1("   -reg_gpio_do_pwm_cnt_3.reg_gpio_do_pwm_cnt_3            |        0x%02X  |  [RW][05:00]""indicates duty cycle for PWM output 3. value d means duty cycle d/64""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x7c618);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  c_gpio.reg_gpio_do_pwm_cnt_2                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_c_gpio_reg_gpio_do_pwm_cnt_2_type */
	/* skip, unused field unused_reg_gpio_do_pwm_cnt_2 (reg_gpio_do_pwm_cnt_2) */
	REG_DUMP_PRINT_1("   -reg_gpio_do_pwm_cnt_2.reg_gpio_do_pwm_cnt_2            |        0x%02X  |  [RW][05:00]""indicates duty cycle for PWM output 2. value d means duty cycle d/64""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x7c614);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  c_gpio.reg_gpio_do_pwm_cnt_1                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_c_gpio_reg_gpio_do_pwm_cnt_1_type */
	/* skip, unused field unused_reg_gpio_do_pwm_cnt_1 (reg_gpio_do_pwm_cnt_1) */
	REG_DUMP_PRINT_1("   -reg_gpio_do_pwm_cnt_1.reg_gpio_do_pwm_cnt_1            |        0x%02X  |  [RW][05:00]""indicates duty cycle for PWM output 1. value d means duty cycle d/64""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x7c610);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  c_gpio.reg_gpio_do_pwm_cnt_0                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_c_gpio_reg_gpio_do_pwm_cnt_0_type */
	/* skip, unused field unused_reg_gpio_do_pwm_cnt_0 (reg_gpio_do_pwm_cnt_0) */
	REG_DUMP_PRINT_1("   -reg_gpio_do_pwm_cnt_0.reg_gpio_do_pwm_cnt_0            |        0x%02X  |  [RW][05:00]""indicates duty cycle for PWM output 0. value d means duty cycle d/64""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x7c60c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  c_gpio.reg_gpio_do_1                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_c_gpio_reg_gpio_do_1_type */
	/* skip, unused field unused_reg_gpio_do_1 (reg_gpio_do_1) */
	REG_DUMP_PRINT_1("   -reg_gpio_do_1.reg_gpio_do_1                            |       0x%03X  |  [RW][11:00]""provides the value for each of the output bits (source 1)""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x7c608);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  c_gpio.reg_gpio_do_0                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_c_gpio_reg_gpio_do_0_type */
	/* skip, unused field unused_reg_gpio_do_0 (reg_gpio_do_0) */
	REG_DUMP_PRINT_1("   -reg_gpio_do_0.reg_gpio_do_0                            |       0x%03X  |  [RW][11:00]""provides the value for each of the output bits (source 0)""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x7c604);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  c_gpio.reg_gpio_do_select                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_c_gpio_reg_gpio_do_select_type */
	/* skip, unused field unused_reg_gpio_do_select (reg_gpio_do_select) */
	REG_DUMP_PRINT_1("   -reg_gpio_do_select.reg_gpio_do_select                  |       0x%03X  |  [RW][11:00]""indicates for each bit of gpio_do whether it should have the value from source 0 (value='0') or source 1 (value='1').""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x7c600);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  c_gpio.reg_gpio_doe                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_c_gpio_reg_gpio_doe_type */
	/* skip, unused field unused_reg_gpio_doe (reg_gpio_doe) */
	REG_DUMP_PRINT_1("   -reg_gpio_doe.reg_gpio_doe                              |       0x%03X  |  [RW][11:00]""indicates for each bit whether it is intended to be an input (value='0') or an output (value='1')""\n", FIELD_VALUE(val, 0, 11));
} /* end c_gpio */

/* Generated Debug Code: Device gpreg_srst */
void ia_css_debug_dump_gpreg_srst(void) {
/* Skipping Device gpreg_srst - No registers to dump*/
} /* end gpreg_srst */

/* Generated Debug Code: Device irq_ctrl */
void ia_css_debug_dump_irq_ctrl(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xbc414);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl.irq_level_not_pulse                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_irq_ctrl_irq_level_not_pulse_type */
	/* skip, unused field unused_irq_level_not_pulse (irq_level_not_pulse) */
	REG_DUMP_PRINT_1("   -irq_level_not_pulse.irq_level_not_pulse      |      0x%04X  |  [RW][12:00]""Indicates for each bit whether an interrupt cause is translated into a pulse (value='0') or into a constant level '1' (value='1') on the IRQ pin.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xbc410);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl.irq_enable                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_irq_ctrl_irq_enable_type */
	/* skip, unused field unused_irq_enable (irq_enable) */
	REG_DUMP_PRINT_1("   -irq_enable.irq_enable                        |      0x%04X  |  [RW][12:00]""Indicates for each bit whether an interrupt cause as monitored by the req_irq_status register also affects the IRQ pin (value='1') or not (value='0').""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xbc408);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl.irq_status                            |  0x%08X  |  ""Indicates for each bit whether a non-masked interrupt has been generated (value='1'). Can be cleared by writing a '1' into the the corresponding bit of the req_irq_clear register.""\n", val);
/* reg_type: reg_input_system_is_a_logic_irq_ctrl_irq_status_type */
	/* skip, unused field unused_irq_status (irq_status) */
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_DMA                      |         0x%01X  |  [RO][00:00]""Represents the status of the irq from  dma.""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_MIPI_BE0                 |         0x%01X  |  [RO][01:01]""Represents the status of the irq from  mipi_be0.""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_MIPI_BE1                 |         0x%01X  |  [RO][02:02]""Represents the status of the irq from  mipi_be1.""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2V0                     |         0x%01X  |  [RO][03:03]""Represents the status of the irq from  s2v0.""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2V1                     |         0x%01X  |  [RO][04:04]""Represents the status of the irq from  s2v1.""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_ISA                      |         0x%01X  |  [RO][05:05]""Represents the status of the irq from  isa.""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_IBUF_CTRL                |         0x%01X  |  [RO][06:06]""Represents the status of the irq from  ibuf_ctrl.""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_PF                       |         0x%01X  |  [RO][07:07]""Represents the status of the irq from  pixel formatter.""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_SOC_MIPI_BE0             |         0x%01X  |  [RO][08:08]""Represents the status of the irq from  soc_mipi_be0.""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_SOC_MIPI_BE1             |         0x%01X  |  [RO][09:09]""Represents the status of the irq from  soc_mipi_be1.""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_SOC_S2M0                 |         0x%01X  |  [RO][10:10]""Represents the status of the irq from  soc_s2m0.""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_SOC_S2M1                 |         0x%01X  |  [RO][11:11]""Represents the status of the irq from  soc_s2m1.""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_SOC_ISAPF                |         0x%01X  |  [RO][12:12]""Represents the status of the irq from  soc_isapf.""\n", FIELD_VALUE(val, 12, 12));
	val = REG_DUMP_READ_REGISTER(0xbc404);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl.irq_mask                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_irq_ctrl_irq_mask_type */
	/* skip, unused field unused_irq_mask (irq_mask) */
	REG_DUMP_PRINT_1("   -irq_mask.irq_mask                            |      0x%04X  |  [RW][12:00]""Indicates for each bit of irq_di whether it can generate an interrupt request (value='1') or not (value='0'). Setting will affect irq_value as well as IRQ output pin.""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0xbc400);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl.irq_edge                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_irq_ctrl_irq_edge_type */
	/* skip, unused field unused_irq_edge (irq_edge) */
	REG_DUMP_PRINT_1("   -irq_edge.irq_edge                            |      0x%04X  |  [RW][12:00]""Indicates for each bit whether an interrupt request should be generated on a falling edge (value='0') or a rising edge (value='1').""\n", FIELD_VALUE(val, 0, 12));
	val = REG_DUMP_READ_REGISTER(0x7c014);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl.irq_level_not_pulse                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_irq_ctrl_irq_level_not_pulse_type */
	REG_DUMP_PRINT_1("   -irq_level_not_pulse.irq_level_not_pulse      |  0x%08X  |  [RW][31:00]""Indicates for each bit whether an interrupt cause is translated into a pulse (value='0') or into a constant level '1' (value='1') on the IRQ pin.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x7c010);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl.irq_enable                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_irq_ctrl_irq_enable_type */
	REG_DUMP_PRINT_1("   -irq_enable.irq_enable                        |  0x%08X  |  [RW][31:00]""Indicates for each bit whether an interrupt cause as monitored by the req_irq_status register also affects the IRQ pin (value='1') or not (value='0').""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x7c008);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl.irq_status                            |  0x%08X  |  ""Indicates for each bit whether a non-masked interrupt has been generated (value='1'). Can be cleared by writing a '1' into the the corresponding bit of the req_irq_clear register.""\n", val);
/* reg_type: reg_input_system_unis_logic_irq_ctrl_irq_status_type */
	REG_DUMP_PRINT_1("   -irq_status.UNIS_IRQ_STAT_DMA_EXT0            |         0x%01X  |  [RO][00:00]""Represents the status of the irq from  dma_ext0.""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -irq_status.UNIS_IRQ_STAT_DMA_EXT1            |         0x%01X  |  [RO][01:01]""Represents the status of the irq from  dma_ext1.""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -irq_status.UNIS_IRQ_STAT_FW_DMA              |         0x%01X  |  [RO][02:02]""Represents the status of the irq from  fw_dma.""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -irq_status.UNIS_IRQ_STAT_CSI2_A              |         0x%01X  |  [RO][03:03]""Represents the status of the irq from  csi2_a.""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -irq_status.UNIS_IRQ_STAT_CSI2_B              |         0x%01X  |  [RO][04:04]""Represents the status of the irq from  csi2_b.""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -irq_status.UNIS_IRQ_STAT_CSI2_C              |         0x%01X  |  [RO][05:05]""Represents the status of the irq from  csi2_c.""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -irq_status.UNIS_IRQ_STAT_CSI2_D              |         0x%01X  |  [RO][06:06]""Represents the status of the irq from  csi2_d.""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -irq_status.UNIS_IRQ_STAT_CSI2_3PH_0          |         0x%01X  |  [RO][07:07]""Represents the status of the irq from  csi2_3ph_0.""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -irq_status.UNIS_IRQ_STAT_CSI2_3PH_1          |         0x%01X  |  [RO][08:08]""Represents the status of the irq from  csi2_3ph_1.""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -irq_status.UNIS_IRQ_STAT_CSI2_3PH_2          |         0x%01X  |  [RO][09:09]""Represents the status of the irq from  csi2_3ph_2.""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -irq_status.UNIS_IRQ_STAT_CSI2_3PH_3          |         0x%01X  |  [RO][10:10]""Represents the status of the irq from  csi2_3ph_3.""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -irq_status.UNIS_IRQ_STAT_CSI2_3PH_A          |         0x%01X  |  [RO][11:11]""Represents the status of the irq from  csi2_3ph_a.""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -irq_status.UNIS_IRQ_STAT_CSI2_3PH_B          |         0x%01X  |  [RO][12:12]""Represents the status of the irq from  csi2_3ph_b.""\n", FIELD_VALUE(val, 12, 12));
	REG_DUMP_PRINT_1("   -irq_status.UNIS_IRQ_STAT_ISL                 |         0x%01X  |  [RO][13:13]""Represents the status of the irq from  input_slice.""\n", FIELD_VALUE(val, 13, 13));
	REG_DUMP_PRINT_1("   -irq_status.UNIS_IRQ_STAT_GDA_STALL_ERR       |         0x%01X  |  [RO][14:14]""Represents the status of the irq from  irq_gda_stall_error.""\n", FIELD_VALUE(val, 14, 14));
	REG_DUMP_PRINT_1("   -irq_status.UNIS_IRQ_STAT_GDA_READ_ERR        |         0x%01X  |  [RO][15:15]""Represents the status of the irq from  irq_gda_read_error.""\n", FIELD_VALUE(val, 15, 15));
	REG_DUMP_PRINT_1("   -irq_status.UNIS_IRQ_STAT_GDA_ALLOC_URGENT    |         0x%01X  |  [RO][16:16]""Represents the status of the irq from  irq_gda_alloc_urgent.""\n", FIELD_VALUE(val, 16, 16));
	REG_DUMP_PRINT_1("   -irq_status.UNIS_IRQ_STAT_GDA_ALLOC_CRITICAL  |         0x%01X  |  [RO][17:17]""Represents the status of the irq from  irq_gda_alloc_critical.""\n", FIELD_VALUE(val, 17, 17));
	REG_DUMP_PRINT_1("   -irq_status.UNIS_IRQ_STAT_SIG2CIO_OVERFLOW    |         0x%01X  |  [RO][18:18]""Represents the status of the irq from  irq_sig2cio_overflow.""\n", FIELD_VALUE(val, 18, 18));
	REG_DUMP_PRINT_1("   -irq_status.UNIS_IRQ_STAT_GPIO0               |         0x%01X  |  [RO][19:19]""Represents the status of the irq from  gpio.""\n", FIELD_VALUE(val, 19, 19));
	REG_DUMP_PRINT_1("   -irq_status.UNIS_IRQ_STAT_GPIO1               |         0x%01X  |  [RO][20:20]""Represents the status of the irq from  gpio.""\n", FIELD_VALUE(val, 20, 20));
	REG_DUMP_PRINT_1("   -irq_status.UNIS_IRQ_STAT_GPIO2               |         0x%01X  |  [RO][21:21]""Represents the status of the irq from  gpio.""\n", FIELD_VALUE(val, 21, 21));
	REG_DUMP_PRINT_1("   -irq_status.UNIS_IRQ_STAT_GPIO3               |         0x%01X  |  [RO][22:22]""Represents the status of the irq from  gpio.""\n", FIELD_VALUE(val, 22, 22));
	REG_DUMP_PRINT_1("   -irq_status.UNIS_IRQ_STAT_GPIO4               |         0x%01X  |  [RO][23:23]""Represents the status of the irq from  gpio.""\n", FIELD_VALUE(val, 23, 23));
	REG_DUMP_PRINT_1("   -irq_status.UNIS_IRQ_STAT_GPIO5               |         0x%01X  |  [RO][24:24]""Represents the status of the irq from  gpio.""\n", FIELD_VALUE(val, 24, 24));
	REG_DUMP_PRINT_1("   -irq_status.UNIS_IRQ_STAT_GPIO6               |         0x%01X  |  [RO][25:25]""Represents the status of the irq from  gpio.""\n", FIELD_VALUE(val, 25, 25));
	REG_DUMP_PRINT_1("   -irq_status.UNIS_IRQ_STAT_GPIO7               |         0x%01X  |  [RO][26:26]""Represents the status of the irq from  gpio.""\n", FIELD_VALUE(val, 26, 26));
	REG_DUMP_PRINT_1("   -irq_status.UNIS_IRQ_STAT_GPIO8               |         0x%01X  |  [RO][27:27]""Represents the status of the irq from  gpio.""\n", FIELD_VALUE(val, 27, 27));
	REG_DUMP_PRINT_1("   -irq_status.UNIS_IRQ_STAT_GPIO9               |         0x%01X  |  [RO][28:28]""Represents the status of the irq from  gpio.""\n", FIELD_VALUE(val, 28, 28));
	REG_DUMP_PRINT_1("   -irq_status.UNIS_IRQ_STAT_GPIO10              |         0x%01X  |  [RO][29:29]""Represents the status of the irq from  gpio.""\n", FIELD_VALUE(val, 29, 29));
	REG_DUMP_PRINT_1("   -irq_status.UNIS_IRQ_STAT_SWIRQ_GPIO11        |         0x%01X  |  [RO][30:30]""Represents the status of the sw irq or of gipio[11].""\n", FIELD_VALUE(val, 30, 30));
	REG_DUMP_PRINT_1("   -irq_status.UNIS_IRQ_STAT_SP                  |         0x%01X  |  [RO][31:31]""Represents the status of the irq from  sp.""\n", FIELD_VALUE(val, 31, 31));
	val = REG_DUMP_READ_REGISTER(0x7c004);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl.irq_mask                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_irq_ctrl_irq_mask_type */
	REG_DUMP_PRINT_1("   -irq_mask.irq_mask                            |  0x%08X  |  [RW][31:00]""Indicates for each bit of irq_di whether it can generate an interrupt request (value='1') or not (value='0'). Setting will affect irq_value as well as IRQ output pin.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x7c000);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl.irq_edge                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_irq_ctrl_irq_edge_type */
	REG_DUMP_PRINT_1("   -irq_edge.irq_edge                            |  0x%08X  |  [RW][31:00]""Indicates for each bit whether an interrupt request should be generated on a falling edge (value='0') or a rising edge (value='1').""\n", FIELD_VALUE(val, 0, 31));
} /* end irq_ctrl */

/* Generated Debug Code: Device master_gate_ciogate_mt2 */
void ia_css_debug_dump_master_gate_ciogate_mt2(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x7b024);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  master_gate_ciogate_mt2.state       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_master_gate_ciogate_mt2_state_type */
	REG_DUMP_PRINT_1("   -state.state                       |  0x%08X  |  [RO][31:00]""The sate of the CIO Gate. Bit 0 = master CS; bit 1 = master RUN; bit 2 = master WE_N; bit 3 = master RACCEPT; bit 4 = master FIRST; bit 5 = master LAST; bit 6 =busy; bit 7 = rd_expected""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x7b020);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  master_gate_ciogate_mt2.rd_counter  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_master_gate_ciogate_mt2_rd_counter_type */
	REG_DUMP_PRINT_1("   -rd_counter.rd_counter             |  0x%08X  |  [RO][31:00]""The counter of the outstanding reads""\n", FIELD_VALUE(val, 0, 31));
} /* end master_gate_ciogate_mt2 */

/* Generated Debug Code: Device master_gate_ciogate_mt1 */
void ia_css_debug_dump_master_gate_ciogate_mt1(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x7b014);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  master_gate_ciogate_mt1.state       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_master_gate_ciogate_mt1_state_type */
	REG_DUMP_PRINT_1("   -state.state                       |  0x%08X  |  [RO][31:00]""The sate of the CIO Gate. Bit 0 = master CS; bit 1 = master RUN; bit 2 = master WE_N; bit 3 = master RACCEPT; bit 4 = master FIRST; bit 5 = master LAST; bit 6 =busy; bit 7 = rd_expected""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x7b010);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  master_gate_ciogate_mt1.rd_counter  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_master_gate_ciogate_mt1_rd_counter_type */
	REG_DUMP_PRINT_1("   -rd_counter.rd_counter             |  0x%08X  |  [RO][31:00]""The counter of the outstanding reads""\n", FIELD_VALUE(val, 0, 31));
} /* end master_gate_ciogate_mt1 */

/* Generated Debug Code: Device master_gate_ciogate_mt0 */
void ia_css_debug_dump_master_gate_ciogate_mt0(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x7b004);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  master_gate_ciogate_mt0.state       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_master_gate_ciogate_mt0_state_type */
	REG_DUMP_PRINT_1("   -state.state                       |  0x%08X  |  [RO][31:00]""The sate of the CIO Gate. Bit 0 = master CS; bit 1 = master RUN; bit 2 = master WE_N; bit 3 = master RACCEPT; bit 4 = master FIRST; bit 5 = master LAST; bit 6 =busy; bit 7 = rd_expected""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x7b000);
	REG_DUMP_PRINT_0("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  master_gate_ciogate_mt0.rd_counter  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_master_gate_ciogate_mt0_rd_counter_type */
	REG_DUMP_PRINT_1("   -rd_counter.rd_counter             |  0x%08X  |  [RO][31:00]""The counter of the outstanding reads""\n", FIELD_VALUE(val, 0, 31));
} /* end master_gate_ciogate_mt0 */

/* Generated Debug Code: Device pma_if */
void ia_css_debug_dump_pma_if(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x7a20c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  pma_if.fillflush_qres_address0                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_pma_if_fillflush_qres_address0_type */
	REG_DUMP_PRINT_1("   -fillflush_qres_address0.fillflush_qres_address0  |  0x%08X  |  [RW][31:00]""Fill/Flush queue reservation address register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x7a208);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  pma_if.fillflush_command0                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_pma_if_fillflush_command0_type */
	REG_DUMP_PRINT_1("   -fillflush_command0.fillflush_command0            |  0x%08X  |  [RW][31:00]""Fill/Flush command token register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x7a204);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  pma_if.fillflush_address0                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_pma_if_fillflush_address0_type */
	REG_DUMP_PRINT_1("   -fillflush_address0.fillflush_address0            |  0x%08X  |  [RW][31:00]""Fill/Flush address register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x7a200);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  pma_if.fillflush_configuration0                    |  0x%08X  |  ""Fill/Flush configuration register, count and queue reservation disable""\n", val);
/* reg_type: reg_input_system_unis_logic_pma_if_fillflush_configuration0_type */
	/* skip, unused field unused_fillflush_configuration0 (fillflush_configuration0) */
	REG_DUMP_PRINT_1("   -fillflush_configuration0.count                   |         0x%01X  |  [RW][01:00]""Fill/Flush count""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -fillflush_configuration0.disable_qres            |         0x%01X  |  [RW][02:02]""Disable queue reservation""\n", FIELD_VALUE(val, 2, 2));
	val = REG_DUMP_READ_REGISTER(0x7a10c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  pma_if.drain_address3                              |  0x%08X  |  ""Drain address and drain count register""\n", val);
/* reg_type: reg_input_system_unis_logic_pma_if_drain_address3_type */
	REG_DUMP_PRINT_1("   -drain_address3.count                             |         0x%01X  |  [RW][01:00]""Drain count""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -drain_address3.address                           |  0x%08X  |  [RW][31:02]""Drain Address""\n", FIELD_VALUE(val, 2, 31));
	val = REG_DUMP_READ_REGISTER(0x7a108);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  pma_if.drain_address2                              |  0x%08X  |  ""Drain address and drain count register""\n", val);
/* reg_type: reg_input_system_unis_logic_pma_if_drain_address2_type */
	REG_DUMP_PRINT_1("   -drain_address2.count                             |         0x%01X  |  [RW][01:00]""Drain count""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -drain_address2.address                           |  0x%08X  |  [RW][31:02]""Drain Address""\n", FIELD_VALUE(val, 2, 31));
	val = REG_DUMP_READ_REGISTER(0x7a104);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  pma_if.drain_address1                              |  0x%08X  |  ""Drain address and drain count register""\n", val);
/* reg_type: reg_input_system_unis_logic_pma_if_drain_address1_type */
	REG_DUMP_PRINT_1("   -drain_address1.count                             |         0x%01X  |  [RW][01:00]""Drain count""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -drain_address1.address                           |  0x%08X  |  [RW][31:02]""Drain Address""\n", FIELD_VALUE(val, 2, 31));
	val = REG_DUMP_READ_REGISTER(0x7a100);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  pma_if.drain_address0                              |  0x%08X  |  ""Drain address and drain count register""\n", val);
/* reg_type: reg_input_system_unis_logic_pma_if_drain_address0_type */
	REG_DUMP_PRINT_1("   -drain_address0.count                             |         0x%01X  |  [RW][01:00]""Drain count""\n", FIELD_VALUE(val, 0, 1));
	REG_DUMP_PRINT_1("   -drain_address0.address                           |  0x%08X  |  [RW][31:02]""Drain Address""\n", FIELD_VALUE(val, 2, 31));
	val = REG_DUMP_READ_REGISTER(0x7a008);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  pma_if.back_off_timer                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_pma_if_back_off_timer_type */
	/* skip, unused field unused_back_off_timer (back_off_timer) */
	REG_DUMP_PRINT_1("   -back_off_timer.back_off_timer                    |      0x%04X  |  [RW][15:00]""Back_off timer register, hold off new queue reservation for this time""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x7a004);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  pma_if.token                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_pma_if_token_type */
	REG_DUMP_PRINT_1("   -token.token                                      |  0x%08X  |  [RW][31:00]""Drain token register""\n", FIELD_VALUE(val, 0, 31));
} /* end pma_if */

/* Generated Debug Code: Device gda */
void ia_css_debug_dump_gda(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x7802c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gda.enable_clk_gate                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_gda_enable_clk_gate_type */
	/* skip, unused field unused_enable_clk_gate (enable_clk_gate) */
	REG_DUMP_PRINT_1("   -enable_clk_gate.enable_clk_gate                |         0x%01X  |  [RW][00:00]""Enable the automatic clockgating in the GDA to save power""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x78028);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gda.port_status                                  |  0x%08X  |  ""The status of the GDA ports""\n", val);
/* reg_type: reg_input_system_unis_logic_gda_port_status_type */
	/* skip, unused field unused_port_status (port_status) */
	REG_DUMP_PRINT_1("   -port_status.mt_cfg_cs                          |         0x%01X  |  [RO][00:00]""The CS of the mt_cfg port""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -port_status.mt_cfg_run                         |         0x%01X  |  [RO][01:01]""The RUN of the mt_cfg port""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -port_status.mt_cfg_we_n                        |         0x%01X  |  [RO][02:02]""The WE_N of the mt_cfg port""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -port_status.sl_wr_cs                           |         0x%01X  |  [RO][03:03]""The CS of the sl_wr port""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -port_status.sl_wr_run                          |         0x%01X  |  [RO][04:04]""The RUN of the sl_wr port""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -port_status.sl_wr_we_n                         |         0x%01X  |  [RO][05:05]""The WE_N of the sl_wr port""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -port_status.sl_rd_cs                           |         0x%01X  |  [RO][06:06]""The CS of the sl_rd port""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -port_status.sl_rd_run                          |         0x%01X  |  [RO][07:07]""The RUN of the sl_rd port""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -port_status.sl_rd_we_n                         |         0x%01X  |  [RO][08:08]""The WE_N of the sl_rd port""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -port_status.mt_wr_cs                           |         0x%01X  |  [RO][09:09]""The CS of the mt_wr port""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -port_status.mt_wr_run                          |         0x%01X  |  [RO][10:10]""The RUN of the mt_wr port""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -port_status.mt_wr_we_n                         |         0x%01X  |  [RO][11:11]""The WE_N of the mt_wr port""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -port_status.mt_rd_cs                           |         0x%01X  |  [RO][12:12]""The CS of the mt_rd port""\n", FIELD_VALUE(val, 12, 12));
	REG_DUMP_PRINT_1("   -port_status.mt_rd_run                          |         0x%01X  |  [RO][13:13]""The RUN of the mt_rd port""\n", FIELD_VALUE(val, 13, 13));
	REG_DUMP_PRINT_1("   -port_status.mt_rd_we_n                         |         0x%01X  |  [RO][14:14]""The WE_N of the mt_rd port""\n", FIELD_VALUE(val, 14, 14));
	val = REG_DUMP_READ_REGISTER(0x78024);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gda.nr_pages_allocated                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_gda_nr_pages_allocated_type */
	/* skip, unused field unused_nr_pages_allocated (nr_pages_allocated) */
	REG_DUMP_PRINT_1("   -nr_pages_allocated.nr_pages_allocated          |        0x%02X  |  [RO][07:00]""The number of allocated pages in the GDA""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0x78020);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gda.iwake_address                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_gda_iwake_address_type */
	/* skip, unused field unused_iwake_address (iwake_address) */
	REG_DUMP_PRINT_1("   -iwake_address.iwake_address                    |  0x%08X  |  [RW][29:00]""The address where the IWake token has to be written to. This is a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x7801c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gda.enable_iwake                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_gda_enable_iwake_type */
	/* skip, unused field unused_enable_iwake (enable_iwake) */
	REG_DUMP_PRINT_1("   -enable_iwake.enable_iwake                      |         0x%01X  |  [RW][00:00]""Enable the sending of an IWake token when the number of allocated pages reached the 'iwake_threshold' value. Only enable after setting the 'iwake_threshold' value, else a token will be immediately send""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x78018);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gda.iwake_reset_threshold                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_gda_iwake_reset_threshold_type */
	/* skip, unused field unused_iwake_reset_threshold (iwake_reset_threshold) */
	REG_DUMP_PRINT_1("   -iwake_reset_threshold.iwake_reset_threshold    |        0x%02X  |  [RW][07:00]""The IWake send status will be reset when the number of allocated pages drops below this value. The 'iwake_threshold' value is used in case this register is set to 0. This value should never be set higher than the 'iwake_threshold' value, this will result in constantly sending IWake tokens when the IWake threshold is reached""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0x78014);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gda.iwake_threshold                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_gda_iwake_threshold_type */
	/* skip, unused field unused_iwake_threshold (iwake_threshold) */
	REG_DUMP_PRINT_1("   -iwake_threshold.iwake_threshold                |        0x%02X  |  [RW][07:00]""Send an IWake when the threshold of allocated pages is reached; only one token is send until the status has been reset""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0x78010);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gda.irq_critical_threshold                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_gda_irq_critical_threshold_type */
	/* skip, unused field unused_irq_critical_threshold (irq_critical_threshold) */
	REG_DUMP_PRINT_1("   -irq_critical_threshold.irq_critical_threshold  |        0x%02X  |  [RW][07:00]""Set the irq_alloc_critical output when this threshold is reached. Disabled when value = 0""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0x7800c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gda.irq_urgent_threshold                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_gda_irq_urgent_threshold_type */
	/* skip, unused field unused_irq_urgent_threshold (irq_urgent_threshold) */
	REG_DUMP_PRINT_1("   -irq_urgent_threshold.irq_urgent_threshold      |        0x%02X  |  [RW][07:00]""Set the irq_alloc_urgent output when this threshold is reached. Disabled when value = 0""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0x78008);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gda.allocation_status                            |  0x%08X  |  ""The status of the GDA for the allocation part""\n", val);
/* reg_type: reg_input_system_unis_logic_gda_allocation_status_type */
	/* skip, unused field unused_allocation_status (allocation_status) */
	REG_DUMP_PRINT_1("   -allocation_status.threshold_reached            |         0x%01X  |  [RO][00:00]""Threshold reached""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -allocation_status.iwake_send                   |         0x%01X  |  [RO][01:01]""IWake send, this will be reset when lower bound (iwake_reset_threshold) is reached""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -allocation_status.stalling                     |         0x%01X  |  [RO][02:02]""Stalling the write port""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -allocation_status.current_virtual_page         |       0x%03X  |  [RO][14:03]""The current virtual page that is being allocated""\n", FIELD_VALUE(val, 3, 14));
	val = REG_DUMP_READ_REGISTER(0x78004);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gda.enable_gda                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_gda_enable_gda_type */
	/* skip, unused field unused_enable_gda (enable_gda) */
	REG_DUMP_PRINT_1("   -enable_gda.enable_gda                          |         0x%01X  |  [RW][00:00]""Enable GDA with; no allocation or address lookup is done when this bit is not set""\n", FIELD_VALUE(val, 0, 0));
} /* end gda */

/* Generated Debug Code: Device fw_dma_eqc */
void ia_css_debug_dump_fw_dma_eqc(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x74010);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_eqc.back_off_timer                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_eqc_back_off_timer_type */
	/* skip, unused field unused_back_off_timer (back_off_timer) */
	REG_DUMP_PRINT_1("   -back_off_timer.back_off_timer          |        0x%02X  |  [RW][05:00]""Back_off timer register, holds off new queue reservation for the specified time""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x74008);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_eqc.queue_reserve_map0            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_eqc_queue_reserve_map0_type */
	REG_DUMP_PRINT_1("   -queue_reserve_map0.queue_reserve_map0  |  0x%08X  |  [RW][31:00]""Queue reserve address register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x74004);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_eqc.ahigh_map0                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_eqc_ahigh_map0_type */
	REG_DUMP_PRINT_1("   -ahigh_map0.ahigh_map0                  |  0x%08X  |  [RW][31:00]""High address compare register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x74000);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_eqc.alow_map0                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_eqc_alow_map0_type */
	REG_DUMP_PRINT_1("   -alow_map0.alow_map0                    |  0x%08X  |  [RW][31:00]""Low address compare register""\n", FIELD_VALUE(val, 0, 31));
} /* end fw_dma_eqc */

/* Generated Debug Code: Device fw_dma_dma */
void ia_css_debug_dump_fw_dma_dma(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x70374);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.terminal1_lock_status                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_terminal1_lock_status_type */
	/* skip, unused field unused_terminal1_lock_status (terminal1_lock_status) */
	REG_DUMP_PRINT_1("   -terminal1_lock_status.terminal1_lock_status                            |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x70370);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.terminal1_pending_counter                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_terminal1_pending_counter_type */
	/* skip, unused field unused_terminal1_pending_counter (terminal1_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal1_pending_counter.terminal1_pending_counter                    |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x70354);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.terminal1_port_mode                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_terminal1_port_mode_type */
	/* skip, unused field unused_terminal1_port_mode (terminal1_port_mode) */
	REG_DUMP_PRINT_1("   -terminal1_port_mode.terminal1_port_mode                                |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x70350);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.terminal1_cio_info_setup                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_terminal1_cio_info_setup_type */
	/* skip, unused field unused_terminal1_cio_info_setup (terminal1_cio_info_setup) */
	REG_DUMP_PRINT_1("   -terminal1_cio_info_setup.terminal1_cio_info_setup                      |       0x%03X  |  [RW][10:00]""Specifies the CIO protocol info field value to be used for all read/write access to this terminal.""\n", FIELD_VALUE(val, 0, 10));
	val = REG_DUMP_READ_REGISTER(0x70344);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.terminal1_region_width                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_terminal1_region_width_type */
	/* skip, unused field unused_terminal1_region_width (terminal1_region_width) */
	REG_DUMP_PRINT_1("   -terminal1_region_width.terminal1_region_width                          |      0x%04X  |  [RW][14:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 14));
	val = REG_DUMP_READ_REGISTER(0x70340);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.terminal1_region_origin                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_terminal1_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal1_region_origin.terminal1_region_origin                        |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x70334);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.terminal0_lock_status                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_terminal0_lock_status_type */
	/* skip, unused field unused_terminal0_lock_status (terminal0_lock_status) */
	REG_DUMP_PRINT_1("   -terminal0_lock_status.terminal0_lock_status                            |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x70330);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.terminal0_pending_counter                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_terminal0_pending_counter_type */
	/* skip, unused field unused_terminal0_pending_counter (terminal0_pending_counter) */
	REG_DUMP_PRINT_1("   -terminal0_pending_counter.terminal0_pending_counter                    |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x70314);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.terminal0_port_mode                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_terminal0_port_mode_type */
	/* skip, unused field unused_terminal0_port_mode (terminal0_port_mode) */
	REG_DUMP_PRINT_1("   -terminal0_port_mode.terminal0_port_mode                                |         0x%01X  |  [RW][00:00]""Register holding the value of the port mode field contained in the terminal descriptor for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x70310);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.terminal0_cio_info_setup                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_terminal0_cio_info_setup_type */
	/* skip, unused field unused_terminal0_cio_info_setup (terminal0_cio_info_setup) */
	REG_DUMP_PRINT_1("   -terminal0_cio_info_setup.terminal0_cio_info_setup                      |       0x%03X  |  [RW][10:00]""Specifies the CIO protocol info field value to be used for all read/write access to this terminal.""\n", FIELD_VALUE(val, 0, 10));
	val = REG_DUMP_READ_REGISTER(0x70304);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.terminal0_region_width                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_terminal0_region_width_type */
	/* skip, unused field unused_terminal0_region_width (terminal0_region_width) */
	REG_DUMP_PRINT_1("   -terminal0_region_width.terminal0_region_width                          |      0x%04X  |  [RW][14:00]""Specifies the region width to be used in transferring data to or from the terminal. The value for the region width is encoded as the width of the region expressed in number of elements minus one. Note, that the contents of this field are only relevant if the terminal is used as the source of the transfer.""\n", FIELD_VALUE(val, 0, 14));
	val = REG_DUMP_READ_REGISTER(0x70300);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.terminal0_region_origin                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_terminal0_region_origin_type */
	REG_DUMP_PRINT_1("   -terminal0_region_origin.terminal0_region_origin                        |  0x%08X  |  [RW][31:00]""Specifies the region origin to be used in transferring data to or from the terminal. The region origin is specified by a (word-aligned) byte address pointing to the element located at coordinate position (0,0) in the region.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x702b4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.unit0_lock_status                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_unit0_lock_status_type */
	/* skip, unused field unused_unit0_lock_status (unit0_lock_status) */
	REG_DUMP_PRINT_1("   -unit0_lock_status.unit0_lock_status                                    |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x702b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.unit0_pending_counter                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_unit0_pending_counter_type */
	/* skip, unused field unused_unit0_pending_counter (unit0_pending_counter) */
	REG_DUMP_PRINT_1("   -unit0_pending_counter.unit0_pending_counter                            |         0x%01X  |  [RO][01:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x70280);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.unit0_unit_width                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_unit0_unit_width_type */
	/* skip, unused field unused_unit0_unit_width (unit0_unit_width) */
	REG_DUMP_PRINT_1("   -unit0_unit_width.unit0_unit_width                                      |      0x%04X  |  [RW][14:00]""Register holding the unit width field contained in the unit descriptor.""\n", FIELD_VALUE(val, 0, 14));
	val = REG_DUMP_READ_REGISTER(0x70278);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.span1_dirty_status                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_span1_dirty_status_type */
	/* skip, unused field unused_span1_dirty_status (span1_dirty_status) */
	REG_DUMP_PRINT_1("   -span1_dirty_status.span1_dirty_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x70274);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.span1_lock_status                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_span1_lock_status_type */
	/* skip, unused field unused_span1_lock_status (span1_lock_status) */
	REG_DUMP_PRINT_1("   -span1_lock_status.span1_lock_status                                    |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x70270);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.span1_pending_counter                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_span1_pending_counter_type */
	/* skip, unused field unused_span1_pending_counter (span1_pending_counter) */
	REG_DUMP_PRINT_1("   -span1_pending_counter.span1_pending_counter                            |         0x%01X  |  [RO][01:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x70254);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.span1_span_mode                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_span1_span_mode_type */
	/* skip, unused field unused_span1_span_mode (span1_span_mode) */
	REG_DUMP_PRINT_1("   -span1_span_mode.span1_span_mode                                        |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x70240);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.span1_unit_location                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_span1_unit_location_type */
	REG_DUMP_PRINT_1("   -span1_unit_location.span1_unit_location                                |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x70238);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.span0_dirty_status                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_span0_dirty_status_type */
	/* skip, unused field unused_span0_dirty_status (span0_dirty_status) */
	REG_DUMP_PRINT_1("   -span0_dirty_status.span0_dirty_status                                  |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x70234);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.span0_lock_status                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_span0_lock_status_type */
	/* skip, unused field unused_span0_lock_status (span0_lock_status) */
	REG_DUMP_PRINT_1("   -span0_lock_status.span0_lock_status                                    |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x70230);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.span0_pending_counter                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_span0_pending_counter_type */
	/* skip, unused field unused_span0_pending_counter (span0_pending_counter) */
	REG_DUMP_PRINT_1("   -span0_pending_counter.span0_pending_counter                            |         0x%01X  |  [RO][01:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x70214);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.span0_span_mode                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_span0_span_mode_type */
	/* skip, unused field unused_span0_span_mode (span0_span_mode) */
	REG_DUMP_PRINT_1("   -span0_span_mode.span0_span_mode                                        |         0x%01X  |  [RW][01:00]""Register holding the span order contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x70200);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.span0_unit_location                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_span0_unit_location_type */
	REG_DUMP_PRINT_1("   -span0_unit_location.span0_unit_location                                |  0x%08X  |  [RW][31:00]""Register holding the value of the unit location field contained in the span descriptor.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x701c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.master1_burst_support                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_master1_burst_support_type */
	/* skip, unused field unused_master1_burst_support (master1_burst_support) */
	REG_DUMP_PRINT_1("   -master1_burst_support.master1_burst_support                            |         0x%01X  |  [RW][01:00]""This register enables or disables different levels of burst support on the data master interface associated with this master 1 register bank. The encoding of this register is explained below.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x701c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.master1_srmd_support                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_master1_srmd_support_type */
	/* skip, unused field unused_master1_srmd_support (master1_srmd_support) */
	REG_DUMP_PRINT_1("   -master1_srmd_support.master1_srmd_support                              |         0x%01X  |  [RW][00:00]""This register enables or disables support for Single-Request-Multiple-Data (SRMD) read protocol on the CIO data master interface associated with this master 1 register bank. When set to 0, all data transfers will use Multiple-Request-Multiple-Data (MRMD) protocol. When set to 1, the master will attempt to use SRMD transfers where applicable.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x70188);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.master0_burst_support                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_master0_burst_support_type */
	/* skip, unused field unused_master0_burst_support (master0_burst_support) */
	REG_DUMP_PRINT_1("   -master0_burst_support.master0_burst_support                            |         0x%01X  |  [RW][01:00]""This register enables or disables different levels of burst support on the data master interface associated with this master 0 register bank. The encoding of this register is explained below.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x70180);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.master0_srmd_support                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_master0_srmd_support_type */
	/* skip, unused field unused_master0_srmd_support (master0_srmd_support) */
	REG_DUMP_PRINT_1("   -master0_srmd_support.master0_srmd_support                              |         0x%01X  |  [RW][00:00]""This register enables or disables support for Single-Request-Multiple-Data (SRMD) read protocol on the CIO data master interface associated with this master 0 register bank. When set to 0, all data transfers will use Multiple-Request-Multiple-Data (MRMD) protocol. When set to 1, the master will attempt to use SRMD transfers where applicable.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x70120);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.physical_block_width_2d_burst_set0                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_physical_block_width_2d_burst_set0_type */
	/* skip, unused field unused_physical_block_width_2d_burst_set0 (physical_block_width_2d_burst_set0) */
	REG_DUMP_PRINT_1("   -physical_block_width_2d_burst_set0.physical_block_width_2d_burst_set0  |      0x%04X  |  [RW][14:00]""Maximum physical block width, encoded as number of physical block columns minus 1, to be used by the DMA masters when transferring units of data, in case the unit height is larger than 1 line. This value determines the splitting of units into columns of physical blocks. For non-strict element precisions this value is constrained to be a multiple of the maximum number of elements that fit a packed data word for each active master.""\n", FIELD_VALUE(val, 0, 14));
	val = REG_DUMP_READ_REGISTER(0x7011c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.physical_block_width_1d_burst_set0                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_physical_block_width_1d_burst_set0_type */
	/* skip, unused field unused_physical_block_width_1d_burst_set0 (physical_block_width_1d_burst_set0) */
	REG_DUMP_PRINT_1("   -physical_block_width_1d_burst_set0.physical_block_width_1d_burst_set0  |      0x%04X  |  [RW][14:00]""Maximum physical block width, encoded as number of physical block columns minus 1, to be used by the DMA masters when transferring units of data, in case the unit height equals 1 line. This value determines the splitting of units into columns of physical blocks. For non-strict element precisions this value is constrained to be a multiple of the maximum number of elements that fit a packed data word for each active master.""\n", FIELD_VALUE(val, 0, 14));
	val = REG_DUMP_READ_REGISTER(0x70114);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.channel_descriptor_base_address                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_channel_descriptor_base_address_type */
	REG_DUMP_PRINT_1("   -channel_descriptor_base_address.channel_descriptor_base_address        |  0x%08X  |  [RW][31:00]""Channel descriptor base address register holding the external memory mapped location from where channel descriptor information is to be fetched on a channel bank refill.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x70110);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.terminal_descriptor_base_address                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_terminal_descriptor_base_address_type */
	REG_DUMP_PRINT_1("   -terminal_descriptor_base_address.terminal_descriptor_base_address      |  0x%08X  |  [RW][31:00]""Terminal descriptor base address register holding the external memory mapped location from where terminal descriptor information is to be fetched on a channel bank refill.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x7010c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.span_descriptor_base_address                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_span_descriptor_base_address_type */
	REG_DUMP_PRINT_1("   -span_descriptor_base_address.span_descriptor_base_address              |  0x%08X  |  [RW][31:00]""Span descriptor base address register holding the external memory mapped location from where span descriptor information is to be fetched on a span bank refill.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x70108);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.unit_descriptor_base_address                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_unit_descriptor_base_address_type */
	REG_DUMP_PRINT_1("   -unit_descriptor_base_address.unit_descriptor_base_address              |  0x%08X  |  [RW][31:00]""Unit descriptor base address register holding the external memory mapped location from where unit descriptor information is to be fetched on a unit bank refill.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x70104);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.idle                                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_idle_type */
	/* skip, unused field unused_idle (idle) */
	REG_DUMP_PRINT_1("   -idle.idle                                                              |         0x%01X  |  [RO][00:00]""Idle read-only status register, indicating whether any command is in flight on the DMA or not. When the value of this register is equal to '0', instructions are in flight and/or have not been acknowledged and hence the DMA is regarded as busy. When the value of this register is equal to '1' the DMA is inactive and hence regarded as idle.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x70090);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.req0_request_resourced                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_req0_request_resourced_type */
	/* skip, unused field unused_req0_request_resourced (req0_request_resourced) */
	REG_DUMP_PRINT_1("   -req0_request_resourced.req0_request_resourced                          |         0x%01X  |  [RO][00:00]""Request resourced register indicating that all internal resources required to move the request into the next internal stage have been successfully reserved by the DMA. This register can be read, but not written through the control slave interface. It is automatically set and cleared by internal DMA logic only. Any write to the register via the control slave interface will simply be ignored.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x7008c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.req0_request_valid                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_req0_request_valid_type */
	/* skip, unused field unused_req0_request_valid (req0_request_valid) */
	REG_DUMP_PRINT_1("   -req0_request_valid.req0_request_valid                                  |         0x%01X  |  [RO][00:00]""Request valid register indicating that the current settings in the register bank compose a valid pending request. This register can be read, but not written through the control slave interface. It is automatically set and cleared by internal DMA logic only. Any write to the register via the control slave interface will simply be ignored.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x70088);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.req0_setup_2                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_req0_setup_2_type */
	/* skip, unused field unused_req0_setup_2 (req0_setup_2) */
	REG_DUMP_PRINT_1("   -req0_setup_2.req0_setup_2                                              |         0x%01X  |  [RW][01:00]""Register specifying the span IDs pointing to the corresponding span descriptors to be used with the instruction.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x70084);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.req0_setup_1                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_req0_setup_1_type */
	/* skip, unused field unused_req0_setup_1 (req0_setup_1) */
	REG_DUMP_PRINT_1("   -req0_setup_1.req0_setup_1                                              |         0x%01X  |  [RW][01:00]""Register specifying the channel ID, terminal IDs and unit IDs pointing to the corresponding channel descriptor, terminal descriptors, and unit descriptor to be used with the instruction.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x70080);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.req0_instruction                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_req0_instruction_type */
	/* skip, unused field unused_req0_instruction (req0_instruction) */
	REG_DUMP_PRINT_1("   -req0_instruction.req0_instruction                                      |       0x%03X  |  [RW][10:00]""Specify the instruction to be executed. A write to this register automatically sets the request valid register to '1'. This register can only be written if the value of the request valid register is equal to '0'.""\n", FIELD_VALUE(val, 0, 10));
	val = REG_DUMP_READ_REGISTER(0x70038);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.channel0_dirty_status                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_channel0_dirty_status_type */
	/* skip, unused field unused_channel0_dirty_status (channel0_dirty_status) */
	REG_DUMP_PRINT_1("   -channel0_dirty_status.channel0_dirty_status                            |         0x%01X  |  [RO][00:00]""Register keeping track of whether any contents of this bank have been modified since they were read from external memory mapped I/O through a cache refill.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x70034);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.channel0_lock_status                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_channel0_lock_status_type */
	/* skip, unused field unused_channel0_lock_status (channel0_lock_status) */
	REG_DUMP_PRINT_1("   -channel0_lock_status.channel0_lock_status                              |         0x%01X  |  [RO][00:00]""Register keeping track of whether the bank is locked for writing (incl. cache refill). This is the case when there are any instructions in flight using the bank. Hence, this register is '1' when the pending counter is not equal to zero and '0' when the pending counter is equal to zero.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x70030);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.channel0_pending_counter                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_channel0_pending_counter_type */
	/* skip, unused field unused_channel0_pending_counter (channel0_pending_counter) */
	REG_DUMP_PRINT_1("   -channel0_pending_counter.channel0_pending_counter                      |         0x%01X  |  [RO][03:00]""Register keeping track of the number of operations currently queued for execution or being executed using this bank.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x7002c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.channel0_completed_counter                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_channel0_completed_counter_type */
	/* skip, unused field unused_channel0_completed_counter (channel0_completed_counter) */
	REG_DUMP_PRINT_1("   -channel0_completed_counter.channel0_completed_counter                  |        0x%02X  |  [RW][04:00]""Register keeping track of the number of operations using this channel that have completed and have been acknowledged, since the last time the register was read. When read through the slave interface and the channel is configured for passive acknowledgement, or when an active acknowledgment occurs, this register is automatically reset to 0. The register can written through the control slave interface for the purpose of state restore, typically when switching bank modes while using active acknowledge.""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0x7001c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.channel0_acknowledge_data                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_channel0_acknowledge_data_type */
	REG_DUMP_PRINT_1("   -channel0_acknowledge_data.channel0_acknowledge_data                    |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge data field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x70018);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.channel0_acknowledge_address                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_channel0_acknowledge_address_type */
	REG_DUMP_PRINT_1("   -channel0_acknowledge_address.channel0_acknowledge_address              |  0x%08X  |  [RW][31:00]""Register holding the value of the acknowledge address field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x70014);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.channel0_acknowledge_mode                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_channel0_acknowledge_mode_type */
	/* skip, unused field unused_channel0_acknowledge_mode (channel0_acknowledge_mode) */
	REG_DUMP_PRINT_1("   -channel0_acknowledge_mode.channel0_acknowledge_mode                    |         0x%01X  |  [RW][03:00]""Register holding the value of the acknowledge mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x70008);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.channel0_padding_mode                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_channel0_padding_mode_type */
	/* skip, unused field unused_channel0_padding_mode (channel0_padding_mode) */
	REG_DUMP_PRINT_1("   -channel0_padding_mode.channel0_padding_mode                            |         0x%01X  |  [RW][02:00]""Register holding the value of the padding mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x70000);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  fw_dma_dma.channel0_element_extend_mode                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_fw_dma_dma_channel0_element_extend_mode_type */
	/* skip, unused field unused_channel0_element_extend_mode (channel0_element_extend_mode) */
	REG_DUMP_PRINT_1("   -channel0_element_extend_mode.channel0_element_extend_mode              |         0x%01X  |  [RW][00:00]""Register holding the value of the element extend mode field contained in the descriptor of the channel for which this bank has been reserved.""\n", FIELD_VALUE(val, 0, 0));
} /* end fw_dma_dma */

/* Generated Debug Code: Device gpr_3 */
void ia_css_debug_dump_gpr_3(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x6ef08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpr_3.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX                                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_gpr_3_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX_type */
	/* skip, unused field unused_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX (csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX) */
	REG_DUMP_PRINT_1("   -csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX  |       0x%03X  |  [RW][10:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 10));
	val = REG_DUMP_READ_REGISTER(0x6ef04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpr_3.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX                                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_gpr_3_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX_type */
	/* skip, unused field unused_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX (csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX) */
	REG_DUMP_PRINT_1("   -csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX      |    0x%06X  |  [RW][21:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 21));
	val = REG_DUMP_READ_REGISTER(0x6ef00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpr_3.str_mon_status                                                                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_gpr_3_str_mon_status_type */
	REG_DUMP_PRINT_1("   -str_mon_status.str_mon_status                                                                                        |  0x%08X  |  [RO][31:00]""Streaming Monitor Status, [accept,valid] of streaming port""\n", FIELD_VALUE(val, 0, 31));
} /* end gpr_3 */

/* Generated Debug Code: Device irq_ctrl0_3 */
void ia_css_debug_dump_irq_ctrl0_3(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x6ed14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_3.irq_level_not_pulse            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl0_3_irq_level_not_pulse_type */
	/* skip, unused field unused_irq_level_not_pulse (irq_level_not_pulse) */
	REG_DUMP_PRINT_1("   -irq_level_not_pulse.irq_level_not_pulse  |  0x%08X  |  [RW][28:00]""Indicates for each bit whether an interrupt cause is translated into a pulse (value='0') or into a constant level '1' (value='1') on the IRQ pin.""\n", FIELD_VALUE(val, 0, 28));
	val = REG_DUMP_READ_REGISTER(0x6ed10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_3.irq_enable                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl0_3_irq_enable_type */
	/* skip, unused field unused_irq_enable (irq_enable) */
	REG_DUMP_PRINT_1("   -irq_enable.irq_enable                    |  0x%08X  |  [RW][28:00]""Indicates for each bit whether an interrupt cause as monitored by the req_irq_status register also affects the IRQ pin (value='1') or not (value='0').""\n", FIELD_VALUE(val, 0, 28));
	val = REG_DUMP_READ_REGISTER(0x6ed08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_3.irq_status                     |  0x%08X  |  ""Indicates for each bit whether a non-masked interrupt has been generated (value='1'). Can be cleared by writing a '1' into the the corresponding bit of the req_irq_clear register.""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl0_3_irq_status_type */
	/* skip, unused field unused_irq_status (irq_status) */
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_0                 |         0x%01X  |  [RO][00:00]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_1                 |         0x%01X  |  [RO][01:01]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_2                 |         0x%01X  |  [RO][02:02]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_3                 |         0x%01X  |  [RO][03:03]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_4                 |         0x%01X  |  [RO][04:04]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_5                 |         0x%01X  |  [RO][05:05]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_6                 |         0x%01X  |  [RO][06:06]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_7                 |         0x%01X  |  [RO][07:07]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_8                 |         0x%01X  |  [RO][08:08]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_9                 |         0x%01X  |  [RO][09:09]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_10                |         0x%01X  |  [RO][10:10]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_11                |         0x%01X  |  [RO][11:11]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_12                |         0x%01X  |  [RO][12:12]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 12, 12));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_13                |         0x%01X  |  [RO][13:13]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 13, 13));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_14                |         0x%01X  |  [RO][14:14]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 14, 14));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_15                |         0x%01X  |  [RO][15:15]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 15, 15));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_16                |         0x%01X  |  [RO][16:16]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 16, 16));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_17                |         0x%01X  |  [RO][17:17]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 17, 17));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_18                |         0x%01X  |  [RO][18:18]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 18, 18));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_19                |         0x%01X  |  [RO][19:19]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 19, 19));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_20                |         0x%01X  |  [RO][20:20]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 20, 20));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_21                |         0x%01X  |  [RO][21:21]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 21, 21));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_22                |         0x%01X  |  [RO][22:22]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 22, 22));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_23                |         0x%01X  |  [RO][23:23]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 23, 23));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_24                |         0x%01X  |  [RO][24:24]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 24, 24));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_25                |         0x%01X  |  [RO][25:25]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 25, 25));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_26                |         0x%01X  |  [RO][26:26]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 26, 26));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_27                |         0x%01X  |  [RO][27:27]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 27, 27));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_28                |         0x%01X  |  [RO][28:28]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 28, 28));
	val = REG_DUMP_READ_REGISTER(0x6ed04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_3.irq_mask                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl0_3_irq_mask_type */
	/* skip, unused field unused_irq_mask (irq_mask) */
	REG_DUMP_PRINT_1("   -irq_mask.irq_mask                        |  0x%08X  |  [RW][28:00]""Indicates for each bit of irq_di whether it can generate an interrupt request (value='1') or not (value='0'). Setting will affect irq_value as well as IRQ output pin.""\n", FIELD_VALUE(val, 0, 28));
	val = REG_DUMP_READ_REGISTER(0x6ed00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_3.irq_edge                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl0_3_irq_edge_type */
	/* skip, unused field unused_irq_edge (irq_edge) */
	REG_DUMP_PRINT_1("   -irq_edge.irq_edge                        |  0x%08X  |  [RW][28:00]""Indicates for each bit whether an interrupt request should be generated on a falling edge (value='0') or a rising edge (value='1').""\n", FIELD_VALUE(val, 0, 28));
} /* end irq_ctrl0_3 */

/* Generated Debug Code: Device irq_ctrl_3 */
void ia_css_debug_dump_irq_ctrl_3(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x6ec14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_3.irq_level_not_pulse             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl_3_irq_level_not_pulse_type */
	/* skip, unused field unused_irq_level_not_pulse (irq_level_not_pulse) */
	REG_DUMP_PRINT_1("   -irq_level_not_pulse.irq_level_not_pulse  |        0x%02X  |  [RW][04:00]""Indicates for each bit whether an interrupt cause is translated into a pulse (value='0') or into a constant level '1' (value='1') on the IRQ pin.""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0x6ec10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_3.irq_enable                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl_3_irq_enable_type */
	/* skip, unused field unused_irq_enable (irq_enable) */
	REG_DUMP_PRINT_1("   -irq_enable.irq_enable                    |        0x%02X  |  [RW][04:00]""Indicates for each bit whether an interrupt cause as monitored by the req_irq_status register also affects the IRQ pin (value='1') or not (value='0').""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0x6ec08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_3.irq_status                      |  0x%08X  |  ""Indicates for each bit whether a non-masked interrupt has been generated (value='1'). Can be cleared by writing a '1' into the the corresponding bit of the req_irq_clear register.""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl_3_irq_status_type */
	/* skip, unused field unused_irq_status (irq_status) */
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX                   |         0x%01X  |  [RO][00:00]""Represents the status of the irq from irq_ctrl0 (csi_rx irqs).""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M                  |         0x%01X  |  [RO][01:01]""Represents the status of the irq from irq_ctrl1 (csi__rx_synchronization_irqs + s2m_irqs).""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_SM                   |         0x%01X  |  [RO][02:02]""Represents the status of the irq from Stream Monitor.""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_IBUF                 |         0x%01X  |  [RO][03:03]""Represents the status of the irq from IBuffer Controller.""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_SIG2CIO              |         0x%01X  |  [RO][04:04]""Represents the status of the irq from SIG2CIO.""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x6ec04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_3.irq_mask                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl_3_irq_mask_type */
	/* skip, unused field unused_irq_mask (irq_mask) */
	REG_DUMP_PRINT_1("   -irq_mask.irq_mask                        |        0x%02X  |  [RW][04:00]""Indicates for each bit of irq_di whether it can generate an interrupt request (value='1') or not (value='0'). Setting will affect irq_value as well as IRQ output pin.""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0x6ec00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_3.irq_edge                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl_3_irq_edge_type */
	/* skip, unused field unused_irq_edge (irq_edge) */
	REG_DUMP_PRINT_1("   -irq_edge.irq_edge                        |        0x%02X  |  [RW][04:00]""Indicates for each bit whether an interrupt request should be generated on a falling edge (value='0') or a rising edge (value='1').""\n", FIELD_VALUE(val, 0, 4));
} /* end irq_ctrl_3 */

/* Generated Debug Code: Device cphy_rx_3 */
void ia_css_debug_dump_cphy_rx_3(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x6e820);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_3.reg_rx_status                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_3_reg_rx_status_type */
	/* skip, unused field unused_reg_rx_status (reg_rx_status) */
	REG_DUMP_PRINT_1("   -reg_rx_status.reg_rx_status                                              |         0x%01X  |  [RO][00:00]""Status register:                    0 = Receiver is IDLE, not processing a packet                    1 = Receiver is processing a packet""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6e81c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_3.reg_sync_cntr_sel                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_3_reg_sync_cntr_sel_type */
	/* skip, unused field unused_reg_sync_cntr_sel (reg_sync_cntr_sel) */
	REG_DUMP_PRINT_1("   -reg_sync_cntr_sel.reg_sync_cntr_sel                                      |         0x%01X  |  [RW][01:00]""Sync counter select register.                    bit 0 => 0: Use internal counter for line start and line end packet IDs.                          => 1: Use line start and line end ID as send by sensor                    bit 1 => 0: Use internal counter for frame start and frame end packet IDs.                          => 1: Use frame start and frame end ID as send by sensor""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x6e818);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_3.reg_cphy_rx_portconfig_timeout_cntr                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_3_reg_cphy_rx_portconfig_timeout_cntr_type */
	/* skip, unused field unused_reg_cphy_rx_portconfig_timeout_cntr (reg_cphy_rx_portconfig_timeout_cntr) */
	REG_DUMP_PRINT_1("   -reg_cphy_rx_portconfig_timeout_cntr.reg_cphy_rx_portconfig_timeout_cntr  |      0x%04X  |  [RW][15:00]""Portconfig timeout counter of CPHY RX.                    Specifies a timeout value in number of isp clk cycles after which                    the elastic fifos of enabled lanes would flush if all such trios do not receive valid data within this time period.                   As an example, set value to 1000 (should be set to a sufficient time that clearly indicates that trios have gone out of sync)""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x6e814);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_3.reg_cphy_rx_portconfig_ctrl                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_3_reg_cphy_rx_portconfig_ctrl_type */
	/* skip, unused field unused_reg_cphy_rx_portconfig_ctrl (reg_cphy_rx_portconfig_ctrl) */
	REG_DUMP_PRINT_1("   -reg_cphy_rx_portconfig_ctrl.reg_cphy_rx_portconfig_ctrl                  |         0x%01X  |  [RW][00:00]""Portconfig control of CPHY RX.                    bit.0 = chicken bit to use internal generated sot (based on rising edge of trio_vld input)""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6e810);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_3.reg_cphy_rx_error_handling                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_3_reg_cphy_rx_error_handling_type */
	/* skip, unused field unused_reg_cphy_rx_error_handling (reg_cphy_rx_error_handling) */
	REG_DUMP_PRINT_1("   -reg_cphy_rx_error_handling.reg_cphy_rx_error_handling                    |        0x%02X  |  [RW][04:00]""Error handling register.                    bit 0 = when set, packets with more than one erro in packet header                            are discarded.                    bit 1 = when set, a short packet with reserved id is discarded and irq                            is raised                    bit 2 = when set, a long packet with reserved id is discarded and irq                            is raised                    bit 3 = when set, detection of incomplete packet is disabled, irq will                            not be generated""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0x6e80c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_3.reg_cphy_rx_ph_crc_config                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_3_reg_cphy_rx_ph_crc_config_type */
	/* skip, unused field unused_reg_cphy_rx_ph_crc_config (reg_cphy_rx_ph_crc_config) */
	REG_DUMP_PRINT_1("   -reg_cphy_rx_ph_crc_config.reg_cphy_rx_ph_crc_config                      |         0x%01X  |  [RW][01:00]""CRC configuration of CPHY RX. ""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x6e808);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_3.reg_cphy_rx_hbp_testmode_enable                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_3_reg_cphy_rx_hbp_testmode_enable_type */
	/* skip, unused field unused_reg_cphy_rx_hbp_testmode_enable (reg_cphy_rx_hbp_testmode_enable) */
	REG_DUMP_PRINT_1("   -reg_cphy_rx_hbp_testmode_enable.reg_cphy_rx_hbp_testmode_enable          |         0x%01X  |  [RW][00:00]""HBP Testmode enable of CPHY RX. ""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6e804);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_3.reg_cphy_rx_nof_enabled_lanes                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_3_reg_cphy_rx_nof_enabled_lanes_type */
	/* skip, unused field unused_reg_cphy_rx_nof_enabled_lanes (reg_cphy_rx_nof_enabled_lanes) */
	REG_DUMP_PRINT_1("   -reg_cphy_rx_nof_enabled_lanes.reg_cphy_rx_nof_enabled_lanes              |         0x%01X  |  [RW][02:00]""Specify Number of enabled data lanes of CPHY RX.                    0 = No lanes enabled                    1 = One   lane  enabled,                    2 = Two   lanes enabled,                    3 = Three lanes enabled,                    4 = Four  lanes enabled,                   ""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x6e800);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_3.reg_cphy_rx_enable                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_3_reg_cphy_rx_enable_type */
	/* skip, unused field unused_reg_cphy_rx_enable (reg_cphy_rx_enable) */
	REG_DUMP_PRINT_1("   -reg_cphy_rx_enable.reg_cphy_rx_enable                                    |         0x%01X  |  [RW][00:00]""Enable CPHY RX""\n", FIELD_VALUE(val, 0, 0));
} /* end cphy_rx_3 */

/* Generated Debug Code: Device gpr_2 */
void ia_css_debug_dump_gpr_2(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x6e708);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpr_2.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX                                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_gpr_2_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX_type */
	/* skip, unused field unused_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX (csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX) */
	REG_DUMP_PRINT_1("   -csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX  |       0x%03X  |  [RW][10:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 10));
	val = REG_DUMP_READ_REGISTER(0x6e704);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpr_2.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX                                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_gpr_2_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX_type */
	/* skip, unused field unused_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX (csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX) */
	REG_DUMP_PRINT_1("   -csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX      |    0x%06X  |  [RW][21:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 21));
	val = REG_DUMP_READ_REGISTER(0x6e700);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpr_2.str_mon_status                                                                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_gpr_2_str_mon_status_type */
	REG_DUMP_PRINT_1("   -str_mon_status.str_mon_status                                                                                        |  0x%08X  |  [RO][31:00]""Streaming Monitor Status, [accept,valid] of streaming port""\n", FIELD_VALUE(val, 0, 31));
} /* end gpr_2 */

/* Generated Debug Code: Device irq_ctrl0_2 */
void ia_css_debug_dump_irq_ctrl0_2(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x6e514);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_2.irq_level_not_pulse            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl0_2_irq_level_not_pulse_type */
	/* skip, unused field unused_irq_level_not_pulse (irq_level_not_pulse) */
	REG_DUMP_PRINT_1("   -irq_level_not_pulse.irq_level_not_pulse  |  0x%08X  |  [RW][28:00]""Indicates for each bit whether an interrupt cause is translated into a pulse (value='0') or into a constant level '1' (value='1') on the IRQ pin.""\n", FIELD_VALUE(val, 0, 28));
	val = REG_DUMP_READ_REGISTER(0x6e510);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_2.irq_enable                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl0_2_irq_enable_type */
	/* skip, unused field unused_irq_enable (irq_enable) */
	REG_DUMP_PRINT_1("   -irq_enable.irq_enable                    |  0x%08X  |  [RW][28:00]""Indicates for each bit whether an interrupt cause as monitored by the req_irq_status register also affects the IRQ pin (value='1') or not (value='0').""\n", FIELD_VALUE(val, 0, 28));
	val = REG_DUMP_READ_REGISTER(0x6e508);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_2.irq_status                     |  0x%08X  |  ""Indicates for each bit whether a non-masked interrupt has been generated (value='1'). Can be cleared by writing a '1' into the the corresponding bit of the req_irq_clear register.""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl0_2_irq_status_type */
	/* skip, unused field unused_irq_status (irq_status) */
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_0                 |         0x%01X  |  [RO][00:00]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_1                 |         0x%01X  |  [RO][01:01]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_2                 |         0x%01X  |  [RO][02:02]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_3                 |         0x%01X  |  [RO][03:03]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_4                 |         0x%01X  |  [RO][04:04]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_5                 |         0x%01X  |  [RO][05:05]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_6                 |         0x%01X  |  [RO][06:06]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_7                 |         0x%01X  |  [RO][07:07]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_8                 |         0x%01X  |  [RO][08:08]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_9                 |         0x%01X  |  [RO][09:09]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_10                |         0x%01X  |  [RO][10:10]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_11                |         0x%01X  |  [RO][11:11]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_12                |         0x%01X  |  [RO][12:12]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 12, 12));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_13                |         0x%01X  |  [RO][13:13]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 13, 13));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_14                |         0x%01X  |  [RO][14:14]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 14, 14));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_15                |         0x%01X  |  [RO][15:15]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 15, 15));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_16                |         0x%01X  |  [RO][16:16]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 16, 16));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_17                |         0x%01X  |  [RO][17:17]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 17, 17));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_18                |         0x%01X  |  [RO][18:18]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 18, 18));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_19                |         0x%01X  |  [RO][19:19]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 19, 19));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_20                |         0x%01X  |  [RO][20:20]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 20, 20));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_21                |         0x%01X  |  [RO][21:21]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 21, 21));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_22                |         0x%01X  |  [RO][22:22]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 22, 22));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_23                |         0x%01X  |  [RO][23:23]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 23, 23));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_24                |         0x%01X  |  [RO][24:24]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 24, 24));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_25                |         0x%01X  |  [RO][25:25]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 25, 25));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_26                |         0x%01X  |  [RO][26:26]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 26, 26));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_27                |         0x%01X  |  [RO][27:27]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 27, 27));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_28                |         0x%01X  |  [RO][28:28]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 28, 28));
	val = REG_DUMP_READ_REGISTER(0x6e504);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_2.irq_mask                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl0_2_irq_mask_type */
	/* skip, unused field unused_irq_mask (irq_mask) */
	REG_DUMP_PRINT_1("   -irq_mask.irq_mask                        |  0x%08X  |  [RW][28:00]""Indicates for each bit of irq_di whether it can generate an interrupt request (value='1') or not (value='0'). Setting will affect irq_value as well as IRQ output pin.""\n", FIELD_VALUE(val, 0, 28));
	val = REG_DUMP_READ_REGISTER(0x6e500);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_2.irq_edge                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl0_2_irq_edge_type */
	/* skip, unused field unused_irq_edge (irq_edge) */
	REG_DUMP_PRINT_1("   -irq_edge.irq_edge                        |  0x%08X  |  [RW][28:00]""Indicates for each bit whether an interrupt request should be generated on a falling edge (value='0') or a rising edge (value='1').""\n", FIELD_VALUE(val, 0, 28));
} /* end irq_ctrl0_2 */

/* Generated Debug Code: Device irq_ctrl_2 */
void ia_css_debug_dump_irq_ctrl_2(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x6e414);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_2.irq_level_not_pulse             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl_2_irq_level_not_pulse_type */
	/* skip, unused field unused_irq_level_not_pulse (irq_level_not_pulse) */
	REG_DUMP_PRINT_1("   -irq_level_not_pulse.irq_level_not_pulse  |         0x%01X  |  [RW][02:00]""Indicates for each bit whether an interrupt cause is translated into a pulse (value='0') or into a constant level '1' (value='1') on the IRQ pin.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x6e410);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_2.irq_enable                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl_2_irq_enable_type */
	/* skip, unused field unused_irq_enable (irq_enable) */
	REG_DUMP_PRINT_1("   -irq_enable.irq_enable                    |         0x%01X  |  [RW][02:00]""Indicates for each bit whether an interrupt cause as monitored by the req_irq_status register also affects the IRQ pin (value='1') or not (value='0').""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x6e408);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_2.irq_status                      |  0x%08X  |  ""Indicates for each bit whether a non-masked interrupt has been generated (value='1'). Can be cleared by writing a '1' into the the corresponding bit of the req_irq_clear register.""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl_2_irq_status_type */
	/* skip, unused field unused_irq_status (irq_status) */
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX                   |         0x%01X  |  [RO][00:00]""Represents the status of the irq from irq_ctrl0 (csi_rx irqs).""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M                  |         0x%01X  |  [RO][02:02]""Represents the status of the irq from irq_ctrl1 (csi__rx_synchronization_irqs + s2m_irqs).""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_SM                   |         0x%01X  |  [RO][03:03]""Represents the status of the irq from Stream Monitor.""\n", FIELD_VALUE(val, 3, 3));
	val = REG_DUMP_READ_REGISTER(0x6e404);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_2.irq_mask                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl_2_irq_mask_type */
	/* skip, unused field unused_irq_mask (irq_mask) */
	REG_DUMP_PRINT_1("   -irq_mask.irq_mask                        |         0x%01X  |  [RW][02:00]""Indicates for each bit of irq_di whether it can generate an interrupt request (value='1') or not (value='0'). Setting will affect irq_value as well as IRQ output pin.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x6e400);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_2.irq_edge                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl_2_irq_edge_type */
	/* skip, unused field unused_irq_edge (irq_edge) */
	REG_DUMP_PRINT_1("   -irq_edge.irq_edge                        |         0x%01X  |  [RW][02:00]""Indicates for each bit whether an interrupt request should be generated on a falling edge (value='0') or a rising edge (value='1').""\n", FIELD_VALUE(val, 0, 2));
} /* end irq_ctrl_2 */

/* Generated Debug Code: Device cphy_rx_2 */
void ia_css_debug_dump_cphy_rx_2(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x6e020);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_2.reg_rx_status                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_2_reg_rx_status_type */
	/* skip, unused field unused_reg_rx_status (reg_rx_status) */
	REG_DUMP_PRINT_1("   -reg_rx_status.reg_rx_status                                              |         0x%01X  |  [RO][00:00]""Status register:                    0 = Receiver is IDLE, not processing a packet                    1 = Receiver is processing a packet""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6e01c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_2.reg_sync_cntr_sel                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_2_reg_sync_cntr_sel_type */
	/* skip, unused field unused_reg_sync_cntr_sel (reg_sync_cntr_sel) */
	REG_DUMP_PRINT_1("   -reg_sync_cntr_sel.reg_sync_cntr_sel                                      |         0x%01X  |  [RW][01:00]""Sync counter select register.                    bit 0 => 0: Use internal counter for line start and line end packet IDs.                          => 1: Use line start and line end ID as send by sensor                    bit 1 => 0: Use internal counter for frame start and frame end packet IDs.                          => 1: Use frame start and frame end ID as send by sensor""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x6e018);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_2.reg_cphy_rx_portconfig_timeout_cntr                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_2_reg_cphy_rx_portconfig_timeout_cntr_type */
	/* skip, unused field unused_reg_cphy_rx_portconfig_timeout_cntr (reg_cphy_rx_portconfig_timeout_cntr) */
	REG_DUMP_PRINT_1("   -reg_cphy_rx_portconfig_timeout_cntr.reg_cphy_rx_portconfig_timeout_cntr  |      0x%04X  |  [RW][15:00]""Portconfig timeout counter of CPHY RX.                    Specifies a timeout value in number of isp clk cycles after which                    the elastic fifos of enabled lanes would flush if all such trios do not receive valid data within this time period.                   As an example, set value to 1000 (should be set to a sufficient time that clearly indicates that trios have gone out of sync)""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x6e014);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_2.reg_cphy_rx_portconfig_ctrl                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_2_reg_cphy_rx_portconfig_ctrl_type */
	/* skip, unused field unused_reg_cphy_rx_portconfig_ctrl (reg_cphy_rx_portconfig_ctrl) */
	REG_DUMP_PRINT_1("   -reg_cphy_rx_portconfig_ctrl.reg_cphy_rx_portconfig_ctrl                  |         0x%01X  |  [RW][00:00]""Portconfig control of CPHY RX.                    bit.0 = chicken bit to use internal generated sot (based on rising edge of trio_vld input)""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6e010);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_2.reg_cphy_rx_error_handling                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_2_reg_cphy_rx_error_handling_type */
	/* skip, unused field unused_reg_cphy_rx_error_handling (reg_cphy_rx_error_handling) */
	REG_DUMP_PRINT_1("   -reg_cphy_rx_error_handling.reg_cphy_rx_error_handling                    |        0x%02X  |  [RW][04:00]""Error handling register.                    bit 0 = when set, packets with more than one erro in packet header                            are discarded.                    bit 1 = when set, a short packet with reserved id is discarded and irq                            is raised                    bit 2 = when set, a long packet with reserved id is discarded and irq                            is raised                    bit 3 = when set, detection of incomplete packet is disabled, irq will                            not be generated""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0x6e00c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_2.reg_cphy_rx_ph_crc_config                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_2_reg_cphy_rx_ph_crc_config_type */
	/* skip, unused field unused_reg_cphy_rx_ph_crc_config (reg_cphy_rx_ph_crc_config) */
	REG_DUMP_PRINT_1("   -reg_cphy_rx_ph_crc_config.reg_cphy_rx_ph_crc_config                      |         0x%01X  |  [RW][01:00]""CRC configuration of CPHY RX. ""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x6e008);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_2.reg_cphy_rx_hbp_testmode_enable                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_2_reg_cphy_rx_hbp_testmode_enable_type */
	/* skip, unused field unused_reg_cphy_rx_hbp_testmode_enable (reg_cphy_rx_hbp_testmode_enable) */
	REG_DUMP_PRINT_1("   -reg_cphy_rx_hbp_testmode_enable.reg_cphy_rx_hbp_testmode_enable          |         0x%01X  |  [RW][00:00]""HBP Testmode enable of CPHY RX. ""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6e004);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_2.reg_cphy_rx_nof_enabled_lanes                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_2_reg_cphy_rx_nof_enabled_lanes_type */
	/* skip, unused field unused_reg_cphy_rx_nof_enabled_lanes (reg_cphy_rx_nof_enabled_lanes) */
	REG_DUMP_PRINT_1("   -reg_cphy_rx_nof_enabled_lanes.reg_cphy_rx_nof_enabled_lanes              |         0x%01X  |  [RW][02:00]""Specify Number of enabled data lanes of CPHY RX.                    0 = No lanes enabled                    1 = One   lane  enabled,                    2 = Two   lanes enabled,                    3 = Three lanes enabled,                    4 = Four  lanes enabled,                   ""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x6e000);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_2.reg_cphy_rx_enable                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_2_reg_cphy_rx_enable_type */
	/* skip, unused field unused_reg_cphy_rx_enable (reg_cphy_rx_enable) */
	REG_DUMP_PRINT_1("   -reg_cphy_rx_enable.reg_cphy_rx_enable                                    |         0x%01X  |  [RW][00:00]""Enable CPHY RX""\n", FIELD_VALUE(val, 0, 0));
} /* end cphy_rx_2 */

/* Generated Debug Code: Device gpr_1 */
void ia_css_debug_dump_gpr_1(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x6df08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpr_1.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX                                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_gpr_1_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX_type */
	/* skip, unused field unused_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX (csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX) */
	REG_DUMP_PRINT_1("   -csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX  |       0x%03X  |  [RW][10:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 10));
	val = REG_DUMP_READ_REGISTER(0x6df04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpr_1.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX                                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_gpr_1_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX_type */
	/* skip, unused field unused_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX (csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX) */
	REG_DUMP_PRINT_1("   -csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX      |    0x%06X  |  [RW][21:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 21));
	val = REG_DUMP_READ_REGISTER(0x6df00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpr_1.str_mon_status                                                                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_gpr_1_str_mon_status_type */
	REG_DUMP_PRINT_1("   -str_mon_status.str_mon_status                                                                                        |  0x%08X  |  [RO][31:00]""Streaming Monitor Status, [accept,valid] of streaming port""\n", FIELD_VALUE(val, 0, 31));
} /* end gpr_1 */

/* Generated Debug Code: Device irq_ctrl0_1 */
void ia_css_debug_dump_irq_ctrl0_1(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x6dd14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_1.irq_level_not_pulse            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl0_1_irq_level_not_pulse_type */
	/* skip, unused field unused_irq_level_not_pulse (irq_level_not_pulse) */
	REG_DUMP_PRINT_1("   -irq_level_not_pulse.irq_level_not_pulse  |  0x%08X  |  [RW][28:00]""Indicates for each bit whether an interrupt cause is translated into a pulse (value='0') or into a constant level '1' (value='1') on the IRQ pin.""\n", FIELD_VALUE(val, 0, 28));
	val = REG_DUMP_READ_REGISTER(0x6dd10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_1.irq_enable                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl0_1_irq_enable_type */
	/* skip, unused field unused_irq_enable (irq_enable) */
	REG_DUMP_PRINT_1("   -irq_enable.irq_enable                    |  0x%08X  |  [RW][28:00]""Indicates for each bit whether an interrupt cause as monitored by the req_irq_status register also affects the IRQ pin (value='1') or not (value='0').""\n", FIELD_VALUE(val, 0, 28));
	val = REG_DUMP_READ_REGISTER(0x6dd08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_1.irq_status                     |  0x%08X  |  ""Indicates for each bit whether a non-masked interrupt has been generated (value='1'). Can be cleared by writing a '1' into the the corresponding bit of the req_irq_clear register.""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl0_1_irq_status_type */
	/* skip, unused field unused_irq_status (irq_status) */
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_0                 |         0x%01X  |  [RO][00:00]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_1                 |         0x%01X  |  [RO][01:01]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_2                 |         0x%01X  |  [RO][02:02]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_3                 |         0x%01X  |  [RO][03:03]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_4                 |         0x%01X  |  [RO][04:04]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_5                 |         0x%01X  |  [RO][05:05]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_6                 |         0x%01X  |  [RO][06:06]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_7                 |         0x%01X  |  [RO][07:07]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_8                 |         0x%01X  |  [RO][08:08]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_9                 |         0x%01X  |  [RO][09:09]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_10                |         0x%01X  |  [RO][10:10]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_11                |         0x%01X  |  [RO][11:11]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_12                |         0x%01X  |  [RO][12:12]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 12, 12));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_13                |         0x%01X  |  [RO][13:13]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 13, 13));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_14                |         0x%01X  |  [RO][14:14]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 14, 14));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_15                |         0x%01X  |  [RO][15:15]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 15, 15));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_16                |         0x%01X  |  [RO][16:16]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 16, 16));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_17                |         0x%01X  |  [RO][17:17]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 17, 17));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_18                |         0x%01X  |  [RO][18:18]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 18, 18));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_19                |         0x%01X  |  [RO][19:19]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 19, 19));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_20                |         0x%01X  |  [RO][20:20]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 20, 20));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_21                |         0x%01X  |  [RO][21:21]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 21, 21));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_22                |         0x%01X  |  [RO][22:22]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 22, 22));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_23                |         0x%01X  |  [RO][23:23]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 23, 23));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_24                |         0x%01X  |  [RO][24:24]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 24, 24));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_25                |         0x%01X  |  [RO][25:25]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 25, 25));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_26                |         0x%01X  |  [RO][26:26]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 26, 26));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_27                |         0x%01X  |  [RO][27:27]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 27, 27));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_28                |         0x%01X  |  [RO][28:28]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 28, 28));
	val = REG_DUMP_READ_REGISTER(0x6dd04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_1.irq_mask                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl0_1_irq_mask_type */
	/* skip, unused field unused_irq_mask (irq_mask) */
	REG_DUMP_PRINT_1("   -irq_mask.irq_mask                        |  0x%08X  |  [RW][28:00]""Indicates for each bit of irq_di whether it can generate an interrupt request (value='1') or not (value='0'). Setting will affect irq_value as well as IRQ output pin.""\n", FIELD_VALUE(val, 0, 28));
	val = REG_DUMP_READ_REGISTER(0x6dd00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_1.irq_edge                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl0_1_irq_edge_type */
	/* skip, unused field unused_irq_edge (irq_edge) */
	REG_DUMP_PRINT_1("   -irq_edge.irq_edge                        |  0x%08X  |  [RW][28:00]""Indicates for each bit whether an interrupt request should be generated on a falling edge (value='0') or a rising edge (value='1').""\n", FIELD_VALUE(val, 0, 28));
} /* end irq_ctrl0_1 */

/* Generated Debug Code: Device irq_ctrl_1 */
void ia_css_debug_dump_irq_ctrl_1(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x6dc14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_1.irq_level_not_pulse             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl_1_irq_level_not_pulse_type */
	/* skip, unused field unused_irq_level_not_pulse (irq_level_not_pulse) */
	REG_DUMP_PRINT_1("   -irq_level_not_pulse.irq_level_not_pulse  |         0x%01X  |  [RW][02:00]""Indicates for each bit whether an interrupt cause is translated into a pulse (value='0') or into a constant level '1' (value='1') on the IRQ pin.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x6dc10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_1.irq_enable                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl_1_irq_enable_type */
	/* skip, unused field unused_irq_enable (irq_enable) */
	REG_DUMP_PRINT_1("   -irq_enable.irq_enable                    |         0x%01X  |  [RW][02:00]""Indicates for each bit whether an interrupt cause as monitored by the req_irq_status register also affects the IRQ pin (value='1') or not (value='0').""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x6dc08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_1.irq_status                      |  0x%08X  |  ""Indicates for each bit whether a non-masked interrupt has been generated (value='1'). Can be cleared by writing a '1' into the the corresponding bit of the req_irq_clear register.""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl_1_irq_status_type */
	/* skip, unused field unused_irq_status (irq_status) */
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX                   |         0x%01X  |  [RO][00:00]""Represents the status of the irq from irq_ctrl0 (csi_rx irqs).""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M                  |         0x%01X  |  [RO][02:02]""Represents the status of the irq from irq_ctrl1 (csi__rx_synchronization_irqs + s2m_irqs).""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_SM                   |         0x%01X  |  [RO][03:03]""Represents the status of the irq from Stream Monitor.""\n", FIELD_VALUE(val, 3, 3));
	val = REG_DUMP_READ_REGISTER(0x6dc04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_1.irq_mask                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl_1_irq_mask_type */
	/* skip, unused field unused_irq_mask (irq_mask) */
	REG_DUMP_PRINT_1("   -irq_mask.irq_mask                        |         0x%01X  |  [RW][02:00]""Indicates for each bit of irq_di whether it can generate an interrupt request (value='1') or not (value='0'). Setting will affect irq_value as well as IRQ output pin.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x6dc00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_1.irq_edge                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl_1_irq_edge_type */
	/* skip, unused field unused_irq_edge (irq_edge) */
	REG_DUMP_PRINT_1("   -irq_edge.irq_edge                        |         0x%01X  |  [RW][02:00]""Indicates for each bit whether an interrupt request should be generated on a falling edge (value='0') or a rising edge (value='1').""\n", FIELD_VALUE(val, 0, 2));
} /* end irq_ctrl_1 */

/* Generated Debug Code: Device cphy_rx_1 */
void ia_css_debug_dump_cphy_rx_1(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x6d820);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_1.reg_rx_status                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_1_reg_rx_status_type */
	/* skip, unused field unused_reg_rx_status (reg_rx_status) */
	REG_DUMP_PRINT_1("   -reg_rx_status.reg_rx_status                                              |         0x%01X  |  [RO][00:00]""Status register:                    0 = Receiver is IDLE, not processing a packet                    1 = Receiver is processing a packet""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6d81c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_1.reg_sync_cntr_sel                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_1_reg_sync_cntr_sel_type */
	/* skip, unused field unused_reg_sync_cntr_sel (reg_sync_cntr_sel) */
	REG_DUMP_PRINT_1("   -reg_sync_cntr_sel.reg_sync_cntr_sel                                      |         0x%01X  |  [RW][01:00]""Sync counter select register.                    bit 0 => 0: Use internal counter for line start and line end packet IDs.                          => 1: Use line start and line end ID as send by sensor                    bit 1 => 0: Use internal counter for frame start and frame end packet IDs.                          => 1: Use frame start and frame end ID as send by sensor""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x6d818);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_1.reg_cphy_rx_portconfig_timeout_cntr                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_1_reg_cphy_rx_portconfig_timeout_cntr_type */
	/* skip, unused field unused_reg_cphy_rx_portconfig_timeout_cntr (reg_cphy_rx_portconfig_timeout_cntr) */
	REG_DUMP_PRINT_1("   -reg_cphy_rx_portconfig_timeout_cntr.reg_cphy_rx_portconfig_timeout_cntr  |      0x%04X  |  [RW][15:00]""Portconfig timeout counter of CPHY RX.                    Specifies a timeout value in number of isp clk cycles after which                    the elastic fifos of enabled lanes would flush if all such trios do not receive valid data within this time period.                   As an example, set value to 1000 (should be set to a sufficient time that clearly indicates that trios have gone out of sync)""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x6d814);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_1.reg_cphy_rx_portconfig_ctrl                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_1_reg_cphy_rx_portconfig_ctrl_type */
	/* skip, unused field unused_reg_cphy_rx_portconfig_ctrl (reg_cphy_rx_portconfig_ctrl) */
	REG_DUMP_PRINT_1("   -reg_cphy_rx_portconfig_ctrl.reg_cphy_rx_portconfig_ctrl                  |         0x%01X  |  [RW][00:00]""Portconfig control of CPHY RX.                    bit.0 = chicken bit to use internal generated sot (based on rising edge of trio_vld input)""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6d810);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_1.reg_cphy_rx_error_handling                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_1_reg_cphy_rx_error_handling_type */
	/* skip, unused field unused_reg_cphy_rx_error_handling (reg_cphy_rx_error_handling) */
	REG_DUMP_PRINT_1("   -reg_cphy_rx_error_handling.reg_cphy_rx_error_handling                    |        0x%02X  |  [RW][04:00]""Error handling register.                    bit 0 = when set, packets with more than one erro in packet header                            are discarded.                    bit 1 = when set, a short packet with reserved id is discarded and irq                            is raised                    bit 2 = when set, a long packet with reserved id is discarded and irq                            is raised                    bit 3 = when set, detection of incomplete packet is disabled, irq will                            not be generated""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0x6d80c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_1.reg_cphy_rx_ph_crc_config                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_1_reg_cphy_rx_ph_crc_config_type */
	/* skip, unused field unused_reg_cphy_rx_ph_crc_config (reg_cphy_rx_ph_crc_config) */
	REG_DUMP_PRINT_1("   -reg_cphy_rx_ph_crc_config.reg_cphy_rx_ph_crc_config                      |         0x%01X  |  [RW][01:00]""CRC configuration of CPHY RX. ""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x6d808);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_1.reg_cphy_rx_hbp_testmode_enable                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_1_reg_cphy_rx_hbp_testmode_enable_type */
	/* skip, unused field unused_reg_cphy_rx_hbp_testmode_enable (reg_cphy_rx_hbp_testmode_enable) */
	REG_DUMP_PRINT_1("   -reg_cphy_rx_hbp_testmode_enable.reg_cphy_rx_hbp_testmode_enable          |         0x%01X  |  [RW][00:00]""HBP Testmode enable of CPHY RX. ""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6d804);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_1.reg_cphy_rx_nof_enabled_lanes                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_1_reg_cphy_rx_nof_enabled_lanes_type */
	/* skip, unused field unused_reg_cphy_rx_nof_enabled_lanes (reg_cphy_rx_nof_enabled_lanes) */
	REG_DUMP_PRINT_1("   -reg_cphy_rx_nof_enabled_lanes.reg_cphy_rx_nof_enabled_lanes              |         0x%01X  |  [RW][02:00]""Specify Number of enabled data lanes of CPHY RX.                    0 = No lanes enabled                    1 = One   lane  enabled,                    2 = Two   lanes enabled,                    3 = Three lanes enabled,                    4 = Four  lanes enabled,                   ""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x6d800);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_1.reg_cphy_rx_enable                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_1_reg_cphy_rx_enable_type */
	/* skip, unused field unused_reg_cphy_rx_enable (reg_cphy_rx_enable) */
	REG_DUMP_PRINT_1("   -reg_cphy_rx_enable.reg_cphy_rx_enable                                    |         0x%01X  |  [RW][00:00]""Enable CPHY RX""\n", FIELD_VALUE(val, 0, 0));
} /* end cphy_rx_1 */

/* Generated Debug Code: Device gpr_0 */
void ia_css_debug_dump_gpr_0(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x6d708);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpr_0.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX                                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_gpr_0_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX_type */
	/* skip, unused field unused_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX (csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX) */
	REG_DUMP_PRINT_1("   -csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX  |       0x%03X  |  [RW][10:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 10));
	val = REG_DUMP_READ_REGISTER(0x6d704);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpr_0.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX                                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_gpr_0_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX_type */
	/* skip, unused field unused_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX (csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX) */
	REG_DUMP_PRINT_1("   -csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX      |    0x%06X  |  [RW][21:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 21));
	val = REG_DUMP_READ_REGISTER(0x6d700);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpr_0.str_mon_status                                                                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_gpr_0_str_mon_status_type */
	REG_DUMP_PRINT_1("   -str_mon_status.str_mon_status                                                                                        |  0x%08X  |  [RO][31:00]""Streaming Monitor Status, [accept,valid] of streaming port""\n", FIELD_VALUE(val, 0, 31));
} /* end gpr_0 */

/* Generated Debug Code: Device irq_ctrl0_0 */
void ia_css_debug_dump_irq_ctrl0_0(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x6d514);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_0.irq_level_not_pulse            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl0_0_irq_level_not_pulse_type */
	/* skip, unused field unused_irq_level_not_pulse (irq_level_not_pulse) */
	REG_DUMP_PRINT_1("   -irq_level_not_pulse.irq_level_not_pulse  |  0x%08X  |  [RW][28:00]""Indicates for each bit whether an interrupt cause is translated into a pulse (value='0') or into a constant level '1' (value='1') on the IRQ pin.""\n", FIELD_VALUE(val, 0, 28));
	val = REG_DUMP_READ_REGISTER(0x6d510);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_0.irq_enable                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl0_0_irq_enable_type */
	/* skip, unused field unused_irq_enable (irq_enable) */
	REG_DUMP_PRINT_1("   -irq_enable.irq_enable                    |  0x%08X  |  [RW][28:00]""Indicates for each bit whether an interrupt cause as monitored by the req_irq_status register also affects the IRQ pin (value='1') or not (value='0').""\n", FIELD_VALUE(val, 0, 28));
	val = REG_DUMP_READ_REGISTER(0x6d508);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_0.irq_status                     |  0x%08X  |  ""Indicates for each bit whether a non-masked interrupt has been generated (value='1'). Can be cleared by writing a '1' into the the corresponding bit of the req_irq_clear register.""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl0_0_irq_status_type */
	/* skip, unused field unused_irq_status (irq_status) */
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_0                 |         0x%01X  |  [RO][00:00]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_1                 |         0x%01X  |  [RO][01:01]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_2                 |         0x%01X  |  [RO][02:02]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_3                 |         0x%01X  |  [RO][03:03]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_4                 |         0x%01X  |  [RO][04:04]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_5                 |         0x%01X  |  [RO][05:05]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_6                 |         0x%01X  |  [RO][06:06]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_7                 |         0x%01X  |  [RO][07:07]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_8                 |         0x%01X  |  [RO][08:08]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_9                 |         0x%01X  |  [RO][09:09]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_10                |         0x%01X  |  [RO][10:10]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_11                |         0x%01X  |  [RO][11:11]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_12                |         0x%01X  |  [RO][12:12]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 12, 12));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_13                |         0x%01X  |  [RO][13:13]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 13, 13));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_14                |         0x%01X  |  [RO][14:14]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 14, 14));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_15                |         0x%01X  |  [RO][15:15]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 15, 15));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_16                |         0x%01X  |  [RO][16:16]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 16, 16));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_17                |         0x%01X  |  [RO][17:17]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 17, 17));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_18                |         0x%01X  |  [RO][18:18]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 18, 18));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_19                |         0x%01X  |  [RO][19:19]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 19, 19));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_20                |         0x%01X  |  [RO][20:20]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 20, 20));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_21                |         0x%01X  |  [RO][21:21]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 21, 21));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_22                |         0x%01X  |  [RO][22:22]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 22, 22));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_23                |         0x%01X  |  [RO][23:23]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 23, 23));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_24                |         0x%01X  |  [RO][24:24]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 24, 24));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_25                |         0x%01X  |  [RO][25:25]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 25, 25));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_26                |         0x%01X  |  [RO][26:26]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 26, 26));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_27                |         0x%01X  |  [RO][27:27]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 27, 27));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_28                |         0x%01X  |  [RO][28:28]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 28, 28));
	val = REG_DUMP_READ_REGISTER(0x6d504);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_0.irq_mask                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl0_0_irq_mask_type */
	/* skip, unused field unused_irq_mask (irq_mask) */
	REG_DUMP_PRINT_1("   -irq_mask.irq_mask                        |  0x%08X  |  [RW][28:00]""Indicates for each bit of irq_di whether it can generate an interrupt request (value='1') or not (value='0'). Setting will affect irq_value as well as IRQ output pin.""\n", FIELD_VALUE(val, 0, 28));
	val = REG_DUMP_READ_REGISTER(0x6d500);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_0.irq_edge                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl0_0_irq_edge_type */
	/* skip, unused field unused_irq_edge (irq_edge) */
	REG_DUMP_PRINT_1("   -irq_edge.irq_edge                        |  0x%08X  |  [RW][28:00]""Indicates for each bit whether an interrupt request should be generated on a falling edge (value='0') or a rising edge (value='1').""\n", FIELD_VALUE(val, 0, 28));
} /* end irq_ctrl0_0 */

/* Generated Debug Code: Device irq_ctrl_0 */
void ia_css_debug_dump_irq_ctrl_0(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x6d414);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_0.irq_level_not_pulse             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl_0_irq_level_not_pulse_type */
	/* skip, unused field unused_irq_level_not_pulse (irq_level_not_pulse) */
	REG_DUMP_PRINT_1("   -irq_level_not_pulse.irq_level_not_pulse  |         0x%01X  |  [RW][02:00]""Indicates for each bit whether an interrupt cause is translated into a pulse (value='0') or into a constant level '1' (value='1') on the IRQ pin.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x6d410);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_0.irq_enable                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl_0_irq_enable_type */
	/* skip, unused field unused_irq_enable (irq_enable) */
	REG_DUMP_PRINT_1("   -irq_enable.irq_enable                    |         0x%01X  |  [RW][02:00]""Indicates for each bit whether an interrupt cause as monitored by the req_irq_status register also affects the IRQ pin (value='1') or not (value='0').""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x6d408);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_0.irq_status                      |  0x%08X  |  ""Indicates for each bit whether a non-masked interrupt has been generated (value='1'). Can be cleared by writing a '1' into the the corresponding bit of the req_irq_clear register.""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl_0_irq_status_type */
	/* skip, unused field unused_irq_status (irq_status) */
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX                   |         0x%01X  |  [RO][00:00]""Represents the status of the irq from irq_ctrl0 (csi_rx irqs).""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M                  |         0x%01X  |  [RO][02:02]""Represents the status of the irq from irq_ctrl1 (csi__rx_synchronization_irqs + s2m_irqs).""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_SM                   |         0x%01X  |  [RO][03:03]""Represents the status of the irq from Stream Monitor.""\n", FIELD_VALUE(val, 3, 3));
	val = REG_DUMP_READ_REGISTER(0x6d404);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_0.irq_mask                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl_0_irq_mask_type */
	/* skip, unused field unused_irq_mask (irq_mask) */
	REG_DUMP_PRINT_1("   -irq_mask.irq_mask                        |         0x%01X  |  [RW][02:00]""Indicates for each bit of irq_di whether it can generate an interrupt request (value='1') or not (value='0'). Setting will affect irq_value as well as IRQ output pin.""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x6d400);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_0.irq_edge                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl_0_irq_edge_type */
	/* skip, unused field unused_irq_edge (irq_edge) */
	REG_DUMP_PRINT_1("   -irq_edge.irq_edge                        |         0x%01X  |  [RW][02:00]""Indicates for each bit whether an interrupt request should be generated on a falling edge (value='0') or a rising edge (value='1').""\n", FIELD_VALUE(val, 0, 2));
} /* end irq_ctrl_0 */

/* Generated Debug Code: Device cphy_rx_0 */
void ia_css_debug_dump_cphy_rx_0(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x6d020);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_0.reg_rx_status                                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_0_reg_rx_status_type */
	/* skip, unused field unused_reg_rx_status (reg_rx_status) */
	REG_DUMP_PRINT_1("   -reg_rx_status.reg_rx_status                                              |         0x%01X  |  [RO][00:00]""Status register:                    0 = Receiver is IDLE, not processing a packet                    1 = Receiver is processing a packet""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6d01c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_0.reg_sync_cntr_sel                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_0_reg_sync_cntr_sel_type */
	/* skip, unused field unused_reg_sync_cntr_sel (reg_sync_cntr_sel) */
	REG_DUMP_PRINT_1("   -reg_sync_cntr_sel.reg_sync_cntr_sel                                      |         0x%01X  |  [RW][01:00]""Sync counter select register.                    bit 0 => 0: Use internal counter for line start and line end packet IDs.                          => 1: Use line start and line end ID as send by sensor                    bit 1 => 0: Use internal counter for frame start and frame end packet IDs.                          => 1: Use frame start and frame end ID as send by sensor""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x6d018);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_0.reg_cphy_rx_portconfig_timeout_cntr                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_0_reg_cphy_rx_portconfig_timeout_cntr_type */
	/* skip, unused field unused_reg_cphy_rx_portconfig_timeout_cntr (reg_cphy_rx_portconfig_timeout_cntr) */
	REG_DUMP_PRINT_1("   -reg_cphy_rx_portconfig_timeout_cntr.reg_cphy_rx_portconfig_timeout_cntr  |      0x%04X  |  [RW][15:00]""Portconfig timeout counter of CPHY RX.                    Specifies a timeout value in number of isp clk cycles after which                    the elastic fifos of enabled lanes would flush if all such trios do not receive valid data within this time period.                   As an example, set value to 1000 (should be set to a sufficient time that clearly indicates that trios have gone out of sync)""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x6d014);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_0.reg_cphy_rx_portconfig_ctrl                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_0_reg_cphy_rx_portconfig_ctrl_type */
	/* skip, unused field unused_reg_cphy_rx_portconfig_ctrl (reg_cphy_rx_portconfig_ctrl) */
	REG_DUMP_PRINT_1("   -reg_cphy_rx_portconfig_ctrl.reg_cphy_rx_portconfig_ctrl                  |         0x%01X  |  [RW][00:00]""Portconfig control of CPHY RX.                    bit.0 = chicken bit to use internal generated sot (based on rising edge of trio_vld input)""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6d010);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_0.reg_cphy_rx_error_handling                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_0_reg_cphy_rx_error_handling_type */
	/* skip, unused field unused_reg_cphy_rx_error_handling (reg_cphy_rx_error_handling) */
	REG_DUMP_PRINT_1("   -reg_cphy_rx_error_handling.reg_cphy_rx_error_handling                    |        0x%02X  |  [RW][04:00]""Error handling register.                    bit 0 = when set, packets with more than one erro in packet header                            are discarded.                    bit 1 = when set, a short packet with reserved id is discarded and irq                            is raised                    bit 2 = when set, a long packet with reserved id is discarded and irq                            is raised                    bit 3 = when set, detection of incomplete packet is disabled, irq will                            not be generated""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0x6d00c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_0.reg_cphy_rx_ph_crc_config                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_0_reg_cphy_rx_ph_crc_config_type */
	/* skip, unused field unused_reg_cphy_rx_ph_crc_config (reg_cphy_rx_ph_crc_config) */
	REG_DUMP_PRINT_1("   -reg_cphy_rx_ph_crc_config.reg_cphy_rx_ph_crc_config                      |         0x%01X  |  [RW][01:00]""CRC configuration of CPHY RX. ""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x6d008);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_0.reg_cphy_rx_hbp_testmode_enable                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_0_reg_cphy_rx_hbp_testmode_enable_type */
	/* skip, unused field unused_reg_cphy_rx_hbp_testmode_enable (reg_cphy_rx_hbp_testmode_enable) */
	REG_DUMP_PRINT_1("   -reg_cphy_rx_hbp_testmode_enable.reg_cphy_rx_hbp_testmode_enable          |         0x%01X  |  [RW][00:00]""HBP Testmode enable of CPHY RX. ""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6d004);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_0.reg_cphy_rx_nof_enabled_lanes                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_0_reg_cphy_rx_nof_enabled_lanes_type */
	/* skip, unused field unused_reg_cphy_rx_nof_enabled_lanes (reg_cphy_rx_nof_enabled_lanes) */
	REG_DUMP_PRINT_1("   -reg_cphy_rx_nof_enabled_lanes.reg_cphy_rx_nof_enabled_lanes              |         0x%01X  |  [RW][02:00]""Specify Number of enabled data lanes of CPHY RX.                    0 = No lanes enabled                    1 = One   lane  enabled,                    2 = Two   lanes enabled,                    3 = Three lanes enabled,                    4 = Four  lanes enabled,                   ""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x6d000);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  cphy_rx_0.reg_cphy_rx_enable                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_cphy_rx_0_reg_cphy_rx_enable_type */
	/* skip, unused field unused_reg_cphy_rx_enable (reg_cphy_rx_enable) */
	REG_DUMP_PRINT_1("   -reg_cphy_rx_enable.reg_cphy_rx_enable                                    |         0x%01X  |  [RW][00:00]""Enable CPHY RX""\n", FIELD_VALUE(val, 0, 0));
} /* end cphy_rx_0 */

/* Generated Debug Code: Device tm */
void ia_css_debug_dump_tm(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x6f344);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_enable_reg_7                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_irq_enable_reg_7_type */
	/* skip, unused field unused_tm_irq_enable_reg_7 (tm_irq_enable_reg_7) */
	REG_DUMP_PRINT_1("   -tm_irq_enable_reg_7.tm_irq_enable_reg_7                |         0x%01X  |  [RW][00:00]""Enable trigger 7 and sticky bits""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6f340);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_enable_reg_6                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_irq_enable_reg_6_type */
	/* skip, unused field unused_tm_irq_enable_reg_6 (tm_irq_enable_reg_6) */
	REG_DUMP_PRINT_1("   -tm_irq_enable_reg_6.tm_irq_enable_reg_6                |         0x%01X  |  [RW][00:00]""Enable trigger 6 and sticky bits""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6f33c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_enable_reg_5                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_irq_enable_reg_5_type */
	/* skip, unused field unused_tm_irq_enable_reg_5 (tm_irq_enable_reg_5) */
	REG_DUMP_PRINT_1("   -tm_irq_enable_reg_5.tm_irq_enable_reg_5                |         0x%01X  |  [RW][00:00]""Enable trigger 5 and sticky bits""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6f338);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_enable_reg_4                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_irq_enable_reg_4_type */
	/* skip, unused field unused_tm_irq_enable_reg_4 (tm_irq_enable_reg_4) */
	REG_DUMP_PRINT_1("   -tm_irq_enable_reg_4.tm_irq_enable_reg_4                |         0x%01X  |  [RW][00:00]""Enable trigger 4 and sticky bits""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6f334);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_enable_reg_3                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_irq_enable_reg_3_type */
	/* skip, unused field unused_tm_irq_enable_reg_3 (tm_irq_enable_reg_3) */
	REG_DUMP_PRINT_1("   -tm_irq_enable_reg_3.tm_irq_enable_reg_3                |         0x%01X  |  [RW][00:00]""Enable trigger 3 and sticky bits""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6f330);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_enable_reg_2                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_irq_enable_reg_2_type */
	/* skip, unused field unused_tm_irq_enable_reg_2 (tm_irq_enable_reg_2) */
	REG_DUMP_PRINT_1("   -tm_irq_enable_reg_2.tm_irq_enable_reg_2                |         0x%01X  |  [RW][00:00]""Enable trigger 2 and sticky bits""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6f32c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_enable_reg_1                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_irq_enable_reg_1_type */
	/* skip, unused field unused_tm_irq_enable_reg_1 (tm_irq_enable_reg_1) */
	REG_DUMP_PRINT_1("   -tm_irq_enable_reg_1.tm_irq_enable_reg_1                |         0x%01X  |  [RW][00:00]""Enable trigger 1 and sticky bits""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6f328);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_enable_reg_0                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_irq_enable_reg_0_type */
	/* skip, unused field unused_tm_irq_enable_reg_0 (tm_irq_enable_reg_0) */
	REG_DUMP_PRINT_1("   -tm_irq_enable_reg_0.tm_irq_enable_reg_0                |         0x%01X  |  [RW][00:00]""Enable trigger 0 and sticky bits""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6f324);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_timer_sel_reg_7                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_irq_timer_sel_reg_7_type */
	/* skip, unused field unused_tm_irq_timer_sel_reg_7 (tm_irq_timer_sel_reg_7) */
	REG_DUMP_PRINT_1("   -tm_irq_timer_sel_reg_7.tm_irq_timer_sel_reg_7          |         0x%01X  |  [RW][02:00]""Selects which counter to be used for matching for trigger 7""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x6f320);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_timer_sel_reg_6                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_irq_timer_sel_reg_6_type */
	/* skip, unused field unused_tm_irq_timer_sel_reg_6 (tm_irq_timer_sel_reg_6) */
	REG_DUMP_PRINT_1("   -tm_irq_timer_sel_reg_6.tm_irq_timer_sel_reg_6          |         0x%01X  |  [RW][02:00]""Selects which counter to be used for matching for trigger 6""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x6f31c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_timer_sel_reg_5                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_irq_timer_sel_reg_5_type */
	/* skip, unused field unused_tm_irq_timer_sel_reg_5 (tm_irq_timer_sel_reg_5) */
	REG_DUMP_PRINT_1("   -tm_irq_timer_sel_reg_5.tm_irq_timer_sel_reg_5          |         0x%01X  |  [RW][02:00]""Selects which counter to be used for matching for trigger 5""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x6f318);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_timer_sel_reg_4                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_irq_timer_sel_reg_4_type */
	/* skip, unused field unused_tm_irq_timer_sel_reg_4 (tm_irq_timer_sel_reg_4) */
	REG_DUMP_PRINT_1("   -tm_irq_timer_sel_reg_4.tm_irq_timer_sel_reg_4          |         0x%01X  |  [RW][02:00]""Selects which counter to be used for matching for trigger 4""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x6f314);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_timer_sel_reg_3                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_irq_timer_sel_reg_3_type */
	/* skip, unused field unused_tm_irq_timer_sel_reg_3 (tm_irq_timer_sel_reg_3) */
	REG_DUMP_PRINT_1("   -tm_irq_timer_sel_reg_3.tm_irq_timer_sel_reg_3          |         0x%01X  |  [RW][02:00]""Selects which counter to be used for matching for trigger 3""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x6f310);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_timer_sel_reg_2                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_irq_timer_sel_reg_2_type */
	/* skip, unused field unused_tm_irq_timer_sel_reg_2 (tm_irq_timer_sel_reg_2) */
	REG_DUMP_PRINT_1("   -tm_irq_timer_sel_reg_2.tm_irq_timer_sel_reg_2          |         0x%01X  |  [RW][02:00]""Selects which counter to be used for matching for trigger 2""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x6f30c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_timer_sel_reg_1                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_irq_timer_sel_reg_1_type */
	/* skip, unused field unused_tm_irq_timer_sel_reg_1 (tm_irq_timer_sel_reg_1) */
	REG_DUMP_PRINT_1("   -tm_irq_timer_sel_reg_1.tm_irq_timer_sel_reg_1          |         0x%01X  |  [RW][02:00]""Selects which counter to be used for matching for trigger 1""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x6f308);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_timer_sel_reg_0                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_irq_timer_sel_reg_0_type */
	/* skip, unused field unused_tm_irq_timer_sel_reg_0 (tm_irq_timer_sel_reg_0) */
	REG_DUMP_PRINT_1("   -tm_irq_timer_sel_reg_0.tm_irq_timer_sel_reg_0          |         0x%01X  |  [RW][02:00]""Selects which counter to be used for matching for trigger 0""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x6f304);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_trigger_value_reg_7                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_irq_trigger_value_reg_7_type */
	REG_DUMP_PRINT_1("   -tm_irq_trigger_value_reg_7.tm_irq_trigger_value_reg_7  |  0x%08X  |  [RW][31:00]""The reference value that is used for comparisson and trigger 7 generation""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x6f300);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_trigger_value_reg_6                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_irq_trigger_value_reg_6_type */
	REG_DUMP_PRINT_1("   -tm_irq_trigger_value_reg_6.tm_irq_trigger_value_reg_6  |  0x%08X  |  [RW][31:00]""The reference value that is used for comparisson and trigger 6 generation""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x6f2fc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_trigger_value_reg_5                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_irq_trigger_value_reg_5_type */
	REG_DUMP_PRINT_1("   -tm_irq_trigger_value_reg_5.tm_irq_trigger_value_reg_5  |  0x%08X  |  [RW][31:00]""The reference value that is used for comparisson and trigger 5 generation""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x6f2f8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_trigger_value_reg_4                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_irq_trigger_value_reg_4_type */
	REG_DUMP_PRINT_1("   -tm_irq_trigger_value_reg_4.tm_irq_trigger_value_reg_4  |  0x%08X  |  [RW][31:00]""The reference value that is used for comparisson and trigger 4 generation""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x6f2f4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_trigger_value_reg_3                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_irq_trigger_value_reg_3_type */
	REG_DUMP_PRINT_1("   -tm_irq_trigger_value_reg_3.tm_irq_trigger_value_reg_3  |  0x%08X  |  [RW][31:00]""The reference value that is used for comparisson and trigger 3 generation""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x6f2f0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_trigger_value_reg_2                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_irq_trigger_value_reg_2_type */
	REG_DUMP_PRINT_1("   -tm_irq_trigger_value_reg_2.tm_irq_trigger_value_reg_2  |  0x%08X  |  [RW][31:00]""The reference value that is used for comparisson and trigger 2 generation""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x6f2ec);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_trigger_value_reg_1                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_irq_trigger_value_reg_1_type */
	REG_DUMP_PRINT_1("   -tm_irq_trigger_value_reg_1.tm_irq_trigger_value_reg_1  |  0x%08X  |  [RW][31:00]""The reference value that is used for comparisson and trigger 1 generation""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x6f2e8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_trigger_value_reg_0                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_irq_trigger_value_reg_0_type */
	REG_DUMP_PRINT_1("   -tm_irq_trigger_value_reg_0.tm_irq_trigger_value_reg_0  |  0x%08X  |  [RW][31:00]""The reference value that is used for comparisson and trigger 0 generation""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x6f2e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_stop_sel_reg_7                               |  0x%08X  |  ""TM stop selection for counter 7""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_stop_sel_reg_7_type */
	/* skip, unused field unused_tm_trace_stop_sel_reg_7 (tm_trace_stop_sel_reg_7) */
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_7.SrcSel                         |        0x%02X  |  [RW][07:00]""Select input / output""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_7.RoutSel                        |         0x%01X  |  [RW][09:08]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_7.SensSel                        |         0x%01X  |  [RW][11:10]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 10, 11));
	val = REG_DUMP_READ_REGISTER(0x6f2e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_stop_sel_reg_6                               |  0x%08X  |  ""TM stop selection for counter 6""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_stop_sel_reg_6_type */
	/* skip, unused field unused_tm_trace_stop_sel_reg_6 (tm_trace_stop_sel_reg_6) */
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_6.SrcSel                         |        0x%02X  |  [RW][07:00]""Select input / output""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_6.RoutSel                        |         0x%01X  |  [RW][09:08]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_6.SensSel                        |         0x%01X  |  [RW][11:10]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 10, 11));
	val = REG_DUMP_READ_REGISTER(0x6f2dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_stop_sel_reg_5                               |  0x%08X  |  ""TM stop selection for counter 5""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_stop_sel_reg_5_type */
	/* skip, unused field unused_tm_trace_stop_sel_reg_5 (tm_trace_stop_sel_reg_5) */
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_5.SrcSel                         |        0x%02X  |  [RW][07:00]""Select input / output""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_5.RoutSel                        |         0x%01X  |  [RW][09:08]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_5.SensSel                        |         0x%01X  |  [RW][11:10]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 10, 11));
	val = REG_DUMP_READ_REGISTER(0x6f2d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_stop_sel_reg_4                               |  0x%08X  |  ""TM stop selection for counter 4""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_stop_sel_reg_4_type */
	/* skip, unused field unused_tm_trace_stop_sel_reg_4 (tm_trace_stop_sel_reg_4) */
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_4.SrcSel                         |        0x%02X  |  [RW][07:00]""Select input / output""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_4.RoutSel                        |         0x%01X  |  [RW][09:08]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_4.SensSel                        |         0x%01X  |  [RW][11:10]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 10, 11));
	val = REG_DUMP_READ_REGISTER(0x6f2d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_stop_sel_reg_3                               |  0x%08X  |  ""TM stop selection for counter 3""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_stop_sel_reg_3_type */
	/* skip, unused field unused_tm_trace_stop_sel_reg_3 (tm_trace_stop_sel_reg_3) */
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_3.SrcSel                         |        0x%02X  |  [RW][07:00]""Select input / output""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_3.RoutSel                        |         0x%01X  |  [RW][09:08]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_3.SensSel                        |         0x%01X  |  [RW][11:10]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 10, 11));
	val = REG_DUMP_READ_REGISTER(0x6f2d0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_stop_sel_reg_2                               |  0x%08X  |  ""TM stop selection for counter 2""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_stop_sel_reg_2_type */
	/* skip, unused field unused_tm_trace_stop_sel_reg_2 (tm_trace_stop_sel_reg_2) */
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_2.SrcSel                         |        0x%02X  |  [RW][07:00]""Select input / output""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_2.RoutSel                        |         0x%01X  |  [RW][09:08]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_2.SensSel                        |         0x%01X  |  [RW][11:10]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 10, 11));
	val = REG_DUMP_READ_REGISTER(0x6f2cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_stop_sel_reg_1                               |  0x%08X  |  ""TM stop selection for counter 1""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_stop_sel_reg_1_type */
	/* skip, unused field unused_tm_trace_stop_sel_reg_1 (tm_trace_stop_sel_reg_1) */
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_1.SrcSel                         |        0x%02X  |  [RW][07:00]""Select input / output""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_1.RoutSel                        |         0x%01X  |  [RW][09:08]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_1.SensSel                        |         0x%01X  |  [RW][11:10]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 10, 11));
	val = REG_DUMP_READ_REGISTER(0x6f2c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_stop_sel_reg_0                               |  0x%08X  |  ""TM stop selection for counter 0""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_stop_sel_reg_0_type */
	/* skip, unused field unused_tm_trace_stop_sel_reg_0 (tm_trace_stop_sel_reg_0) */
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_0.SrcSel                         |        0x%02X  |  [RW][07:00]""Select input / output""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_0.RoutSel                        |         0x%01X  |  [RW][09:08]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_0.SensSel                        |         0x%01X  |  [RW][11:10]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 10, 11));
	val = REG_DUMP_READ_REGISTER(0x6f2c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_start_sel_reg_7                              |  0x%08X  |  ""TM start selection for counter 7""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_start_sel_reg_7_type */
	/* skip, unused field unused_tm_trace_start_sel_reg_7 (tm_trace_start_sel_reg_7) */
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_7.SrcSel                        |        0x%02X  |  [RW][07:00]""Select input / output""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_7.RoutSel                       |         0x%01X  |  [RW][09:08]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_7.SensSel                       |         0x%01X  |  [RW][11:10]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 10, 11));
	val = REG_DUMP_READ_REGISTER(0x6f2c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_start_sel_reg_6                              |  0x%08X  |  ""TM start selection for counter 6""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_start_sel_reg_6_type */
	/* skip, unused field unused_tm_trace_start_sel_reg_6 (tm_trace_start_sel_reg_6) */
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_6.SrcSel                        |        0x%02X  |  [RW][07:00]""Select input / output""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_6.RoutSel                       |         0x%01X  |  [RW][09:08]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_6.SensSel                       |         0x%01X  |  [RW][11:10]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 10, 11));
	val = REG_DUMP_READ_REGISTER(0x6f2bc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_start_sel_reg_5                              |  0x%08X  |  ""TM start selection for counter 5""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_start_sel_reg_5_type */
	/* skip, unused field unused_tm_trace_start_sel_reg_5 (tm_trace_start_sel_reg_5) */
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_5.SrcSel                        |        0x%02X  |  [RW][07:00]""Select input / output""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_5.RoutSel                       |         0x%01X  |  [RW][09:08]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_5.SensSel                       |         0x%01X  |  [RW][11:10]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 10, 11));
	val = REG_DUMP_READ_REGISTER(0x6f2b8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_start_sel_reg_4                              |  0x%08X  |  ""TM start selection for counter 4""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_start_sel_reg_4_type */
	/* skip, unused field unused_tm_trace_start_sel_reg_4 (tm_trace_start_sel_reg_4) */
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_4.SrcSel                        |        0x%02X  |  [RW][07:00]""Select input / output""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_4.RoutSel                       |         0x%01X  |  [RW][09:08]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_4.SensSel                       |         0x%01X  |  [RW][11:10]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 10, 11));
	val = REG_DUMP_READ_REGISTER(0x6f2b4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_start_sel_reg_3                              |  0x%08X  |  ""TM start selection for counter 3""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_start_sel_reg_3_type */
	/* skip, unused field unused_tm_trace_start_sel_reg_3 (tm_trace_start_sel_reg_3) */
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_3.SrcSel                        |        0x%02X  |  [RW][07:00]""Select input / output""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_3.RoutSel                       |         0x%01X  |  [RW][09:08]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_3.SensSel                       |         0x%01X  |  [RW][11:10]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 10, 11));
	val = REG_DUMP_READ_REGISTER(0x6f2b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_start_sel_reg_2                              |  0x%08X  |  ""TM start selection for counter 2""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_start_sel_reg_2_type */
	/* skip, unused field unused_tm_trace_start_sel_reg_2 (tm_trace_start_sel_reg_2) */
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_2.SrcSel                        |        0x%02X  |  [RW][07:00]""Select input / output""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_2.RoutSel                       |         0x%01X  |  [RW][09:08]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_2.SensSel                       |         0x%01X  |  [RW][11:10]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 10, 11));
	val = REG_DUMP_READ_REGISTER(0x6f2ac);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_start_sel_reg_1                              |  0x%08X  |  ""TM start selection for counter 1""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_start_sel_reg_1_type */
	/* skip, unused field unused_tm_trace_start_sel_reg_1 (tm_trace_start_sel_reg_1) */
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_1.SrcSel                        |        0x%02X  |  [RW][07:00]""Select input / output""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_1.RoutSel                       |         0x%01X  |  [RW][09:08]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_1.SensSel                       |         0x%01X  |  [RW][11:10]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 10, 11));
	val = REG_DUMP_READ_REGISTER(0x6f2a8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_start_sel_reg_0                              |  0x%08X  |  ""TM start selection for counter 0""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_start_sel_reg_0_type */
	/* skip, unused field unused_tm_trace_start_sel_reg_0 (tm_trace_start_sel_reg_0) */
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_0.SrcSel                        |        0x%02X  |  [RW][07:00]""Select input / output""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_0.RoutSel                       |         0x%01X  |  [RW][09:08]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_0.SensSel                       |         0x%01X  |  [RW][11:10]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 10, 11));
	val = REG_DUMP_READ_REGISTER(0x6f2a4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_input_sel_reg_7                              |  0x%08X  |  ""TM input selection for counter 7""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_input_sel_reg_7_type */
	/* skip, unused field unused_tm_trace_input_sel_reg_7 (tm_trace_input_sel_reg_7) */
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_7.SrcSel                        |        0x%02X  |  [RW][07:00]""Select input / output""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_7.RoutSel                       |         0x%01X  |  [RW][09:08]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_7.SensSel                       |         0x%01X  |  [RW][11:10]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 10, 11));
	val = REG_DUMP_READ_REGISTER(0x6f2a0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_input_sel_reg_6                              |  0x%08X  |  ""TM input selection for counter 6""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_input_sel_reg_6_type */
	/* skip, unused field unused_tm_trace_input_sel_reg_6 (tm_trace_input_sel_reg_6) */
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_6.SrcSel                        |        0x%02X  |  [RW][07:00]""Select input / output""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_6.RoutSel                       |         0x%01X  |  [RW][09:08]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_6.SensSel                       |         0x%01X  |  [RW][11:10]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 10, 11));
	val = REG_DUMP_READ_REGISTER(0x6f29c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_input_sel_reg_5                              |  0x%08X  |  ""TM input selection for counter 5""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_input_sel_reg_5_type */
	/* skip, unused field unused_tm_trace_input_sel_reg_5 (tm_trace_input_sel_reg_5) */
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_5.SrcSel                        |        0x%02X  |  [RW][07:00]""Select input / output""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_5.RoutSel                       |         0x%01X  |  [RW][09:08]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_5.SensSel                       |         0x%01X  |  [RW][11:10]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 10, 11));
	val = REG_DUMP_READ_REGISTER(0x6f298);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_input_sel_reg_4                              |  0x%08X  |  ""TM input selection for counter 4""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_input_sel_reg_4_type */
	/* skip, unused field unused_tm_trace_input_sel_reg_4 (tm_trace_input_sel_reg_4) */
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_4.SrcSel                        |        0x%02X  |  [RW][07:00]""Select input / output""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_4.RoutSel                       |         0x%01X  |  [RW][09:08]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_4.SensSel                       |         0x%01X  |  [RW][11:10]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 10, 11));
	val = REG_DUMP_READ_REGISTER(0x6f294);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_input_sel_reg_3                              |  0x%08X  |  ""TM input selection for counter 3""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_input_sel_reg_3_type */
	/* skip, unused field unused_tm_trace_input_sel_reg_3 (tm_trace_input_sel_reg_3) */
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_3.SrcSel                        |        0x%02X  |  [RW][07:00]""Select input / output""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_3.RoutSel                       |         0x%01X  |  [RW][09:08]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_3.SensSel                       |         0x%01X  |  [RW][11:10]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 10, 11));
	val = REG_DUMP_READ_REGISTER(0x6f290);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_input_sel_reg_2                              |  0x%08X  |  ""TM input selection for counter 2""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_input_sel_reg_2_type */
	/* skip, unused field unused_tm_trace_input_sel_reg_2 (tm_trace_input_sel_reg_2) */
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_2.SrcSel                        |        0x%02X  |  [RW][07:00]""Select input / output""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_2.RoutSel                       |         0x%01X  |  [RW][09:08]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_2.SensSel                       |         0x%01X  |  [RW][11:10]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 10, 11));
	val = REG_DUMP_READ_REGISTER(0x6f28c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_input_sel_reg_1                              |  0x%08X  |  ""TM input selection for counter 1""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_input_sel_reg_1_type */
	/* skip, unused field unused_tm_trace_input_sel_reg_1 (tm_trace_input_sel_reg_1) */
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_1.SrcSel                        |        0x%02X  |  [RW][07:00]""Select input / output""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_1.RoutSel                       |         0x%01X  |  [RW][09:08]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_1.SensSel                       |         0x%01X  |  [RW][11:10]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 10, 11));
	val = REG_DUMP_READ_REGISTER(0x6f288);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_input_sel_reg_0                              |  0x%08X  |  ""TM input selection for counter 0""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_input_sel_reg_0_type */
	/* skip, unused field unused_tm_trace_input_sel_reg_0 (tm_trace_input_sel_reg_0) */
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_0.SrcSel                        |        0x%02X  |  [RW][07:00]""Select input / output""\n", FIELD_VALUE(val, 0, 7));
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_0.RoutSel                       |         0x%01X  |  [RW][09:08]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 8, 9));
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_0.SensSel                       |         0x%01X  |  [RW][11:10]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 10, 11));
	val = REG_DUMP_READ_REGISTER(0x6f284);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_value_reg_7                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_value_reg_7_type */
	REG_DUMP_PRINT_1("   -tm_value_reg_7.tm_value_reg_7                          |  0x%08X  |  [RO][31:00]""TM current value of counter 7""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x6f280);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_value_reg_6                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_value_reg_6_type */
	REG_DUMP_PRINT_1("   -tm_value_reg_6.tm_value_reg_6                          |  0x%08X  |  [RO][31:00]""TM current value of counter 6""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x6f27c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_value_reg_5                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_value_reg_5_type */
	REG_DUMP_PRINT_1("   -tm_value_reg_5.tm_value_reg_5                          |  0x%08X  |  [RO][31:00]""TM current value of counter 5""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x6f278);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_value_reg_4                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_value_reg_4_type */
	REG_DUMP_PRINT_1("   -tm_value_reg_4.tm_value_reg_4                          |  0x%08X  |  [RO][31:00]""TM current value of counter 4""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x6f274);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_value_reg_3                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_value_reg_3_type */
	REG_DUMP_PRINT_1("   -tm_value_reg_3.tm_value_reg_3                          |  0x%08X  |  [RO][31:00]""TM current value of counter 3""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x6f270);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_value_reg_2                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_value_reg_2_type */
	REG_DUMP_PRINT_1("   -tm_value_reg_2.tm_value_reg_2                          |  0x%08X  |  [RO][31:00]""TM current value of counter 2""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x6f26c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_value_reg_1                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_value_reg_1_type */
	REG_DUMP_PRINT_1("   -tm_value_reg_1.tm_value_reg_1                          |  0x%08X  |  [RO][31:00]""TM current value of counter 1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x6f268);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_value_reg_0                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_value_reg_0_type */
	REG_DUMP_PRINT_1("   -tm_value_reg_0.tm_value_reg_0                          |  0x%08X  |  [RO][31:00]""TM current value of counter 0""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x6f264);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_enable_reg_7                                       |  0x%08X  |  ""TM counter 7 enable""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_enable_reg_7_type */
	/* skip, unused field unused_tm_enable_reg_7 (tm_enable_reg_7) */
	REG_DUMP_PRINT_1("   -tm_enable_reg_7.Enable                                 |         0x%01X  |  [RW][00:00]""When 0 counter is enabled, when 1 counter is enabled""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -tm_enable_reg_7.Halt                                   |         0x%01X  |  [RW][01:01]""When 0 counter will wrap around, when 1 counter will halt""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -tm_enable_reg_7.Reset_on_match                         |         0x%01X  |  [RW][02:02]""When 0 counter is not modified, when 1 counter reset on match""\n", FIELD_VALUE(val, 2, 2));
	val = REG_DUMP_READ_REGISTER(0x6f260);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_enable_reg_6                                       |  0x%08X  |  ""TM counter 6 enable""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_enable_reg_6_type */
	/* skip, unused field unused_tm_enable_reg_6 (tm_enable_reg_6) */
	REG_DUMP_PRINT_1("   -tm_enable_reg_6.Enable                                 |         0x%01X  |  [RW][00:00]""When 0 counter is enabled, when 1 counter is enabled""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -tm_enable_reg_6.Halt                                   |         0x%01X  |  [RW][01:01]""When 0 counter will wrap around, when 1 counter will halt""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -tm_enable_reg_6.Reset_on_match                         |         0x%01X  |  [RW][02:02]""When 0 counter is not modified, when 1 counter reset on match""\n", FIELD_VALUE(val, 2, 2));
	val = REG_DUMP_READ_REGISTER(0x6f25c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_enable_reg_5                                       |  0x%08X  |  ""TM counter 5 enable""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_enable_reg_5_type */
	/* skip, unused field unused_tm_enable_reg_5 (tm_enable_reg_5) */
	REG_DUMP_PRINT_1("   -tm_enable_reg_5.Enable                                 |         0x%01X  |  [RW][00:00]""When 0 counter is enabled, when 1 counter is enabled""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -tm_enable_reg_5.Halt                                   |         0x%01X  |  [RW][01:01]""When 0 counter will wrap around, when 1 counter will halt""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -tm_enable_reg_5.Reset_on_match                         |         0x%01X  |  [RW][02:02]""When 0 counter is not modified, when 1 counter reset on match""\n", FIELD_VALUE(val, 2, 2));
	val = REG_DUMP_READ_REGISTER(0x6f258);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_enable_reg_4                                       |  0x%08X  |  ""TM counter 4 enable""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_enable_reg_4_type */
	/* skip, unused field unused_tm_enable_reg_4 (tm_enable_reg_4) */
	REG_DUMP_PRINT_1("   -tm_enable_reg_4.Enable                                 |         0x%01X  |  [RW][00:00]""When 0 counter is enabled, when 1 counter is enabled""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -tm_enable_reg_4.Halt                                   |         0x%01X  |  [RW][01:01]""When 0 counter will wrap around, when 1 counter will halt""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -tm_enable_reg_4.Reset_on_match                         |         0x%01X  |  [RW][02:02]""When 0 counter is not modified, when 1 counter reset on match""\n", FIELD_VALUE(val, 2, 2));
	val = REG_DUMP_READ_REGISTER(0x6f254);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_enable_reg_3                                       |  0x%08X  |  ""TM counter 3 enable""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_enable_reg_3_type */
	/* skip, unused field unused_tm_enable_reg_3 (tm_enable_reg_3) */
	REG_DUMP_PRINT_1("   -tm_enable_reg_3.Enable                                 |         0x%01X  |  [RW][00:00]""When 0 counter is enabled, when 1 counter is enabled""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -tm_enable_reg_3.Halt                                   |         0x%01X  |  [RW][01:01]""When 0 counter will wrap around, when 1 counter will halt""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -tm_enable_reg_3.Reset_on_match                         |         0x%01X  |  [RW][02:02]""When 0 counter is not modified, when 1 counter reset on match""\n", FIELD_VALUE(val, 2, 2));
	val = REG_DUMP_READ_REGISTER(0x6f250);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_enable_reg_2                                       |  0x%08X  |  ""TM counter 2 enable""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_enable_reg_2_type */
	/* skip, unused field unused_tm_enable_reg_2 (tm_enable_reg_2) */
	REG_DUMP_PRINT_1("   -tm_enable_reg_2.Enable                                 |         0x%01X  |  [RW][00:00]""When 0 counter is enabled, when 1 counter is enabled""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -tm_enable_reg_2.Halt                                   |         0x%01X  |  [RW][01:01]""When 0 counter will wrap around, when 1 counter will halt""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -tm_enable_reg_2.Reset_on_match                         |         0x%01X  |  [RW][02:02]""When 0 counter is not modified, when 1 counter reset on match""\n", FIELD_VALUE(val, 2, 2));
	val = REG_DUMP_READ_REGISTER(0x6f24c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_enable_reg_1                                       |  0x%08X  |  ""TM counter 1 enable""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_enable_reg_1_type */
	/* skip, unused field unused_tm_enable_reg_1 (tm_enable_reg_1) */
	REG_DUMP_PRINT_1("   -tm_enable_reg_1.Enable                                 |         0x%01X  |  [RW][00:00]""When 0 counter is enabled, when 1 counter is enabled""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -tm_enable_reg_1.Halt                                   |         0x%01X  |  [RW][01:01]""When 0 counter will wrap around, when 1 counter will halt""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -tm_enable_reg_1.Reset_on_match                         |         0x%01X  |  [RW][02:02]""When 0 counter is not modified, when 1 counter reset on match""\n", FIELD_VALUE(val, 2, 2));
	val = REG_DUMP_READ_REGISTER(0x6f248);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_enable_reg_0                                       |  0x%08X  |  ""TM counter 0 enable""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_enable_reg_0_type */
	/* skip, unused field unused_tm_enable_reg_0 (tm_enable_reg_0) */
	REG_DUMP_PRINT_1("   -tm_enable_reg_0.Enable                                 |         0x%01X  |  [RW][00:00]""When 0 counter is enabled, when 1 counter is enabled""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -tm_enable_reg_0.Halt                                   |         0x%01X  |  [RW][01:01]""When 0 counter will wrap around, when 1 counter will halt""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -tm_enable_reg_0.Reset_on_match                         |         0x%01X  |  [RW][02:02]""When 0 counter is not modified, when 1 counter reset on match""\n", FIELD_VALUE(val, 2, 2));
	val = REG_DUMP_READ_REGISTER(0x6f244);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_lost_packets_reg                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_lost_packets_reg_type */
	/* skip, unused field unused_tm_lost_packets_reg (tm_lost_packets_reg) */
	REG_DUMP_PRINT_1("   -tm_lost_packets_reg.tm_lost_packets_reg                |      0x%04X  |  [RO][15:00]""Tracks number of lost packets in acase of lossy tracing.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x6f23c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_enable_ddr_reg_5                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_enable_ddr_reg_5_type */
	/* skip, unused field unused_tm_trace_enable_ddr_reg_5 (tm_trace_enable_ddr_reg_5) */
	REG_DUMP_PRINT_1("   -tm_trace_enable_ddr_reg_5.tm_trace_enable_ddr_reg_5    |    0x%06X  |  [RW][23:00]""Individual trace enable for tracing to DDR for port 5.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6f238);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_enable_ddr_reg_4                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_enable_ddr_reg_4_type */
	/* skip, unused field unused_tm_trace_enable_ddr_reg_4 (tm_trace_enable_ddr_reg_4) */
	REG_DUMP_PRINT_1("   -tm_trace_enable_ddr_reg_4.tm_trace_enable_ddr_reg_4    |    0x%06X  |  [RW][23:00]""Individual trace enable for tracing to DDR for port 4.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6f234);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_enable_ddr_reg_3                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_enable_ddr_reg_3_type */
	/* skip, unused field unused_tm_trace_enable_ddr_reg_3 (tm_trace_enable_ddr_reg_3) */
	REG_DUMP_PRINT_1("   -tm_trace_enable_ddr_reg_3.tm_trace_enable_ddr_reg_3    |    0x%06X  |  [RW][23:00]""Individual trace enable for tracing to DDR for port 3.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6f230);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_enable_ddr_reg_2                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_enable_ddr_reg_2_type */
	/* skip, unused field unused_tm_trace_enable_ddr_reg_2 (tm_trace_enable_ddr_reg_2) */
	REG_DUMP_PRINT_1("   -tm_trace_enable_ddr_reg_2.tm_trace_enable_ddr_reg_2    |    0x%06X  |  [RW][23:00]""Individual trace enable for tracing to DDR for port 2.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6f22c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_enable_ddr_reg_1                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_enable_ddr_reg_1_type */
	/* skip, unused field unused_tm_trace_enable_ddr_reg_1 (tm_trace_enable_ddr_reg_1) */
	REG_DUMP_PRINT_1("   -tm_trace_enable_ddr_reg_1.tm_trace_enable_ddr_reg_1    |    0x%06X  |  [RW][23:00]""Individual trace enable for tracing to DDR for port 1.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6f228);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_enable_ddr_reg_0                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_enable_ddr_reg_0_type */
	/* skip, unused field unused_tm_trace_enable_ddr_reg_0 (tm_trace_enable_ddr_reg_0) */
	REG_DUMP_PRINT_1("   -tm_trace_enable_ddr_reg_0.tm_trace_enable_ddr_reg_0    |    0x%06X  |  [RW][23:00]""Individual trace enable for tracing to DDR for port 0.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6f224);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_enable_npk_reg_5                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_enable_npk_reg_5_type */
	/* skip, unused field unused_tm_trace_enable_npk_reg_5 (tm_trace_enable_npk_reg_5) */
	REG_DUMP_PRINT_1("   -tm_trace_enable_npk_reg_5.tm_trace_enable_npk_reg_5    |    0x%06X  |  [RW][23:00]""Individual trace enable for tracing to NPK for port 5.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6f220);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_enable_npk_reg_4                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_enable_npk_reg_4_type */
	/* skip, unused field unused_tm_trace_enable_npk_reg_4 (tm_trace_enable_npk_reg_4) */
	REG_DUMP_PRINT_1("   -tm_trace_enable_npk_reg_4.tm_trace_enable_npk_reg_4    |    0x%06X  |  [RW][23:00]""Individual trace enable for tracing to NPK for port 4.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6f21c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_enable_npk_reg_3                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_enable_npk_reg_3_type */
	/* skip, unused field unused_tm_trace_enable_npk_reg_3 (tm_trace_enable_npk_reg_3) */
	REG_DUMP_PRINT_1("   -tm_trace_enable_npk_reg_3.tm_trace_enable_npk_reg_3    |    0x%06X  |  [RW][23:00]""Individual trace enable for tracing to NPK for port 3.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6f218);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_enable_npk_reg_2                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_enable_npk_reg_2_type */
	/* skip, unused field unused_tm_trace_enable_npk_reg_2 (tm_trace_enable_npk_reg_2) */
	REG_DUMP_PRINT_1("   -tm_trace_enable_npk_reg_2.tm_trace_enable_npk_reg_2    |    0x%06X  |  [RW][23:00]""Individual trace enable for tracing to NPK for port 2.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6f214);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_enable_npk_reg_1                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_enable_npk_reg_1_type */
	/* skip, unused field unused_tm_trace_enable_npk_reg_1 (tm_trace_enable_npk_reg_1) */
	REG_DUMP_PRINT_1("   -tm_trace_enable_npk_reg_1.tm_trace_enable_npk_reg_1    |    0x%06X  |  [RW][23:00]""Individual trace enable for tracing to NPK for port 1.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6f210);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_enable_npk_reg_0                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_enable_npk_reg_0_type */
	/* skip, unused field unused_tm_trace_enable_npk_reg_0 (tm_trace_enable_npk_reg_0) */
	REG_DUMP_PRINT_1("   -tm_trace_enable_npk_reg_0.tm_trace_enable_npk_reg_0    |    0x%06X  |  [RW][23:00]""Individual trace enable for tracing to NPK for port 0.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6f20c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_addr_reg                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_addr_reg_type */
	REG_DUMP_PRINT_1("   -tm_trace_addr_reg.tm_trace_addr_reg                    |  0x%08X  |  [RW][31:00]""Address to which all trace packet are sent.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x6f208);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_header_reg                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_trace_header_reg_type */
	/* skip, unused field unused_tm_trace_header_reg (tm_trace_header_reg) */
	REG_DUMP_PRINT_1("   -tm_trace_header_reg.tm_trace_header_reg                |        0x%02X  |  [RW][07:00]""SVEN header""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0x6f204);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_overall_enable_reg                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_tm_tm_overall_enable_reg_type */
	/* skip, unused field unused_tm_overall_enable_reg (tm_overall_enable_reg) */
	REG_DUMP_PRINT_1("   -tm_overall_enable_reg.tm_overall_enable_reg            |         0x%01X  |  [RW][00:00]""Overall enable all the counters""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x67b34);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_enable_reg_7                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_irq_enable_reg_7_type */
	/* skip, unused field unused_tm_irq_enable_reg_7 (tm_irq_enable_reg_7) */
	REG_DUMP_PRINT_1("   -tm_irq_enable_reg_7.tm_irq_enable_reg_7                |         0x%01X  |  [RW][00:00]""Enable trigger 7 and sticky bits""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x67b30);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_enable_reg_6                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_irq_enable_reg_6_type */
	/* skip, unused field unused_tm_irq_enable_reg_6 (tm_irq_enable_reg_6) */
	REG_DUMP_PRINT_1("   -tm_irq_enable_reg_6.tm_irq_enable_reg_6                |         0x%01X  |  [RW][00:00]""Enable trigger 6 and sticky bits""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x67b2c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_enable_reg_5                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_irq_enable_reg_5_type */
	/* skip, unused field unused_tm_irq_enable_reg_5 (tm_irq_enable_reg_5) */
	REG_DUMP_PRINT_1("   -tm_irq_enable_reg_5.tm_irq_enable_reg_5                |         0x%01X  |  [RW][00:00]""Enable trigger 5 and sticky bits""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x67b28);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_enable_reg_4                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_irq_enable_reg_4_type */
	/* skip, unused field unused_tm_irq_enable_reg_4 (tm_irq_enable_reg_4) */
	REG_DUMP_PRINT_1("   -tm_irq_enable_reg_4.tm_irq_enable_reg_4                |         0x%01X  |  [RW][00:00]""Enable trigger 4 and sticky bits""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x67b24);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_enable_reg_3                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_irq_enable_reg_3_type */
	/* skip, unused field unused_tm_irq_enable_reg_3 (tm_irq_enable_reg_3) */
	REG_DUMP_PRINT_1("   -tm_irq_enable_reg_3.tm_irq_enable_reg_3                |         0x%01X  |  [RW][00:00]""Enable trigger 3 and sticky bits""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x67b20);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_enable_reg_2                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_irq_enable_reg_2_type */
	/* skip, unused field unused_tm_irq_enable_reg_2 (tm_irq_enable_reg_2) */
	REG_DUMP_PRINT_1("   -tm_irq_enable_reg_2.tm_irq_enable_reg_2                |         0x%01X  |  [RW][00:00]""Enable trigger 2 and sticky bits""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x67b1c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_enable_reg_1                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_irq_enable_reg_1_type */
	/* skip, unused field unused_tm_irq_enable_reg_1 (tm_irq_enable_reg_1) */
	REG_DUMP_PRINT_1("   -tm_irq_enable_reg_1.tm_irq_enable_reg_1                |         0x%01X  |  [RW][00:00]""Enable trigger 1 and sticky bits""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x67b18);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_enable_reg_0                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_irq_enable_reg_0_type */
	/* skip, unused field unused_tm_irq_enable_reg_0 (tm_irq_enable_reg_0) */
	REG_DUMP_PRINT_1("   -tm_irq_enable_reg_0.tm_irq_enable_reg_0                |         0x%01X  |  [RW][00:00]""Enable trigger 0 and sticky bits""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x67b14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_timer_sel_reg_7                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_irq_timer_sel_reg_7_type */
	/* skip, unused field unused_tm_irq_timer_sel_reg_7 (tm_irq_timer_sel_reg_7) */
	REG_DUMP_PRINT_1("   -tm_irq_timer_sel_reg_7.tm_irq_timer_sel_reg_7          |         0x%01X  |  [RW][02:00]""Selects which counter to be used for matching for trigger 7""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x67b10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_timer_sel_reg_6                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_irq_timer_sel_reg_6_type */
	/* skip, unused field unused_tm_irq_timer_sel_reg_6 (tm_irq_timer_sel_reg_6) */
	REG_DUMP_PRINT_1("   -tm_irq_timer_sel_reg_6.tm_irq_timer_sel_reg_6          |         0x%01X  |  [RW][02:00]""Selects which counter to be used for matching for trigger 6""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x67b0c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_timer_sel_reg_5                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_irq_timer_sel_reg_5_type */
	/* skip, unused field unused_tm_irq_timer_sel_reg_5 (tm_irq_timer_sel_reg_5) */
	REG_DUMP_PRINT_1("   -tm_irq_timer_sel_reg_5.tm_irq_timer_sel_reg_5          |         0x%01X  |  [RW][02:00]""Selects which counter to be used for matching for trigger 5""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x67b08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_timer_sel_reg_4                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_irq_timer_sel_reg_4_type */
	/* skip, unused field unused_tm_irq_timer_sel_reg_4 (tm_irq_timer_sel_reg_4) */
	REG_DUMP_PRINT_1("   -tm_irq_timer_sel_reg_4.tm_irq_timer_sel_reg_4          |         0x%01X  |  [RW][02:00]""Selects which counter to be used for matching for trigger 4""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x67b04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_timer_sel_reg_3                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_irq_timer_sel_reg_3_type */
	/* skip, unused field unused_tm_irq_timer_sel_reg_3 (tm_irq_timer_sel_reg_3) */
	REG_DUMP_PRINT_1("   -tm_irq_timer_sel_reg_3.tm_irq_timer_sel_reg_3          |         0x%01X  |  [RW][02:00]""Selects which counter to be used for matching for trigger 3""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x67b00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_timer_sel_reg_2                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_irq_timer_sel_reg_2_type */
	/* skip, unused field unused_tm_irq_timer_sel_reg_2 (tm_irq_timer_sel_reg_2) */
	REG_DUMP_PRINT_1("   -tm_irq_timer_sel_reg_2.tm_irq_timer_sel_reg_2          |         0x%01X  |  [RW][02:00]""Selects which counter to be used for matching for trigger 2""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x67afc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_timer_sel_reg_1                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_irq_timer_sel_reg_1_type */
	/* skip, unused field unused_tm_irq_timer_sel_reg_1 (tm_irq_timer_sel_reg_1) */
	REG_DUMP_PRINT_1("   -tm_irq_timer_sel_reg_1.tm_irq_timer_sel_reg_1          |         0x%01X  |  [RW][02:00]""Selects which counter to be used for matching for trigger 1""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x67af8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_timer_sel_reg_0                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_irq_timer_sel_reg_0_type */
	/* skip, unused field unused_tm_irq_timer_sel_reg_0 (tm_irq_timer_sel_reg_0) */
	REG_DUMP_PRINT_1("   -tm_irq_timer_sel_reg_0.tm_irq_timer_sel_reg_0          |         0x%01X  |  [RW][02:00]""Selects which counter to be used for matching for trigger 0""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x67af4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_trigger_value_reg_7                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_irq_trigger_value_reg_7_type */
	REG_DUMP_PRINT_1("   -tm_irq_trigger_value_reg_7.tm_irq_trigger_value_reg_7  |  0x%08X  |  [RW][31:00]""The reference value that is used for comparisson and trigger 7 generation""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x67af0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_trigger_value_reg_6                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_irq_trigger_value_reg_6_type */
	REG_DUMP_PRINT_1("   -tm_irq_trigger_value_reg_6.tm_irq_trigger_value_reg_6  |  0x%08X  |  [RW][31:00]""The reference value that is used for comparisson and trigger 6 generation""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x67aec);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_trigger_value_reg_5                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_irq_trigger_value_reg_5_type */
	REG_DUMP_PRINT_1("   -tm_irq_trigger_value_reg_5.tm_irq_trigger_value_reg_5  |  0x%08X  |  [RW][31:00]""The reference value that is used for comparisson and trigger 5 generation""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x67ae8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_trigger_value_reg_4                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_irq_trigger_value_reg_4_type */
	REG_DUMP_PRINT_1("   -tm_irq_trigger_value_reg_4.tm_irq_trigger_value_reg_4  |  0x%08X  |  [RW][31:00]""The reference value that is used for comparisson and trigger 4 generation""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x67ae4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_trigger_value_reg_3                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_irq_trigger_value_reg_3_type */
	REG_DUMP_PRINT_1("   -tm_irq_trigger_value_reg_3.tm_irq_trigger_value_reg_3  |  0x%08X  |  [RW][31:00]""The reference value that is used for comparisson and trigger 3 generation""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x67ae0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_trigger_value_reg_2                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_irq_trigger_value_reg_2_type */
	REG_DUMP_PRINT_1("   -tm_irq_trigger_value_reg_2.tm_irq_trigger_value_reg_2  |  0x%08X  |  [RW][31:00]""The reference value that is used for comparisson and trigger 2 generation""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x67adc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_trigger_value_reg_1                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_irq_trigger_value_reg_1_type */
	REG_DUMP_PRINT_1("   -tm_irq_trigger_value_reg_1.tm_irq_trigger_value_reg_1  |  0x%08X  |  [RW][31:00]""The reference value that is used for comparisson and trigger 1 generation""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x67ad8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_irq_trigger_value_reg_0                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_irq_trigger_value_reg_0_type */
	REG_DUMP_PRINT_1("   -tm_irq_trigger_value_reg_0.tm_irq_trigger_value_reg_0  |  0x%08X  |  [RW][31:00]""The reference value that is used for comparisson and trigger 0 generation""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x67ad4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_stop_sel_reg_7                               |  0x%08X  |  ""TM stop selection for counter 7""\n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_stop_sel_reg_7_type */
	/* skip, unused field unused_tm_trace_stop_sel_reg_7 (tm_trace_stop_sel_reg_7) */
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_7.SrcSel                         |        0x%02X  |  [RW][06:00]""Select input / output""\n", FIELD_VALUE(val, 0, 6));
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_7.RoutSel                        |         0x%01X  |  [RW][08:07]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 7, 8));
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_7.SensSel                        |         0x%01X  |  [RW][10:09]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 9, 10));
	val = REG_DUMP_READ_REGISTER(0x67ad0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_stop_sel_reg_6                               |  0x%08X  |  ""TM stop selection for counter 6""\n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_stop_sel_reg_6_type */
	/* skip, unused field unused_tm_trace_stop_sel_reg_6 (tm_trace_stop_sel_reg_6) */
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_6.SrcSel                         |        0x%02X  |  [RW][06:00]""Select input / output""\n", FIELD_VALUE(val, 0, 6));
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_6.RoutSel                        |         0x%01X  |  [RW][08:07]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 7, 8));
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_6.SensSel                        |         0x%01X  |  [RW][10:09]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 9, 10));
	val = REG_DUMP_READ_REGISTER(0x67acc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_stop_sel_reg_5                               |  0x%08X  |  ""TM stop selection for counter 5""\n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_stop_sel_reg_5_type */
	/* skip, unused field unused_tm_trace_stop_sel_reg_5 (tm_trace_stop_sel_reg_5) */
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_5.SrcSel                         |        0x%02X  |  [RW][06:00]""Select input / output""\n", FIELD_VALUE(val, 0, 6));
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_5.RoutSel                        |         0x%01X  |  [RW][08:07]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 7, 8));
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_5.SensSel                        |         0x%01X  |  [RW][10:09]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 9, 10));
	val = REG_DUMP_READ_REGISTER(0x67ac8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_stop_sel_reg_4                               |  0x%08X  |  ""TM stop selection for counter 4""\n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_stop_sel_reg_4_type */
	/* skip, unused field unused_tm_trace_stop_sel_reg_4 (tm_trace_stop_sel_reg_4) */
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_4.SrcSel                         |        0x%02X  |  [RW][06:00]""Select input / output""\n", FIELD_VALUE(val, 0, 6));
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_4.RoutSel                        |         0x%01X  |  [RW][08:07]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 7, 8));
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_4.SensSel                        |         0x%01X  |  [RW][10:09]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 9, 10));
	val = REG_DUMP_READ_REGISTER(0x67ac4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_stop_sel_reg_3                               |  0x%08X  |  ""TM stop selection for counter 3""\n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_stop_sel_reg_3_type */
	/* skip, unused field unused_tm_trace_stop_sel_reg_3 (tm_trace_stop_sel_reg_3) */
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_3.SrcSel                         |        0x%02X  |  [RW][06:00]""Select input / output""\n", FIELD_VALUE(val, 0, 6));
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_3.RoutSel                        |         0x%01X  |  [RW][08:07]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 7, 8));
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_3.SensSel                        |         0x%01X  |  [RW][10:09]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 9, 10));
	val = REG_DUMP_READ_REGISTER(0x67ac0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_stop_sel_reg_2                               |  0x%08X  |  ""TM stop selection for counter 2""\n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_stop_sel_reg_2_type */
	/* skip, unused field unused_tm_trace_stop_sel_reg_2 (tm_trace_stop_sel_reg_2) */
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_2.SrcSel                         |        0x%02X  |  [RW][06:00]""Select input / output""\n", FIELD_VALUE(val, 0, 6));
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_2.RoutSel                        |         0x%01X  |  [RW][08:07]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 7, 8));
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_2.SensSel                        |         0x%01X  |  [RW][10:09]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 9, 10));
	val = REG_DUMP_READ_REGISTER(0x67abc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_stop_sel_reg_1                               |  0x%08X  |  ""TM stop selection for counter 1""\n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_stop_sel_reg_1_type */
	/* skip, unused field unused_tm_trace_stop_sel_reg_1 (tm_trace_stop_sel_reg_1) */
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_1.SrcSel                         |        0x%02X  |  [RW][06:00]""Select input / output""\n", FIELD_VALUE(val, 0, 6));
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_1.RoutSel                        |         0x%01X  |  [RW][08:07]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 7, 8));
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_1.SensSel                        |         0x%01X  |  [RW][10:09]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 9, 10));
	val = REG_DUMP_READ_REGISTER(0x67ab8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_stop_sel_reg_0                               |  0x%08X  |  ""TM stop selection for counter 0""\n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_stop_sel_reg_0_type */
	/* skip, unused field unused_tm_trace_stop_sel_reg_0 (tm_trace_stop_sel_reg_0) */
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_0.SrcSel                         |        0x%02X  |  [RW][06:00]""Select input / output""\n", FIELD_VALUE(val, 0, 6));
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_0.RoutSel                        |         0x%01X  |  [RW][08:07]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 7, 8));
	REG_DUMP_PRINT_1("   -tm_trace_stop_sel_reg_0.SensSel                        |         0x%01X  |  [RW][10:09]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 9, 10));
	val = REG_DUMP_READ_REGISTER(0x67ab4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_start_sel_reg_7                              |  0x%08X  |  ""TM start selection for counter 7""\n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_start_sel_reg_7_type */
	/* skip, unused field unused_tm_trace_start_sel_reg_7 (tm_trace_start_sel_reg_7) */
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_7.SrcSel                        |        0x%02X  |  [RW][06:00]""Select input / output""\n", FIELD_VALUE(val, 0, 6));
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_7.RoutSel                       |         0x%01X  |  [RW][08:07]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 7, 8));
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_7.SensSel                       |         0x%01X  |  [RW][10:09]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 9, 10));
	val = REG_DUMP_READ_REGISTER(0x67ab0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_start_sel_reg_6                              |  0x%08X  |  ""TM start selection for counter 6""\n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_start_sel_reg_6_type */
	/* skip, unused field unused_tm_trace_start_sel_reg_6 (tm_trace_start_sel_reg_6) */
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_6.SrcSel                        |        0x%02X  |  [RW][06:00]""Select input / output""\n", FIELD_VALUE(val, 0, 6));
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_6.RoutSel                       |         0x%01X  |  [RW][08:07]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 7, 8));
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_6.SensSel                       |         0x%01X  |  [RW][10:09]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 9, 10));
	val = REG_DUMP_READ_REGISTER(0x67aac);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_start_sel_reg_5                              |  0x%08X  |  ""TM start selection for counter 5""\n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_start_sel_reg_5_type */
	/* skip, unused field unused_tm_trace_start_sel_reg_5 (tm_trace_start_sel_reg_5) */
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_5.SrcSel                        |        0x%02X  |  [RW][06:00]""Select input / output""\n", FIELD_VALUE(val, 0, 6));
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_5.RoutSel                       |         0x%01X  |  [RW][08:07]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 7, 8));
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_5.SensSel                       |         0x%01X  |  [RW][10:09]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 9, 10));
	val = REG_DUMP_READ_REGISTER(0x67aa8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_start_sel_reg_4                              |  0x%08X  |  ""TM start selection for counter 4""\n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_start_sel_reg_4_type */
	/* skip, unused field unused_tm_trace_start_sel_reg_4 (tm_trace_start_sel_reg_4) */
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_4.SrcSel                        |        0x%02X  |  [RW][06:00]""Select input / output""\n", FIELD_VALUE(val, 0, 6));
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_4.RoutSel                       |         0x%01X  |  [RW][08:07]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 7, 8));
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_4.SensSel                       |         0x%01X  |  [RW][10:09]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 9, 10));
	val = REG_DUMP_READ_REGISTER(0x67aa4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_start_sel_reg_3                              |  0x%08X  |  ""TM start selection for counter 3""\n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_start_sel_reg_3_type */
	/* skip, unused field unused_tm_trace_start_sel_reg_3 (tm_trace_start_sel_reg_3) */
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_3.SrcSel                        |        0x%02X  |  [RW][06:00]""Select input / output""\n", FIELD_VALUE(val, 0, 6));
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_3.RoutSel                       |         0x%01X  |  [RW][08:07]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 7, 8));
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_3.SensSel                       |         0x%01X  |  [RW][10:09]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 9, 10));
	val = REG_DUMP_READ_REGISTER(0x67aa0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_start_sel_reg_2                              |  0x%08X  |  ""TM start selection for counter 2""\n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_start_sel_reg_2_type */
	/* skip, unused field unused_tm_trace_start_sel_reg_2 (tm_trace_start_sel_reg_2) */
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_2.SrcSel                        |        0x%02X  |  [RW][06:00]""Select input / output""\n", FIELD_VALUE(val, 0, 6));
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_2.RoutSel                       |         0x%01X  |  [RW][08:07]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 7, 8));
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_2.SensSel                       |         0x%01X  |  [RW][10:09]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 9, 10));
	val = REG_DUMP_READ_REGISTER(0x67a9c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_start_sel_reg_1                              |  0x%08X  |  ""TM start selection for counter 1""\n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_start_sel_reg_1_type */
	/* skip, unused field unused_tm_trace_start_sel_reg_1 (tm_trace_start_sel_reg_1) */
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_1.SrcSel                        |        0x%02X  |  [RW][06:00]""Select input / output""\n", FIELD_VALUE(val, 0, 6));
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_1.RoutSel                       |         0x%01X  |  [RW][08:07]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 7, 8));
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_1.SensSel                       |         0x%01X  |  [RW][10:09]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 9, 10));
	val = REG_DUMP_READ_REGISTER(0x67a98);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_start_sel_reg_0                              |  0x%08X  |  ""TM start selection for counter 0""\n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_start_sel_reg_0_type */
	/* skip, unused field unused_tm_trace_start_sel_reg_0 (tm_trace_start_sel_reg_0) */
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_0.SrcSel                        |        0x%02X  |  [RW][06:00]""Select input / output""\n", FIELD_VALUE(val, 0, 6));
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_0.RoutSel                       |         0x%01X  |  [RW][08:07]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 7, 8));
	REG_DUMP_PRINT_1("   -tm_trace_start_sel_reg_0.SensSel                       |         0x%01X  |  [RW][10:09]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 9, 10));
	val = REG_DUMP_READ_REGISTER(0x67a94);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_input_sel_reg_7                              |  0x%08X  |  ""TM input selection for counter 7""\n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_input_sel_reg_7_type */
	/* skip, unused field unused_tm_trace_input_sel_reg_7 (tm_trace_input_sel_reg_7) */
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_7.SrcSel                        |        0x%02X  |  [RW][06:00]""Select input / output""\n", FIELD_VALUE(val, 0, 6));
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_7.RoutSel                       |         0x%01X  |  [RW][08:07]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 7, 8));
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_7.SensSel                       |         0x%01X  |  [RW][10:09]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 9, 10));
	val = REG_DUMP_READ_REGISTER(0x67a90);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_input_sel_reg_6                              |  0x%08X  |  ""TM input selection for counter 6""\n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_input_sel_reg_6_type */
	/* skip, unused field unused_tm_trace_input_sel_reg_6 (tm_trace_input_sel_reg_6) */
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_6.SrcSel                        |        0x%02X  |  [RW][06:00]""Select input / output""\n", FIELD_VALUE(val, 0, 6));
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_6.RoutSel                       |         0x%01X  |  [RW][08:07]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 7, 8));
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_6.SensSel                       |         0x%01X  |  [RW][10:09]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 9, 10));
	val = REG_DUMP_READ_REGISTER(0x67a8c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_input_sel_reg_5                              |  0x%08X  |  ""TM input selection for counter 5""\n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_input_sel_reg_5_type */
	/* skip, unused field unused_tm_trace_input_sel_reg_5 (tm_trace_input_sel_reg_5) */
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_5.SrcSel                        |        0x%02X  |  [RW][06:00]""Select input / output""\n", FIELD_VALUE(val, 0, 6));
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_5.RoutSel                       |         0x%01X  |  [RW][08:07]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 7, 8));
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_5.SensSel                       |         0x%01X  |  [RW][10:09]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 9, 10));
	val = REG_DUMP_READ_REGISTER(0x67a88);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_input_sel_reg_4                              |  0x%08X  |  ""TM input selection for counter 4""\n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_input_sel_reg_4_type */
	/* skip, unused field unused_tm_trace_input_sel_reg_4 (tm_trace_input_sel_reg_4) */
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_4.SrcSel                        |        0x%02X  |  [RW][06:00]""Select input / output""\n", FIELD_VALUE(val, 0, 6));
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_4.RoutSel                       |         0x%01X  |  [RW][08:07]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 7, 8));
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_4.SensSel                       |         0x%01X  |  [RW][10:09]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 9, 10));
	val = REG_DUMP_READ_REGISTER(0x67a84);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_input_sel_reg_3                              |  0x%08X  |  ""TM input selection for counter 3""\n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_input_sel_reg_3_type */
	/* skip, unused field unused_tm_trace_input_sel_reg_3 (tm_trace_input_sel_reg_3) */
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_3.SrcSel                        |        0x%02X  |  [RW][06:00]""Select input / output""\n", FIELD_VALUE(val, 0, 6));
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_3.RoutSel                       |         0x%01X  |  [RW][08:07]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 7, 8));
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_3.SensSel                       |         0x%01X  |  [RW][10:09]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 9, 10));
	val = REG_DUMP_READ_REGISTER(0x67a80);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_input_sel_reg_2                              |  0x%08X  |  ""TM input selection for counter 2""\n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_input_sel_reg_2_type */
	/* skip, unused field unused_tm_trace_input_sel_reg_2 (tm_trace_input_sel_reg_2) */
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_2.SrcSel                        |        0x%02X  |  [RW][06:00]""Select input / output""\n", FIELD_VALUE(val, 0, 6));
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_2.RoutSel                       |         0x%01X  |  [RW][08:07]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 7, 8));
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_2.SensSel                       |         0x%01X  |  [RW][10:09]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 9, 10));
	val = REG_DUMP_READ_REGISTER(0x67a7c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_input_sel_reg_1                              |  0x%08X  |  ""TM input selection for counter 1""\n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_input_sel_reg_1_type */
	/* skip, unused field unused_tm_trace_input_sel_reg_1 (tm_trace_input_sel_reg_1) */
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_1.SrcSel                        |        0x%02X  |  [RW][06:00]""Select input / output""\n", FIELD_VALUE(val, 0, 6));
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_1.RoutSel                       |         0x%01X  |  [RW][08:07]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 7, 8));
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_1.SensSel                       |         0x%01X  |  [RW][10:09]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 9, 10));
	val = REG_DUMP_READ_REGISTER(0x67a78);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_input_sel_reg_0                              |  0x%08X  |  ""TM input selection for counter 0""\n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_input_sel_reg_0_type */
	/* skip, unused field unused_tm_trace_input_sel_reg_0 (tm_trace_input_sel_reg_0) */
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_0.SrcSel                        |        0x%02X  |  [RW][06:00]""Select input / output""\n", FIELD_VALUE(val, 0, 6));
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_0.RoutSel                       |         0x%01X  |  [RW][08:07]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 7, 8));
	REG_DUMP_PRINT_1("   -tm_trace_input_sel_reg_0.SensSel                       |         0x%01X  |  [RW][10:09]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 9, 10));
	val = REG_DUMP_READ_REGISTER(0x67a74);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_value_reg_7                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_value_reg_7_type */
	REG_DUMP_PRINT_1("   -tm_value_reg_7.tm_value_reg_7                          |  0x%08X  |  [RO][31:00]""TM current value of counter 7""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x67a70);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_value_reg_6                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_value_reg_6_type */
	REG_DUMP_PRINT_1("   -tm_value_reg_6.tm_value_reg_6                          |  0x%08X  |  [RO][31:00]""TM current value of counter 6""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x67a6c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_value_reg_5                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_value_reg_5_type */
	REG_DUMP_PRINT_1("   -tm_value_reg_5.tm_value_reg_5                          |  0x%08X  |  [RO][31:00]""TM current value of counter 5""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x67a68);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_value_reg_4                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_value_reg_4_type */
	REG_DUMP_PRINT_1("   -tm_value_reg_4.tm_value_reg_4                          |  0x%08X  |  [RO][31:00]""TM current value of counter 4""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x67a64);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_value_reg_3                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_value_reg_3_type */
	REG_DUMP_PRINT_1("   -tm_value_reg_3.tm_value_reg_3                          |  0x%08X  |  [RO][31:00]""TM current value of counter 3""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x67a60);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_value_reg_2                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_value_reg_2_type */
	REG_DUMP_PRINT_1("   -tm_value_reg_2.tm_value_reg_2                          |  0x%08X  |  [RO][31:00]""TM current value of counter 2""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x67a5c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_value_reg_1                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_value_reg_1_type */
	REG_DUMP_PRINT_1("   -tm_value_reg_1.tm_value_reg_1                          |  0x%08X  |  [RO][31:00]""TM current value of counter 1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x67a58);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_value_reg_0                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_value_reg_0_type */
	REG_DUMP_PRINT_1("   -tm_value_reg_0.tm_value_reg_0                          |  0x%08X  |  [RO][31:00]""TM current value of counter 0""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x67a54);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_enable_reg_7                                       |  0x%08X  |  ""TM counter 7 enable""\n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_enable_reg_7_type */
	/* skip, unused field unused_tm_enable_reg_7 (tm_enable_reg_7) */
	REG_DUMP_PRINT_1("   -tm_enable_reg_7.Enable                                 |         0x%01X  |  [RW][00:00]""When 0 counter is enabled, when 1 counter is enabled""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -tm_enable_reg_7.Halt                                   |         0x%01X  |  [RW][01:01]""When 0 counter will wrap around, when 1 counter will halt""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -tm_enable_reg_7.Reset_on_match                         |         0x%01X  |  [RW][02:02]""When 0 counter is not modified, when 1 counter reset on match""\n", FIELD_VALUE(val, 2, 2));
	val = REG_DUMP_READ_REGISTER(0x67a50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_enable_reg_6                                       |  0x%08X  |  ""TM counter 6 enable""\n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_enable_reg_6_type */
	/* skip, unused field unused_tm_enable_reg_6 (tm_enable_reg_6) */
	REG_DUMP_PRINT_1("   -tm_enable_reg_6.Enable                                 |         0x%01X  |  [RW][00:00]""When 0 counter is enabled, when 1 counter is enabled""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -tm_enable_reg_6.Halt                                   |         0x%01X  |  [RW][01:01]""When 0 counter will wrap around, when 1 counter will halt""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -tm_enable_reg_6.Reset_on_match                         |         0x%01X  |  [RW][02:02]""When 0 counter is not modified, when 1 counter reset on match""\n", FIELD_VALUE(val, 2, 2));
	val = REG_DUMP_READ_REGISTER(0x67a4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_enable_reg_5                                       |  0x%08X  |  ""TM counter 5 enable""\n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_enable_reg_5_type */
	/* skip, unused field unused_tm_enable_reg_5 (tm_enable_reg_5) */
	REG_DUMP_PRINT_1("   -tm_enable_reg_5.Enable                                 |         0x%01X  |  [RW][00:00]""When 0 counter is enabled, when 1 counter is enabled""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -tm_enable_reg_5.Halt                                   |         0x%01X  |  [RW][01:01]""When 0 counter will wrap around, when 1 counter will halt""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -tm_enable_reg_5.Reset_on_match                         |         0x%01X  |  [RW][02:02]""When 0 counter is not modified, when 1 counter reset on match""\n", FIELD_VALUE(val, 2, 2));
	val = REG_DUMP_READ_REGISTER(0x67a48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_enable_reg_4                                       |  0x%08X  |  ""TM counter 4 enable""\n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_enable_reg_4_type */
	/* skip, unused field unused_tm_enable_reg_4 (tm_enable_reg_4) */
	REG_DUMP_PRINT_1("   -tm_enable_reg_4.Enable                                 |         0x%01X  |  [RW][00:00]""When 0 counter is enabled, when 1 counter is enabled""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -tm_enable_reg_4.Halt                                   |         0x%01X  |  [RW][01:01]""When 0 counter will wrap around, when 1 counter will halt""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -tm_enable_reg_4.Reset_on_match                         |         0x%01X  |  [RW][02:02]""When 0 counter is not modified, when 1 counter reset on match""\n", FIELD_VALUE(val, 2, 2));
	val = REG_DUMP_READ_REGISTER(0x67a44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_enable_reg_3                                       |  0x%08X  |  ""TM counter 3 enable""\n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_enable_reg_3_type */
	/* skip, unused field unused_tm_enable_reg_3 (tm_enable_reg_3) */
	REG_DUMP_PRINT_1("   -tm_enable_reg_3.Enable                                 |         0x%01X  |  [RW][00:00]""When 0 counter is enabled, when 1 counter is enabled""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -tm_enable_reg_3.Halt                                   |         0x%01X  |  [RW][01:01]""When 0 counter will wrap around, when 1 counter will halt""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -tm_enable_reg_3.Reset_on_match                         |         0x%01X  |  [RW][02:02]""When 0 counter is not modified, when 1 counter reset on match""\n", FIELD_VALUE(val, 2, 2));
	val = REG_DUMP_READ_REGISTER(0x67a40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_enable_reg_2                                       |  0x%08X  |  ""TM counter 2 enable""\n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_enable_reg_2_type */
	/* skip, unused field unused_tm_enable_reg_2 (tm_enable_reg_2) */
	REG_DUMP_PRINT_1("   -tm_enable_reg_2.Enable                                 |         0x%01X  |  [RW][00:00]""When 0 counter is enabled, when 1 counter is enabled""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -tm_enable_reg_2.Halt                                   |         0x%01X  |  [RW][01:01]""When 0 counter will wrap around, when 1 counter will halt""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -tm_enable_reg_2.Reset_on_match                         |         0x%01X  |  [RW][02:02]""When 0 counter is not modified, when 1 counter reset on match""\n", FIELD_VALUE(val, 2, 2));
	val = REG_DUMP_READ_REGISTER(0x67a3c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_enable_reg_1                                       |  0x%08X  |  ""TM counter 1 enable""\n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_enable_reg_1_type */
	/* skip, unused field unused_tm_enable_reg_1 (tm_enable_reg_1) */
	REG_DUMP_PRINT_1("   -tm_enable_reg_1.Enable                                 |         0x%01X  |  [RW][00:00]""When 0 counter is enabled, when 1 counter is enabled""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -tm_enable_reg_1.Halt                                   |         0x%01X  |  [RW][01:01]""When 0 counter will wrap around, when 1 counter will halt""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -tm_enable_reg_1.Reset_on_match                         |         0x%01X  |  [RW][02:02]""When 0 counter is not modified, when 1 counter reset on match""\n", FIELD_VALUE(val, 2, 2));
	val = REG_DUMP_READ_REGISTER(0x67a38);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_enable_reg_0                                       |  0x%08X  |  ""TM counter 0 enable""\n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_enable_reg_0_type */
	/* skip, unused field unused_tm_enable_reg_0 (tm_enable_reg_0) */
	REG_DUMP_PRINT_1("   -tm_enable_reg_0.Enable                                 |         0x%01X  |  [RW][00:00]""When 0 counter is enabled, when 1 counter is enabled""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -tm_enable_reg_0.Halt                                   |         0x%01X  |  [RW][01:01]""When 0 counter will wrap around, when 1 counter will halt""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -tm_enable_reg_0.Reset_on_match                         |         0x%01X  |  [RW][02:02]""When 0 counter is not modified, when 1 counter reset on match""\n", FIELD_VALUE(val, 2, 2));
	val = REG_DUMP_READ_REGISTER(0x67a34);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_lost_packets_reg                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_lost_packets_reg_type */
	/* skip, unused field unused_tm_lost_packets_reg (tm_lost_packets_reg) */
	REG_DUMP_PRINT_1("   -tm_lost_packets_reg.tm_lost_packets_reg                |      0x%04X  |  [RO][15:00]""Tracks number of lost packets in acase of lossy tracing.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x67a2c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_enable_ddr_reg_3                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_enable_ddr_reg_3_type */
	/* skip, unused field unused_tm_trace_enable_ddr_reg_3 (tm_trace_enable_ddr_reg_3) */
	REG_DUMP_PRINT_1("   -tm_trace_enable_ddr_reg_3.tm_trace_enable_ddr_reg_3    |    0x%06X  |  [RW][23:00]""Individual trace enable for tracing to DDR for port 3.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x67a28);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_enable_ddr_reg_2                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_enable_ddr_reg_2_type */
	/* skip, unused field unused_tm_trace_enable_ddr_reg_2 (tm_trace_enable_ddr_reg_2) */
	REG_DUMP_PRINT_1("   -tm_trace_enable_ddr_reg_2.tm_trace_enable_ddr_reg_2    |    0x%06X  |  [RW][23:00]""Individual trace enable for tracing to DDR for port 2.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x67a24);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_enable_ddr_reg_1                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_enable_ddr_reg_1_type */
	/* skip, unused field unused_tm_trace_enable_ddr_reg_1 (tm_trace_enable_ddr_reg_1) */
	REG_DUMP_PRINT_1("   -tm_trace_enable_ddr_reg_1.tm_trace_enable_ddr_reg_1    |    0x%06X  |  [RW][23:00]""Individual trace enable for tracing to DDR for port 1.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x67a20);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_enable_ddr_reg_0                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_enable_ddr_reg_0_type */
	/* skip, unused field unused_tm_trace_enable_ddr_reg_0 (tm_trace_enable_ddr_reg_0) */
	REG_DUMP_PRINT_1("   -tm_trace_enable_ddr_reg_0.tm_trace_enable_ddr_reg_0    |    0x%06X  |  [RW][23:00]""Individual trace enable for tracing to DDR for port 0.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x67a1c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_enable_npk_reg_3                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_enable_npk_reg_3_type */
	/* skip, unused field unused_tm_trace_enable_npk_reg_3 (tm_trace_enable_npk_reg_3) */
	REG_DUMP_PRINT_1("   -tm_trace_enable_npk_reg_3.tm_trace_enable_npk_reg_3    |    0x%06X  |  [RW][23:00]""Individual trace enable for tracing to NPK for port 3.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x67a18);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_enable_npk_reg_2                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_enable_npk_reg_2_type */
	/* skip, unused field unused_tm_trace_enable_npk_reg_2 (tm_trace_enable_npk_reg_2) */
	REG_DUMP_PRINT_1("   -tm_trace_enable_npk_reg_2.tm_trace_enable_npk_reg_2    |    0x%06X  |  [RW][23:00]""Individual trace enable for tracing to NPK for port 2.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x67a14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_enable_npk_reg_1                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_enable_npk_reg_1_type */
	/* skip, unused field unused_tm_trace_enable_npk_reg_1 (tm_trace_enable_npk_reg_1) */
	REG_DUMP_PRINT_1("   -tm_trace_enable_npk_reg_1.tm_trace_enable_npk_reg_1    |    0x%06X  |  [RW][23:00]""Individual trace enable for tracing to NPK for port 1.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x67a10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_enable_npk_reg_0                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_enable_npk_reg_0_type */
	/* skip, unused field unused_tm_trace_enable_npk_reg_0 (tm_trace_enable_npk_reg_0) */
	REG_DUMP_PRINT_1("   -tm_trace_enable_npk_reg_0.tm_trace_enable_npk_reg_0    |    0x%06X  |  [RW][23:00]""Individual trace enable for tracing to NPK for port 0.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x67a0c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_addr_reg                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_addr_reg_type */
	REG_DUMP_PRINT_1("   -tm_trace_addr_reg.tm_trace_addr_reg                    |  0x%08X  |  [RW][31:00]""Address to which all trace packet are sent.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x67a08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_trace_header_reg                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_trace_header_reg_type */
	/* skip, unused field unused_tm_trace_header_reg (tm_trace_header_reg) */
	REG_DUMP_PRINT_1("   -tm_trace_header_reg.tm_trace_header_reg                |        0x%02X  |  [RW][07:00]""SVEN header""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0x67a04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  tm.tm_overall_enable_reg                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_tm_tm_overall_enable_reg_type */
	/* skip, unused field unused_tm_overall_enable_reg (tm_overall_enable_reg) */
	REG_DUMP_PRINT_1("   -tm_overall_enable_reg.tm_overall_enable_reg            |         0x%01X  |  [RW][00:00]""Overall enable all the counters.""\n", FIELD_VALUE(val, 0, 0));
} /* end tm */

/* Generated Debug Code: Device eqc */
void ia_css_debug_dump_eqc(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xbd040);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  eqc.back_off_timer                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_eqc_back_off_timer_type */
	/* skip, unused field unused_back_off_timer (back_off_timer) */
	REG_DUMP_PRINT_1("   -back_off_timer.back_off_timer          |        0x%02X  |  [RW][05:00]""Back_off timer register, holds off new queue reservation for the specified time""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0xbd038);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  eqc.queue_reserve_map3                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_eqc_queue_reserve_map3_type */
	REG_DUMP_PRINT_1("   -queue_reserve_map3.queue_reserve_map3  |  0x%08X  |  [RW][31:00]""Queue reserve address register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xbd034);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  eqc.ahigh_map3                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_eqc_ahigh_map3_type */
	REG_DUMP_PRINT_1("   -ahigh_map3.ahigh_map3                  |  0x%08X  |  [RW][31:00]""High address compare register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xbd030);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  eqc.alow_map3                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_eqc_alow_map3_type */
	REG_DUMP_PRINT_1("   -alow_map3.alow_map3                    |  0x%08X  |  [RW][31:00]""Low address compare register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xbd028);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  eqc.queue_reserve_map2                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_eqc_queue_reserve_map2_type */
	REG_DUMP_PRINT_1("   -queue_reserve_map2.queue_reserve_map2  |  0x%08X  |  [RW][31:00]""Queue reserve address register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xbd024);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  eqc.ahigh_map2                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_eqc_ahigh_map2_type */
	REG_DUMP_PRINT_1("   -ahigh_map2.ahigh_map2                  |  0x%08X  |  [RW][31:00]""High address compare register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xbd020);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  eqc.alow_map2                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_eqc_alow_map2_type */
	REG_DUMP_PRINT_1("   -alow_map2.alow_map2                    |  0x%08X  |  [RW][31:00]""Low address compare register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xbd018);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  eqc.queue_reserve_map1                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_eqc_queue_reserve_map1_type */
	REG_DUMP_PRINT_1("   -queue_reserve_map1.queue_reserve_map1  |  0x%08X  |  [RW][31:00]""Queue reserve address register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xbd014);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  eqc.ahigh_map1                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_eqc_ahigh_map1_type */
	REG_DUMP_PRINT_1("   -ahigh_map1.ahigh_map1                  |  0x%08X  |  [RW][31:00]""High address compare register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xbd010);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  eqc.alow_map1                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_eqc_alow_map1_type */
	REG_DUMP_PRINT_1("   -alow_map1.alow_map1                    |  0x%08X  |  [RW][31:00]""Low address compare register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xbd008);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  eqc.queue_reserve_map0                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_eqc_queue_reserve_map0_type */
	REG_DUMP_PRINT_1("   -queue_reserve_map0.queue_reserve_map0  |  0x%08X  |  [RW][31:00]""Queue reserve address register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xbd004);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  eqc.ahigh_map0                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_eqc_ahigh_map0_type */
	REG_DUMP_PRINT_1("   -ahigh_map0.ahigh_map0                  |  0x%08X  |  [RW][31:00]""High address compare register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xbd000);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  eqc.alow_map0                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_eqc_alow_map0_type */
	REG_DUMP_PRINT_1("   -alow_map0.alow_map0                    |  0x%08X  |  [RW][31:00]""Low address compare register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x6f110);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  eqc.back_off_timer                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_eqc_back_off_timer_type */
	/* skip, unused field unused_back_off_timer (back_off_timer) */
	REG_DUMP_PRINT_1("   -back_off_timer.back_off_timer          |        0x%02X  |  [RW][05:00]""Back_off timer register, holds off new queue reservation for the specified time""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x6f108);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  eqc.queue_reserve_map0                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_eqc_queue_reserve_map0_type */
	REG_DUMP_PRINT_1("   -queue_reserve_map0.queue_reserve_map0  |  0x%08X  |  [RW][31:00]""Queue reserve address register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x6f104);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  eqc.ahigh_map0                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_eqc_ahigh_map0_type */
	REG_DUMP_PRINT_1("   -ahigh_map0.ahigh_map0                  |  0x%08X  |  [RW][31:00]""High address compare register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x6f100);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  eqc.alow_map0                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_eqc_alow_map0_type */
	REG_DUMP_PRINT_1("   -alow_map0.alow_map0                    |  0x%08X  |  [RW][31:00]""Low address compare register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x67910);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  eqc.back_off_timer                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_eqc_back_off_timer_type */
	/* skip, unused field unused_back_off_timer (back_off_timer) */
	REG_DUMP_PRINT_1("   -back_off_timer.back_off_timer          |        0x%02X  |  [RW][05:00]""Back_off timer register, holds off new queue reservation for the specified time""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x67908);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  eqc.queue_reserve_map0                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_eqc_queue_reserve_map0_type */
	REG_DUMP_PRINT_1("   -queue_reserve_map0.queue_reserve_map0  |  0x%08X  |  [RW][31:00]""Queue reserve address register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x67904);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  eqc.ahigh_map0                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_eqc_ahigh_map0_type */
	REG_DUMP_PRINT_1("   -ahigh_map0.ahigh_map0                  |  0x%08X  |  [RW][31:00]""High address compare register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x67900);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  eqc.alow_map0                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_eqc_alow_map0_type */
	REG_DUMP_PRINT_1("   -alow_map0.alow_map0                    |  0x%08X  |  [RW][31:00]""Low address compare register""\n", FIELD_VALUE(val, 0, 31));
} /* end eqc */

/* Generated Debug Code: Device gpreg */
void ia_css_debug_dump_gpreg(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xbc010);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpreg.isgpreg4                                                                                                                                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_gpreg_isgpreg4_type */
	/* skip, unused field unused_isgpreg4 (isgpreg4) */
	REG_DUMP_PRINT_1("   -isgpreg4.isgpreg4                                                                                                                                                        |         0x%01X  |  [RW][00:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xbc00c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpreg.isgpreg3                                                                                                                                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_gpreg_isgpreg3_type */
	/* skip, unused field unused_isgpreg3 (isgpreg3) */
	REG_DUMP_PRINT_1("   -isgpreg3.isgpreg3                                                                                                                                                        |         0x%01X  |  [RW][00:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xbc008);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpreg.isgpreg2                                                                                                                                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_gpreg_isgpreg2_type */
	/* skip, unused field unused_isgpreg2 (isgpreg2) */
	REG_DUMP_PRINT_1("   -isgpreg2.isgpreg2                                                                                                                                                        |         0x%01X  |  [RW][00:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x7c418);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpreg.sel_irqreg                                                                                                                                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_gpreg_sel_irqreg_type */
	/* skip, unused field unused_sel_irqreg (sel_irqreg) */
	REG_DUMP_PRINT_1("   -sel_irqreg.sel_irqreg                                                                                                                                                    |         0x%01X  |  [RW][00:00]""Selection between sw_irq and gpio[11] register.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x7c414);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpreg.irqreg                                                                                                                                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_gpreg_irqreg_type */
	/* skip, unused field unused_irqreg (irqreg) */
	REG_DUMP_PRINT_1("   -irqreg.irqreg                                                                                                                                                            |         0x%01X  |  [RW][00:00]""FW interrupt register.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x7c410);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpreg.trace_timer_rst_n_reg                                                                                                                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_gpreg_trace_timer_rst_n_reg_type */
	/* skip, unused field unused_trace_timer_rst_n_reg (trace_timer_rst_n_reg) */
	REG_DUMP_PRINT_1("   -trace_timer_rst_n_reg.trace_timer_rst_n_reg                                                                                                                              |         0x%01X  |  [RW][00:00]""General-purpose configuration to reset in sync all the counters in gp_counters, trace monitors, trace units.                   This reset is active low. Counters by default are kept to 0. Only when this reg is set to 1 the counters                    start""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x7c40c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpreg.abgreg                                                                                                                                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_gpreg_abgreg_type */
	/* skip, unused field unused_abgreg (abgreg) */
	REG_DUMP_PRINT_1("   -abgreg.abgreg                                                                                                                                                            |         0x%01X  |  [RW][00:00]""General-purpose configuration to disable access_blockers WO, by default these access blockers in front of DMAs and ISP PMEM are enabled.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x7c408);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpreg.cdcgreg2                                                                                                                                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_gpreg_cdcgreg2_type */
	/* skip, unused field unused_cdcgreg2 (cdcgreg2) */
	REG_DUMP_PRINT_1("   -cdcgreg2.cdcgreg2                                                                                                                                                        |        0x%02X  |  [RW][04:00]""General-purpose configuration for cdc burst collector threshod.""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0x7c404);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpreg.cdcgreg1                                                                                                                                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_gpreg_cdcgreg1_type */
	/* skip, unused field unused_cdcgreg1 (cdcgreg1) */
	REG_DUMP_PRINT_1("   -cdcgreg1.cdcgreg1                                                                                                                                                        |        0x%02X  |  [RW][04:00]""General-purpose configuration for cdc burst collector threshod.""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0x7c400);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpreg.cdcgreg0                                                                                                                                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_gpreg_cdcgreg0_type */
	/* skip, unused field unused_cdcgreg0 (cdcgreg0) */
	REG_DUMP_PRINT_1("   -cdcgreg0.cdcgreg0                                                                                                                                                        |        0x%02X  |  [RW][04:00]""General-purpose configuration for cdc burst collector threshod.""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0x6f020);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpreg.csi2gpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_PORT_CLKGATING_DISABLE_REG_IDX                                                                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_gpreg_csi2gpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_PORT_CLKGATING_DISABLE_REG_IDX_type */
	/* skip, unused field unused_csi2gpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_PORT_CLKGATING_DISABLE_REG_IDX (csi2gpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_PORT_CLKGATING_DISABLE_REG_IDX) */
	REG_DUMP_PRINT_1("   -csi2gpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_PORT_CLKGATING_DISABLE_REG_IDX.csi2gpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_PORT_CLKGATING_DISABLE_REG_IDX                          |        0x%02X  |  [RO][05:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x6f01c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpreg.csi2gpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_SEL_MIPI_PKT_GEN0_REG_IDX                                                                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_gpreg_csi2gpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_SEL_MIPI_PKT_GEN0_REG_IDX_type */
	/* skip, unused field unused_csi2gpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_SEL_MIPI_PKT_GEN0_REG_IDX (csi2gpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_SEL_MIPI_PKT_GEN0_REG_IDX) */
	REG_DUMP_PRINT_1("   -csi2gpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_SEL_MIPI_PKT_GEN0_REG_IDX.csi2gpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_SEL_MIPI_PKT_GEN0_REG_IDX                                    |         0x%01X  |  [RO][00:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6f014);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpreg.csi2_3phgpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_PORT_CONFIG_REG_IDX                                                                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_gpreg_csi2_3phgpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_PORT_CONFIG_REG_IDX_type */
	/* skip, unused field unused_csi2_3phgpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_PORT_CONFIG_REG_IDX (csi2_3phgpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_PORT_CONFIG_REG_IDX) */
	REG_DUMP_PRINT_1("   -csi2_3phgpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_PORT_CONFIG_REG_IDX.csi2_3phgpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_PORT_CONFIG_REG_IDX                                        |        0x%02X  |  [RW][04:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0x6f010);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpreg.csi2_3phgpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_HPLL_FREQ_ISCLK_RATIO_OVERRIDE_REG_IDX                                                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_gpreg_csi2_3phgpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_HPLL_FREQ_ISCLK_RATIO_OVERRIDE_REG_IDX_type */
	/* skip, unused field unused_csi2_3phgpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_HPLL_FREQ_ISCLK_RATIO_OVERRIDE_REG_IDX (csi2_3phgpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_HPLL_FREQ_ISCLK_RATIO_OVERRIDE_REG_IDX) */
	REG_DUMP_PRINT_1("   -csi2_3phgpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_HPLL_FREQ_ISCLK_RATIO_OVERRIDE_REG_IDX.csi2_3phgpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_HPLL_FREQ_ISCLK_RATIO_OVERRIDE_REG_IDX  |         0x%01X  |  [RW][00:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6f00c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpreg.csi2_3phgpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_ISCLK_RATIO_REG_IDX                                                                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_gpreg_csi2_3phgpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_ISCLK_RATIO_REG_IDX_type */
	/* skip, unused field unused_csi2_3phgpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_ISCLK_RATIO_REG_IDX (csi2_3phgpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_ISCLK_RATIO_REG_IDX) */
	REG_DUMP_PRINT_1("   -csi2_3phgpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_ISCLK_RATIO_REG_IDX.csi2_3phgpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_ISCLK_RATIO_REG_IDX                                        |        0x%02X  |  [RW][04:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0x6f008);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpreg.csi2_3phgpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_HPLL_FREQ_REG_IDX                                                                                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_gpreg_csi2_3phgpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_HPLL_FREQ_REG_IDX_type */
	/* skip, unused field unused_csi2_3phgpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_HPLL_FREQ_REG_IDX (csi2_3phgpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_HPLL_FREQ_REG_IDX) */
	REG_DUMP_PRINT_1("   -csi2_3phgpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_HPLL_FREQ_REG_IDX.csi2_3phgpregHIVE_ISYS2600_CSI2_3PH_GPREG_CR_HPLL_FREQ_REG_IDX                                            |         0x%01X  |  [RW][01:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x6782c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpreg.csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_RCOMP_START_SOFT_REG_IDX                                                                                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_gpreg_csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_RCOMP_START_SOFT_REG_IDX_type */
	/* skip, unused field unused_csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_RCOMP_START_SOFT_REG_IDX (csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_RCOMP_START_SOFT_REG_IDX) */
	REG_DUMP_PRINT_1("   -csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_RCOMP_START_SOFT_REG_IDX.csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_RCOMP_START_SOFT_REG_IDX                                              |         0x%01X  |  [RW][00:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x67828);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpreg.csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_PORT_CLKGATING_DISABLE_REG_IDX                                                                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_gpreg_csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_PORT_CLKGATING_DISABLE_REG_IDX_type */
	/* skip, unused field unused_csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_PORT_CLKGATING_DISABLE_REG_IDX (csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_PORT_CLKGATING_DISABLE_REG_IDX) */
	REG_DUMP_PRINT_1("   -csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_PORT_CLKGATING_DISABLE_REG_IDX.csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_PORT_CLKGATING_DISABLE_REG_IDX                                  |         0x%01X  |  [RO][03:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x67824);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpreg.csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_SEL_MIPI_PKT_GEN0_REG_IDX                                                                                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_gpreg_csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_SEL_MIPI_PKT_GEN0_REG_IDX_type */
	/* skip, unused field unused_csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_SEL_MIPI_PKT_GEN0_REG_IDX (csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_SEL_MIPI_PKT_GEN0_REG_IDX) */
	REG_DUMP_PRINT_1("   -csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_SEL_MIPI_PKT_GEN0_REG_IDX.csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_SEL_MIPI_PKT_GEN0_REG_IDX                                            |         0x%01X  |  [RO][00:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x67820);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpreg.csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_RCOMP_TIMER_VALUE_REG_IDX                                                                                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_gpreg_csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_RCOMP_TIMER_VALUE_REG_IDX_type */
	REG_DUMP_PRINT_1("   -csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_RCOMP_TIMER_VALUE_REG_IDX.csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_RCOMP_TIMER_VALUE_REG_IDX                                            |  0x%08X  |  [RW][31:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x6781c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpreg.csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_RCOMP_TIMER_DISABLE_REG_IDX                                                                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_gpreg_csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_RCOMP_TIMER_DISABLE_REG_IDX_type */
	/* skip, unused field unused_csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_RCOMP_TIMER_DISABLE_REG_IDX (csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_RCOMP_TIMER_DISABLE_REG_IDX) */
	REG_DUMP_PRINT_1("   -csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_RCOMP_TIMER_DISABLE_REG_IDX.csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_RCOMP_TIMER_DISABLE_REG_IDX                                        |         0x%01X  |  [RW][00:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x67814);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpreg.csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_PORT_CONFIG_REG_IDX                                                                                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_gpreg_csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_PORT_CONFIG_REG_IDX_type */
	/* skip, unused field unused_csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_PORT_CONFIG_REG_IDX (csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_PORT_CONFIG_REG_IDX) */
	REG_DUMP_PRINT_1("   -csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_PORT_CONFIG_REG_IDX.csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_PORT_CONFIG_REG_IDX                                                        |        0x%02X  |  [RW][04:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0x67810);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpreg.csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_HPLL_FREQ_ISCLK_RATIO_OVERRIDE_REG_IDX                                                                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_gpreg_csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_HPLL_FREQ_ISCLK_RATIO_OVERRIDE_REG_IDX_type */
	/* skip, unused field unused_csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_HPLL_FREQ_ISCLK_RATIO_OVERRIDE_REG_IDX (csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_HPLL_FREQ_ISCLK_RATIO_OVERRIDE_REG_IDX) */
	REG_DUMP_PRINT_1("   -csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_HPLL_FREQ_ISCLK_RATIO_OVERRIDE_REG_IDX.csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_HPLL_FREQ_ISCLK_RATIO_OVERRIDE_REG_IDX                  |         0x%01X  |  [RW][00:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6780c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpreg.csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_ISCLK_RATIO_REG_IDX                                                                                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_gpreg_csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_ISCLK_RATIO_REG_IDX_type */
	/* skip, unused field unused_csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_ISCLK_RATIO_REG_IDX (csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_ISCLK_RATIO_REG_IDX) */
	REG_DUMP_PRINT_1("   -csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_ISCLK_RATIO_REG_IDX.csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_ISCLK_RATIO_REG_IDX                                                        |        0x%02X  |  [RW][04:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0x67808);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpreg.csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_HPLL_FREQ_REG_IDX                                                                                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_gpreg_csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_HPLL_FREQ_REG_IDX_type */
	/* skip, unused field unused_csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_HPLL_FREQ_REG_IDX (csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_HPLL_FREQ_REG_IDX) */
	REG_DUMP_PRINT_1("   -csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_HPLL_FREQ_REG_IDX.csi2gpregHIVE_ISYS2600_CSI2_GPREG_CR_HPLL_FREQ_REG_IDX                                                            |         0x%01X  |  [RW][01:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 1));
} /* end gpreg */

/* Generated Debug Code: Device gpr_d */
void ia_css_debug_dump_gpr_d(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x67708);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpr_d.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX                                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_gpr_d_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX_type */
	/* skip, unused field unused_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX (csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX) */
	REG_DUMP_PRINT_1("   -csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX  |       0x%03X  |  [RW][10:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 10));
	val = REG_DUMP_READ_REGISTER(0x67704);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpr_d.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX                                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_gpr_d_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX_type */
	/* skip, unused field unused_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX (csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX) */
	REG_DUMP_PRINT_1("   -csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX      |    0x%06X  |  [RW][21:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 21));
	val = REG_DUMP_READ_REGISTER(0x67700);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpr_d.str_mon_status                                                                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_gpr_d_str_mon_status_type */
	REG_DUMP_PRINT_1("   -str_mon_status.str_mon_status                                                                                        |  0x%08X  |  [RO][31:00]""Streaming Monitor Status, [accept,valid] of streaming port""\n", FIELD_VALUE(val, 0, 31));
} /* end gpr_d */

/* Generated Debug Code: Device irq_ctrl1_d */
void ia_css_debug_dump_irq_ctrl1_d(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x67614);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl1_d.irq_level_not_pulse            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl1_d_irq_level_not_pulse_type */
	/* skip, unused field unused_irq_level_not_pulse (irq_level_not_pulse) */
	REG_DUMP_PRINT_1("   -irq_level_not_pulse.irq_level_not_pulse  |       0x%03X  |  [RW][11:00]""Indicates for each bit whether an interrupt cause is translated into a pulse (value='0') or into a constant level '1' (value='1') on the IRQ pin.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x67610);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl1_d.irq_enable                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl1_d_irq_enable_type */
	/* skip, unused field unused_irq_enable (irq_enable) */
	REG_DUMP_PRINT_1("   -irq_enable.irq_enable                    |       0x%03X  |  [RW][11:00]""Indicates for each bit whether an interrupt cause as monitored by the req_irq_status register also affects the IRQ pin (value='1') or not (value='0').""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x67608);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl1_d.irq_status                     |  0x%08X  |  ""Indicates for each bit whether a non-masked interrupt has been generated (value='1'). Can be cleared by writing a '1' into the the corresponding bit of the req_irq_clear register.""\n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl1_d_irq_status_type */
	/* skip, unused field unused_irq_status (irq_status) */
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_0                |         0x%01X  |  [RO][00:00]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_1                |         0x%01X  |  [RO][01:01]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_2                |         0x%01X  |  [RO][02:02]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_3                |         0x%01X  |  [RO][03:03]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_4                |         0x%01X  |  [RO][04:04]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_5                |         0x%01X  |  [RO][05:05]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_6                |         0x%01X  |  [RO][06:06]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_7                |         0x%01X  |  [RO][07:07]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_8                |         0x%01X  |  [RO][08:08]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_9                |         0x%01X  |  [RO][09:09]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_10               |         0x%01X  |  [RO][10:10]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_11               |         0x%01X  |  [RO][11:11]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 11, 11));
	val = REG_DUMP_READ_REGISTER(0x67604);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl1_d.irq_mask                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl1_d_irq_mask_type */
	/* skip, unused field unused_irq_mask (irq_mask) */
	REG_DUMP_PRINT_1("   -irq_mask.irq_mask                        |       0x%03X  |  [RW][11:00]""Indicates for each bit of irq_di whether it can generate an interrupt request (value='1') or not (value='0'). Setting will affect irq_value as well as IRQ output pin.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x67600);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl1_d.irq_edge                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl1_d_irq_edge_type */
	/* skip, unused field unused_irq_edge (irq_edge) */
	REG_DUMP_PRINT_1("   -irq_edge.irq_edge                        |       0x%03X  |  [RW][11:00]""Indicates for each bit whether an interrupt request should be generated on a falling edge (value='0') or a rising edge (value='1').""\n", FIELD_VALUE(val, 0, 11));
} /* end irq_ctrl1_d */

/* Generated Debug Code: Device irq_ctrl0_d */
void ia_css_debug_dump_irq_ctrl0_d(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x67514);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_d.irq_level_not_pulse            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl0_d_irq_level_not_pulse_type */
	/* skip, unused field unused_irq_level_not_pulse (irq_level_not_pulse) */
	REG_DUMP_PRINT_1("   -irq_level_not_pulse.irq_level_not_pulse  |     0x%05X  |  [RW][16:00]""Indicates for each bit whether an interrupt cause is translated into a pulse (value='0') or into a constant level '1' (value='1') on the IRQ pin.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0x67510);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_d.irq_enable                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl0_d_irq_enable_type */
	/* skip, unused field unused_irq_enable (irq_enable) */
	REG_DUMP_PRINT_1("   -irq_enable.irq_enable                    |     0x%05X  |  [RW][16:00]""Indicates for each bit whether an interrupt cause as monitored by the req_irq_status register also affects the IRQ pin (value='1') or not (value='0').""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0x67508);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_d.irq_status                     |  0x%08X  |  ""Indicates for each bit whether a non-masked interrupt has been generated (value='1'). Can be cleared by writing a '1' into the the corresponding bit of the req_irq_clear register.""\n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl0_d_irq_status_type */
	/* skip, unused field unused_irq_status (irq_status) */
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_0             |         0x%01X  |  [RO][00:00]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_1             |         0x%01X  |  [RO][01:01]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_2             |         0x%01X  |  [RO][02:02]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_3             |         0x%01X  |  [RO][03:03]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_4             |         0x%01X  |  [RO][04:04]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_5             |         0x%01X  |  [RO][05:05]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_6             |         0x%01X  |  [RO][06:06]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_7             |         0x%01X  |  [RO][07:07]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_8             |         0x%01X  |  [RO][08:08]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_9             |         0x%01X  |  [RO][09:09]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_10            |         0x%01X  |  [RO][10:10]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_11            |         0x%01X  |  [RO][11:11]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_12            |         0x%01X  |  [RO][12:12]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 12, 12));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_13            |         0x%01X  |  [RO][13:13]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 13, 13));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_14            |         0x%01X  |  [RO][14:14]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 14, 14));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_15            |         0x%01X  |  [RO][15:15]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 15, 15));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_16            |         0x%01X  |  [RO][16:16]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 16, 16));
	val = REG_DUMP_READ_REGISTER(0x67504);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_d.irq_mask                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl0_d_irq_mask_type */
	/* skip, unused field unused_irq_mask (irq_mask) */
	REG_DUMP_PRINT_1("   -irq_mask.irq_mask                        |     0x%05X  |  [RW][16:00]""Indicates for each bit of irq_di whether it can generate an interrupt request (value='1') or not (value='0'). Setting will affect irq_value as well as IRQ output pin.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0x67500);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_d.irq_edge                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl0_d_irq_edge_type */
	/* skip, unused field unused_irq_edge (irq_edge) */
	REG_DUMP_PRINT_1("   -irq_edge.irq_edge                        |     0x%05X  |  [RW][16:00]""Indicates for each bit whether an interrupt request should be generated on a falling edge (value='0') or a rising edge (value='1').""\n", FIELD_VALUE(val, 0, 16));
} /* end irq_ctrl0_d */

/* Generated Debug Code: Device irq_ctrl_d */
void ia_css_debug_dump_irq_ctrl_d(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x67414);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_d.irq_level_not_pulse             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl_d_irq_level_not_pulse_type */
	/* skip, unused field unused_irq_level_not_pulse (irq_level_not_pulse) */
	REG_DUMP_PRINT_1("   -irq_level_not_pulse.irq_level_not_pulse  |    0x%06X  |  [RW][20:00]""Indicates for each bit whether an interrupt cause is translated into a pulse (value='0') or into a constant level '1' (value='1') on the IRQ pin.""\n", FIELD_VALUE(val, 0, 20));
	val = REG_DUMP_READ_REGISTER(0x67410);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_d.irq_enable                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl_d_irq_enable_type */
	/* skip, unused field unused_irq_enable (irq_enable) */
	REG_DUMP_PRINT_1("   -irq_enable.irq_enable                    |    0x%06X  |  [RW][20:00]""Indicates for each bit whether an interrupt cause as monitored by the req_irq_status register also affects the IRQ pin (value='1') or not (value='0').""\n", FIELD_VALUE(val, 0, 20));
	val = REG_DUMP_READ_REGISTER(0x67408);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_d.irq_status                      |  0x%08X  |  ""Indicates for each bit whether a non-masked interrupt has been generated (value='1'). Can be cleared by writing a '1' into the the corresponding bit of the req_irq_clear register.""\n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl_d_irq_status_type */
	/* skip, unused field unused_irq_status (irq_status) */
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_0             |         0x%01X  |  [RO][00:00]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_1             |         0x%01X  |  [RO][01:01]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_2             |         0x%01X  |  [RO][02:02]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_3             |         0x%01X  |  [RO][03:03]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_4             |         0x%01X  |  [RO][04:04]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_5             |         0x%01X  |  [RO][05:05]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_6             |         0x%01X  |  [RO][06:06]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_7             |         0x%01X  |  [RO][07:07]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_8             |         0x%01X  |  [RO][08:08]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_9             |         0x%01X  |  [RO][09:09]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_10            |         0x%01X  |  [RO][10:10]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_11            |         0x%01X  |  [RO][11:11]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_12            |         0x%01X  |  [RO][12:12]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 12, 12));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_13            |         0x%01X  |  [RO][13:13]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 13, 13));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_14            |         0x%01X  |  [RO][14:14]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 14, 14));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_15            |         0x%01X  |  [RO][15:15]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 15, 15));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX               |         0x%01X  |  [RO][16:16]""Represents the status of the irq from irq_ctrl0 (csi_rx irqs).""\n", FIELD_VALUE(val, 16, 16));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M                  |         0x%01X  |  [RO][17:17]""Represents the status of the irq from irq_ctrl1 (csi__rx_synchronization_irqs + s2m_irqs).""\n", FIELD_VALUE(val, 17, 17));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_SM                   |         0x%01X  |  [RO][18:18]""Represents the status of the irq from Stream Monitor.""\n", FIELD_VALUE(val, 18, 18));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_IBUF                 |         0x%01X  |  [RO][19:19]""Represents the status of the irq from IBuffer Controller.""\n", FIELD_VALUE(val, 19, 19));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_SIG2CIO              |         0x%01X  |  [RO][20:20]""Represents the status of the irq from Sig2Cio.""\n", FIELD_VALUE(val, 20, 20));
	val = REG_DUMP_READ_REGISTER(0x67404);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_d.irq_mask                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl_d_irq_mask_type */
	/* skip, unused field unused_irq_mask (irq_mask) */
	REG_DUMP_PRINT_1("   -irq_mask.irq_mask                        |    0x%06X  |  [RW][20:00]""Indicates for each bit of irq_di whether it can generate an interrupt request (value='1') or not (value='0'). Setting will affect irq_value as well as IRQ output pin.""\n", FIELD_VALUE(val, 0, 20));
	val = REG_DUMP_READ_REGISTER(0x67400);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_d.irq_edge                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl_d_irq_edge_type */
	/* skip, unused field unused_irq_edge (irq_edge) */
	REG_DUMP_PRINT_1("   -irq_edge.irq_edge                        |    0x%06X  |  [RW][20:00]""Indicates for each bit whether an interrupt request should be generated on a falling edge (value='0') or a rising edge (value='1').""\n", FIELD_VALUE(val, 0, 20));
} /* end irq_ctrl_d */

/* Generated Debug Code: Device csi_rx_d */
void ia_css_debug_dump_csi_rx_d(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x67038);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_d.reg_rx_csi_dly_cnt_settle_dlane0                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_d_reg_rx_csi_dly_cnt_settle_dlane0_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_settle_dlane0 (reg_rx_csi_dly_cnt_settle_dlane0) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_settle_dlane0.reg_rx_csi_dly_cnt_settle_dlane0  |    0x%06X  |  [RW][23:00]""Specify the Delay value for Settling time of Data lane 0 HS Rx data.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x67034);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_d.reg_rx_csi_dly_cnt_termen_dlane0                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_d_reg_rx_csi_dly_cnt_termen_dlane0_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_termen_dlane0 (reg_rx_csi_dly_cnt_termen_dlane0) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_termen_dlane0.reg_rx_csi_dly_cnt_termen_dlane0  |    0x%06X  |  [RW][23:00]""Specify the Delay value for Termination enable of Data lane 0 HS Rx.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x67030);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_d.reg_rx_csi_dly_cnt_settle_clane                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_d_reg_rx_csi_dly_cnt_settle_clane_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_settle_clane (reg_rx_csi_dly_cnt_settle_clane) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_settle_clane.reg_rx_csi_dly_cnt_settle_clane    |    0x%06X  |  [RW][23:00]""Specify the Delay value for HS Settling time of Clock lane HS Rx data.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6702c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_d.reg_rx_csi_dly_cnt_termen_clane                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_d_reg_rx_csi_dly_cnt_termen_clane_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_termen_clane (reg_rx_csi_dly_cnt_termen_clane) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_termen_clane.reg_rx_csi_dly_cnt_termen_clane    |    0x%06X  |  [RW][23:00]""Specify the Delay value for Termination enable of Clock lane HS Rx.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x67028);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_d.reg_rx_csi_status_dlane_lp                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_d_reg_rx_csi_status_dlane_lp_type */
	/* skip, unused field unused_reg_rx_csi_status_dlane_lp (reg_rx_csi_status_dlane_lp) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_status_dlane_lp.reg_rx_csi_status_dlane_lp              |    0x%06X  |  [RW][23:00]""Status register for low power communication errors and events (Escape mode (errors), trigger events)                    This is an edge triggered status register which bits can be cleared via writing.                   Reading:                    Error entering escape mode:                    Bit.0 =LP Esc Error Dlane-0                    Bit.1 =LP Esc Error Dlane-1                    Bit.2 =LP Esc Error Dlane-2                    Bit.3 =LP Esc Error Dlane-3                    Low power events, refer to REF-2 DPHY MAS, section 4.3.2 for detailed information:                    Bit.4 =LP TriggerEsc0 (Rst) Dlane-0                    Bit.5 =LP TriggerEsc1 (Unk3) Dlane-0                    Bit.6 =LP TriggerEsc2 (Unk4) Dlane-0                    Bit.7 =LP TriggerEsc3 (Unk5) Dlane-0                    Bit.8 =LP TriggerEsc0 (Rst) Dlane-1                    Bit.9 =LP TriggerEsc1 (Unk3) Dlane-1                    Bit.10 =LP TriggerEsc2 (Unk4) Dlane-1                    Bit.11 =LP TriggerEsc3 (Unk5) Dlane-1                    Bit.12 =LP TriggerEsc0 (Rst) Dlane-2                    Bit.13 =LP TriggerEsc1 (Unk3) Dlane-2                    Bit.14 =LP TriggerEsc2 (Unk4) Dlane-2                    Bit.15 =LP TriggerEsc3 (Unk5) Dlane-2                    Bit.16 =LP TriggerEsc0 (Rst) Dlane-3                    Bit.17 =LP TriggerEsc1 (Unk3) Dlane-3                    Bit.18 =LP TriggerEsc2 (Unk4) Dlane-3                    Bit.19 =LP TriggerEsc3 (Unk5) Dlane-3                    Bit.20 =LP UlpsEsc Dlane-0                    Bit.21 =LP UlpsEsc Dlane-1                    Bit.22 =LP UlpsEsc Dlane-2                    Bit.23 =LP UlpsEsc Dlane-3                    Writing:                    Writing a '1' to a particular bit clears that bit.                    Eg.                    Writing 0x1 clears bit.0                    Writing 0x3 clears bit.0 and bit.1                    Etc.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x67024);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_d.reg_rx_csi_status_dlane_hs                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_d_reg_rx_csi_status_dlane_hs_type */
	/* skip, unused field unused_reg_rx_csi_status_dlane_hs (reg_rx_csi_status_dlane_hs) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_status_dlane_hs.reg_rx_csi_status_dlane_hs              |        0x%02X  |  [RW][07:00]""Status register for high speed communication errors (single bit, multiple bit errors in sync pattern)                    This is an edge triggered status register which bits can be cleared via writing.                    Reading:                    DPHY recoverable sync errors (single bit error):                     Bit.0 =HS SOT Error Dlane-0                    Bit.1 =HS SOT Error Dlane-1                    Bit.2 =HS SOT Error Dlane-2                    Bit.3 =HS SOT Error Dlane-3                    DPHY NON-recoverable sync errors (multiple bit error):                    Bit.4 =HS SOT Sync Error Dlane-0                    Bit.5 =HS SOT Sync Error Dlane-1                    Bit.6 =HS SOT Sync Error Dlane-2                    Bit.7 =HS SOT Sync Error Dlane-3                    Writing:                    Writing a '1' to a particular bit clears that bit.                    Eg.                   Writing 0x1 clears bit.0                    Writing 0x3 clears bit.0 and bit.1                    Etc. ""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0x67020);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_d.reg_rx_csi_status                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_d_reg_rx_csi_status_type */
	/* skip, unused field unused_reg_rx_csi_status (reg_rx_csi_status) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_status.reg_rx_csi_status                                |         0x%01X  |  [RO][01:00]""Status register.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x6701c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_d.reg_rx_csi_lp_if_config                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_d_reg_rx_csi_lp_if_config_type */
	/* skip, unused field unused_reg_rx_csi_lp_if_config (reg_rx_csi_lp_if_config) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_lp_if_config.reg_rx_csi_lp_if_config                    |         0x%01X  |  [RW][02:00]""Long packet inter-frame configuration register (error type 8a)                    bit[1:0]                    00 = filter out all long packets in between frames, no error is communicated (only via IRQ)                    01 = filter out inter-frame long packets while VC is inactive, pass when active                    10 = always pass                    11 = reserved/not used                    bit[2]                    0 = no error flag + code added to passed packet                    1 = error flag + code added to passed packet""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x67018);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_d.reg_rx_csi_sp_if_config                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_d_reg_rx_csi_sp_if_config_type */
	/* skip, unused field unused_reg_rx_csi_sp_if_config (reg_rx_csi_sp_if_config) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_sp_if_config.reg_rx_csi_sp_if_config                    |         0x%01X  |  [RW][02:00]""Short packet inter-frame configuration register (error type 8a)                    bit[1:0]                    00 = filter out all short packets in between frames, no error is communicated (only via IRQ)                    01 = filter out inter-frame short packets while VC is inactive, pass when active                    10 = always pass                    11 = reserved/not used                    bit[2]                    0 = no error flag + code added to passed packet                    1 = error flag + code added to passed packet""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x67014);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_d.reg_rx_csi_sync_cntr_sel                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_d_reg_rx_csi_sync_cntr_sel_type */
	/* skip, unused field unused_reg_rx_csi_sync_cntr_sel (reg_rx_csi_sync_cntr_sel) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_sync_cntr_sel.reg_rx_csi_sync_cntr_sel                  |         0x%01X  |  [RW][01:00]""Sync counter select register. 		               bit 0 => 0: Use internal counter for line start and line end packet IDs.                          => 1: Use line start and line end ID as send by sensor 									 bit 1 => 0: Use internal counter for frame start and frame end packet IDs.                          => 1: Use frame start and frame end ID as send by sensor""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x67010);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_d.reg_rx_csi_error_handling                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_d_reg_rx_csi_error_handling_type */
	/* skip, unused field unused_reg_rx_csi_error_handling (reg_rx_csi_error_handling) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_error_handling.reg_rx_csi_error_handling                |        0x%02X  |  [RW][04:00]""Error handling register. 		               bit 0 = when set, packets with more than one erro in packet header 									  			 are discarded. 									 bit 1 = when set, a short packet with reserved id is discarded and irq 									  			 is raised 									 bit 2 = when set, a long packet with reserved id is discarded and irq 									  			 is raised 		               bit 3 = when set, detection of incomplete packet is disabled, irq will 									         not be generated""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0x6700c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_d.reg_rx_csi_hbp_testmode_enable                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_d_reg_rx_csi_hbp_testmode_enable_type */
	/* skip, unused field unused_reg_rx_csi_hbp_testmode_enable (reg_rx_csi_hbp_testmode_enable) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_hbp_testmode_enable.reg_rx_csi_hbp_testmode_enable      |         0x%01X  |  [RW][00:00]""HBP test mode enable register of CSI RX.                    0 = Normal mode(DPHY receives HS data and byte clock from AFE), 									 1 = HBP test mode (DPHY receives HS data and byte clock via TESTER GPIOs),                   ""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x67008);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_d.reg_rx_csi_control                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_d_reg_rx_csi_control_type */
	/* skip, unused field unused_reg_rx_csi_control (reg_rx_csi_control) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_control.reg_rx_csi_control                              |       0x%03X  |  [RW][10:00]""Control register CSI RX.                    bit 0 = release_lp11 									 bit 1 = disable_byte_clk_gating,                   ""\n", FIELD_VALUE(val, 0, 10));
	val = REG_DUMP_READ_REGISTER(0x67004);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_d.reg_rx_csi_nof_enabled_lanes                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_d_reg_rx_csi_nof_enabled_lanes_type */
	/* skip, unused field unused_reg_rx_csi_nof_enabled_lanes (reg_rx_csi_nof_enabled_lanes) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_nof_enabled_lanes.reg_rx_csi_nof_enabled_lanes          |         0x%01X  |  [RW][02:00]""Specify Number of enabled data lanes of CSI RX.                    0 = No lanes enabled 									 1 = One   lane  enabled,                    2 = Two   lanes enabled,                    3 = Three lanes enabled,                    4 = Four  lanes enabled,                   ""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x67000);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_d.reg_rx_csi_enable                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_d_reg_rx_csi_enable_type */
	/* skip, unused field unused_reg_rx_csi_enable (reg_rx_csi_enable) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_enable.reg_rx_csi_enable                                |         0x%01X  |  [RW][00:00]""Enable CSI RX""\n", FIELD_VALUE(val, 0, 0));
} /* end csi_rx_d */

/* Generated Debug Code: Device gpr_c */
void ia_css_debug_dump_gpr_c(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x66708);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpr_c.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX                                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_gpr_c_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX_type */
	/* skip, unused field unused_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX (csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX) */
	REG_DUMP_PRINT_1("   -csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX  |       0x%03X  |  [RW][10:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 10));
	val = REG_DUMP_READ_REGISTER(0x66704);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpr_c.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX                                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_gpr_c_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX_type */
	/* skip, unused field unused_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX (csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX) */
	REG_DUMP_PRINT_1("   -csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX      |    0x%06X  |  [RW][21:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 21));
	val = REG_DUMP_READ_REGISTER(0x66700);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpr_c.str_mon_status                                                                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_gpr_c_str_mon_status_type */
	REG_DUMP_PRINT_1("   -str_mon_status.str_mon_status                                                                                        |  0x%08X  |  [RO][31:00]""Streaming Monitor Status, [accept,valid] of streaming port""\n", FIELD_VALUE(val, 0, 31));
} /* end gpr_c */

/* Generated Debug Code: Device irq_ctrl1_c */
void ia_css_debug_dump_irq_ctrl1_c(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x66614);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl1_c.irq_level_not_pulse            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl1_c_irq_level_not_pulse_type */
	/* skip, unused field unused_irq_level_not_pulse (irq_level_not_pulse) */
	REG_DUMP_PRINT_1("   -irq_level_not_pulse.irq_level_not_pulse  |       0x%03X  |  [RW][11:00]""Indicates for each bit whether an interrupt cause is translated into a pulse (value='0') or into a constant level '1' (value='1') on the IRQ pin.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x66610);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl1_c.irq_enable                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl1_c_irq_enable_type */
	/* skip, unused field unused_irq_enable (irq_enable) */
	REG_DUMP_PRINT_1("   -irq_enable.irq_enable                    |       0x%03X  |  [RW][11:00]""Indicates for each bit whether an interrupt cause as monitored by the req_irq_status register also affects the IRQ pin (value='1') or not (value='0').""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x66608);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl1_c.irq_status                     |  0x%08X  |  ""Indicates for each bit whether a non-masked interrupt has been generated (value='1'). Can be cleared by writing a '1' into the the corresponding bit of the req_irq_clear register.""\n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl1_c_irq_status_type */
	/* skip, unused field unused_irq_status (irq_status) */
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_0                |         0x%01X  |  [RO][00:00]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_1                |         0x%01X  |  [RO][01:01]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_2                |         0x%01X  |  [RO][02:02]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_3                |         0x%01X  |  [RO][03:03]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_4                |         0x%01X  |  [RO][04:04]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_5                |         0x%01X  |  [RO][05:05]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_6                |         0x%01X  |  [RO][06:06]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_7                |         0x%01X  |  [RO][07:07]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_8                |         0x%01X  |  [RO][08:08]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_9                |         0x%01X  |  [RO][09:09]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_10               |         0x%01X  |  [RO][10:10]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_11               |         0x%01X  |  [RO][11:11]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 11, 11));
	val = REG_DUMP_READ_REGISTER(0x66604);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl1_c.irq_mask                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl1_c_irq_mask_type */
	/* skip, unused field unused_irq_mask (irq_mask) */
	REG_DUMP_PRINT_1("   -irq_mask.irq_mask                        |       0x%03X  |  [RW][11:00]""Indicates for each bit of irq_di whether it can generate an interrupt request (value='1') or not (value='0'). Setting will affect irq_value as well as IRQ output pin.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x66600);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl1_c.irq_edge                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl1_c_irq_edge_type */
	/* skip, unused field unused_irq_edge (irq_edge) */
	REG_DUMP_PRINT_1("   -irq_edge.irq_edge                        |       0x%03X  |  [RW][11:00]""Indicates for each bit whether an interrupt request should be generated on a falling edge (value='0') or a rising edge (value='1').""\n", FIELD_VALUE(val, 0, 11));
} /* end irq_ctrl1_c */

/* Generated Debug Code: Device irq_ctrl0_c */
void ia_css_debug_dump_irq_ctrl0_c(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x66514);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_c.irq_level_not_pulse            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl0_c_irq_level_not_pulse_type */
	/* skip, unused field unused_irq_level_not_pulse (irq_level_not_pulse) */
	REG_DUMP_PRINT_1("   -irq_level_not_pulse.irq_level_not_pulse  |     0x%05X  |  [RW][16:00]""Indicates for each bit whether an interrupt cause is translated into a pulse (value='0') or into a constant level '1' (value='1') on the IRQ pin.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0x66510);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_c.irq_enable                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl0_c_irq_enable_type */
	/* skip, unused field unused_irq_enable (irq_enable) */
	REG_DUMP_PRINT_1("   -irq_enable.irq_enable                    |     0x%05X  |  [RW][16:00]""Indicates for each bit whether an interrupt cause as monitored by the req_irq_status register also affects the IRQ pin (value='1') or not (value='0').""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0x66508);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_c.irq_status                     |  0x%08X  |  ""Indicates for each bit whether a non-masked interrupt has been generated (value='1'). Can be cleared by writing a '1' into the the corresponding bit of the req_irq_clear register.""\n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl0_c_irq_status_type */
	/* skip, unused field unused_irq_status (irq_status) */
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_0             |         0x%01X  |  [RO][00:00]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_1             |         0x%01X  |  [RO][01:01]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_2             |         0x%01X  |  [RO][02:02]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_3             |         0x%01X  |  [RO][03:03]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_4             |         0x%01X  |  [RO][04:04]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_5             |         0x%01X  |  [RO][05:05]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_6             |         0x%01X  |  [RO][06:06]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_7             |         0x%01X  |  [RO][07:07]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_8             |         0x%01X  |  [RO][08:08]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_9             |         0x%01X  |  [RO][09:09]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_10            |         0x%01X  |  [RO][10:10]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_11            |         0x%01X  |  [RO][11:11]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_12            |         0x%01X  |  [RO][12:12]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 12, 12));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_13            |         0x%01X  |  [RO][13:13]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 13, 13));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_14            |         0x%01X  |  [RO][14:14]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 14, 14));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_15            |         0x%01X  |  [RO][15:15]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 15, 15));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_16            |         0x%01X  |  [RO][16:16]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 16, 16));
	val = REG_DUMP_READ_REGISTER(0x66504);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_c.irq_mask                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl0_c_irq_mask_type */
	/* skip, unused field unused_irq_mask (irq_mask) */
	REG_DUMP_PRINT_1("   -irq_mask.irq_mask                        |     0x%05X  |  [RW][16:00]""Indicates for each bit of irq_di whether it can generate an interrupt request (value='1') or not (value='0'). Setting will affect irq_value as well as IRQ output pin.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0x66500);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_c.irq_edge                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl0_c_irq_edge_type */
	/* skip, unused field unused_irq_edge (irq_edge) */
	REG_DUMP_PRINT_1("   -irq_edge.irq_edge                        |     0x%05X  |  [RW][16:00]""Indicates for each bit whether an interrupt request should be generated on a falling edge (value='0') or a rising edge (value='1').""\n", FIELD_VALUE(val, 0, 16));
} /* end irq_ctrl0_c */

/* Generated Debug Code: Device irq_ctrl_c */
void ia_css_debug_dump_irq_ctrl_c(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x66414);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_c.irq_level_not_pulse             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl_c_irq_level_not_pulse_type */
	/* skip, unused field unused_irq_level_not_pulse (irq_level_not_pulse) */
	REG_DUMP_PRINT_1("   -irq_level_not_pulse.irq_level_not_pulse  |     0x%05X  |  [RW][18:00]""Indicates for each bit whether an interrupt cause is translated into a pulse (value='0') or into a constant level '1' (value='1') on the IRQ pin.""\n", FIELD_VALUE(val, 0, 18));
	val = REG_DUMP_READ_REGISTER(0x66410);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_c.irq_enable                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl_c_irq_enable_type */
	/* skip, unused field unused_irq_enable (irq_enable) */
	REG_DUMP_PRINT_1("   -irq_enable.irq_enable                    |     0x%05X  |  [RW][18:00]""Indicates for each bit whether an interrupt cause as monitored by the req_irq_status register also affects the IRQ pin (value='1') or not (value='0').""\n", FIELD_VALUE(val, 0, 18));
	val = REG_DUMP_READ_REGISTER(0x66408);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_c.irq_status                      |  0x%08X  |  ""Indicates for each bit whether a non-masked interrupt has been generated (value='1'). Can be cleared by writing a '1' into the the corresponding bit of the req_irq_clear register.""\n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl_c_irq_status_type */
	/* skip, unused field unused_irq_status (irq_status) */
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_0             |         0x%01X  |  [RO][00:00]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_1             |         0x%01X  |  [RO][01:01]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_2             |         0x%01X  |  [RO][02:02]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_3             |         0x%01X  |  [RO][03:03]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_4             |         0x%01X  |  [RO][04:04]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_5             |         0x%01X  |  [RO][05:05]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_6             |         0x%01X  |  [RO][06:06]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_7             |         0x%01X  |  [RO][07:07]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_8             |         0x%01X  |  [RO][08:08]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_9             |         0x%01X  |  [RO][09:09]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_10            |         0x%01X  |  [RO][10:10]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_11            |         0x%01X  |  [RO][11:11]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_12            |         0x%01X  |  [RO][12:12]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 12, 12));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_13            |         0x%01X  |  [RO][13:13]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 13, 13));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_14            |         0x%01X  |  [RO][14:14]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 14, 14));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_15            |         0x%01X  |  [RO][15:15]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 15, 15));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX               |         0x%01X  |  [RO][16:16]""Represents the status of the irq from irq_ctrl0 (csi_rx irqs).""\n", FIELD_VALUE(val, 16, 16));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M                  |         0x%01X  |  [RO][17:17]""Represents the status of the irq from irq_ctrl1 (csi__rx_synchronization_irqs + s2m_irqs).""\n", FIELD_VALUE(val, 17, 17));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_SM                   |         0x%01X  |  [RO][18:18]""Represents the status of the irq from Stream Monitor.""\n", FIELD_VALUE(val, 18, 18));
	val = REG_DUMP_READ_REGISTER(0x66404);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_c.irq_mask                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl_c_irq_mask_type */
	/* skip, unused field unused_irq_mask (irq_mask) */
	REG_DUMP_PRINT_1("   -irq_mask.irq_mask                        |     0x%05X  |  [RW][18:00]""Indicates for each bit of irq_di whether it can generate an interrupt request (value='1') or not (value='0'). Setting will affect irq_value as well as IRQ output pin.""\n", FIELD_VALUE(val, 0, 18));
	val = REG_DUMP_READ_REGISTER(0x66400);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_c.irq_edge                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl_c_irq_edge_type */
	/* skip, unused field unused_irq_edge (irq_edge) */
	REG_DUMP_PRINT_1("   -irq_edge.irq_edge                        |     0x%05X  |  [RW][18:00]""Indicates for each bit whether an interrupt request should be generated on a falling edge (value='0') or a rising edge (value='1').""\n", FIELD_VALUE(val, 0, 18));
} /* end irq_ctrl_c */

/* Generated Debug Code: Device csi_rx_c */
void ia_css_debug_dump_csi_rx_c(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x66040);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_c.reg_rx_csi_dly_cnt_settle_dlane1                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_c_reg_rx_csi_dly_cnt_settle_dlane1_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_settle_dlane1 (reg_rx_csi_dly_cnt_settle_dlane1) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_settle_dlane1.reg_rx_csi_dly_cnt_settle_dlane1  |    0x%06X  |  [RW][23:00]""Specify the Delay value for Settling time of Data lane 1 HS Rx data.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6603c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_c.reg_rx_csi_dly_cnt_termen_dlane1                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_c_reg_rx_csi_dly_cnt_termen_dlane1_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_termen_dlane1 (reg_rx_csi_dly_cnt_termen_dlane1) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_termen_dlane1.reg_rx_csi_dly_cnt_termen_dlane1  |    0x%06X  |  [RW][23:00]""Specify the Delay value for Termination enable of Data lane 1 HS Rx.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x66038);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_c.reg_rx_csi_dly_cnt_settle_dlane0                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_c_reg_rx_csi_dly_cnt_settle_dlane0_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_settle_dlane0 (reg_rx_csi_dly_cnt_settle_dlane0) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_settle_dlane0.reg_rx_csi_dly_cnt_settle_dlane0  |    0x%06X  |  [RW][23:00]""Specify the Delay value for Settling time of Data lane 0 HS Rx data.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x66034);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_c.reg_rx_csi_dly_cnt_termen_dlane0                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_c_reg_rx_csi_dly_cnt_termen_dlane0_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_termen_dlane0 (reg_rx_csi_dly_cnt_termen_dlane0) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_termen_dlane0.reg_rx_csi_dly_cnt_termen_dlane0  |    0x%06X  |  [RW][23:00]""Specify the Delay value for Termination enable of Data lane 0 HS Rx.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x66030);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_c.reg_rx_csi_dly_cnt_settle_clane                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_c_reg_rx_csi_dly_cnt_settle_clane_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_settle_clane (reg_rx_csi_dly_cnt_settle_clane) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_settle_clane.reg_rx_csi_dly_cnt_settle_clane    |    0x%06X  |  [RW][23:00]""Specify the Delay value for HS Settling time of Clock lane HS Rx data.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6602c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_c.reg_rx_csi_dly_cnt_termen_clane                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_c_reg_rx_csi_dly_cnt_termen_clane_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_termen_clane (reg_rx_csi_dly_cnt_termen_clane) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_termen_clane.reg_rx_csi_dly_cnt_termen_clane    |    0x%06X  |  [RW][23:00]""Specify the Delay value for Termination enable of Clock lane HS Rx.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x66028);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_c.reg_rx_csi_status_dlane_lp                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_c_reg_rx_csi_status_dlane_lp_type */
	/* skip, unused field unused_reg_rx_csi_status_dlane_lp (reg_rx_csi_status_dlane_lp) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_status_dlane_lp.reg_rx_csi_status_dlane_lp              |    0x%06X  |  [RW][23:00]""Status register for low power communication errors and events (Escape mode (errors), trigger events)                    This is an edge triggered status register which bits can be cleared via writing.                   Reading:                    Error entering escape mode:                    Bit.0 =LP Esc Error Dlane-0                    Bit.1 =LP Esc Error Dlane-1                    Bit.2 =LP Esc Error Dlane-2                    Bit.3 =LP Esc Error Dlane-3                    Low power events, refer to REF-2 DPHY MAS, section 4.3.2 for detailed information:                    Bit.4 =LP TriggerEsc0 (Rst) Dlane-0                    Bit.5 =LP TriggerEsc1 (Unk3) Dlane-0                    Bit.6 =LP TriggerEsc2 (Unk4) Dlane-0                    Bit.7 =LP TriggerEsc3 (Unk5) Dlane-0                    Bit.8 =LP TriggerEsc0 (Rst) Dlane-1                    Bit.9 =LP TriggerEsc1 (Unk3) Dlane-1                    Bit.10 =LP TriggerEsc2 (Unk4) Dlane-1                    Bit.11 =LP TriggerEsc3 (Unk5) Dlane-1                    Bit.12 =LP TriggerEsc0 (Rst) Dlane-2                    Bit.13 =LP TriggerEsc1 (Unk3) Dlane-2                    Bit.14 =LP TriggerEsc2 (Unk4) Dlane-2                    Bit.15 =LP TriggerEsc3 (Unk5) Dlane-2                    Bit.16 =LP TriggerEsc0 (Rst) Dlane-3                    Bit.17 =LP TriggerEsc1 (Unk3) Dlane-3                    Bit.18 =LP TriggerEsc2 (Unk4) Dlane-3                    Bit.19 =LP TriggerEsc3 (Unk5) Dlane-3                    Bit.20 =LP UlpsEsc Dlane-0                    Bit.21 =LP UlpsEsc Dlane-1                    Bit.22 =LP UlpsEsc Dlane-2                    Bit.23 =LP UlpsEsc Dlane-3                    Writing:                    Writing a '1' to a particular bit clears that bit.                    Eg.                    Writing 0x1 clears bit.0                    Writing 0x3 clears bit.0 and bit.1                    Etc.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x66024);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_c.reg_rx_csi_status_dlane_hs                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_c_reg_rx_csi_status_dlane_hs_type */
	/* skip, unused field unused_reg_rx_csi_status_dlane_hs (reg_rx_csi_status_dlane_hs) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_status_dlane_hs.reg_rx_csi_status_dlane_hs              |        0x%02X  |  [RW][07:00]""Status register for high speed communication errors (single bit, multiple bit errors in sync pattern)                    This is an edge triggered status register which bits can be cleared via writing.                    Reading:                    DPHY recoverable sync errors (single bit error):                     Bit.0 =HS SOT Error Dlane-0                    Bit.1 =HS SOT Error Dlane-1                    Bit.2 =HS SOT Error Dlane-2                    Bit.3 =HS SOT Error Dlane-3                    DPHY NON-recoverable sync errors (multiple bit error):                    Bit.4 =HS SOT Sync Error Dlane-0                    Bit.5 =HS SOT Sync Error Dlane-1                    Bit.6 =HS SOT Sync Error Dlane-2                    Bit.7 =HS SOT Sync Error Dlane-3                    Writing:                    Writing a '1' to a particular bit clears that bit.                    Eg.                   Writing 0x1 clears bit.0                    Writing 0x3 clears bit.0 and bit.1                    Etc. ""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0x66020);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_c.reg_rx_csi_status                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_c_reg_rx_csi_status_type */
	/* skip, unused field unused_reg_rx_csi_status (reg_rx_csi_status) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_status.reg_rx_csi_status                                |         0x%01X  |  [RO][01:00]""Status register.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x6601c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_c.reg_rx_csi_lp_if_config                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_c_reg_rx_csi_lp_if_config_type */
	/* skip, unused field unused_reg_rx_csi_lp_if_config (reg_rx_csi_lp_if_config) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_lp_if_config.reg_rx_csi_lp_if_config                    |         0x%01X  |  [RW][02:00]""Long packet inter-frame configuration register (error type 8a)                    bit[1:0]                    00 = filter out all long packets in between frames, no error is communicated (only via IRQ)                    01 = filter out inter-frame long packets while VC is inactive, pass when active                    10 = always pass                    11 = reserved/not used                    bit[2]                    0 = no error flag + code added to passed packet                    1 = error flag + code added to passed packet""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x66018);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_c.reg_rx_csi_sp_if_config                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_c_reg_rx_csi_sp_if_config_type */
	/* skip, unused field unused_reg_rx_csi_sp_if_config (reg_rx_csi_sp_if_config) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_sp_if_config.reg_rx_csi_sp_if_config                    |         0x%01X  |  [RW][02:00]""Short packet inter-frame configuration register (error type 8a)                    bit[1:0]                    00 = filter out all short packets in between frames, no error is communicated (only via IRQ)                    01 = filter out inter-frame short packets while VC is inactive, pass when active                    10 = always pass                    11 = reserved/not used                    bit[2]                    0 = no error flag + code added to passed packet                    1 = error flag + code added to passed packet""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x66014);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_c.reg_rx_csi_sync_cntr_sel                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_c_reg_rx_csi_sync_cntr_sel_type */
	/* skip, unused field unused_reg_rx_csi_sync_cntr_sel (reg_rx_csi_sync_cntr_sel) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_sync_cntr_sel.reg_rx_csi_sync_cntr_sel                  |         0x%01X  |  [RW][01:00]""Sync counter select register. 		               bit 0 => 0: Use internal counter for line start and line end packet IDs.                          => 1: Use line start and line end ID as send by sensor 									 bit 1 => 0: Use internal counter for frame start and frame end packet IDs.                          => 1: Use frame start and frame end ID as send by sensor""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x66010);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_c.reg_rx_csi_error_handling                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_c_reg_rx_csi_error_handling_type */
	/* skip, unused field unused_reg_rx_csi_error_handling (reg_rx_csi_error_handling) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_error_handling.reg_rx_csi_error_handling                |        0x%02X  |  [RW][04:00]""Error handling register. 		               bit 0 = when set, packets with more than one erro in packet header 									  			 are discarded. 									 bit 1 = when set, a short packet with reserved id is discarded and irq 									  			 is raised 									 bit 2 = when set, a long packet with reserved id is discarded and irq 									  			 is raised 		               bit 3 = when set, detection of incomplete packet is disabled, irq will 									         not be generated""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0x6600c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_c.reg_rx_csi_hbp_testmode_enable                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_c_reg_rx_csi_hbp_testmode_enable_type */
	/* skip, unused field unused_reg_rx_csi_hbp_testmode_enable (reg_rx_csi_hbp_testmode_enable) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_hbp_testmode_enable.reg_rx_csi_hbp_testmode_enable      |         0x%01X  |  [RW][00:00]""HBP test mode enable register of CSI RX.                    0 = Normal mode(DPHY receives HS data and byte clock from AFE), 									 1 = HBP test mode (DPHY receives HS data and byte clock via TESTER GPIOs),                   ""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x66008);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_c.reg_rx_csi_control                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_c_reg_rx_csi_control_type */
	/* skip, unused field unused_reg_rx_csi_control (reg_rx_csi_control) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_control.reg_rx_csi_control                              |       0x%03X  |  [RW][10:00]""Control register CSI RX.                    bit 0 = release_lp11 									 bit 1 = disable_byte_clk_gating,                   ""\n", FIELD_VALUE(val, 0, 10));
	val = REG_DUMP_READ_REGISTER(0x66004);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_c.reg_rx_csi_nof_enabled_lanes                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_c_reg_rx_csi_nof_enabled_lanes_type */
	/* skip, unused field unused_reg_rx_csi_nof_enabled_lanes (reg_rx_csi_nof_enabled_lanes) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_nof_enabled_lanes.reg_rx_csi_nof_enabled_lanes          |         0x%01X  |  [RW][02:00]""Specify Number of enabled data lanes of CSI RX.                    0 = No lanes enabled 									 1 = One   lane  enabled,                    2 = Two   lanes enabled,                    3 = Three lanes enabled,                    4 = Four  lanes enabled,                   ""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x66000);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_c.reg_rx_csi_enable                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_c_reg_rx_csi_enable_type */
	/* skip, unused field unused_reg_rx_csi_enable (reg_rx_csi_enable) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_enable.reg_rx_csi_enable                                |         0x%01X  |  [RW][00:00]""Enable CSI RX""\n", FIELD_VALUE(val, 0, 0));
} /* end csi_rx_c */

/* Generated Debug Code: Device gpr_b */
void ia_css_debug_dump_gpr_b(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x6cf08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpr_b.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX                                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_gpr_b_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX_type */
	/* skip, unused field unused_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX (csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX) */
	REG_DUMP_PRINT_1("   -csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX  |       0x%03X  |  [RW][10:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 10));
	val = REG_DUMP_READ_REGISTER(0x6cf04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpr_b.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX                                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_gpr_b_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX_type */
	/* skip, unused field unused_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX (csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX) */
	REG_DUMP_PRINT_1("   -csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX      |    0x%06X  |  [RW][21:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 21));
	val = REG_DUMP_READ_REGISTER(0x6cf00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpr_b.str_mon_status                                                                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_gpr_b_str_mon_status_type */
	REG_DUMP_PRINT_1("   -str_mon_status.str_mon_status                                                                                        |  0x%08X  |  [RO][31:00]""Streaming Monitor Status, [accept,valid] of streaming port""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x65708);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpr_b.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX                                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_gpr_b_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX_type */
	/* skip, unused field unused_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX (csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX) */
	REG_DUMP_PRINT_1("   -csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX  |       0x%03X  |  [RW][10:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 10));
	val = REG_DUMP_READ_REGISTER(0x65704);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpr_b.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX                                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_gpr_b_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX_type */
	/* skip, unused field unused_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX (csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX) */
	REG_DUMP_PRINT_1("   -csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX      |    0x%06X  |  [RW][21:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 21));
	val = REG_DUMP_READ_REGISTER(0x65700);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpr_b.str_mon_status                                                                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_gpr_b_str_mon_status_type */
	REG_DUMP_PRINT_1("   -str_mon_status.str_mon_status                                                                                        |  0x%08X  |  [RO][31:00]""Streaming Monitor Status, [accept,valid] of streaming port""\n", FIELD_VALUE(val, 0, 31));
} /* end gpr_b */

/* Generated Debug Code: Device irq_ctrl1_b */
void ia_css_debug_dump_irq_ctrl1_b(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x6ce14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl1_b.irq_level_not_pulse            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl1_b_irq_level_not_pulse_type */
	/* skip, unused field unused_irq_level_not_pulse (irq_level_not_pulse) */
	REG_DUMP_PRINT_1("   -irq_level_not_pulse.irq_level_not_pulse  |       0x%03X  |  [RW][11:00]""Indicates for each bit whether an interrupt cause is translated into a pulse (value='0') or into a constant level '1' (value='1') on the IRQ pin.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x6ce10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl1_b.irq_enable                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl1_b_irq_enable_type */
	/* skip, unused field unused_irq_enable (irq_enable) */
	REG_DUMP_PRINT_1("   -irq_enable.irq_enable                    |       0x%03X  |  [RW][11:00]""Indicates for each bit whether an interrupt cause as monitored by the req_irq_status register also affects the IRQ pin (value='1') or not (value='0').""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x6ce08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl1_b.irq_status                     |  0x%08X  |  ""Indicates for each bit whether a non-masked interrupt has been generated (value='1'). Can be cleared by writing a '1' into the the corresponding bit of the req_irq_clear register.""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl1_b_irq_status_type */
	/* skip, unused field unused_irq_status (irq_status) */
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_0                |         0x%01X  |  [RO][00:00]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_1                |         0x%01X  |  [RO][01:01]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_2                |         0x%01X  |  [RO][02:02]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_3                |         0x%01X  |  [RO][03:03]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_4                |         0x%01X  |  [RO][04:04]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_5                |         0x%01X  |  [RO][05:05]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_6                |         0x%01X  |  [RO][06:06]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_7                |         0x%01X  |  [RO][07:07]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_8                |         0x%01X  |  [RO][08:08]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_9                |         0x%01X  |  [RO][09:09]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_10               |         0x%01X  |  [RO][10:10]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_11               |         0x%01X  |  [RO][11:11]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 11, 11));
	val = REG_DUMP_READ_REGISTER(0x6ce04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl1_b.irq_mask                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl1_b_irq_mask_type */
	/* skip, unused field unused_irq_mask (irq_mask) */
	REG_DUMP_PRINT_1("   -irq_mask.irq_mask                        |       0x%03X  |  [RW][11:00]""Indicates for each bit of irq_di whether it can generate an interrupt request (value='1') or not (value='0'). Setting will affect irq_value as well as IRQ output pin.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x6ce00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl1_b.irq_edge                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl1_b_irq_edge_type */
	/* skip, unused field unused_irq_edge (irq_edge) */
	REG_DUMP_PRINT_1("   -irq_edge.irq_edge                        |       0x%03X  |  [RW][11:00]""Indicates for each bit whether an interrupt request should be generated on a falling edge (value='0') or a rising edge (value='1').""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x65614);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl1_b.irq_level_not_pulse            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl1_b_irq_level_not_pulse_type */
	/* skip, unused field unused_irq_level_not_pulse (irq_level_not_pulse) */
	REG_DUMP_PRINT_1("   -irq_level_not_pulse.irq_level_not_pulse  |       0x%03X  |  [RW][11:00]""Indicates for each bit whether an interrupt cause is translated into a pulse (value='0') or into a constant level '1' (value='1') on the IRQ pin.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x65610);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl1_b.irq_enable                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl1_b_irq_enable_type */
	/* skip, unused field unused_irq_enable (irq_enable) */
	REG_DUMP_PRINT_1("   -irq_enable.irq_enable                    |       0x%03X  |  [RW][11:00]""Indicates for each bit whether an interrupt cause as monitored by the req_irq_status register also affects the IRQ pin (value='1') or not (value='0').""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x65608);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl1_b.irq_status                     |  0x%08X  |  ""Indicates for each bit whether a non-masked interrupt has been generated (value='1'). Can be cleared by writing a '1' into the the corresponding bit of the req_irq_clear register.""\n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl1_b_irq_status_type */
	/* skip, unused field unused_irq_status (irq_status) */
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_0                |         0x%01X  |  [RO][00:00]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_1                |         0x%01X  |  [RO][01:01]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_2                |         0x%01X  |  [RO][02:02]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_3                |         0x%01X  |  [RO][03:03]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_4                |         0x%01X  |  [RO][04:04]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_5                |         0x%01X  |  [RO][05:05]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_6                |         0x%01X  |  [RO][06:06]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_7                |         0x%01X  |  [RO][07:07]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_8                |         0x%01X  |  [RO][08:08]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_9                |         0x%01X  |  [RO][09:09]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_10               |         0x%01X  |  [RO][10:10]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_11               |         0x%01X  |  [RO][11:11]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 11, 11));
	val = REG_DUMP_READ_REGISTER(0x65604);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl1_b.irq_mask                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl1_b_irq_mask_type */
	/* skip, unused field unused_irq_mask (irq_mask) */
	REG_DUMP_PRINT_1("   -irq_mask.irq_mask                        |       0x%03X  |  [RW][11:00]""Indicates for each bit of irq_di whether it can generate an interrupt request (value='1') or not (value='0'). Setting will affect irq_value as well as IRQ output pin.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x65600);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl1_b.irq_edge                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl1_b_irq_edge_type */
	/* skip, unused field unused_irq_edge (irq_edge) */
	REG_DUMP_PRINT_1("   -irq_edge.irq_edge                        |       0x%03X  |  [RW][11:00]""Indicates for each bit whether an interrupt request should be generated on a falling edge (value='0') or a rising edge (value='1').""\n", FIELD_VALUE(val, 0, 11));
} /* end irq_ctrl1_b */

/* Generated Debug Code: Device irq_ctrl0_b */
void ia_css_debug_dump_irq_ctrl0_b(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x6cd14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_b.irq_level_not_pulse            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl0_b_irq_level_not_pulse_type */
	/* skip, unused field unused_irq_level_not_pulse (irq_level_not_pulse) */
	REG_DUMP_PRINT_1("   -irq_level_not_pulse.irq_level_not_pulse  |     0x%05X  |  [RW][16:00]""Indicates for each bit whether an interrupt cause is translated into a pulse (value='0') or into a constant level '1' (value='1') on the IRQ pin.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0x6cd10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_b.irq_enable                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl0_b_irq_enable_type */
	/* skip, unused field unused_irq_enable (irq_enable) */
	REG_DUMP_PRINT_1("   -irq_enable.irq_enable                    |     0x%05X  |  [RW][16:00]""Indicates for each bit whether an interrupt cause as monitored by the req_irq_status register also affects the IRQ pin (value='1') or not (value='0').""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0x6cd08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_b.irq_status                     |  0x%08X  |  ""Indicates for each bit whether a non-masked interrupt has been generated (value='1'). Can be cleared by writing a '1' into the the corresponding bit of the req_irq_clear register.""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl0_b_irq_status_type */
	/* skip, unused field unused_irq_status (irq_status) */
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_0                 |         0x%01X  |  [RO][00:00]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_1                 |         0x%01X  |  [RO][01:01]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_2                 |         0x%01X  |  [RO][02:02]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_3                 |         0x%01X  |  [RO][03:03]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_4                 |         0x%01X  |  [RO][04:04]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_5                 |         0x%01X  |  [RO][05:05]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_6                 |         0x%01X  |  [RO][06:06]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_7                 |         0x%01X  |  [RO][07:07]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_8                 |         0x%01X  |  [RO][08:08]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_9                 |         0x%01X  |  [RO][09:09]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_10                |         0x%01X  |  [RO][10:10]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_11                |         0x%01X  |  [RO][11:11]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_12                |         0x%01X  |  [RO][12:12]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 12, 12));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_13                |         0x%01X  |  [RO][13:13]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 13, 13));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_14                |         0x%01X  |  [RO][14:14]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 14, 14));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_15                |         0x%01X  |  [RO][15:15]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 15, 15));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_16                |         0x%01X  |  [RO][16:16]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 16, 16));
	val = REG_DUMP_READ_REGISTER(0x6cd04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_b.irq_mask                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl0_b_irq_mask_type */
	/* skip, unused field unused_irq_mask (irq_mask) */
	REG_DUMP_PRINT_1("   -irq_mask.irq_mask                        |     0x%05X  |  [RW][16:00]""Indicates for each bit of irq_di whether it can generate an interrupt request (value='1') or not (value='0'). Setting will affect irq_value as well as IRQ output pin.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0x6cd00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_b.irq_edge                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl0_b_irq_edge_type */
	/* skip, unused field unused_irq_edge (irq_edge) */
	REG_DUMP_PRINT_1("   -irq_edge.irq_edge                        |     0x%05X  |  [RW][16:00]""Indicates for each bit whether an interrupt request should be generated on a falling edge (value='0') or a rising edge (value='1').""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0x65514);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_b.irq_level_not_pulse            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl0_b_irq_level_not_pulse_type */
	/* skip, unused field unused_irq_level_not_pulse (irq_level_not_pulse) */
	REG_DUMP_PRINT_1("   -irq_level_not_pulse.irq_level_not_pulse  |     0x%05X  |  [RW][16:00]""Indicates for each bit whether an interrupt cause is translated into a pulse (value='0') or into a constant level '1' (value='1') on the IRQ pin.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0x65510);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_b.irq_enable                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl0_b_irq_enable_type */
	/* skip, unused field unused_irq_enable (irq_enable) */
	REG_DUMP_PRINT_1("   -irq_enable.irq_enable                    |     0x%05X  |  [RW][16:00]""Indicates for each bit whether an interrupt cause as monitored by the req_irq_status register also affects the IRQ pin (value='1') or not (value='0').""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0x65508);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_b.irq_status                     |  0x%08X  |  ""Indicates for each bit whether a non-masked interrupt has been generated (value='1'). Can be cleared by writing a '1' into the the corresponding bit of the req_irq_clear register.""\n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl0_b_irq_status_type */
	/* skip, unused field unused_irq_status (irq_status) */
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_0             |         0x%01X  |  [RO][00:00]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_1             |         0x%01X  |  [RO][01:01]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_2             |         0x%01X  |  [RO][02:02]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_3             |         0x%01X  |  [RO][03:03]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_4             |         0x%01X  |  [RO][04:04]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_5             |         0x%01X  |  [RO][05:05]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_6             |         0x%01X  |  [RO][06:06]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_7             |         0x%01X  |  [RO][07:07]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_8             |         0x%01X  |  [RO][08:08]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_9             |         0x%01X  |  [RO][09:09]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_10            |         0x%01X  |  [RO][10:10]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_11            |         0x%01X  |  [RO][11:11]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_12            |         0x%01X  |  [RO][12:12]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 12, 12));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_13            |         0x%01X  |  [RO][13:13]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 13, 13));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_14            |         0x%01X  |  [RO][14:14]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 14, 14));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_15            |         0x%01X  |  [RO][15:15]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 15, 15));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_16            |         0x%01X  |  [RO][16:16]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 16, 16));
	val = REG_DUMP_READ_REGISTER(0x65504);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_b.irq_mask                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl0_b_irq_mask_type */
	/* skip, unused field unused_irq_mask (irq_mask) */
	REG_DUMP_PRINT_1("   -irq_mask.irq_mask                        |     0x%05X  |  [RW][16:00]""Indicates for each bit of irq_di whether it can generate an interrupt request (value='1') or not (value='0'). Setting will affect irq_value as well as IRQ output pin.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0x65500);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_b.irq_edge                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl0_b_irq_edge_type */
	/* skip, unused field unused_irq_edge (irq_edge) */
	REG_DUMP_PRINT_1("   -irq_edge.irq_edge                        |     0x%05X  |  [RW][16:00]""Indicates for each bit whether an interrupt request should be generated on a falling edge (value='0') or a rising edge (value='1').""\n", FIELD_VALUE(val, 0, 16));
} /* end irq_ctrl0_b */

/* Generated Debug Code: Device irq_ctrl_b */
void ia_css_debug_dump_irq_ctrl_b(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x6cc14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_b.irq_level_not_pulse             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl_b_irq_level_not_pulse_type */
	/* skip, unused field unused_irq_level_not_pulse (irq_level_not_pulse) */
	REG_DUMP_PRINT_1("   -irq_level_not_pulse.irq_level_not_pulse  |     0x%05X  |  [RW][18:00]""Indicates for each bit whether an interrupt cause is translated into a pulse (value='0') or into a constant level '1' (value='1') on the IRQ pin.""\n", FIELD_VALUE(val, 0, 18));
	val = REG_DUMP_READ_REGISTER(0x6cc10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_b.irq_enable                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl_b_irq_enable_type */
	/* skip, unused field unused_irq_enable (irq_enable) */
	REG_DUMP_PRINT_1("   -irq_enable.irq_enable                    |     0x%05X  |  [RW][18:00]""Indicates for each bit whether an interrupt cause as monitored by the req_irq_status register also affects the IRQ pin (value='1') or not (value='0').""\n", FIELD_VALUE(val, 0, 18));
	val = REG_DUMP_READ_REGISTER(0x6cc08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_b.irq_status                      |  0x%08X  |  ""Indicates for each bit whether a non-masked interrupt has been generated (value='1'). Can be cleared by writing a '1' into the the corresponding bit of the req_irq_clear register.""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl_b_irq_status_type */
	/* skip, unused field unused_irq_status (irq_status) */
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_0                 |         0x%01X  |  [RO][00:00]""Represents the status of the irq from  csi_rx_ irqs sync.""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_1                 |         0x%01X  |  [RO][01:01]""Represents the status of the irq from  csi_rx_ irqs sync.""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_2                 |         0x%01X  |  [RO][02:02]""Represents the status of the irq from  csi_rx_ irqs sync.""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_3                 |         0x%01X  |  [RO][03:03]""Represents the status of the irq from  csi_rx_ irqs sync.""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_4                 |         0x%01X  |  [RO][04:04]""Represents the status of the irq from  csi_rx_ irqs sync.""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_5                 |         0x%01X  |  [RO][05:05]""Represents the status of the irq from  csi_rx_ irqs sync.""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_6                 |         0x%01X  |  [RO][06:06]""Represents the status of the irq from  csi_rx_ irqs sync.""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_7                 |         0x%01X  |  [RO][07:07]""Represents the status of the irq from  csi_rx_ irqs sync.""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_8                 |         0x%01X  |  [RO][08:08]""Represents the status of the irq from  csi_rx_ irqs sync.""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_9                 |         0x%01X  |  [RO][09:09]""Represents the status of the irq from  csi_rx_ irqs sync.""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_10                |         0x%01X  |  [RO][10:10]""Represents the status of the irq from  csi_rx_ irqs sync.""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_11                |         0x%01X  |  [RO][11:11]""Represents the status of the irq from  csi_rx_ irqs sync.""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_12                |         0x%01X  |  [RO][12:12]""Represents the status of the irq from  csi_rx_ irqs sync.""\n", FIELD_VALUE(val, 12, 12));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_13                |         0x%01X  |  [RO][13:13]""Represents the status of the irq from  csi_rx_ irqs sync.""\n", FIELD_VALUE(val, 13, 13));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_14                |         0x%01X  |  [RO][14:14]""Represents the status of the irq from  csi_rx_ irqs sync.""\n", FIELD_VALUE(val, 14, 14));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_15                |         0x%01X  |  [RO][15:15]""Represents the status of the irq from  csi_rx_ irqs sync.""\n", FIELD_VALUE(val, 15, 15));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX                   |         0x%01X  |  [RO][16:16]""Represents the status of the irq from irq_ctrl0 (csi_rx irqs).""\n", FIELD_VALUE(val, 16, 16));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M                  |         0x%01X  |  [RO][17:17]""Represents the status of the irq from irq_ctrl1 (csi__rx_synchronization_irqs + s2m_irqs).""\n", FIELD_VALUE(val, 17, 17));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_SM                   |         0x%01X  |  [RO][18:18]""Represents the status of the irq from Stream Monitor.""\n", FIELD_VALUE(val, 18, 18));
	val = REG_DUMP_READ_REGISTER(0x6cc04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_b.irq_mask                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl_b_irq_mask_type */
	/* skip, unused field unused_irq_mask (irq_mask) */
	REG_DUMP_PRINT_1("   -irq_mask.irq_mask                        |     0x%05X  |  [RW][18:00]""Indicates for each bit of irq_di whether it can generate an interrupt request (value='1') or not (value='0'). Setting will affect irq_value as well as IRQ output pin.""\n", FIELD_VALUE(val, 0, 18));
	val = REG_DUMP_READ_REGISTER(0x6cc00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_b.irq_edge                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl_b_irq_edge_type */
	/* skip, unused field unused_irq_edge (irq_edge) */
	REG_DUMP_PRINT_1("   -irq_edge.irq_edge                        |     0x%05X  |  [RW][18:00]""Indicates for each bit whether an interrupt request should be generated on a falling edge (value='0') or a rising edge (value='1').""\n", FIELD_VALUE(val, 0, 18));
	val = REG_DUMP_READ_REGISTER(0x65414);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_b.irq_level_not_pulse             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl_b_irq_level_not_pulse_type */
	/* skip, unused field unused_irq_level_not_pulse (irq_level_not_pulse) */
	REG_DUMP_PRINT_1("   -irq_level_not_pulse.irq_level_not_pulse  |     0x%05X  |  [RW][18:00]""Indicates for each bit whether an interrupt cause is translated into a pulse (value='0') or into a constant level '1' (value='1') on the IRQ pin.""\n", FIELD_VALUE(val, 0, 18));
	val = REG_DUMP_READ_REGISTER(0x65410);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_b.irq_enable                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl_b_irq_enable_type */
	/* skip, unused field unused_irq_enable (irq_enable) */
	REG_DUMP_PRINT_1("   -irq_enable.irq_enable                    |     0x%05X  |  [RW][18:00]""Indicates for each bit whether an interrupt cause as monitored by the req_irq_status register also affects the IRQ pin (value='1') or not (value='0').""\n", FIELD_VALUE(val, 0, 18));
	val = REG_DUMP_READ_REGISTER(0x65408);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_b.irq_status                      |  0x%08X  |  ""Indicates for each bit whether a non-masked interrupt has been generated (value='1'). Can be cleared by writing a '1' into the the corresponding bit of the req_irq_clear register.""\n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl_b_irq_status_type */
	/* skip, unused field unused_irq_status (irq_status) */
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_0             |         0x%01X  |  [RO][00:00]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_1             |         0x%01X  |  [RO][01:01]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_2             |         0x%01X  |  [RO][02:02]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_3             |         0x%01X  |  [RO][03:03]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_4             |         0x%01X  |  [RO][04:04]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_5             |         0x%01X  |  [RO][05:05]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_6             |         0x%01X  |  [RO][06:06]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_7             |         0x%01X  |  [RO][07:07]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_8             |         0x%01X  |  [RO][08:08]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_9             |         0x%01X  |  [RO][09:09]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_10            |         0x%01X  |  [RO][10:10]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_11            |         0x%01X  |  [RO][11:11]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_12            |         0x%01X  |  [RO][12:12]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 12, 12));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_13            |         0x%01X  |  [RO][13:13]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 13, 13));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_14            |         0x%01X  |  [RO][14:14]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 14, 14));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_15            |         0x%01X  |  [RO][15:15]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 15, 15));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX               |         0x%01X  |  [RO][16:16]""Represents the status of the irq from irq_ctrl0 (csi_rx irqs).""\n", FIELD_VALUE(val, 16, 16));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M                  |         0x%01X  |  [RO][17:17]""Represents the status of the irq from irq_ctrl1 (csi__rx_synchronization_irqs + s2m_irqs).""\n", FIELD_VALUE(val, 17, 17));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_SM                   |         0x%01X  |  [RO][18:18]""Represents the status of the irq from Stream Monitor.""\n", FIELD_VALUE(val, 18, 18));
	val = REG_DUMP_READ_REGISTER(0x65404);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_b.irq_mask                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl_b_irq_mask_type */
	/* skip, unused field unused_irq_mask (irq_mask) */
	REG_DUMP_PRINT_1("   -irq_mask.irq_mask                        |     0x%05X  |  [RW][18:00]""Indicates for each bit of irq_di whether it can generate an interrupt request (value='1') or not (value='0'). Setting will affect irq_value as well as IRQ output pin.""\n", FIELD_VALUE(val, 0, 18));
	val = REG_DUMP_READ_REGISTER(0x65400);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_b.irq_edge                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl_b_irq_edge_type */
	/* skip, unused field unused_irq_edge (irq_edge) */
	REG_DUMP_PRINT_1("   -irq_edge.irq_edge                        |     0x%05X  |  [RW][18:00]""Indicates for each bit whether an interrupt request should be generated on a falling edge (value='0') or a rising edge (value='1').""\n", FIELD_VALUE(val, 0, 18));
} /* end irq_ctrl_b */

/* Generated Debug Code: Device csi_rx_b */
void ia_css_debug_dump_csi_rx_b(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x6c840);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_b.reg_rx_csi_dly_cnt_settle_dlane1                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_b_reg_rx_csi_dly_cnt_settle_dlane1_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_settle_dlane1 (reg_rx_csi_dly_cnt_settle_dlane1) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_settle_dlane1.reg_rx_csi_dly_cnt_settle_dlane1  |    0x%06X  |  [RW][23:00]""Specify the Delay value for Settling time of Data lane 1 HS Rx data.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6c83c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_b.reg_rx_csi_dly_cnt_termen_dlane1                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_b_reg_rx_csi_dly_cnt_termen_dlane1_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_termen_dlane1 (reg_rx_csi_dly_cnt_termen_dlane1) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_termen_dlane1.reg_rx_csi_dly_cnt_termen_dlane1  |    0x%06X  |  [RW][23:00]""Specify the Delay value for Termination enable of Data lane 1 HS Rx.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6c838);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_b.reg_rx_csi_dly_cnt_settle_dlane0                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_b_reg_rx_csi_dly_cnt_settle_dlane0_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_settle_dlane0 (reg_rx_csi_dly_cnt_settle_dlane0) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_settle_dlane0.reg_rx_csi_dly_cnt_settle_dlane0  |    0x%06X  |  [RW][23:00]""Specify the Delay value for Settling time of Data lane 0 HS Rx data.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6c830);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_b.reg_rx_csi_dly_cnt_settle_clane                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_b_reg_rx_csi_dly_cnt_settle_clane_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_settle_clane (reg_rx_csi_dly_cnt_settle_clane) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_settle_clane.reg_rx_csi_dly_cnt_settle_clane    |    0x%06X  |  [RW][23:00]""Specify the Delay value for HS Settling time of Clock lane HS Rx data.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6c82c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_b.reg_rx_csi_dly_cnt_termen_clane                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_b_reg_rx_csi_dly_cnt_termen_clane_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_termen_clane (reg_rx_csi_dly_cnt_termen_clane) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_termen_clane.reg_rx_csi_dly_cnt_termen_clane    |    0x%06X  |  [RW][23:00]""Specify the Delay value for Termination enable of Clock lane HS Rx.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6c828);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_b.reg_rx_csi_status_dlane_lp                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_b_reg_rx_csi_status_dlane_lp_type */
	/* skip, unused field unused_reg_rx_csi_status_dlane_lp (reg_rx_csi_status_dlane_lp) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_status_dlane_lp.reg_rx_csi_status_dlane_lp              |    0x%06X  |  [RW][23:00]""Status register for low power communication errors and events (Escape mode (errors), trigger events)                    This is an edge triggered status register which bits can be cleared via writing.                   Reading:                    Error entering escape mode:                    Bit.0 =LP Esc Error Dlane-0                    Bit.1 =LP Esc Error Dlane-1                    Bit.2 =LP Esc Error Dlane-2                    Bit.3 =LP Esc Error Dlane-3                    Low power events, refer to REF-2 DPHY MAS, section 4.3.2 for detailed information:                    Bit.4 =LP TriggerEsc0 (Rst) Dlane-0                    Bit.5 =LP TriggerEsc1 (Unk3) Dlane-0                    Bit.6 =LP TriggerEsc2 (Unk4) Dlane-0                    Bit.7 =LP TriggerEsc3 (Unk5) Dlane-0                    Bit.8 =LP TriggerEsc0 (Rst) Dlane-1                    Bit.9 =LP TriggerEsc1 (Unk3) Dlane-1                    Bit.10 =LP TriggerEsc2 (Unk4) Dlane-1                    Bit.11 =LP TriggerEsc3 (Unk5) Dlane-1                    Bit.12 =LP TriggerEsc0 (Rst) Dlane-2                    Bit.13 =LP TriggerEsc1 (Unk3) Dlane-2                    Bit.14 =LP TriggerEsc2 (Unk4) Dlane-2                    Bit.15 =LP TriggerEsc3 (Unk5) Dlane-2                    Bit.16 =LP TriggerEsc0 (Rst) Dlane-3                    Bit.17 =LP TriggerEsc1 (Unk3) Dlane-3                    Bit.18 =LP TriggerEsc2 (Unk4) Dlane-3                    Bit.19 =LP TriggerEsc3 (Unk5) Dlane-3                    Bit.20 =LP UlpsEsc Dlane-0                    Bit.21 =LP UlpsEsc Dlane-1                    Bit.22 =LP UlpsEsc Dlane-2                    Bit.23 =LP UlpsEsc Dlane-3                    Writing:                    Writing a '1' to a particular bit clears that bit.                    Eg.                    Writing 0x1 clears bit.0                    Writing 0x3 clears bit.0 and bit.1                    Etc.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6c824);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_b.reg_rx_csi_status_dlane_hs                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_b_reg_rx_csi_status_dlane_hs_type */
	/* skip, unused field unused_reg_rx_csi_status_dlane_hs (reg_rx_csi_status_dlane_hs) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_status_dlane_hs.reg_rx_csi_status_dlane_hs              |        0x%02X  |  [RW][07:00]""Status register for high speed communication errors (single bit, multiple bit errors in sync pattern)                    This is an edge triggered status register which bits can be cleared via writing.                    Reading:                    DPHY recoverable sync errors (single bit error):                     Bit.0 =HS SOT Error Dlane-0                    Bit.1 =HS SOT Error Dlane-1                    Bit.2 =HS SOT Error Dlane-2                    Bit.3 =HS SOT Error Dlane-3                    DPHY NON-recoverable sync errors (multiple bit error):                    Bit.4 =HS SOT Sync Error Dlane-0                    Bit.5 =HS SOT Sync Error Dlane-1                    Bit.6 =HS SOT Sync Error Dlane-2                    Bit.7 =HS SOT Sync Error Dlane-3                    Writing:                    Writing a '1' to a particular bit clears that bit.                    Eg.                   Writing 0x1 clears bit.0                    Writing 0x3 clears bit.0 and bit.1                    Etc. ""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0x6c820);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_b.reg_rx_csi_status                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_b_reg_rx_csi_status_type */
	/* skip, unused field unused_reg_rx_csi_status (reg_rx_csi_status) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_status.reg_rx_csi_status                                |         0x%01X  |  [RO][01:00]""Status register.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x6c81c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_b.reg_rx_csi_lp_if_config                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_b_reg_rx_csi_lp_if_config_type */
	/* skip, unused field unused_reg_rx_csi_lp_if_config (reg_rx_csi_lp_if_config) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_lp_if_config.reg_rx_csi_lp_if_config                    |         0x%01X  |  [RW][02:00]""Long packet inter-frame configuration register (error type 8a)                    bit[1:0]                    00 = filter out all long packets in between frames, no error is communicated (only via IRQ)                    01 = filter out inter-frame long packets while VC is inactive, pass when active                    10 = always pass                    11 = reserved/not used                    bit[2]                    0 = no error flag + code added to passed packet                    1 = error flag + code added to passed packet""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x6c818);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_b.reg_rx_csi_sp_if_config                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_b_reg_rx_csi_sp_if_config_type */
	/* skip, unused field unused_reg_rx_csi_sp_if_config (reg_rx_csi_sp_if_config) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_sp_if_config.reg_rx_csi_sp_if_config                    |         0x%01X  |  [RW][02:00]""Short packet inter-frame configuration register (error type 8a)                    bit[1:0]                    00 = filter out all short packets in between frames, no error is communicated (only via IRQ)                    01 = filter out inter-frame short packets while VC is inactive, pass when active                    10 = always pass                    11 = reserved/not used                    bit[2]                    0 = no error flag + code added to passed packet                    1 = error flag + code added to passed packet""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x6c814);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_b.reg_rx_csi_sync_cntr_sel                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_b_reg_rx_csi_sync_cntr_sel_type */
	/* skip, unused field unused_reg_rx_csi_sync_cntr_sel (reg_rx_csi_sync_cntr_sel) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_sync_cntr_sel.reg_rx_csi_sync_cntr_sel                  |         0x%01X  |  [RW][01:00]""Sync counter select register. 		               bit 0 => 0: Use internal counter for line start and line end packet IDs.                          => 1: Use line start and line end ID as send by sensor 									 bit 1 => 0: Use internal counter for frame start and frame end packet IDs.                          => 1: Use frame start and frame end ID as send by sensor""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x6c810);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_b.reg_rx_csi_error_handling                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_b_reg_rx_csi_error_handling_type */
	/* skip, unused field unused_reg_rx_csi_error_handling (reg_rx_csi_error_handling) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_error_handling.reg_rx_csi_error_handling                |        0x%02X  |  [RW][04:00]""Error handling register. 		               bit 0 = when set, packets with more than one erro in packet header 									  			 are discarded. 									 bit 1 = when set, a short packet with reserved id is discarded and irq 									  			 is raised 									 bit 2 = when set, a long packet with reserved id is discarded and irq 									  			 is raised 		               bit 3 = when set, detection of incomplete packet is disabled, irq will 									         not be generated""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0x6c80c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_b.reg_rx_csi_hbp_testmode_enable                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_b_reg_rx_csi_hbp_testmode_enable_type */
	/* skip, unused field unused_reg_rx_csi_hbp_testmode_enable (reg_rx_csi_hbp_testmode_enable) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_hbp_testmode_enable.reg_rx_csi_hbp_testmode_enable      |         0x%01X  |  [RW][00:00]""HBP test mode enable register of CSI RX.                    0 = Normal mode(DPHY receives HS data and byte clock from AFE), 									 1 = HBP test mode (DPHY receives HS data and byte clock via TESTER GPIOs),                   ""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6c808);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_b.reg_rx_csi_control                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_b_reg_rx_csi_control_type */
	/* skip, unused field unused_reg_rx_csi_control (reg_rx_csi_control) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_control.reg_rx_csi_control                              |       0x%03X  |  [RW][10:00]""Control register CSI RX.                    bit 0 = release_lp11 									 bit 1 = disable_byte_clk_gating,                   ""\n", FIELD_VALUE(val, 0, 10));
	val = REG_DUMP_READ_REGISTER(0x6c804);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_b.reg_rx_csi_nof_enabled_lanes                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_b_reg_rx_csi_nof_enabled_lanes_type */
	/* skip, unused field unused_reg_rx_csi_nof_enabled_lanes (reg_rx_csi_nof_enabled_lanes) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_nof_enabled_lanes.reg_rx_csi_nof_enabled_lanes          |         0x%01X  |  [RW][02:00]""Specify Number of enabled data lanes of CSI RX.                    0 = No lanes enabled 									 1 = One   lane  enabled,                    2 = Two   lanes enabled,                    3 = Three lanes enabled,                    4 = Four  lanes enabled,                   ""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x6c800);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_b.reg_rx_csi_enable                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_b_reg_rx_csi_enable_type */
	/* skip, unused field unused_reg_rx_csi_enable (reg_rx_csi_enable) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_enable.reg_rx_csi_enable                                |         0x%01X  |  [RW][00:00]""Enable CSI RX""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x65040);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_b.reg_rx_csi_dly_cnt_settle_dlane1                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_b_reg_rx_csi_dly_cnt_settle_dlane1_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_settle_dlane1 (reg_rx_csi_dly_cnt_settle_dlane1) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_settle_dlane1.reg_rx_csi_dly_cnt_settle_dlane1  |    0x%06X  |  [RW][23:00]""Specify the Delay value for Settling time of Data lane 1 HS Rx data.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6503c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_b.reg_rx_csi_dly_cnt_termen_dlane1                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_b_reg_rx_csi_dly_cnt_termen_dlane1_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_termen_dlane1 (reg_rx_csi_dly_cnt_termen_dlane1) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_termen_dlane1.reg_rx_csi_dly_cnt_termen_dlane1  |    0x%06X  |  [RW][23:00]""Specify the Delay value for Termination enable of Data lane 1 HS Rx.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x65038);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_b.reg_rx_csi_dly_cnt_settle_dlane0                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_b_reg_rx_csi_dly_cnt_settle_dlane0_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_settle_dlane0 (reg_rx_csi_dly_cnt_settle_dlane0) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_settle_dlane0.reg_rx_csi_dly_cnt_settle_dlane0  |    0x%06X  |  [RW][23:00]""Specify the Delay value for Settling time of Data lane 0 HS Rx data.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x65030);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_b.reg_rx_csi_dly_cnt_settle_clane                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_b_reg_rx_csi_dly_cnt_settle_clane_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_settle_clane (reg_rx_csi_dly_cnt_settle_clane) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_settle_clane.reg_rx_csi_dly_cnt_settle_clane    |    0x%06X  |  [RW][23:00]""Specify the Delay value for HS Settling time of Clock lane HS Rx data.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6502c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_b.reg_rx_csi_dly_cnt_termen_clane                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_b_reg_rx_csi_dly_cnt_termen_clane_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_termen_clane (reg_rx_csi_dly_cnt_termen_clane) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_termen_clane.reg_rx_csi_dly_cnt_termen_clane    |    0x%06X  |  [RW][23:00]""Specify the Delay value for Termination enable of Clock lane HS Rx.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x65028);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_b.reg_rx_csi_status_dlane_lp                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_b_reg_rx_csi_status_dlane_lp_type */
	/* skip, unused field unused_reg_rx_csi_status_dlane_lp (reg_rx_csi_status_dlane_lp) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_status_dlane_lp.reg_rx_csi_status_dlane_lp              |    0x%06X  |  [RW][23:00]""Status register for low power communication errors and events (Escape mode (errors), trigger events)                    This is an edge triggered status register which bits can be cleared via writing.                   Reading:                    Error entering escape mode:                    Bit.0 =LP Esc Error Dlane-0                    Bit.1 =LP Esc Error Dlane-1                    Bit.2 =LP Esc Error Dlane-2                    Bit.3 =LP Esc Error Dlane-3                    Low power events, refer to REF-2 DPHY MAS, section 4.3.2 for detailed information:                    Bit.4 =LP TriggerEsc0 (Rst) Dlane-0                    Bit.5 =LP TriggerEsc1 (Unk3) Dlane-0                    Bit.6 =LP TriggerEsc2 (Unk4) Dlane-0                    Bit.7 =LP TriggerEsc3 (Unk5) Dlane-0                    Bit.8 =LP TriggerEsc0 (Rst) Dlane-1                    Bit.9 =LP TriggerEsc1 (Unk3) Dlane-1                    Bit.10 =LP TriggerEsc2 (Unk4) Dlane-1                    Bit.11 =LP TriggerEsc3 (Unk5) Dlane-1                    Bit.12 =LP TriggerEsc0 (Rst) Dlane-2                    Bit.13 =LP TriggerEsc1 (Unk3) Dlane-2                    Bit.14 =LP TriggerEsc2 (Unk4) Dlane-2                    Bit.15 =LP TriggerEsc3 (Unk5) Dlane-2                    Bit.16 =LP TriggerEsc0 (Rst) Dlane-3                    Bit.17 =LP TriggerEsc1 (Unk3) Dlane-3                    Bit.18 =LP TriggerEsc2 (Unk4) Dlane-3                    Bit.19 =LP TriggerEsc3 (Unk5) Dlane-3                    Bit.20 =LP UlpsEsc Dlane-0                    Bit.21 =LP UlpsEsc Dlane-1                    Bit.22 =LP UlpsEsc Dlane-2                    Bit.23 =LP UlpsEsc Dlane-3                    Writing:                    Writing a '1' to a particular bit clears that bit.                    Eg.                    Writing 0x1 clears bit.0                    Writing 0x3 clears bit.0 and bit.1                    Etc.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x65024);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_b.reg_rx_csi_status_dlane_hs                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_b_reg_rx_csi_status_dlane_hs_type */
	/* skip, unused field unused_reg_rx_csi_status_dlane_hs (reg_rx_csi_status_dlane_hs) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_status_dlane_hs.reg_rx_csi_status_dlane_hs              |        0x%02X  |  [RW][07:00]""Status register for high speed communication errors (single bit, multiple bit errors in sync pattern)                    This is an edge triggered status register which bits can be cleared via writing.                    Reading:                    DPHY recoverable sync errors (single bit error):                     Bit.0 =HS SOT Error Dlane-0                    Bit.1 =HS SOT Error Dlane-1                    Bit.2 =HS SOT Error Dlane-2                    Bit.3 =HS SOT Error Dlane-3                    DPHY NON-recoverable sync errors (multiple bit error):                    Bit.4 =HS SOT Sync Error Dlane-0                    Bit.5 =HS SOT Sync Error Dlane-1                    Bit.6 =HS SOT Sync Error Dlane-2                    Bit.7 =HS SOT Sync Error Dlane-3                    Writing:                    Writing a '1' to a particular bit clears that bit.                    Eg.                   Writing 0x1 clears bit.0                    Writing 0x3 clears bit.0 and bit.1                    Etc. ""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0x65020);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_b.reg_rx_csi_status                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_b_reg_rx_csi_status_type */
	/* skip, unused field unused_reg_rx_csi_status (reg_rx_csi_status) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_status.reg_rx_csi_status                                |         0x%01X  |  [RO][01:00]""Status register.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x6501c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_b.reg_rx_csi_lp_if_config                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_b_reg_rx_csi_lp_if_config_type */
	/* skip, unused field unused_reg_rx_csi_lp_if_config (reg_rx_csi_lp_if_config) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_lp_if_config.reg_rx_csi_lp_if_config                    |         0x%01X  |  [RW][02:00]""Long packet inter-frame configuration register (error type 8a)                    bit[1:0]                    00 = filter out all long packets in between frames, no error is communicated (only via IRQ)                    01 = filter out inter-frame long packets while VC is inactive, pass when active                    10 = always pass                    11 = reserved/not used                    bit[2]                    0 = no error flag + code added to passed packet                    1 = error flag + code added to passed packet""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x65018);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_b.reg_rx_csi_sp_if_config                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_b_reg_rx_csi_sp_if_config_type */
	/* skip, unused field unused_reg_rx_csi_sp_if_config (reg_rx_csi_sp_if_config) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_sp_if_config.reg_rx_csi_sp_if_config                    |         0x%01X  |  [RW][02:00]""Short packet inter-frame configuration register (error type 8a)                    bit[1:0]                    00 = filter out all short packets in between frames, no error is communicated (only via IRQ)                    01 = filter out inter-frame short packets while VC is inactive, pass when active                    10 = always pass                    11 = reserved/not used                    bit[2]                    0 = no error flag + code added to passed packet                    1 = error flag + code added to passed packet""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x65014);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_b.reg_rx_csi_sync_cntr_sel                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_b_reg_rx_csi_sync_cntr_sel_type */
	/* skip, unused field unused_reg_rx_csi_sync_cntr_sel (reg_rx_csi_sync_cntr_sel) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_sync_cntr_sel.reg_rx_csi_sync_cntr_sel                  |         0x%01X  |  [RW][01:00]""Sync counter select register. 		               bit 0 => 0: Use internal counter for line start and line end packet IDs.                          => 1: Use line start and line end ID as send by sensor 									 bit 1 => 0: Use internal counter for frame start and frame end packet IDs.                          => 1: Use frame start and frame end ID as send by sensor""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x65010);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_b.reg_rx_csi_error_handling                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_b_reg_rx_csi_error_handling_type */
	/* skip, unused field unused_reg_rx_csi_error_handling (reg_rx_csi_error_handling) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_error_handling.reg_rx_csi_error_handling                |        0x%02X  |  [RW][04:00]""Error handling register. 		               bit 0 = when set, packets with more than one erro in packet header 									  			 are discarded. 									 bit 1 = when set, a short packet with reserved id is discarded and irq 									  			 is raised 									 bit 2 = when set, a long packet with reserved id is discarded and irq 									  			 is raised 		               bit 3 = when set, detection of incomplete packet is disabled, irq will 									         not be generated""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0x6500c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_b.reg_rx_csi_hbp_testmode_enable                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_b_reg_rx_csi_hbp_testmode_enable_type */
	/* skip, unused field unused_reg_rx_csi_hbp_testmode_enable (reg_rx_csi_hbp_testmode_enable) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_hbp_testmode_enable.reg_rx_csi_hbp_testmode_enable      |         0x%01X  |  [RW][00:00]""HBP test mode enable register of CSI RX.                    0 = Normal mode(DPHY receives HS data and byte clock from AFE), 									 1 = HBP test mode (DPHY receives HS data and byte clock via TESTER GPIOs),                   ""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x65008);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_b.reg_rx_csi_control                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_b_reg_rx_csi_control_type */
	/* skip, unused field unused_reg_rx_csi_control (reg_rx_csi_control) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_control.reg_rx_csi_control                              |       0x%03X  |  [RW][10:00]""Control register CSI RX.                    bit 0 = release_lp11 									 bit 1 = disable_byte_clk_gating,                   ""\n", FIELD_VALUE(val, 0, 10));
	val = REG_DUMP_READ_REGISTER(0x65004);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_b.reg_rx_csi_nof_enabled_lanes                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_b_reg_rx_csi_nof_enabled_lanes_type */
	/* skip, unused field unused_reg_rx_csi_nof_enabled_lanes (reg_rx_csi_nof_enabled_lanes) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_nof_enabled_lanes.reg_rx_csi_nof_enabled_lanes          |         0x%01X  |  [RW][02:00]""Specify Number of enabled data lanes of CSI RX.                    0 = No lanes enabled 									 1 = One   lane  enabled,                    2 = Two   lanes enabled,                    3 = Three lanes enabled,                    4 = Four  lanes enabled,                   ""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x65000);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_b.reg_rx_csi_enable                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_b_reg_rx_csi_enable_type */
	/* skip, unused field unused_reg_rx_csi_enable (reg_rx_csi_enable) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_enable.reg_rx_csi_enable                                |         0x%01X  |  [RW][00:00]""Enable CSI RX""\n", FIELD_VALUE(val, 0, 0));
} /* end csi_rx_b */

/* Generated Debug Code: Device mipi_pkt_gen0 */
void ia_css_debug_dump_mipi_pkt_gen0(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x6f474);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.tpg_b2_reg                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_mipi_pkt_gen0_tpg_b2_reg_type */
	/* skip, unused field unused_tpg_b2_reg (tpg_b2_reg) */
	REG_DUMP_PRINT_1("   -tpg_b2_reg.tpg_b2_reg                    |       0x%03X  |  [RW][11:00]""Defines the blue2 color for test pattern generator""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x6f470);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.tpg_g2_reg                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_mipi_pkt_gen0_tpg_g2_reg_type */
	/* skip, unused field unused_tpg_g2_reg (tpg_g2_reg) */
	REG_DUMP_PRINT_1("   -tpg_g2_reg.tpg_g2_reg                    |       0x%03X  |  [RW][11:00]""Defines the green2 color for test pattern generator""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x6f46c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.tpg_r2_reg                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_mipi_pkt_gen0_tpg_r2_reg_type */
	/* skip, unused field unused_tpg_r2_reg (tpg_r2_reg) */
	REG_DUMP_PRINT_1("   -tpg_r2_reg.tpg_r2_reg                    |       0x%03X  |  [RW][11:00]""Defines the red2 color for test pattern generator""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x6f468);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.tpg_b1_reg                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_mipi_pkt_gen0_tpg_b1_reg_type */
	/* skip, unused field unused_tpg_b1_reg (tpg_b1_reg) */
	REG_DUMP_PRINT_1("   -tpg_b1_reg.tpg_b1_reg                    |       0x%03X  |  [RW][11:00]""Defines the blue1 color for test pattern generator""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x6f464);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.tpg_g1_reg                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_mipi_pkt_gen0_tpg_g1_reg_type */
	/* skip, unused field unused_tpg_g1_reg (tpg_g1_reg) */
	REG_DUMP_PRINT_1("   -tpg_g1_reg.tpg_g1_reg                    |       0x%03X  |  [RW][11:00]""Defines the green1 color for test pattern generator""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x6f460);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.tpg_r1_reg                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_mipi_pkt_gen0_tpg_r1_reg_type */
	/* skip, unused field unused_tpg_r1_reg (tpg_r1_reg) */
	REG_DUMP_PRINT_1("   -tpg_r1_reg.tpg_r1_reg                    |       0x%03X  |  [RW][11:00]""Defines the red1 color for test pattern generator""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x6f45c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.tpg_vcnt_delta_reg           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_mipi_pkt_gen0_tpg_vcnt_delta_reg_type */
	/* skip, unused field unused_tpg_vcnt_delta_reg (tpg_vcnt_delta_reg) */
	REG_DUMP_PRINT_1("   -tpg_vcnt_delta_reg.tpg_vcnt_delta_reg    |         0x%01X  |  [RW][03:00]""Sets the vertical counter delta in the TPG""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x6f458);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.tpg_hcnt_delta_reg           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_mipi_pkt_gen0_tpg_hcnt_delta_reg_type */
	/* skip, unused field unused_tpg_hcnt_delta_reg (tpg_hcnt_delta_reg) */
	REG_DUMP_PRINT_1("   -tpg_hcnt_delta_reg.tpg_hcnt_delta_reg    |         0x%01X  |  [RW][03:00]""Sets the horizontal counter delta in the TPG""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x6f454);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.tpg_xycnt_mask_reg           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_mipi_pkt_gen0_tpg_xycnt_mask_reg_type */
	/* skip, unused field unused_tpg_xycnt_mask_reg (tpg_xycnt_mask_reg) */
	REG_DUMP_PRINT_1("   -tpg_xycnt_mask_reg.tpg_xycnt_mask_reg    |       0x%03X  |  [RW][11:00]""Sets the xy counter mask in the TPG""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x6f450);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.tpg_vcnt_mask_reg            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_mipi_pkt_gen0_tpg_vcnt_mask_reg_type */
	/* skip, unused field unused_tpg_vcnt_mask_reg (tpg_vcnt_mask_reg) */
	REG_DUMP_PRINT_1("   -tpg_vcnt_mask_reg.tpg_vcnt_mask_reg      |      0x%04X  |  [RW][15:00]""Sets the vertical counter mask in the TPG""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x6f44c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.tpg_hcnt_mask_reg            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_mipi_pkt_gen0_tpg_hcnt_mask_reg_type */
	/* skip, unused field unused_tpg_hcnt_mask_reg (tpg_hcnt_mask_reg) */
	REG_DUMP_PRINT_1("   -tpg_hcnt_mask_reg.tpg_hcnt_mask_reg      |      0x%04X  |  [RW][15:00]""Sets the horizontal counter mask in the TPG""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x6f448);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.tpg_mode_reg                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_mipi_pkt_gen0_tpg_mode_reg_type */
	/* skip, unused field unused_tpg_mode_reg (tpg_mode_reg) */
	REG_DUMP_PRINT_1("   -tpg_mode_reg.tpg_mode_reg                |         0x%01X  |  [RW][01:00]""Sets the mode of the test pattern generator. 'b00-ramp mode, 'b01-checkerboard, 'b10-frame based color""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x6f444);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.syng_stat_done_reg           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_mipi_pkt_gen0_syng_stat_done_reg_type */
	/* skip, unused field unused_syng_stat_done_reg (syng_stat_done_reg) */
	REG_DUMP_PRINT_1("   -syng_stat_done_reg.syng_stat_done_reg    |         0x%01X  |  [RO][00:00]""Returns value zero or one, indicating whether sync gen has finished.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6f440);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.syng_stat_fcnt_reg           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_mipi_pkt_gen0_syng_stat_fcnt_reg_type */
	/* skip, unused field unused_syng_stat_fcnt_reg (syng_stat_fcnt_reg) */
	REG_DUMP_PRINT_1("   -syng_stat_fcnt_reg.syng_stat_fcnt_reg    |      0x%04X  |  [RO][15:00]""Returns the value of the frame counter in the sync generator""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x6f43c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.syng_stat_vcnt_reg           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_mipi_pkt_gen0_syng_stat_vcnt_reg_type */
	/* skip, unused field unused_syng_stat_vcnt_reg (syng_stat_vcnt_reg) */
	REG_DUMP_PRINT_1("   -syng_stat_vcnt_reg.syng_stat_vcnt_reg    |      0x%04X  |  [RO][15:00]""Returns the value of the vertical counter in the sync generator""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x6f438);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.syng_stat_hcnt_reg           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_mipi_pkt_gen0_syng_stat_hcnt_reg_type */
	/* skip, unused field unused_syng_stat_hcnt_reg (syng_stat_hcnt_reg) */
	REG_DUMP_PRINT_1("   -syng_stat_hcnt_reg.syng_stat_hcnt_reg    |      0x%04X  |  [RO][15:00]""Returns the value of the horizontal counter in the sync generator""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x6f434);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.syng_vblank_cyc_reg          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_mipi_pkt_gen0_syng_vblank_cyc_reg_type */
	/* skip, unused field unused_syng_vblank_cyc_reg (syng_vblank_cyc_reg) */
	REG_DUMP_PRINT_1("   -syng_vblank_cyc_reg.syng_vblank_cyc_reg  |      0x%04X  |  [RW][15:00]""Sets the number of cycles between the end-of-frame and start-of-frame pulses.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x6f430);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.syng_hblank_cyc_reg          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_mipi_pkt_gen0_syng_hblank_cyc_reg_type */
	/* skip, unused field unused_syng_hblank_cyc_reg (syng_hblank_cyc_reg) */
	REG_DUMP_PRINT_1("   -syng_hblank_cyc_reg.syng_hblank_cyc_reg  |      0x%04X  |  [RW][15:00]""Sets the number of cycles between the end-of-line and start-of-line pulses.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x6f42c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.syng_nof_lines_reg           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_mipi_pkt_gen0_syng_nof_lines_reg_type */
	/* skip, unused field unused_syng_nof_lines_reg (syng_nof_lines_reg) */
	REG_DUMP_PRINT_1("   -syng_nof_lines_reg.syng_nof_lines_reg    |      0x%04X  |  [RW][15:00]""Sets the number of lines per frame in the Sync generator""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x6f428);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.syng_nof_pixels_reg          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_mipi_pkt_gen0_syng_nof_pixels_reg_type */
	/* skip, unused field unused_syng_nof_pixels_reg (syng_nof_pixels_reg) */
	REG_DUMP_PRINT_1("   -syng_nof_pixels_reg.syng_nof_pixels_reg  |      0x%04X  |  [RW][15:00]""Sets the number of active pixels per line in the Sync Generator""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x6f424);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.syng_nof_frames_reg          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_mipi_pkt_gen0_syng_nof_frames_reg_type */
	/* skip, unused field unused_syng_nof_frames_reg (syng_nof_frames_reg) */
	REG_DUMP_PRINT_1("   -syng_nof_frames_reg.syng_nof_frames_reg  |      0x%04X  |  [RW][15:00]""Sets the sync generator parameter Number of Frames.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x6f420);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.syng_pause_reg               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_mipi_pkt_gen0_syng_pause_reg_type */
	/* skip, unused field unused_syng_pause_reg (syng_pause_reg) */
	REG_DUMP_PRINT_1("   -syng_pause_reg.syng_pause_reg            |         0x%01X  |  [RW][00:00]""Sets the sync generator in pause mode (value=1) or not (value=0).""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6f41c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.syng_free_run_reg            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_mipi_pkt_gen0_syng_free_run_reg_type */
	/* skip, unused field unused_syng_free_run_reg (syng_free_run_reg) */
	REG_DUMP_PRINT_1("   -syng_free_run_reg.syng_free_run_reg      |         0x%01X  |  [RW][00:00]""Sets the sync generator in free running mode (value=1) or let it stall in sync with either the prbs or TPG (value=0).""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6f418);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.prbs_rstval_reg1             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_mipi_pkt_gen0_prbs_rstval_reg1_type */
	/* skip, unused field unused_prbs_rstval_reg1 (prbs_rstval_reg1) */
	REG_DUMP_PRINT_1("   -prbs_rstval_reg1.prbs_rstval_reg1        |  0x%08X  |  [RW][30:00]""Set the reset value of the LFSR1 in the prbs.""\n", FIELD_VALUE(val, 0, 30));
	val = REG_DUMP_READ_REGISTER(0x6f414);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.prbs_rstval_reg0             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_mipi_pkt_gen0_prbs_rstval_reg0_type */
	/* skip, unused field unused_prbs_rstval_reg0 (prbs_rstval_reg0) */
	REG_DUMP_PRINT_1("   -prbs_rstval_reg0.prbs_rstval_reg0        |  0x%08X  |  [RW][30:00]""Set the reset value of the LFSR0 in the prbs.""\n", FIELD_VALUE(val, 0, 30));
	val = REG_DUMP_READ_REGISTER(0x6f410);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.com_wcount_reg               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_mipi_pkt_gen0_com_wcount_reg_type */
	/* skip, unused field unused_com_wcount_reg (com_wcount_reg) */
	REG_DUMP_PRINT_1("   -com_wcount_reg.com_wcount_reg            |      0x%04X  |  [RW][15:00]""Word count register in bytes. Equals: (number of pixels per line * data type in bits)/8""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x6f40c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.com_vchan_reg                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_mipi_pkt_gen0_com_vchan_reg_type */
	/* skip, unused field unused_com_vchan_reg (com_vchan_reg) */
	REG_DUMP_PRINT_1("   -com_vchan_reg.com_vchan_reg              |         0x%01X  |  [RW][01:00]""Virtual channel identifier register. User can specify separate channels for different data flows.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x6f408);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.com_vtype_reg                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_mipi_pkt_gen0_com_vtype_reg_type */
	/* skip, unused field unused_com_vtype_reg (com_vtype_reg) */
	REG_DUMP_PRINT_1("   -com_vtype_reg.com_vtype_reg              |        0x%02X  |  [RW][05:00]""Virtual data type register. User can specify any supported MIPI format.""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x6f404);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.com_dtype_reg                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_mipi_pkt_gen0_com_dtype_reg_type */
	/* skip, unused field unused_com_dtype_reg (com_dtype_reg) */
	REG_DUMP_PRINT_1("   -com_dtype_reg.com_dtype_reg              |         0x%01X  |  [RW][01:00]""Data type register, defaults to RAW8.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x6f400);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.com_enable_reg               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_mipi_pkt_gen0_com_enable_reg_type */
	/* skip, unused field unused_com_enable_reg (com_enable_reg) */
	REG_DUMP_PRINT_1("   -com_enable_reg.com_enable_reg            |         0x%01X  |  [RW][01:00]""Enables/Disable MIPI Packet Generator components.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x64874);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.tpg_b2_reg                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_mipi_pkt_gen0_tpg_b2_reg_type */
	/* skip, unused field unused_tpg_b2_reg (tpg_b2_reg) */
	REG_DUMP_PRINT_1("   -tpg_b2_reg.tpg_b2_reg                    |       0x%03X  |  [RW][11:00]""Defines the blue2 color for test pattern generator""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x64870);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.tpg_g2_reg                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_mipi_pkt_gen0_tpg_g2_reg_type */
	/* skip, unused field unused_tpg_g2_reg (tpg_g2_reg) */
	REG_DUMP_PRINT_1("   -tpg_g2_reg.tpg_g2_reg                    |       0x%03X  |  [RW][11:00]""Defines the green2 color for test pattern generator""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x6486c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.tpg_r2_reg                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_mipi_pkt_gen0_tpg_r2_reg_type */
	/* skip, unused field unused_tpg_r2_reg (tpg_r2_reg) */
	REG_DUMP_PRINT_1("   -tpg_r2_reg.tpg_r2_reg                    |       0x%03X  |  [RW][11:00]""Defines the red2 color for test pattern generator""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x64868);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.tpg_b1_reg                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_mipi_pkt_gen0_tpg_b1_reg_type */
	/* skip, unused field unused_tpg_b1_reg (tpg_b1_reg) */
	REG_DUMP_PRINT_1("   -tpg_b1_reg.tpg_b1_reg                    |       0x%03X  |  [RW][11:00]""Defines the blue1 color for test pattern generator""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x64864);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.tpg_g1_reg                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_mipi_pkt_gen0_tpg_g1_reg_type */
	/* skip, unused field unused_tpg_g1_reg (tpg_g1_reg) */
	REG_DUMP_PRINT_1("   -tpg_g1_reg.tpg_g1_reg                    |       0x%03X  |  [RW][11:00]""Defines the green1 color for test pattern generator""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x64860);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.tpg_r1_reg                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_mipi_pkt_gen0_tpg_r1_reg_type */
	/* skip, unused field unused_tpg_r1_reg (tpg_r1_reg) */
	REG_DUMP_PRINT_1("   -tpg_r1_reg.tpg_r1_reg                    |       0x%03X  |  [RW][11:00]""Defines the red1 color for test pattern generator""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x6485c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.tpg_vcnt_delta_reg           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_mipi_pkt_gen0_tpg_vcnt_delta_reg_type */
	/* skip, unused field unused_tpg_vcnt_delta_reg (tpg_vcnt_delta_reg) */
	REG_DUMP_PRINT_1("   -tpg_vcnt_delta_reg.tpg_vcnt_delta_reg    |         0x%01X  |  [RW][03:00]""Sets the vertical counter delta in the TPG""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x64858);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.tpg_hcnt_delta_reg           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_mipi_pkt_gen0_tpg_hcnt_delta_reg_type */
	/* skip, unused field unused_tpg_hcnt_delta_reg (tpg_hcnt_delta_reg) */
	REG_DUMP_PRINT_1("   -tpg_hcnt_delta_reg.tpg_hcnt_delta_reg    |         0x%01X  |  [RW][03:00]""Sets the horizontal counter delta in the TPG""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x64854);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.tpg_xycnt_mask_reg           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_mipi_pkt_gen0_tpg_xycnt_mask_reg_type */
	/* skip, unused field unused_tpg_xycnt_mask_reg (tpg_xycnt_mask_reg) */
	REG_DUMP_PRINT_1("   -tpg_xycnt_mask_reg.tpg_xycnt_mask_reg    |       0x%03X  |  [RW][11:00]""Sets the xy counter mask in the TPG""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x64850);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.tpg_vcnt_mask_reg            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_mipi_pkt_gen0_tpg_vcnt_mask_reg_type */
	/* skip, unused field unused_tpg_vcnt_mask_reg (tpg_vcnt_mask_reg) */
	REG_DUMP_PRINT_1("   -tpg_vcnt_mask_reg.tpg_vcnt_mask_reg      |      0x%04X  |  [RW][15:00]""Sets the vertical counter mask in the TPG""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x6484c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.tpg_hcnt_mask_reg            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_mipi_pkt_gen0_tpg_hcnt_mask_reg_type */
	/* skip, unused field unused_tpg_hcnt_mask_reg (tpg_hcnt_mask_reg) */
	REG_DUMP_PRINT_1("   -tpg_hcnt_mask_reg.tpg_hcnt_mask_reg      |      0x%04X  |  [RW][15:00]""Sets the horizontal counter mask in the TPG""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x64848);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.tpg_mode_reg                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_mipi_pkt_gen0_tpg_mode_reg_type */
	/* skip, unused field unused_tpg_mode_reg (tpg_mode_reg) */
	REG_DUMP_PRINT_1("   -tpg_mode_reg.tpg_mode_reg                |         0x%01X  |  [RW][01:00]""Sets the mode of the test pattern generator. 'b00-ramp mode, 'b01-checkerboard, 'b10-frame based color""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x64844);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.syng_stat_done_reg           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_mipi_pkt_gen0_syng_stat_done_reg_type */
	/* skip, unused field unused_syng_stat_done_reg (syng_stat_done_reg) */
	REG_DUMP_PRINT_1("   -syng_stat_done_reg.syng_stat_done_reg    |         0x%01X  |  [RO][00:00]""Returns value zero or one, indicating whether sync gen has finished.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x64840);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.syng_stat_fcnt_reg           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_mipi_pkt_gen0_syng_stat_fcnt_reg_type */
	/* skip, unused field unused_syng_stat_fcnt_reg (syng_stat_fcnt_reg) */
	REG_DUMP_PRINT_1("   -syng_stat_fcnt_reg.syng_stat_fcnt_reg    |      0x%04X  |  [RO][15:00]""Returns the value of the frame counter in the sync generator""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x6483c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.syng_stat_vcnt_reg           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_mipi_pkt_gen0_syng_stat_vcnt_reg_type */
	/* skip, unused field unused_syng_stat_vcnt_reg (syng_stat_vcnt_reg) */
	REG_DUMP_PRINT_1("   -syng_stat_vcnt_reg.syng_stat_vcnt_reg    |      0x%04X  |  [RO][15:00]""Returns the value of the vertical counter in the sync generator""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x64838);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.syng_stat_hcnt_reg           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_mipi_pkt_gen0_syng_stat_hcnt_reg_type */
	/* skip, unused field unused_syng_stat_hcnt_reg (syng_stat_hcnt_reg) */
	REG_DUMP_PRINT_1("   -syng_stat_hcnt_reg.syng_stat_hcnt_reg    |      0x%04X  |  [RO][15:00]""Returns the value of the horizontal counter in the sync generator""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x64834);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.syng_vblank_cyc_reg          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_mipi_pkt_gen0_syng_vblank_cyc_reg_type */
	/* skip, unused field unused_syng_vblank_cyc_reg (syng_vblank_cyc_reg) */
	REG_DUMP_PRINT_1("   -syng_vblank_cyc_reg.syng_vblank_cyc_reg  |      0x%04X  |  [RW][15:00]""Sets the number of cycles between the end-of-frame and start-of-frame pulses.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x64830);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.syng_hblank_cyc_reg          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_mipi_pkt_gen0_syng_hblank_cyc_reg_type */
	/* skip, unused field unused_syng_hblank_cyc_reg (syng_hblank_cyc_reg) */
	REG_DUMP_PRINT_1("   -syng_hblank_cyc_reg.syng_hblank_cyc_reg  |      0x%04X  |  [RW][15:00]""Sets the number of cycles between the end-of-line and start-of-line pulses.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x6482c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.syng_nof_lines_reg           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_mipi_pkt_gen0_syng_nof_lines_reg_type */
	/* skip, unused field unused_syng_nof_lines_reg (syng_nof_lines_reg) */
	REG_DUMP_PRINT_1("   -syng_nof_lines_reg.syng_nof_lines_reg    |      0x%04X  |  [RW][15:00]""Sets the number of lines per frame in the Sync generator""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x64828);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.syng_nof_pixels_reg          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_mipi_pkt_gen0_syng_nof_pixels_reg_type */
	/* skip, unused field unused_syng_nof_pixels_reg (syng_nof_pixels_reg) */
	REG_DUMP_PRINT_1("   -syng_nof_pixels_reg.syng_nof_pixels_reg  |      0x%04X  |  [RW][15:00]""Sets the number of active pixels per line in the Sync Generator""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x64824);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.syng_nof_frames_reg          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_mipi_pkt_gen0_syng_nof_frames_reg_type */
	/* skip, unused field unused_syng_nof_frames_reg (syng_nof_frames_reg) */
	REG_DUMP_PRINT_1("   -syng_nof_frames_reg.syng_nof_frames_reg  |      0x%04X  |  [RW][15:00]""Sets the sync generator parameter Number of Frames.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x64820);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.syng_pause_reg               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_mipi_pkt_gen0_syng_pause_reg_type */
	/* skip, unused field unused_syng_pause_reg (syng_pause_reg) */
	REG_DUMP_PRINT_1("   -syng_pause_reg.syng_pause_reg            |         0x%01X  |  [RW][00:00]""Sets the sync generator in pause mode (value=1) or not (value=0).""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6481c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.syng_free_run_reg            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_mipi_pkt_gen0_syng_free_run_reg_type */
	/* skip, unused field unused_syng_free_run_reg (syng_free_run_reg) */
	REG_DUMP_PRINT_1("   -syng_free_run_reg.syng_free_run_reg      |         0x%01X  |  [RW][00:00]""Sets the sync generator in free running mode (value=1) or let it stall in sync with either the prbs or TPG (value=0).""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x64818);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.prbs_rstval_reg1             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_mipi_pkt_gen0_prbs_rstval_reg1_type */
	/* skip, unused field unused_prbs_rstval_reg1 (prbs_rstval_reg1) */
	REG_DUMP_PRINT_1("   -prbs_rstval_reg1.prbs_rstval_reg1        |  0x%08X  |  [RW][30:00]""Set the reset value of the LFSR1 in the prbs.""\n", FIELD_VALUE(val, 0, 30));
	val = REG_DUMP_READ_REGISTER(0x64814);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.prbs_rstval_reg0             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_mipi_pkt_gen0_prbs_rstval_reg0_type */
	/* skip, unused field unused_prbs_rstval_reg0 (prbs_rstval_reg0) */
	REG_DUMP_PRINT_1("   -prbs_rstval_reg0.prbs_rstval_reg0        |  0x%08X  |  [RW][30:00]""Set the reset value of the LFSR0 in the prbs.""\n", FIELD_VALUE(val, 0, 30));
	val = REG_DUMP_READ_REGISTER(0x64810);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.com_wcount_reg               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_mipi_pkt_gen0_com_wcount_reg_type */
	/* skip, unused field unused_com_wcount_reg (com_wcount_reg) */
	REG_DUMP_PRINT_1("   -com_wcount_reg.com_wcount_reg            |      0x%04X  |  [RW][15:00]""Word count register in bytes. Equals: (number of pixels per line * data type in bits)/8""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x6480c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.com_vchan_reg                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_mipi_pkt_gen0_com_vchan_reg_type */
	/* skip, unused field unused_com_vchan_reg (com_vchan_reg) */
	REG_DUMP_PRINT_1("   -com_vchan_reg.com_vchan_reg              |         0x%01X  |  [RW][01:00]""Virtual channel identifier register. User can specify separate channels for different data flows.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x64808);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.com_vtype_reg                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_mipi_pkt_gen0_com_vtype_reg_type */
	/* skip, unused field unused_com_vtype_reg (com_vtype_reg) */
	REG_DUMP_PRINT_1("   -com_vtype_reg.com_vtype_reg              |        0x%02X  |  [RW][05:00]""Virtual data type register. User can specify any supported MIPI format.""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x64804);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.com_dtype_reg                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_mipi_pkt_gen0_com_dtype_reg_type */
	/* skip, unused field unused_com_dtype_reg (com_dtype_reg) */
	REG_DUMP_PRINT_1("   -com_dtype_reg.com_dtype_reg              |         0x%01X  |  [RW][01:00]""Data type register, defaults to RAW8.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x64800);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  mipi_pkt_gen0.com_enable_reg               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_mipi_pkt_gen0_com_enable_reg_type */
	/* skip, unused field unused_com_enable_reg (com_enable_reg) */
	REG_DUMP_PRINT_1("   -com_enable_reg.com_enable_reg            |         0x%01X  |  [RW][01:00]""Enables/Disable MIPI Packet Generator components.""\n", FIELD_VALUE(val, 0, 1));
} /* end mipi_pkt_gen0 */

/* Generated Debug Code: Device gpr_a */
void ia_css_debug_dump_gpr_a(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x6c708);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpr_a.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX                                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_gpr_a_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX_type */
	/* skip, unused field unused_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX (csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX) */
	REG_DUMP_PRINT_1("   -csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX  |       0x%03X  |  [RW][10:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 10));
	val = REG_DUMP_READ_REGISTER(0x6c704);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpr_a.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX                                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_gpr_a_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX_type */
	/* skip, unused field unused_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX (csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX) */
	REG_DUMP_PRINT_1("   -csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX      |    0x%06X  |  [RW][21:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 21));
	val = REG_DUMP_READ_REGISTER(0x6c700);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpr_a.str_mon_status                                                                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_gpr_a_str_mon_status_type */
	REG_DUMP_PRINT_1("   -str_mon_status.str_mon_status                                                                                        |  0x%08X  |  [RO][31:00]""Streaming Monitor Status, [accept,valid] of streaming port""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x64708);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpr_a.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX                                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_gpr_a_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX_type */
	/* skip, unused field unused_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX (csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX) */
	REG_DUMP_PRINT_1("   -csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_IRQ_EN_IDX  |       0x%03X  |  [RW][10:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 10));
	val = REG_DUMP_READ_REGISTER(0x64704);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpr_a.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX                                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_gpr_a_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX_type */
	/* skip, unused field unused_csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX (csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX) */
	REG_DUMP_PRINT_1("   -csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX.csi2_pipe_gpregHIVE_ISYS2600_PIPE_GPREG_STRMON_COND_IDX      |    0x%06X  |  [RW][21:00]""General-purpose configuration register.""\n", FIELD_VALUE(val, 0, 21));
	val = REG_DUMP_READ_REGISTER(0x64700);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  gpr_a.str_mon_status                                                                                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_gpr_a_str_mon_status_type */
	REG_DUMP_PRINT_1("   -str_mon_status.str_mon_status                                                                                        |  0x%08X  |  [RO][31:00]""Streaming Monitor Status, [accept,valid] of streaming port""\n", FIELD_VALUE(val, 0, 31));
} /* end gpr_a */

/* Generated Debug Code: Device irq_ctrl1_a */
void ia_css_debug_dump_irq_ctrl1_a(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x6c614);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl1_a.irq_level_not_pulse            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl1_a_irq_level_not_pulse_type */
	/* skip, unused field unused_irq_level_not_pulse (irq_level_not_pulse) */
	REG_DUMP_PRINT_1("   -irq_level_not_pulse.irq_level_not_pulse  |    0x%06X  |  [RW][23:00]""Indicates for each bit whether an interrupt cause is translated into a pulse (value='0') or into a constant level '1' (value='1') on the IRQ pin.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6c610);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl1_a.irq_enable                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl1_a_irq_enable_type */
	/* skip, unused field unused_irq_enable (irq_enable) */
	REG_DUMP_PRINT_1("   -irq_enable.irq_enable                    |    0x%06X  |  [RW][23:00]""Indicates for each bit whether an interrupt cause as monitored by the req_irq_status register also affects the IRQ pin (value='1') or not (value='0').""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6c608);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl1_a.irq_status                     |  0x%08X  |  ""Indicates for each bit whether a non-masked interrupt has been generated (value='1'). Can be cleared by writing a '1' into the the corresponding bit of the req_irq_clear register.""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl1_a_irq_status_type */
	/* skip, unused field unused_irq_status (irq_status) */
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_0                |         0x%01X  |  [RO][00:00]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_1                |         0x%01X  |  [RO][01:01]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_2                |         0x%01X  |  [RO][02:02]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_3                |         0x%01X  |  [RO][03:03]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_4                |         0x%01X  |  [RO][04:04]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_5                |         0x%01X  |  [RO][05:05]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_6                |         0x%01X  |  [RO][06:06]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_7                |         0x%01X  |  [RO][07:07]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_8                |         0x%01X  |  [RO][08:08]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_9                |         0x%01X  |  [RO][09:09]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_10               |         0x%01X  |  [RO][10:10]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_11               |         0x%01X  |  [RO][11:11]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_12               |         0x%01X  |  [RO][12:12]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 12, 12));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_13               |         0x%01X  |  [RO][13:13]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 13, 13));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_14               |         0x%01X  |  [RO][14:14]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 14, 14));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_15               |         0x%01X  |  [RO][15:15]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 15, 15));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_16               |         0x%01X  |  [RO][16:16]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 16, 16));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_17               |         0x%01X  |  [RO][17:17]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 17, 17));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_18               |         0x%01X  |  [RO][18:18]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 18, 18));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_19               |         0x%01X  |  [RO][19:19]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 19, 19));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_20               |         0x%01X  |  [RO][20:20]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 20, 20));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_21               |         0x%01X  |  [RO][21:21]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 21, 21));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_22               |         0x%01X  |  [RO][22:22]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 22, 22));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_23               |         0x%01X  |  [RO][23:23]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 23, 23));
	val = REG_DUMP_READ_REGISTER(0x6c604);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl1_a.irq_mask                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl1_a_irq_mask_type */
	/* skip, unused field unused_irq_mask (irq_mask) */
	REG_DUMP_PRINT_1("   -irq_mask.irq_mask                        |    0x%06X  |  [RW][23:00]""Indicates for each bit of irq_di whether it can generate an interrupt request (value='1') or not (value='0'). Setting will affect irq_value as well as IRQ output pin.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6c600);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl1_a.irq_edge                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl1_a_irq_edge_type */
	/* skip, unused field unused_irq_edge (irq_edge) */
	REG_DUMP_PRINT_1("   -irq_edge.irq_edge                        |    0x%06X  |  [RW][23:00]""Indicates for each bit whether an interrupt request should be generated on a falling edge (value='0') or a rising edge (value='1').""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x64614);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl1_a.irq_level_not_pulse            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl1_a_irq_level_not_pulse_type */
	/* skip, unused field unused_irq_level_not_pulse (irq_level_not_pulse) */
	REG_DUMP_PRINT_1("   -irq_level_not_pulse.irq_level_not_pulse  |    0x%06X  |  [RW][23:00]""Indicates for each bit whether an interrupt cause is translated into a pulse (value='0') or into a constant level '1' (value='1') on the IRQ pin.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x64610);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl1_a.irq_enable                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl1_a_irq_enable_type */
	/* skip, unused field unused_irq_enable (irq_enable) */
	REG_DUMP_PRINT_1("   -irq_enable.irq_enable                    |    0x%06X  |  [RW][23:00]""Indicates for each bit whether an interrupt cause as monitored by the req_irq_status register also affects the IRQ pin (value='1') or not (value='0').""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x64608);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl1_a.irq_status                     |  0x%08X  |  ""Indicates for each bit whether a non-masked interrupt has been generated (value='1'). Can be cleared by writing a '1' into the the corresponding bit of the req_irq_clear register.""\n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl1_a_irq_status_type */
	/* skip, unused field unused_irq_status (irq_status) */
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_0                |         0x%01X  |  [RO][00:00]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_1                |         0x%01X  |  [RO][01:01]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_2                |         0x%01X  |  [RO][02:02]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_3                |         0x%01X  |  [RO][03:03]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_4                |         0x%01X  |  [RO][04:04]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_5                |         0x%01X  |  [RO][05:05]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_6                |         0x%01X  |  [RO][06:06]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_7                |         0x%01X  |  [RO][07:07]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_8                |         0x%01X  |  [RO][08:08]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_9                |         0x%01X  |  [RO][09:09]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_10               |         0x%01X  |  [RO][10:10]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_11               |         0x%01X  |  [RO][11:11]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_12               |         0x%01X  |  [RO][12:12]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 12, 12));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_13               |         0x%01X  |  [RO][13:13]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 13, 13));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_14               |         0x%01X  |  [RO][14:14]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 14, 14));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_15               |         0x%01X  |  [RO][15:15]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 15, 15));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_16               |         0x%01X  |  [RO][16:16]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 16, 16));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_17               |         0x%01X  |  [RO][17:17]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 17, 17));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_18               |         0x%01X  |  [RO][18:18]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 18, 18));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_19               |         0x%01X  |  [RO][19:19]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 19, 19));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_20               |         0x%01X  |  [RO][20:20]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 20, 20));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_21               |         0x%01X  |  [RO][21:21]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 21, 21));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_23               |         0x%01X  |  [RO][22:22]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 22, 22));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M_24               |         0x%01X  |  [RO][23:23]""Represents the status of the irq from  mipi stream2mmio.""\n", FIELD_VALUE(val, 23, 23));
	val = REG_DUMP_READ_REGISTER(0x64604);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl1_a.irq_mask                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl1_a_irq_mask_type */
	/* skip, unused field unused_irq_mask (irq_mask) */
	REG_DUMP_PRINT_1("   -irq_mask.irq_mask                        |    0x%06X  |  [RW][23:00]""Indicates for each bit of irq_di whether it can generate an interrupt request (value='1') or not (value='0'). Setting will affect irq_value as well as IRQ output pin.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x64600);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl1_a.irq_edge                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl1_a_irq_edge_type */
	/* skip, unused field unused_irq_edge (irq_edge) */
	REG_DUMP_PRINT_1("   -irq_edge.irq_edge                        |    0x%06X  |  [RW][23:00]""Indicates for each bit whether an interrupt request should be generated on a falling edge (value='0') or a rising edge (value='1').""\n", FIELD_VALUE(val, 0, 23));
} /* end irq_ctrl1_a */

/* Generated Debug Code: Device irq_ctrl0_a */
void ia_css_debug_dump_irq_ctrl0_a(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x6c514);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_a.irq_level_not_pulse            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl0_a_irq_level_not_pulse_type */
	/* skip, unused field unused_irq_level_not_pulse (irq_level_not_pulse) */
	REG_DUMP_PRINT_1("   -irq_level_not_pulse.irq_level_not_pulse  |     0x%05X  |  [RW][16:00]""Indicates for each bit whether an interrupt cause is translated into a pulse (value='0') or into a constant level '1' (value='1') on the IRQ pin.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0x6c510);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_a.irq_enable                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl0_a_irq_enable_type */
	/* skip, unused field unused_irq_enable (irq_enable) */
	REG_DUMP_PRINT_1("   -irq_enable.irq_enable                    |     0x%05X  |  [RW][16:00]""Indicates for each bit whether an interrupt cause as monitored by the req_irq_status register also affects the IRQ pin (value='1') or not (value='0').""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0x6c508);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_a.irq_status                     |  0x%08X  |  ""Indicates for each bit whether a non-masked interrupt has been generated (value='1'). Can be cleared by writing a '1' into the the corresponding bit of the req_irq_clear register.""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl0_a_irq_status_type */
	/* skip, unused field unused_irq_status (irq_status) */
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_0                 |         0x%01X  |  [RO][00:00]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_1                 |         0x%01X  |  [RO][01:01]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_2                 |         0x%01X  |  [RO][02:02]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_3                 |         0x%01X  |  [RO][03:03]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_4                 |         0x%01X  |  [RO][04:04]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_5                 |         0x%01X  |  [RO][05:05]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_6                 |         0x%01X  |  [RO][06:06]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_7                 |         0x%01X  |  [RO][07:07]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_8                 |         0x%01X  |  [RO][08:08]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_9                 |         0x%01X  |  [RO][09:09]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_10                |         0x%01X  |  [RO][10:10]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_11                |         0x%01X  |  [RO][11:11]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_12                |         0x%01X  |  [RO][12:12]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 12, 12));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_13                |         0x%01X  |  [RO][13:13]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 13, 13));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_14                |         0x%01X  |  [RO][14:14]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 14, 14));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_15                |         0x%01X  |  [RO][15:15]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 15, 15));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_16                |         0x%01X  |  [RO][16:16]""Represents the status of the irq from  rx.""\n", FIELD_VALUE(val, 16, 16));
	val = REG_DUMP_READ_REGISTER(0x6c504);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_a.irq_mask                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl0_a_irq_mask_type */
	/* skip, unused field unused_irq_mask (irq_mask) */
	REG_DUMP_PRINT_1("   -irq_mask.irq_mask                        |     0x%05X  |  [RW][16:00]""Indicates for each bit of irq_di whether it can generate an interrupt request (value='1') or not (value='0'). Setting will affect irq_value as well as IRQ output pin.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0x6c500);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_a.irq_edge                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl0_a_irq_edge_type */
	/* skip, unused field unused_irq_edge (irq_edge) */
	REG_DUMP_PRINT_1("   -irq_edge.irq_edge                        |     0x%05X  |  [RW][16:00]""Indicates for each bit whether an interrupt request should be generated on a falling edge (value='0') or a rising edge (value='1').""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0x64514);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_a.irq_level_not_pulse            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl0_a_irq_level_not_pulse_type */
	/* skip, unused field unused_irq_level_not_pulse (irq_level_not_pulse) */
	REG_DUMP_PRINT_1("   -irq_level_not_pulse.irq_level_not_pulse  |     0x%05X  |  [RW][16:00]""Indicates for each bit whether an interrupt cause is translated into a pulse (value='0') or into a constant level '1' (value='1') on the IRQ pin.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0x64510);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_a.irq_enable                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl0_a_irq_enable_type */
	/* skip, unused field unused_irq_enable (irq_enable) */
	REG_DUMP_PRINT_1("   -irq_enable.irq_enable                    |     0x%05X  |  [RW][16:00]""Indicates for each bit whether an interrupt cause as monitored by the req_irq_status register also affects the IRQ pin (value='1') or not (value='0').""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0x64508);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_a.irq_status                     |  0x%08X  |  ""Indicates for each bit whether a non-masked interrupt has been generated (value='1'). Can be cleared by writing a '1' into the the corresponding bit of the req_irq_clear register.""\n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl0_a_irq_status_type */
	/* skip, unused field unused_irq_status (irq_status) */
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_0             |         0x%01X  |  [RO][00:00]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_1             |         0x%01X  |  [RO][01:01]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_2             |         0x%01X  |  [RO][02:02]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_3             |         0x%01X  |  [RO][03:03]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_4             |         0x%01X  |  [RO][04:04]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_5             |         0x%01X  |  [RO][05:05]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_6             |         0x%01X  |  [RO][06:06]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_7             |         0x%01X  |  [RO][07:07]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_8             |         0x%01X  |  [RO][08:08]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_9             |         0x%01X  |  [RO][09:09]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_10            |         0x%01X  |  [RO][10:10]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_11            |         0x%01X  |  [RO][11:11]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_12            |         0x%01X  |  [RO][12:12]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 12, 12));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_13            |         0x%01X  |  [RO][13:13]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 13, 13));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_14            |         0x%01X  |  [RO][14:14]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 14, 14));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_15            |         0x%01X  |  [RO][15:15]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 15, 15));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_16            |         0x%01X  |  [RO][16:16]""Represents the status of the irq from  csi_rx.""\n", FIELD_VALUE(val, 16, 16));
	val = REG_DUMP_READ_REGISTER(0x64504);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_a.irq_mask                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl0_a_irq_mask_type */
	/* skip, unused field unused_irq_mask (irq_mask) */
	REG_DUMP_PRINT_1("   -irq_mask.irq_mask                        |     0x%05X  |  [RW][16:00]""Indicates for each bit of irq_di whether it can generate an interrupt request (value='1') or not (value='0'). Setting will affect irq_value as well as IRQ output pin.""\n", FIELD_VALUE(val, 0, 16));
	val = REG_DUMP_READ_REGISTER(0x64500);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl0_a.irq_edge                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl0_a_irq_edge_type */
	/* skip, unused field unused_irq_edge (irq_edge) */
	REG_DUMP_PRINT_1("   -irq_edge.irq_edge                        |     0x%05X  |  [RW][16:00]""Indicates for each bit whether an interrupt request should be generated on a falling edge (value='0') or a rising edge (value='1').""\n", FIELD_VALUE(val, 0, 16));
} /* end irq_ctrl0_a */

/* Generated Debug Code: Device irq_ctrl_a */
void ia_css_debug_dump_irq_ctrl_a(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x6c414);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_a.irq_level_not_pulse             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl_a_irq_level_not_pulse_type */
	/* skip, unused field unused_irq_level_not_pulse (irq_level_not_pulse) */
	REG_DUMP_PRINT_1("   -irq_level_not_pulse.irq_level_not_pulse  |     0x%05X  |  [RW][18:00]""Indicates for each bit whether an interrupt cause is translated into a pulse (value='0') or into a constant level '1' (value='1') on the IRQ pin.""\n", FIELD_VALUE(val, 0, 18));
	val = REG_DUMP_READ_REGISTER(0x6c410);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_a.irq_enable                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl_a_irq_enable_type */
	/* skip, unused field unused_irq_enable (irq_enable) */
	REG_DUMP_PRINT_1("   -irq_enable.irq_enable                    |     0x%05X  |  [RW][18:00]""Indicates for each bit whether an interrupt cause as monitored by the req_irq_status register also affects the IRQ pin (value='1') or not (value='0').""\n", FIELD_VALUE(val, 0, 18));
	val = REG_DUMP_READ_REGISTER(0x6c408);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_a.irq_status                      |  0x%08X  |  ""Indicates for each bit whether a non-masked interrupt has been generated (value='1'). Can be cleared by writing a '1' into the the corresponding bit of the req_irq_clear register.""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl_a_irq_status_type */
	/* skip, unused field unused_irq_status (irq_status) */
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_0                 |         0x%01X  |  [RO][00:00]""Represents the status of the irq from  csi_rx_ irqs sync.""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_1                 |         0x%01X  |  [RO][01:01]""Represents the status of the irq from  csi_rx_ irqs sync.""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_2                 |         0x%01X  |  [RO][02:02]""Represents the status of the irq from  csi_rx_ irqs sync.""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_3                 |         0x%01X  |  [RO][03:03]""Represents the status of the irq from  csi_rx_ irqs sync.""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_4                 |         0x%01X  |  [RO][04:04]""Represents the status of the irq from  csi_rx_ irqs sync.""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_5                 |         0x%01X  |  [RO][05:05]""Represents the status of the irq from  csi_rx_ irqs sync.""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_6                 |         0x%01X  |  [RO][06:06]""Represents the status of the irq from  csi_rx_ irqs sync.""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_7                 |         0x%01X  |  [RO][07:07]""Represents the status of the irq from  csi_rx_ irqs sync.""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_8                 |         0x%01X  |  [RO][08:08]""Represents the status of the irq from  csi_rx_ irqs sync.""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_9                 |         0x%01X  |  [RO][09:09]""Represents the status of the irq from  csi_rx_ irqs sync.""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_10                |         0x%01X  |  [RO][10:10]""Represents the status of the irq from  csi_rx_ irqs sync.""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_11                |         0x%01X  |  [RO][11:11]""Represents the status of the irq from  csi_rx_ irqs sync.""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_12                |         0x%01X  |  [RO][12:12]""Represents the status of the irq from  csi_rx_ irqs sync.""\n", FIELD_VALUE(val, 12, 12));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_13                |         0x%01X  |  [RO][13:13]""Represents the status of the irq from  csi_rx_ irqs sync.""\n", FIELD_VALUE(val, 13, 13));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_14                |         0x%01X  |  [RO][14:14]""Represents the status of the irq from  csi_rx_ irqs sync.""\n", FIELD_VALUE(val, 14, 14));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX_15                |         0x%01X  |  [RO][15:15]""Represents the status of the irq from  csi_rx_ irqs sync.""\n", FIELD_VALUE(val, 15, 15));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_RX                   |         0x%01X  |  [RO][16:16]""Represents the status of the irq from irq_ctrl0 (csi_rx irqs).""\n", FIELD_VALUE(val, 16, 16));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M                  |         0x%01X  |  [RO][17:17]""Represents the status of the irq from irq_ctrl1 (csi__rx_synchronization_irqs + s2m_irqs).""\n", FIELD_VALUE(val, 17, 17));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_SM                   |         0x%01X  |  [RO][18:18]""Represents the status of the irq from Stream Monitor.""\n", FIELD_VALUE(val, 18, 18));
	val = REG_DUMP_READ_REGISTER(0x6c404);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_a.irq_mask                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl_a_irq_mask_type */
	/* skip, unused field unused_irq_mask (irq_mask) */
	REG_DUMP_PRINT_1("   -irq_mask.irq_mask                        |     0x%05X  |  [RW][18:00]""Indicates for each bit of irq_di whether it can generate an interrupt request (value='1') or not (value='0'). Setting will affect irq_value as well as IRQ output pin.""\n", FIELD_VALUE(val, 0, 18));
	val = REG_DUMP_READ_REGISTER(0x6c400);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_a.irq_edge                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_irq_ctrl_a_irq_edge_type */
	/* skip, unused field unused_irq_edge (irq_edge) */
	REG_DUMP_PRINT_1("   -irq_edge.irq_edge                        |     0x%05X  |  [RW][18:00]""Indicates for each bit whether an interrupt request should be generated on a falling edge (value='0') or a rising edge (value='1').""\n", FIELD_VALUE(val, 0, 18));
	val = REG_DUMP_READ_REGISTER(0x64414);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_a.irq_level_not_pulse             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl_a_irq_level_not_pulse_type */
	/* skip, unused field unused_irq_level_not_pulse (irq_level_not_pulse) */
	REG_DUMP_PRINT_1("   -irq_level_not_pulse.irq_level_not_pulse  |     0x%05X  |  [RW][18:00]""Indicates for each bit whether an interrupt cause is translated into a pulse (value='0') or into a constant level '1' (value='1') on the IRQ pin.""\n", FIELD_VALUE(val, 0, 18));
	val = REG_DUMP_READ_REGISTER(0x64410);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_a.irq_enable                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl_a_irq_enable_type */
	/* skip, unused field unused_irq_enable (irq_enable) */
	REG_DUMP_PRINT_1("   -irq_enable.irq_enable                    |     0x%05X  |  [RW][18:00]""Indicates for each bit whether an interrupt cause as monitored by the req_irq_status register also affects the IRQ pin (value='1') or not (value='0').""\n", FIELD_VALUE(val, 0, 18));
	val = REG_DUMP_READ_REGISTER(0x64408);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_a.irq_status                      |  0x%08X  |  ""Indicates for each bit whether a non-masked interrupt has been generated (value='1'). Can be cleared by writing a '1' into the the corresponding bit of the req_irq_clear register.""\n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl_a_irq_status_type */
	/* skip, unused field unused_irq_status (irq_status) */
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_0             |         0x%01X  |  [RO][00:00]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_1             |         0x%01X  |  [RO][01:01]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_2             |         0x%01X  |  [RO][02:02]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_3             |         0x%01X  |  [RO][03:03]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_4             |         0x%01X  |  [RO][04:04]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_5             |         0x%01X  |  [RO][05:05]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_6             |         0x%01X  |  [RO][06:06]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_7             |         0x%01X  |  [RO][07:07]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_8             |         0x%01X  |  [RO][08:08]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_9             |         0x%01X  |  [RO][09:09]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_10            |         0x%01X  |  [RO][10:10]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_11            |         0x%01X  |  [RO][11:11]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_12            |         0x%01X  |  [RO][12:12]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 12, 12));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_13            |         0x%01X  |  [RO][13:13]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 13, 13));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_14            |         0x%01X  |  [RO][14:14]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 14, 14));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX_15            |         0x%01X  |  [RO][15:15]""Represents the status of the synchronization irq from  csi_rx.""\n", FIELD_VALUE(val, 15, 15));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_CSI_RX               |         0x%01X  |  [RO][16:16]""Represents the status of the irq from irq_ctrl0 (csi_rx irqs).""\n", FIELD_VALUE(val, 16, 16));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_S2M                  |         0x%01X  |  [RO][17:17]""Represents the status of the irq from irq_ctrl1 (csi__rx_synchronization_irqs + s2m_irqs).""\n", FIELD_VALUE(val, 17, 17));
	REG_DUMP_PRINT_1("   -irq_status.IRQ_STAT_SM                   |         0x%01X  |  [RO][18:18]""Represents the status of the irq from Stream Monitor.""\n", FIELD_VALUE(val, 18, 18));
	val = REG_DUMP_READ_REGISTER(0x64404);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_a.irq_mask                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl_a_irq_mask_type */
	/* skip, unused field unused_irq_mask (irq_mask) */
	REG_DUMP_PRINT_1("   -irq_mask.irq_mask                        |     0x%05X  |  [RW][18:00]""Indicates for each bit of irq_di whether it can generate an interrupt request (value='1') or not (value='0'). Setting will affect irq_value as well as IRQ output pin.""\n", FIELD_VALUE(val, 0, 18));
	val = REG_DUMP_READ_REGISTER(0x64400);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  irq_ctrl_a.irq_edge                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_irq_ctrl_a_irq_edge_type */
	/* skip, unused field unused_irq_edge (irq_edge) */
	REG_DUMP_PRINT_1("   -irq_edge.irq_edge                        |     0x%05X  |  [RW][18:00]""Indicates for each bit whether an interrupt request should be generated on a falling edge (value='0') or a rising edge (value='1').""\n", FIELD_VALUE(val, 0, 18));
} /* end irq_ctrl_a */

/* Generated Debug Code: Device csi_rx_a */
void ia_css_debug_dump_csi_rx_a(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x6c050);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_dly_cnt_settle_dlane3                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_a_reg_rx_csi_dly_cnt_settle_dlane3_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_settle_dlane3 (reg_rx_csi_dly_cnt_settle_dlane3) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_settle_dlane3.reg_rx_csi_dly_cnt_settle_dlane3  |    0x%06X  |  [RW][23:00]""Specify the Delay value for Settling time of Data lane 3 HS Rx data.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6c04c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_dly_cnt_termen_dlane3                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_a_reg_rx_csi_dly_cnt_termen_dlane3_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_termen_dlane3 (reg_rx_csi_dly_cnt_termen_dlane3) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_termen_dlane3.reg_rx_csi_dly_cnt_termen_dlane3  |    0x%06X  |  [RW][23:00]""Specify the Delay value for Termination enable of Data lane 3 HS Rx.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6c048);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_dly_cnt_settle_dlane2                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_a_reg_rx_csi_dly_cnt_settle_dlane2_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_settle_dlane2 (reg_rx_csi_dly_cnt_settle_dlane2) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_settle_dlane2.reg_rx_csi_dly_cnt_settle_dlane2  |    0x%06X  |  [RW][23:00]""Specify the Delay value for Settling time of Data lane 2 HS Rx data.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6c044);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_dly_cnt_termen_dlane2                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_a_reg_rx_csi_dly_cnt_termen_dlane2_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_termen_dlane2 (reg_rx_csi_dly_cnt_termen_dlane2) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_termen_dlane2.reg_rx_csi_dly_cnt_termen_dlane2  |    0x%06X  |  [RW][23:00]""Specify the Delay value for Termination enable of Data lane 2 HS Rx.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6c040);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_dly_cnt_settle_dlane1                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_a_reg_rx_csi_dly_cnt_settle_dlane1_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_settle_dlane1 (reg_rx_csi_dly_cnt_settle_dlane1) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_settle_dlane1.reg_rx_csi_dly_cnt_settle_dlane1  |    0x%06X  |  [RW][23:00]""Specify the Delay value for Settling time of Data lane 1 HS Rx data.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6c03c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_dly_cnt_termen_dlane1                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_a_reg_rx_csi_dly_cnt_termen_dlane1_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_termen_dlane1 (reg_rx_csi_dly_cnt_termen_dlane1) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_termen_dlane1.reg_rx_csi_dly_cnt_termen_dlane1  |    0x%06X  |  [RW][23:00]""Specify the Delay value for Termination enable of Data lane 1 HS Rx.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6c038);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_dly_cnt_settle_dlane0                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_a_reg_rx_csi_dly_cnt_settle_dlane0_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_settle_dlane0 (reg_rx_csi_dly_cnt_settle_dlane0) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_settle_dlane0.reg_rx_csi_dly_cnt_settle_dlane0  |    0x%06X  |  [RW][23:00]""Specify the Delay value for Settling time of Data lane 0 HS Rx data.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6c034);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_dly_cnt_termen_dlane0                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_a_reg_rx_csi_dly_cnt_termen_dlane0_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_termen_dlane0 (reg_rx_csi_dly_cnt_termen_dlane0) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_termen_dlane0.reg_rx_csi_dly_cnt_termen_dlane0  |    0x%06X  |  [RW][23:00]""Specify the Delay value for Termination enable of Data lane 0 HS Rx.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6c030);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_dly_cnt_settle_clane                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_a_reg_rx_csi_dly_cnt_settle_clane_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_settle_clane (reg_rx_csi_dly_cnt_settle_clane) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_settle_clane.reg_rx_csi_dly_cnt_settle_clane    |    0x%06X  |  [RW][23:00]""Specify the Delay value for HS Settling time of Clock lane HS Rx data.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6c02c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_dly_cnt_termen_clane                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_a_reg_rx_csi_dly_cnt_termen_clane_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_termen_clane (reg_rx_csi_dly_cnt_termen_clane) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_termen_clane.reg_rx_csi_dly_cnt_termen_clane    |    0x%06X  |  [RW][23:00]""Specify the Delay value for Termination enable of Clock lane HS Rx.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6c028);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_status_dlane_lp                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_a_reg_rx_csi_status_dlane_lp_type */
	/* skip, unused field unused_reg_rx_csi_status_dlane_lp (reg_rx_csi_status_dlane_lp) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_status_dlane_lp.reg_rx_csi_status_dlane_lp              |    0x%06X  |  [RW][23:00]""Status register for low power communication errors and events (Escape mode (errors), trigger events)                    This is an edge triggered status register which bits can be cleared via writing.                   Reading:                    Error entering escape mode:                    Bit.0 =LP Esc Error Dlane-0                    Bit.1 =LP Esc Error Dlane-1                    Bit.2 =LP Esc Error Dlane-2                    Bit.3 =LP Esc Error Dlane-3                    Low power events, refer to REF-2 DPHY MAS, section 4.3.2 for detailed information:                    Bit.4 =LP TriggerEsc0 (Rst) Dlane-0                    Bit.5 =LP TriggerEsc1 (Unk3) Dlane-0                    Bit.6 =LP TriggerEsc2 (Unk4) Dlane-0                    Bit.7 =LP TriggerEsc3 (Unk5) Dlane-0                    Bit.8 =LP TriggerEsc0 (Rst) Dlane-1                    Bit.9 =LP TriggerEsc1 (Unk3) Dlane-1                    Bit.10 =LP TriggerEsc2 (Unk4) Dlane-1                    Bit.11 =LP TriggerEsc3 (Unk5) Dlane-1                    Bit.12 =LP TriggerEsc0 (Rst) Dlane-2                    Bit.13 =LP TriggerEsc1 (Unk3) Dlane-2                    Bit.14 =LP TriggerEsc2 (Unk4) Dlane-2                    Bit.15 =LP TriggerEsc3 (Unk5) Dlane-2                    Bit.16 =LP TriggerEsc0 (Rst) Dlane-3                    Bit.17 =LP TriggerEsc1 (Unk3) Dlane-3                    Bit.18 =LP TriggerEsc2 (Unk4) Dlane-3                    Bit.19 =LP TriggerEsc3 (Unk5) Dlane-3                    Bit.20 =LP UlpsEsc Dlane-0                    Bit.21 =LP UlpsEsc Dlane-1                    Bit.22 =LP UlpsEsc Dlane-2                    Bit.23 =LP UlpsEsc Dlane-3                    Writing:                    Writing a '1' to a particular bit clears that bit.                    Eg.                    Writing 0x1 clears bit.0                    Writing 0x3 clears bit.0 and bit.1                    Etc.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6c024);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_status_dlane_hs                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_a_reg_rx_csi_status_dlane_hs_type */
	/* skip, unused field unused_reg_rx_csi_status_dlane_hs (reg_rx_csi_status_dlane_hs) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_status_dlane_hs.reg_rx_csi_status_dlane_hs              |        0x%02X  |  [RW][07:00]""Status register for high speed communication errors (single bit, multiple bit errors in sync pattern)                    This is an edge triggered status register which bits can be cleared via writing.                    Reading:                    DPHY recoverable sync errors (single bit error):                     Bit.0 =HS SOT Error Dlane-0                    Bit.1 =HS SOT Error Dlane-1                    Bit.2 =HS SOT Error Dlane-2                    Bit.3 =HS SOT Error Dlane-3                    DPHY NON-recoverable sync errors (multiple bit error):                    Bit.4 =HS SOT Sync Error Dlane-0                    Bit.5 =HS SOT Sync Error Dlane-1                    Bit.6 =HS SOT Sync Error Dlane-2                    Bit.7 =HS SOT Sync Error Dlane-3                    Writing:                    Writing a '1' to a particular bit clears that bit.                    Eg.                   Writing 0x1 clears bit.0                    Writing 0x3 clears bit.0 and bit.1                    Etc. ""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0x6c020);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_status                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_a_reg_rx_csi_status_type */
	/* skip, unused field unused_reg_rx_csi_status (reg_rx_csi_status) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_status.reg_rx_csi_status                                |         0x%01X  |  [RO][01:00]""Status register.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x6c01c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_lp_if_config                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_a_reg_rx_csi_lp_if_config_type */
	/* skip, unused field unused_reg_rx_csi_lp_if_config (reg_rx_csi_lp_if_config) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_lp_if_config.reg_rx_csi_lp_if_config                    |         0x%01X  |  [RW][02:00]""Long packet inter-frame configuration register (error type 8a)                    bit[1:0]                    00 = filter out all long packets in between frames, no error is communicated (only via IRQ)                    01 = filter out inter-frame long packets while VC is inactive, pass when active                    10 = always pass                    11 = reserved/not used                    bit[2]                    0 = no error flag + code added to passed packet                    1 = error flag + code added to passed packet""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x6c018);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_sp_if_config                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_a_reg_rx_csi_sp_if_config_type */
	/* skip, unused field unused_reg_rx_csi_sp_if_config (reg_rx_csi_sp_if_config) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_sp_if_config.reg_rx_csi_sp_if_config                    |         0x%01X  |  [RW][02:00]""Short packet inter-frame configuration register (error type 8a)                    bit[1:0]                    00 = filter out all short packets in between frames, no error is communicated (only via IRQ)                    01 = filter out inter-frame short packets while VC is inactive, pass when active                    10 = always pass                    11 = reserved/not used                    bit[2]                    0 = no error flag + code added to passed packet                    1 = error flag + code added to passed packet""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x6c014);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_sync_cntr_sel                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_a_reg_rx_csi_sync_cntr_sel_type */
	/* skip, unused field unused_reg_rx_csi_sync_cntr_sel (reg_rx_csi_sync_cntr_sel) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_sync_cntr_sel.reg_rx_csi_sync_cntr_sel                  |         0x%01X  |  [RW][01:00]""Sync counter select register. 		               bit 0 => 0: Use internal counter for line start and line end packet IDs.                          => 1: Use line start and line end ID as send by sensor 									 bit 1 => 0: Use internal counter for frame start and frame end packet IDs.                          => 1: Use frame start and frame end ID as send by sensor""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x6c010);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_error_handling                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_a_reg_rx_csi_error_handling_type */
	/* skip, unused field unused_reg_rx_csi_error_handling (reg_rx_csi_error_handling) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_error_handling.reg_rx_csi_error_handling                |        0x%02X  |  [RW][04:00]""Error handling register. 		               bit 0 = when set, packets with more than one erro in packet header 									  			 are discarded. 									 bit 1 = when set, a short packet with reserved id is discarded and irq 									  			 is raised 									 bit 2 = when set, a long packet with reserved id is discarded and irq 									  			 is raised 		               bit 3 = when set, detection of incomplete packet is disabled, irq will 									         not be generated""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0x6c00c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_hbp_testmode_enable                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_a_reg_rx_csi_hbp_testmode_enable_type */
	/* skip, unused field unused_reg_rx_csi_hbp_testmode_enable (reg_rx_csi_hbp_testmode_enable) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_hbp_testmode_enable.reg_rx_csi_hbp_testmode_enable      |         0x%01X  |  [RW][00:00]""HBP test mode enable register of CSI RX.                    0 = Normal mode(DPHY receives HS data and byte clock from AFE), 									 1 = HBP test mode (DPHY receives HS data and byte clock via TESTER GPIOs),                   ""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6c008);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_control                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_a_reg_rx_csi_control_type */
	/* skip, unused field unused_reg_rx_csi_control (reg_rx_csi_control) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_control.reg_rx_csi_control                              |       0x%03X  |  [RW][10:00]""Control register CSI RX.                    bit 0 = release_lp11 									 bit 1 = disable_byte_clk_gating,                   ""\n", FIELD_VALUE(val, 0, 10));
	val = REG_DUMP_READ_REGISTER(0x6c004);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_nof_enabled_lanes                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_a_reg_rx_csi_nof_enabled_lanes_type */
	/* skip, unused field unused_reg_rx_csi_nof_enabled_lanes (reg_rx_csi_nof_enabled_lanes) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_nof_enabled_lanes.reg_rx_csi_nof_enabled_lanes          |         0x%01X  |  [RW][02:00]""Specify Number of enabled data lanes of CSI RX.                    0 = No lanes enabled 									 1 = One   lane  enabled,                    2 = Two   lanes enabled,                    3 = Three lanes enabled,                    4 = Four  lanes enabled,                   ""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x6c000);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_enable                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_csi_rx_a_reg_rx_csi_enable_type */
	/* skip, unused field unused_reg_rx_csi_enable (reg_rx_csi_enable) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_enable.reg_rx_csi_enable                                |         0x%01X  |  [RW][00:00]""Enable CSI RX""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x64050);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_dly_cnt_settle_dlane3                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_a_reg_rx_csi_dly_cnt_settle_dlane3_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_settle_dlane3 (reg_rx_csi_dly_cnt_settle_dlane3) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_settle_dlane3.reg_rx_csi_dly_cnt_settle_dlane3  |    0x%06X  |  [RW][23:00]""Specify the Delay value for Settling time of Data lane 3 HS Rx data.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6404c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_dly_cnt_termen_dlane3                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_a_reg_rx_csi_dly_cnt_termen_dlane3_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_termen_dlane3 (reg_rx_csi_dly_cnt_termen_dlane3) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_termen_dlane3.reg_rx_csi_dly_cnt_termen_dlane3  |    0x%06X  |  [RW][23:00]""Specify the Delay value for Termination enable of Data lane 3 HS Rx.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x64048);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_dly_cnt_settle_dlane2                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_a_reg_rx_csi_dly_cnt_settle_dlane2_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_settle_dlane2 (reg_rx_csi_dly_cnt_settle_dlane2) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_settle_dlane2.reg_rx_csi_dly_cnt_settle_dlane2  |    0x%06X  |  [RW][23:00]""Specify the Delay value for Settling time of Data lane 2 HS Rx data.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x64044);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_dly_cnt_termen_dlane2                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_a_reg_rx_csi_dly_cnt_termen_dlane2_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_termen_dlane2 (reg_rx_csi_dly_cnt_termen_dlane2) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_termen_dlane2.reg_rx_csi_dly_cnt_termen_dlane2  |    0x%06X  |  [RW][23:00]""Specify the Delay value for Termination enable of Data lane 2 HS Rx.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x64040);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_dly_cnt_settle_dlane1                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_a_reg_rx_csi_dly_cnt_settle_dlane1_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_settle_dlane1 (reg_rx_csi_dly_cnt_settle_dlane1) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_settle_dlane1.reg_rx_csi_dly_cnt_settle_dlane1  |    0x%06X  |  [RW][23:00]""Specify the Delay value for Settling time of Data lane 1 HS Rx data.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6403c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_dly_cnt_termen_dlane1                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_a_reg_rx_csi_dly_cnt_termen_dlane1_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_termen_dlane1 (reg_rx_csi_dly_cnt_termen_dlane1) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_termen_dlane1.reg_rx_csi_dly_cnt_termen_dlane1  |    0x%06X  |  [RW][23:00]""Specify the Delay value for Termination enable of Data lane 1 HS Rx.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x64038);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_dly_cnt_settle_dlane0                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_a_reg_rx_csi_dly_cnt_settle_dlane0_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_settle_dlane0 (reg_rx_csi_dly_cnt_settle_dlane0) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_settle_dlane0.reg_rx_csi_dly_cnt_settle_dlane0  |    0x%06X  |  [RW][23:00]""Specify the Delay value for Settling time of Data lane 0 HS Rx data.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x64034);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_dly_cnt_termen_dlane0                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_a_reg_rx_csi_dly_cnt_termen_dlane0_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_termen_dlane0 (reg_rx_csi_dly_cnt_termen_dlane0) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_termen_dlane0.reg_rx_csi_dly_cnt_termen_dlane0  |    0x%06X  |  [RW][23:00]""Specify the Delay value for Termination enable of Data lane 0 HS Rx.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x64030);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_dly_cnt_settle_clane                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_a_reg_rx_csi_dly_cnt_settle_clane_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_settle_clane (reg_rx_csi_dly_cnt_settle_clane) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_settle_clane.reg_rx_csi_dly_cnt_settle_clane    |    0x%06X  |  [RW][23:00]""Specify the Delay value for HS Settling time of Clock lane HS Rx data.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x6402c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_dly_cnt_termen_clane                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_a_reg_rx_csi_dly_cnt_termen_clane_type */
	/* skip, unused field unused_reg_rx_csi_dly_cnt_termen_clane (reg_rx_csi_dly_cnt_termen_clane) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_dly_cnt_termen_clane.reg_rx_csi_dly_cnt_termen_clane    |    0x%06X  |  [RW][23:00]""Specify the Delay value for Termination enable of Clock lane HS Rx.                    Counter resolution is 0.0625ns per count number.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x64028);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_status_dlane_lp                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_a_reg_rx_csi_status_dlane_lp_type */
	/* skip, unused field unused_reg_rx_csi_status_dlane_lp (reg_rx_csi_status_dlane_lp) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_status_dlane_lp.reg_rx_csi_status_dlane_lp              |    0x%06X  |  [RW][23:00]""Status register for low power communication errors and events (Escape mode (errors), trigger events)                    This is an edge triggered status register which bits can be cleared via writing.                   Reading:                    Error entering escape mode:                    Bit.0 =LP Esc Error Dlane-0                    Bit.1 =LP Esc Error Dlane-1                    Bit.2 =LP Esc Error Dlane-2                    Bit.3 =LP Esc Error Dlane-3                    Low power events, refer to REF-2 DPHY MAS, section 4.3.2 for detailed information:                    Bit.4 =LP TriggerEsc0 (Rst) Dlane-0                    Bit.5 =LP TriggerEsc1 (Unk3) Dlane-0                    Bit.6 =LP TriggerEsc2 (Unk4) Dlane-0                    Bit.7 =LP TriggerEsc3 (Unk5) Dlane-0                    Bit.8 =LP TriggerEsc0 (Rst) Dlane-1                    Bit.9 =LP TriggerEsc1 (Unk3) Dlane-1                    Bit.10 =LP TriggerEsc2 (Unk4) Dlane-1                    Bit.11 =LP TriggerEsc3 (Unk5) Dlane-1                    Bit.12 =LP TriggerEsc0 (Rst) Dlane-2                    Bit.13 =LP TriggerEsc1 (Unk3) Dlane-2                    Bit.14 =LP TriggerEsc2 (Unk4) Dlane-2                    Bit.15 =LP TriggerEsc3 (Unk5) Dlane-2                    Bit.16 =LP TriggerEsc0 (Rst) Dlane-3                    Bit.17 =LP TriggerEsc1 (Unk3) Dlane-3                    Bit.18 =LP TriggerEsc2 (Unk4) Dlane-3                    Bit.19 =LP TriggerEsc3 (Unk5) Dlane-3                    Bit.20 =LP UlpsEsc Dlane-0                    Bit.21 =LP UlpsEsc Dlane-1                    Bit.22 =LP UlpsEsc Dlane-2                    Bit.23 =LP UlpsEsc Dlane-3                    Writing:                    Writing a '1' to a particular bit clears that bit.                    Eg.                    Writing 0x1 clears bit.0                    Writing 0x3 clears bit.0 and bit.1                    Etc.""\n", FIELD_VALUE(val, 0, 23));
	val = REG_DUMP_READ_REGISTER(0x64024);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_status_dlane_hs                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_a_reg_rx_csi_status_dlane_hs_type */
	/* skip, unused field unused_reg_rx_csi_status_dlane_hs (reg_rx_csi_status_dlane_hs) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_status_dlane_hs.reg_rx_csi_status_dlane_hs              |        0x%02X  |  [RW][07:00]""Status register for high speed communication errors (single bit, multiple bit errors in sync pattern)                    This is an edge triggered status register which bits can be cleared via writing.                    Reading:                    DPHY recoverable sync errors (single bit error):                     Bit.0 =HS SOT Error Dlane-0                    Bit.1 =HS SOT Error Dlane-1                    Bit.2 =HS SOT Error Dlane-2                    Bit.3 =HS SOT Error Dlane-3                    DPHY NON-recoverable sync errors (multiple bit error):                    Bit.4 =HS SOT Sync Error Dlane-0                    Bit.5 =HS SOT Sync Error Dlane-1                    Bit.6 =HS SOT Sync Error Dlane-2                    Bit.7 =HS SOT Sync Error Dlane-3                    Writing:                    Writing a '1' to a particular bit clears that bit.                    Eg.                   Writing 0x1 clears bit.0                    Writing 0x3 clears bit.0 and bit.1                    Etc. ""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0x64020);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_status                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_a_reg_rx_csi_status_type */
	/* skip, unused field unused_reg_rx_csi_status (reg_rx_csi_status) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_status.reg_rx_csi_status                                |         0x%01X  |  [RO][01:00]""Status register.""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x6401c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_lp_if_config                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_a_reg_rx_csi_lp_if_config_type */
	/* skip, unused field unused_reg_rx_csi_lp_if_config (reg_rx_csi_lp_if_config) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_lp_if_config.reg_rx_csi_lp_if_config                    |         0x%01X  |  [RW][02:00]""Long packet inter-frame configuration register (error type 8a)                    bit[1:0]                    00 = filter out all long packets in between frames, no error is communicated (only via IRQ)                    01 = filter out inter-frame long packets while VC is inactive, pass when active                    10 = always pass                    11 = reserved/not used                    bit[2]                    0 = no error flag + code added to passed packet                    1 = error flag + code added to passed packet""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x64018);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_sp_if_config                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_a_reg_rx_csi_sp_if_config_type */
	/* skip, unused field unused_reg_rx_csi_sp_if_config (reg_rx_csi_sp_if_config) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_sp_if_config.reg_rx_csi_sp_if_config                    |         0x%01X  |  [RW][02:00]""Short packet inter-frame configuration register (error type 8a)                    bit[1:0]                    00 = filter out all short packets in between frames, no error is communicated (only via IRQ)                    01 = filter out inter-frame short packets while VC is inactive, pass when active                    10 = always pass                    11 = reserved/not used                    bit[2]                    0 = no error flag + code added to passed packet                    1 = error flag + code added to passed packet""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x64014);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_sync_cntr_sel                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_a_reg_rx_csi_sync_cntr_sel_type */
	/* skip, unused field unused_reg_rx_csi_sync_cntr_sel (reg_rx_csi_sync_cntr_sel) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_sync_cntr_sel.reg_rx_csi_sync_cntr_sel                  |         0x%01X  |  [RW][01:00]""Sync counter select register. 		               bit 0 => 0: Use internal counter for line start and line end packet IDs.                          => 1: Use line start and line end ID as send by sensor 									 bit 1 => 0: Use internal counter for frame start and frame end packet IDs.                          => 1: Use frame start and frame end ID as send by sensor""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x64010);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_error_handling                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_a_reg_rx_csi_error_handling_type */
	/* skip, unused field unused_reg_rx_csi_error_handling (reg_rx_csi_error_handling) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_error_handling.reg_rx_csi_error_handling                |        0x%02X  |  [RW][04:00]""Error handling register. 		               bit 0 = when set, packets with more than one erro in packet header 									  			 are discarded. 									 bit 1 = when set, a short packet with reserved id is discarded and irq 									  			 is raised 									 bit 2 = when set, a long packet with reserved id is discarded and irq 									  			 is raised 		               bit 3 = when set, detection of incomplete packet is disabled, irq will 									         not be generated""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0x6400c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_hbp_testmode_enable                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_a_reg_rx_csi_hbp_testmode_enable_type */
	/* skip, unused field unused_reg_rx_csi_hbp_testmode_enable (reg_rx_csi_hbp_testmode_enable) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_hbp_testmode_enable.reg_rx_csi_hbp_testmode_enable      |         0x%01X  |  [RW][00:00]""HBP test mode enable register of CSI RX.                    0 = Normal mode(DPHY receives HS data and byte clock from AFE), 									 1 = HBP test mode (DPHY receives HS data and byte clock via TESTER GPIOs),                   ""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x64008);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_control                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_a_reg_rx_csi_control_type */
	/* skip, unused field unused_reg_rx_csi_control (reg_rx_csi_control) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_control.reg_rx_csi_control                              |       0x%03X  |  [RW][10:00]""Control register CSI RX.                    bit 0 = release_lp11 									 bit 1 = disable_byte_clk_gating,                   ""\n", FIELD_VALUE(val, 0, 10));
	val = REG_DUMP_READ_REGISTER(0x64004);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_nof_enabled_lanes                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_a_reg_rx_csi_nof_enabled_lanes_type */
	/* skip, unused field unused_reg_rx_csi_nof_enabled_lanes (reg_rx_csi_nof_enabled_lanes) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_nof_enabled_lanes.reg_rx_csi_nof_enabled_lanes          |         0x%01X  |  [RW][02:00]""Specify Number of enabled data lanes of CSI RX.                    0 = No lanes enabled 									 1 = One   lane  enabled,                    2 = Two   lanes enabled,                    3 = Three lanes enabled,                    4 = Four  lanes enabled,                   ""\n", FIELD_VALUE(val, 0, 2));
	val = REG_DUMP_READ_REGISTER(0x64000);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  csi_rx_a.reg_rx_csi_enable                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_csi_rx_a_reg_rx_csi_enable_type */
	/* skip, unused field unused_reg_rx_csi_enable (reg_rx_csi_enable) */
	REG_DUMP_PRINT_1("   -reg_rx_csi_enable.reg_rx_csi_enable                                |         0x%01X  |  [RW][00:00]""Enable CSI RX""\n", FIELD_VALUE(val, 0, 0));
} /* end csi_rx_a */

/* Generated Debug Code: Device ibuf_ctrl */
void ia_css_debug_dump_ibuf_ctrl(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xb5f24);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest15_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest15_iwake_threshold_type */
	/* skip, unused field unused_dest15_iwake_threshold (dest15_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest15_iwake_threshold.dest15_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb5f1c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest15_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest15_st_addr_type */
	REG_DUMP_PRINT_1("   -dest15_st_addr.dest15_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb5f18);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest15_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest15_dest_mode_type */
	/* skip, unused field unused_dest15_dest_mode (dest15_dest_mode) */
	REG_DUMP_PRINT_1("   -dest15_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest15_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest15_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest15_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest15_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xb5f14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest15_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest15_term_b_addr_type */
	/* skip, unused field unused_dest15_term_b_addr (dest15_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest15_term_b_addr.dest15_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5f10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest15_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest15_span_b_addr_type */
	/* skip, unused field unused_dest15_span_b_addr (dest15_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest15_span_b_addr.dest15_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5f0c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest15_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest15_span_a_addr_type */
	/* skip, unused field unused_dest15_span_a_addr (dest15_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest15_span_a_addr.dest15_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5f08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest15_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest15_channel_addr_type */
	/* skip, unused field unused_dest15_channel_addr (dest15_channel_addr) */
	REG_DUMP_PRINT_1("   -dest15_channel_addr.dest15_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5f04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest15_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest15_requester_addr_type */
	/* skip, unused field unused_dest15_requester_addr (dest15_requester_addr) */
	REG_DUMP_PRINT_1("   -dest15_requester_addr.dest15_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5f00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest15_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest15_feed_addr_type */
	/* skip, unused field unused_dest15_feed_addr (dest15_feed_addr) */
	REG_DUMP_PRINT_1("   -dest15_feed_addr.dest15_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5ee4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_dest0_cur_cmds                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid15_dest0_cur_cmds_type */
	/* skip, unused field unused_sid15_dest0_cur_cmds (sid15_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid15_dest0_cur_cmds.sid15_dest0_cur_cmds                          |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb5ee0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_dest0_sync_state                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid15_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid15_dest0_sync_state.sid15_dest0_sync_state                      |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb5edc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_dest0_cur_ack_line                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid15_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid15_dest0_cur_ack_line (sid15_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid15_dest0_cur_ack_line.sid15_dest0_cur_ack_line                  |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb5ed8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_dest0_cur_ack_unit_in_line                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid15_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid15_dest0_cur_ack_unit_in_line (sid15_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid15_dest0_cur_ack_unit_in_line.sid15_dest0_cur_ack_unit_in_line  |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb5ed4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_dest0_cur_ack_unit                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid15_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid15_dest0_cur_ack_unit (sid15_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid15_dest0_cur_ack_unit.sid15_dest0_cur_ack_unit                  |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb5ecc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_main_control_state                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid15_main_control_state_type */
	/* skip, unused field unused_sid15_main_control_state (sid15_main_control_state) */
	REG_DUMP_PRINT_1("   -sid15_main_control_state.sid15_main_control_state                  |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb5ec8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_s2m_cur_ack_line                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid15_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid15_s2m_cur_ack_line (sid15_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid15_s2m_cur_ack_line.sid15_s2m_cur_ack_line                      |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb5ec4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_s2m_cur_ack_unit_in_line                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid15_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid15_s2m_cur_ack_unit_in_line (sid15_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid15_s2m_cur_ack_unit_in_line.sid15_s2m_cur_ack_unit_in_line      |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb5ec0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_s2m_cur_cmds                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid15_s2m_cur_cmds_type */
	/* skip, unused field unused_sid15_s2m_cur_cmds (sid15_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid15_s2m_cur_cmds.sid15_s2m_cur_cmds                              |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb5e98);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_error_reg                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid15_error_reg_type */
	REG_DUMP_PRINT_1("   -sid15_error_reg.sid15_error_reg                                    |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb5e88);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_eventque_sidpid                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid15_eventque_sidpid_type */
	/* skip, unused field unused_sid15_eventque_sidpid (sid15_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid15_eventque_sidpid.sid15_eventque_sidpid                        |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb5e84);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_ack_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid15_ack_addr_type */
	/* skip, unused field unused_sid15_ack_addr (sid15_ack_addr) */
	REG_DUMP_PRINT_1("   -sid15_ack_addr.sid15_ack_addr                                      |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5e68);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_dest0_enabled                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid15_dest0_enabled_type */
	/* skip, unused field unused_sid15_dest0_enabled (sid15_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid15_dest0_enabled.sid15_dest0_enabled                            |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 15""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb5e5c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_first_page_nr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid15_first_page_nr_type */
	/* skip, unused field unused_sid15_first_page_nr (sid15_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid15_first_page_nr.sid15_first_page_nr                            |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb5e54);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_units_p_ibuf                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid15_units_p_ibuf_type */
	/* skip, unused field unused_sid15_units_p_ibuf (sid15_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid15_units_p_ibuf.sid15_units_p_ibuf                              |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb5e50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_unit_size                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid15_unit_size_type */
	/* skip, unused field unused_sid15_unit_size (sid15_unit_size) */
	REG_DUMP_PRINT_1("   -sid15_unit_size.sid15_unit_size                                    |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb5e4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_lines_p_frame                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid15_lines_p_frame_type */
	/* skip, unused field unused_sid15_lines_p_frame (sid15_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid15_lines_p_frame.sid15_lines_p_frame                            |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb5e48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_units_p_line                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid15_units_p_line_type */
	/* skip, unused field unused_sid15_units_p_line (sid15_units_p_line) */
	REG_DUMP_PRINT_1("   -sid15_units_p_line.sid15_units_p_line                              |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb5e44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_str2mmio_store_cmd                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid15_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid15_str2mmio_store_cmd (sid15_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid15_str2mmio_store_cmd.sid15_str2mmio_store_cmd                  |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb5e40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_str2mmio_proc_addr                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid15_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid15_str2mmio_proc_addr (sid15_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid15_str2mmio_proc_addr.sid15_str2mmio_proc_addr                  |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5d24);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest14_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest14_iwake_threshold_type */
	/* skip, unused field unused_dest14_iwake_threshold (dest14_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest14_iwake_threshold.dest14_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb5d1c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest14_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest14_st_addr_type */
	REG_DUMP_PRINT_1("   -dest14_st_addr.dest14_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb5d18);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest14_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest14_dest_mode_type */
	/* skip, unused field unused_dest14_dest_mode (dest14_dest_mode) */
	REG_DUMP_PRINT_1("   -dest14_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest14_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest14_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest14_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest14_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xb5d14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest14_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest14_term_b_addr_type */
	/* skip, unused field unused_dest14_term_b_addr (dest14_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest14_term_b_addr.dest14_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5d10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest14_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest14_span_b_addr_type */
	/* skip, unused field unused_dest14_span_b_addr (dest14_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest14_span_b_addr.dest14_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5d0c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest14_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest14_span_a_addr_type */
	/* skip, unused field unused_dest14_span_a_addr (dest14_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest14_span_a_addr.dest14_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5d08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest14_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest14_channel_addr_type */
	/* skip, unused field unused_dest14_channel_addr (dest14_channel_addr) */
	REG_DUMP_PRINT_1("   -dest14_channel_addr.dest14_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5d04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest14_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest14_requester_addr_type */
	/* skip, unused field unused_dest14_requester_addr (dest14_requester_addr) */
	REG_DUMP_PRINT_1("   -dest14_requester_addr.dest14_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5d00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest14_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest14_feed_addr_type */
	/* skip, unused field unused_dest14_feed_addr (dest14_feed_addr) */
	REG_DUMP_PRINT_1("   -dest14_feed_addr.dest14_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5ce4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_dest0_cur_cmds                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid14_dest0_cur_cmds_type */
	/* skip, unused field unused_sid14_dest0_cur_cmds (sid14_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid14_dest0_cur_cmds.sid14_dest0_cur_cmds                          |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb5ce0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_dest0_sync_state                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid14_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid14_dest0_sync_state.sid14_dest0_sync_state                      |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb5cdc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_dest0_cur_ack_line                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid14_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid14_dest0_cur_ack_line (sid14_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid14_dest0_cur_ack_line.sid14_dest0_cur_ack_line                  |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb5cd8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_dest0_cur_ack_unit_in_line                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid14_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid14_dest0_cur_ack_unit_in_line (sid14_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid14_dest0_cur_ack_unit_in_line.sid14_dest0_cur_ack_unit_in_line  |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb5cd4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_dest0_cur_ack_unit                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid14_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid14_dest0_cur_ack_unit (sid14_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid14_dest0_cur_ack_unit.sid14_dest0_cur_ack_unit                  |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb5ccc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_main_control_state                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid14_main_control_state_type */
	/* skip, unused field unused_sid14_main_control_state (sid14_main_control_state) */
	REG_DUMP_PRINT_1("   -sid14_main_control_state.sid14_main_control_state                  |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb5cc8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_s2m_cur_ack_line                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid14_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid14_s2m_cur_ack_line (sid14_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid14_s2m_cur_ack_line.sid14_s2m_cur_ack_line                      |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb5cc4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_s2m_cur_ack_unit_in_line                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid14_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid14_s2m_cur_ack_unit_in_line (sid14_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid14_s2m_cur_ack_unit_in_line.sid14_s2m_cur_ack_unit_in_line      |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb5cc0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_s2m_cur_cmds                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid14_s2m_cur_cmds_type */
	/* skip, unused field unused_sid14_s2m_cur_cmds (sid14_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid14_s2m_cur_cmds.sid14_s2m_cur_cmds                              |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb5c98);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_error_reg                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid14_error_reg_type */
	REG_DUMP_PRINT_1("   -sid14_error_reg.sid14_error_reg                                    |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb5c88);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_eventque_sidpid                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid14_eventque_sidpid_type */
	/* skip, unused field unused_sid14_eventque_sidpid (sid14_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid14_eventque_sidpid.sid14_eventque_sidpid                        |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb5c84);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_ack_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid14_ack_addr_type */
	/* skip, unused field unused_sid14_ack_addr (sid14_ack_addr) */
	REG_DUMP_PRINT_1("   -sid14_ack_addr.sid14_ack_addr                                      |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5c68);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_dest0_enabled                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid14_dest0_enabled_type */
	/* skip, unused field unused_sid14_dest0_enabled (sid14_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid14_dest0_enabled.sid14_dest0_enabled                            |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 14""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb5c5c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_first_page_nr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid14_first_page_nr_type */
	/* skip, unused field unused_sid14_first_page_nr (sid14_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid14_first_page_nr.sid14_first_page_nr                            |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb5c54);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_units_p_ibuf                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid14_units_p_ibuf_type */
	/* skip, unused field unused_sid14_units_p_ibuf (sid14_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid14_units_p_ibuf.sid14_units_p_ibuf                              |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb5c50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_unit_size                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid14_unit_size_type */
	/* skip, unused field unused_sid14_unit_size (sid14_unit_size) */
	REG_DUMP_PRINT_1("   -sid14_unit_size.sid14_unit_size                                    |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb5c4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_lines_p_frame                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid14_lines_p_frame_type */
	/* skip, unused field unused_sid14_lines_p_frame (sid14_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid14_lines_p_frame.sid14_lines_p_frame                            |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb5c48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_units_p_line                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid14_units_p_line_type */
	/* skip, unused field unused_sid14_units_p_line (sid14_units_p_line) */
	REG_DUMP_PRINT_1("   -sid14_units_p_line.sid14_units_p_line                              |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb5c44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_str2mmio_store_cmd                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid14_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid14_str2mmio_store_cmd (sid14_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid14_str2mmio_store_cmd.sid14_str2mmio_store_cmd                  |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb5c40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_str2mmio_proc_addr                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid14_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid14_str2mmio_proc_addr (sid14_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid14_str2mmio_proc_addr.sid14_str2mmio_proc_addr                  |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5bcc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed13_cur_rcvd_acks                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed13_cur_rcvd_acks_type */
	/* skip, unused field unused_feed13_cur_rcvd_acks (feed13_cur_rcvd_acks) */
	REG_DUMP_PRINT_1("   -feed13_cur_rcvd_acks.feed13_cur_rcvd_acks                          |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb5bc8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed13_cur_snd_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed13_cur_snd_cmds_type */
	/* skip, unused field unused_feed13_cur_snd_cmds (feed13_cur_snd_cmds) */
	REG_DUMP_PRINT_1("   -feed13_cur_snd_cmds.feed13_cur_snd_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands send for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb5bc4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed13_cur_line_in                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed13_cur_line_in_type */
	/* skip, unused field unused_feed13_cur_line_in (feed13_cur_line_in) */
	REG_DUMP_PRINT_1("   -feed13_cur_line_in.feed13_cur_line_in                              |         0x%01X  |  [RO][03:00]""The current number of lines in a 2D block that not have been transferred""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb5bc0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed13_cur_unit_in_line_in                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed13_cur_unit_in_line_in_type */
	/* skip, unused field unused_feed13_cur_unit_in_line_in (feed13_cur_unit_in_line_in) */
	REG_DUMP_PRINT_1("   -feed13_cur_unit_in_line_in.feed13_cur_unit_in_line_in              |         0x%01X  |  [RO][03:00]""The current number of units from the input in the line of a 2D block""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb5bb0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed13_sync_feeders                                        |  0x%08X  |  ""The feeder will wait with sending a command to the DMA until all feeders with the same bit set are ready to send a command.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed13_sync_feeders_type */
	/* skip, unused field unused_feed13_sync_feeders (feed13_sync_feeders) */
	REG_DUMP_PRINT_1("   -feed13_sync_feeders.feed_sync_0                                    |         0x%01X  |  [RW][00:00]""Sync with all feeders with bit 0 set""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed13_sync_feeders.feed_sync_1                                    |         0x%01X  |  [RW][01:01]""Sync with all feeders with bit 1 set""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0xb5bac);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed13_wait_order                                          |  0x%08X  |  ""Two feeders, set with the same order unit (bit 1..4), will keep the order in feeding.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed13_wait_order_type */
	/* skip, unused field unused_feed13_wait_order (feed13_wait_order) */
	REG_DUMP_PRINT_1("   -feed13_wait_order.feed_order                                       |         0x%01X  |  [RW][00:00]""0: send as first, 1: send as second""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed13_wait_order.enable_order_0                                   |         0x%01X  |  [RW][01:01]""Enable the order for order unit 0""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -feed13_wait_order.enable_order_1                                   |         0x%01X  |  [RW][02:02]""Enable the order for order unit 1""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -feed13_wait_order.enable_order_2                                   |         0x%01X  |  [RW][03:03]""Enable the order for order unit 2""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -feed13_wait_order.enable_order_3                                   |         0x%01X  |  [RW][04:04]""Enable the order for order unit 3""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xb5ba8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed13_wait_on_feeders                                     |  0x%08X  |  ""The feeder will wait for other feeders when the have the bit for the same destination set.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed13_wait_on_feeders_type */
	/* skip, unused field unused_feed13_wait_on_feeders (feed13_wait_on_feeders) */
	REG_DUMP_PRINT_1("   -feed13_wait_on_feeders.feed_dest_0                                 |         0x%01X  |  [RW][00:00]""Wait with feeding for all feeders that are currently feeding a line and have bit 0 set""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed13_wait_on_feeders.feed_dest_1                                 |         0x%01X  |  [RW][01:01]""Wait with feeding for all feeders that are currently feeding a line and have bit 1 set""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -feed13_wait_on_feeders.feed_dest_2                                 |         0x%01X  |  [RW][02:02]""Wait with feeding for all feeders that are currently feeding a line and have bit 2 set""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -feed13_wait_on_feeders.feed_dest_3                                 |         0x%01X  |  [RW][03:03]""Wait with feeding for all feeders that are currently feeding a line and have bit 3 set""\n", FIELD_VALUE(val, 3, 3));
	val = REG_DUMP_READ_REGISTER(0xb5ba4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed13_eventque_sidpid                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed13_eventque_sidpid_type */
	/* skip, unused field unused_feed13_eventque_sidpid (feed13_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -feed13_eventque_sidpid.feed13_eventque_sidpid                      |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb5ba0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed13_height                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed13_height_type */
	/* skip, unused field unused_feed13_height (feed13_height) */
	REG_DUMP_PRINT_1("   -feed13_height.feed13_height                                        |         0x%01X  |  [RW][03:00]""The number of lines needed for a 2D unit block. A transfer will only begin when receiving cmd number (units_p_line_in * (height - 1)) + 1""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb5b9c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed13_last_units_out                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed13_last_units_out_type */
	/* skip, unused field unused_feed13_last_units_out (feed13_last_units_out) */
	REG_DUMP_PRINT_1("   -feed13_last_units_out.feed13_last_units_out                        |        0x%02X  |  [RW][06:00]""The last unit number to the DMA for the last unit from the input buffer in a line.""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb5b98);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed13_units_out_p_in                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed13_units_out_p_in_type */
	/* skip, unused field unused_feed13_units_out_p_in (feed13_units_out_p_in) */
	REG_DUMP_PRINT_1("   -feed13_units_out_p_in.feed13_units_out_p_in                        |        0x%02X  |  [RW][06:00]""The number of units being transferred by the DMA that fit (width wise) in a unit from the input buffer""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb5b94);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed13_units_p_line_in                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed13_units_p_line_in_type */
	/* skip, unused field unused_feed13_units_p_line_in (feed13_units_p_line_in) */
	REG_DUMP_PRINT_1("   -feed13_units_p_line_in.feed13_units_p_line_in                      |         0x%01X  |  [RW][03:00]""The number of units per line at the input buffer""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb5b90);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed13_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed13_channel_addr_type */
	/* skip, unused field unused_feed13_channel_addr (feed13_channel_addr) */
	REG_DUMP_PRINT_1("   -feed13_channel_addr.feed13_channel_addr                            |  0x%08X  |  [RW][29:00]""The address where the channel in the DMA is located""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5b8c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed13_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed13_requester_addr_type */
	/* skip, unused field unused_feed13_requester_addr (feed13_requester_addr) */
	REG_DUMP_PRINT_1("   -feed13_requester_addr.feed13_requester_addr                        |  0x%08X  |  [RW][29:00]""The address where the requester in the DMA is located""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5b88);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed13_ack_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed13_ack_addr_type */
	/* skip, unused field unused_feed13_ack_addr (feed13_ack_addr) */
	REG_DUMP_PRINT_1("   -feed13_ack_addr.feed13_ack_addr                                    |  0x%08X  |  [RW][29:00]""The address where the acknowledgement has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5b24);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest13_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest13_iwake_threshold_type */
	/* skip, unused field unused_dest13_iwake_threshold (dest13_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest13_iwake_threshold.dest13_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb5b1c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest13_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest13_st_addr_type */
	REG_DUMP_PRINT_1("   -dest13_st_addr.dest13_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb5b18);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest13_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest13_dest_mode_type */
	/* skip, unused field unused_dest13_dest_mode (dest13_dest_mode) */
	REG_DUMP_PRINT_1("   -dest13_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest13_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest13_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest13_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest13_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xb5b14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest13_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest13_term_b_addr_type */
	/* skip, unused field unused_dest13_term_b_addr (dest13_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest13_term_b_addr.dest13_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5b10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest13_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest13_span_b_addr_type */
	/* skip, unused field unused_dest13_span_b_addr (dest13_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest13_span_b_addr.dest13_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5b0c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest13_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest13_span_a_addr_type */
	/* skip, unused field unused_dest13_span_a_addr (dest13_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest13_span_a_addr.dest13_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5b08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest13_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest13_channel_addr_type */
	/* skip, unused field unused_dest13_channel_addr (dest13_channel_addr) */
	REG_DUMP_PRINT_1("   -dest13_channel_addr.dest13_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5b04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest13_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest13_requester_addr_type */
	/* skip, unused field unused_dest13_requester_addr (dest13_requester_addr) */
	REG_DUMP_PRINT_1("   -dest13_requester_addr.dest13_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5b00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest13_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest13_feed_addr_type */
	/* skip, unused field unused_dest13_feed_addr (dest13_feed_addr) */
	REG_DUMP_PRINT_1("   -dest13_feed_addr.dest13_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5ae4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_dest0_cur_cmds                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid13_dest0_cur_cmds_type */
	/* skip, unused field unused_sid13_dest0_cur_cmds (sid13_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid13_dest0_cur_cmds.sid13_dest0_cur_cmds                          |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb5ae0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_dest0_sync_state                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid13_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid13_dest0_sync_state.sid13_dest0_sync_state                      |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb5adc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_dest0_cur_ack_line                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid13_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid13_dest0_cur_ack_line (sid13_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid13_dest0_cur_ack_line.sid13_dest0_cur_ack_line                  |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb5ad8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_dest0_cur_ack_unit_in_line                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid13_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid13_dest0_cur_ack_unit_in_line (sid13_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid13_dest0_cur_ack_unit_in_line.sid13_dest0_cur_ack_unit_in_line  |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb5ad4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_dest0_cur_ack_unit                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid13_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid13_dest0_cur_ack_unit (sid13_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid13_dest0_cur_ack_unit.sid13_dest0_cur_ack_unit                  |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb5acc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_main_control_state                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid13_main_control_state_type */
	/* skip, unused field unused_sid13_main_control_state (sid13_main_control_state) */
	REG_DUMP_PRINT_1("   -sid13_main_control_state.sid13_main_control_state                  |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb5ac8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_s2m_cur_ack_line                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid13_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid13_s2m_cur_ack_line (sid13_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid13_s2m_cur_ack_line.sid13_s2m_cur_ack_line                      |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb5ac4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_s2m_cur_ack_unit_in_line                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid13_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid13_s2m_cur_ack_unit_in_line (sid13_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid13_s2m_cur_ack_unit_in_line.sid13_s2m_cur_ack_unit_in_line      |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb5ac0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_s2m_cur_cmds                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid13_s2m_cur_cmds_type */
	/* skip, unused field unused_sid13_s2m_cur_cmds (sid13_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid13_s2m_cur_cmds.sid13_s2m_cur_cmds                              |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb5a98);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_error_reg                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid13_error_reg_type */
	REG_DUMP_PRINT_1("   -sid13_error_reg.sid13_error_reg                                    |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb5a88);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_eventque_sidpid                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid13_eventque_sidpid_type */
	/* skip, unused field unused_sid13_eventque_sidpid (sid13_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid13_eventque_sidpid.sid13_eventque_sidpid                        |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb5a84);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_ack_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid13_ack_addr_type */
	/* skip, unused field unused_sid13_ack_addr (sid13_ack_addr) */
	REG_DUMP_PRINT_1("   -sid13_ack_addr.sid13_ack_addr                                      |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5a68);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_dest0_enabled                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid13_dest0_enabled_type */
	/* skip, unused field unused_sid13_dest0_enabled (sid13_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid13_dest0_enabled.sid13_dest0_enabled                            |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 13""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb5a5c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_first_page_nr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid13_first_page_nr_type */
	/* skip, unused field unused_sid13_first_page_nr (sid13_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid13_first_page_nr.sid13_first_page_nr                            |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb5a54);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_units_p_ibuf                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid13_units_p_ibuf_type */
	/* skip, unused field unused_sid13_units_p_ibuf (sid13_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid13_units_p_ibuf.sid13_units_p_ibuf                              |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb5a50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_unit_size                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid13_unit_size_type */
	/* skip, unused field unused_sid13_unit_size (sid13_unit_size) */
	REG_DUMP_PRINT_1("   -sid13_unit_size.sid13_unit_size                                    |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb5a4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_lines_p_frame                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid13_lines_p_frame_type */
	/* skip, unused field unused_sid13_lines_p_frame (sid13_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid13_lines_p_frame.sid13_lines_p_frame                            |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb5a48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_units_p_line                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid13_units_p_line_type */
	/* skip, unused field unused_sid13_units_p_line (sid13_units_p_line) */
	REG_DUMP_PRINT_1("   -sid13_units_p_line.sid13_units_p_line                              |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb5a44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_str2mmio_store_cmd                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid13_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid13_str2mmio_store_cmd (sid13_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid13_str2mmio_store_cmd.sid13_str2mmio_store_cmd                  |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb5a40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_str2mmio_proc_addr                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid13_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid13_str2mmio_proc_addr (sid13_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid13_str2mmio_proc_addr.sid13_str2mmio_proc_addr                  |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb59cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed12_cur_rcvd_acks                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed12_cur_rcvd_acks_type */
	/* skip, unused field unused_feed12_cur_rcvd_acks (feed12_cur_rcvd_acks) */
	REG_DUMP_PRINT_1("   -feed12_cur_rcvd_acks.feed12_cur_rcvd_acks                          |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb59c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed12_cur_snd_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed12_cur_snd_cmds_type */
	/* skip, unused field unused_feed12_cur_snd_cmds (feed12_cur_snd_cmds) */
	REG_DUMP_PRINT_1("   -feed12_cur_snd_cmds.feed12_cur_snd_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands send for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb59c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed12_cur_line_in                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed12_cur_line_in_type */
	/* skip, unused field unused_feed12_cur_line_in (feed12_cur_line_in) */
	REG_DUMP_PRINT_1("   -feed12_cur_line_in.feed12_cur_line_in                              |         0x%01X  |  [RO][03:00]""The current number of lines in a 2D block that not have been transferred""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb59c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed12_cur_unit_in_line_in                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed12_cur_unit_in_line_in_type */
	/* skip, unused field unused_feed12_cur_unit_in_line_in (feed12_cur_unit_in_line_in) */
	REG_DUMP_PRINT_1("   -feed12_cur_unit_in_line_in.feed12_cur_unit_in_line_in              |         0x%01X  |  [RO][03:00]""The current number of units from the input in the line of a 2D block""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb59b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed12_sync_feeders                                        |  0x%08X  |  ""The feeder will wait with sending a command to the DMA until all feeders with the same bit set are ready to send a command.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed12_sync_feeders_type */
	/* skip, unused field unused_feed12_sync_feeders (feed12_sync_feeders) */
	REG_DUMP_PRINT_1("   -feed12_sync_feeders.feed_sync_0                                    |         0x%01X  |  [RW][00:00]""Sync with all feeders with bit 0 set""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed12_sync_feeders.feed_sync_1                                    |         0x%01X  |  [RW][01:01]""Sync with all feeders with bit 1 set""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0xb59ac);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed12_wait_order                                          |  0x%08X  |  ""Two feeders, set with the same order unit (bit 1..4), will keep the order in feeding.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed12_wait_order_type */
	/* skip, unused field unused_feed12_wait_order (feed12_wait_order) */
	REG_DUMP_PRINT_1("   -feed12_wait_order.feed_order                                       |         0x%01X  |  [RW][00:00]""0: send as first, 1: send as second""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed12_wait_order.enable_order_0                                   |         0x%01X  |  [RW][01:01]""Enable the order for order unit 0""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -feed12_wait_order.enable_order_1                                   |         0x%01X  |  [RW][02:02]""Enable the order for order unit 1""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -feed12_wait_order.enable_order_2                                   |         0x%01X  |  [RW][03:03]""Enable the order for order unit 2""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -feed12_wait_order.enable_order_3                                   |         0x%01X  |  [RW][04:04]""Enable the order for order unit 3""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xb59a8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed12_wait_on_feeders                                     |  0x%08X  |  ""The feeder will wait for other feeders when the have the bit for the same destination set.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed12_wait_on_feeders_type */
	/* skip, unused field unused_feed12_wait_on_feeders (feed12_wait_on_feeders) */
	REG_DUMP_PRINT_1("   -feed12_wait_on_feeders.feed_dest_0                                 |         0x%01X  |  [RW][00:00]""Wait with feeding for all feeders that are currently feeding a line and have bit 0 set""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed12_wait_on_feeders.feed_dest_1                                 |         0x%01X  |  [RW][01:01]""Wait with feeding for all feeders that are currently feeding a line and have bit 1 set""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -feed12_wait_on_feeders.feed_dest_2                                 |         0x%01X  |  [RW][02:02]""Wait with feeding for all feeders that are currently feeding a line and have bit 2 set""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -feed12_wait_on_feeders.feed_dest_3                                 |         0x%01X  |  [RW][03:03]""Wait with feeding for all feeders that are currently feeding a line and have bit 3 set""\n", FIELD_VALUE(val, 3, 3));
	val = REG_DUMP_READ_REGISTER(0xb59a4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed12_eventque_sidpid                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed12_eventque_sidpid_type */
	/* skip, unused field unused_feed12_eventque_sidpid (feed12_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -feed12_eventque_sidpid.feed12_eventque_sidpid                      |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb59a0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed12_height                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed12_height_type */
	/* skip, unused field unused_feed12_height (feed12_height) */
	REG_DUMP_PRINT_1("   -feed12_height.feed12_height                                        |         0x%01X  |  [RW][03:00]""The number of lines needed for a 2D unit block. A transfer will only begin when receiving cmd number (units_p_line_in * (height - 1)) + 1""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb599c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed12_last_units_out                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed12_last_units_out_type */
	/* skip, unused field unused_feed12_last_units_out (feed12_last_units_out) */
	REG_DUMP_PRINT_1("   -feed12_last_units_out.feed12_last_units_out                        |        0x%02X  |  [RW][06:00]""The last unit number to the DMA for the last unit from the input buffer in a line.""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb5998);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed12_units_out_p_in                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed12_units_out_p_in_type */
	/* skip, unused field unused_feed12_units_out_p_in (feed12_units_out_p_in) */
	REG_DUMP_PRINT_1("   -feed12_units_out_p_in.feed12_units_out_p_in                        |        0x%02X  |  [RW][06:00]""The number of units being transferred by the DMA that fit (width wise) in a unit from the input buffer""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb5994);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed12_units_p_line_in                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed12_units_p_line_in_type */
	/* skip, unused field unused_feed12_units_p_line_in (feed12_units_p_line_in) */
	REG_DUMP_PRINT_1("   -feed12_units_p_line_in.feed12_units_p_line_in                      |         0x%01X  |  [RW][03:00]""The number of units per line at the input buffer""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb5990);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed12_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed12_channel_addr_type */
	/* skip, unused field unused_feed12_channel_addr (feed12_channel_addr) */
	REG_DUMP_PRINT_1("   -feed12_channel_addr.feed12_channel_addr                            |  0x%08X  |  [RW][29:00]""The address where the channel in the DMA is located""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb598c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed12_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed12_requester_addr_type */
	/* skip, unused field unused_feed12_requester_addr (feed12_requester_addr) */
	REG_DUMP_PRINT_1("   -feed12_requester_addr.feed12_requester_addr                        |  0x%08X  |  [RW][29:00]""The address where the requester in the DMA is located""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5988);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed12_ack_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed12_ack_addr_type */
	/* skip, unused field unused_feed12_ack_addr (feed12_ack_addr) */
	REG_DUMP_PRINT_1("   -feed12_ack_addr.feed12_ack_addr                                    |  0x%08X  |  [RW][29:00]""The address where the acknowledgement has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5924);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest12_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest12_iwake_threshold_type */
	/* skip, unused field unused_dest12_iwake_threshold (dest12_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest12_iwake_threshold.dest12_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb591c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest12_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest12_st_addr_type */
	REG_DUMP_PRINT_1("   -dest12_st_addr.dest12_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb5918);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest12_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest12_dest_mode_type */
	/* skip, unused field unused_dest12_dest_mode (dest12_dest_mode) */
	REG_DUMP_PRINT_1("   -dest12_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest12_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest12_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest12_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest12_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xb5914);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest12_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest12_term_b_addr_type */
	/* skip, unused field unused_dest12_term_b_addr (dest12_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest12_term_b_addr.dest12_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5910);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest12_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest12_span_b_addr_type */
	/* skip, unused field unused_dest12_span_b_addr (dest12_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest12_span_b_addr.dest12_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb590c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest12_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest12_span_a_addr_type */
	/* skip, unused field unused_dest12_span_a_addr (dest12_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest12_span_a_addr.dest12_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5908);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest12_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest12_channel_addr_type */
	/* skip, unused field unused_dest12_channel_addr (dest12_channel_addr) */
	REG_DUMP_PRINT_1("   -dest12_channel_addr.dest12_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5904);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest12_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest12_requester_addr_type */
	/* skip, unused field unused_dest12_requester_addr (dest12_requester_addr) */
	REG_DUMP_PRINT_1("   -dest12_requester_addr.dest12_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5900);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest12_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest12_feed_addr_type */
	/* skip, unused field unused_dest12_feed_addr (dest12_feed_addr) */
	REG_DUMP_PRINT_1("   -dest12_feed_addr.dest12_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb58e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_dest0_cur_cmds                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid12_dest0_cur_cmds_type */
	/* skip, unused field unused_sid12_dest0_cur_cmds (sid12_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid12_dest0_cur_cmds.sid12_dest0_cur_cmds                          |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb58e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_dest0_sync_state                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid12_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid12_dest0_sync_state.sid12_dest0_sync_state                      |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb58dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_dest0_cur_ack_line                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid12_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid12_dest0_cur_ack_line (sid12_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid12_dest0_cur_ack_line.sid12_dest0_cur_ack_line                  |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb58d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_dest0_cur_ack_unit_in_line                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid12_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid12_dest0_cur_ack_unit_in_line (sid12_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid12_dest0_cur_ack_unit_in_line.sid12_dest0_cur_ack_unit_in_line  |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb58d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_dest0_cur_ack_unit                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid12_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid12_dest0_cur_ack_unit (sid12_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid12_dest0_cur_ack_unit.sid12_dest0_cur_ack_unit                  |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb58cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_main_control_state                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid12_main_control_state_type */
	/* skip, unused field unused_sid12_main_control_state (sid12_main_control_state) */
	REG_DUMP_PRINT_1("   -sid12_main_control_state.sid12_main_control_state                  |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb58c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_s2m_cur_ack_line                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid12_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid12_s2m_cur_ack_line (sid12_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid12_s2m_cur_ack_line.sid12_s2m_cur_ack_line                      |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb58c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_s2m_cur_ack_unit_in_line                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid12_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid12_s2m_cur_ack_unit_in_line (sid12_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid12_s2m_cur_ack_unit_in_line.sid12_s2m_cur_ack_unit_in_line      |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb58c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_s2m_cur_cmds                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid12_s2m_cur_cmds_type */
	/* skip, unused field unused_sid12_s2m_cur_cmds (sid12_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid12_s2m_cur_cmds.sid12_s2m_cur_cmds                              |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb5898);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_error_reg                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid12_error_reg_type */
	REG_DUMP_PRINT_1("   -sid12_error_reg.sid12_error_reg                                    |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb5888);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_eventque_sidpid                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid12_eventque_sidpid_type */
	/* skip, unused field unused_sid12_eventque_sidpid (sid12_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid12_eventque_sidpid.sid12_eventque_sidpid                        |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb5884);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_ack_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid12_ack_addr_type */
	/* skip, unused field unused_sid12_ack_addr (sid12_ack_addr) */
	REG_DUMP_PRINT_1("   -sid12_ack_addr.sid12_ack_addr                                      |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5868);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_dest0_enabled                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid12_dest0_enabled_type */
	/* skip, unused field unused_sid12_dest0_enabled (sid12_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid12_dest0_enabled.sid12_dest0_enabled                            |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 12""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb585c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_first_page_nr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid12_first_page_nr_type */
	/* skip, unused field unused_sid12_first_page_nr (sid12_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid12_first_page_nr.sid12_first_page_nr                            |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb5854);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_units_p_ibuf                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid12_units_p_ibuf_type */
	/* skip, unused field unused_sid12_units_p_ibuf (sid12_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid12_units_p_ibuf.sid12_units_p_ibuf                              |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb5850);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_unit_size                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid12_unit_size_type */
	/* skip, unused field unused_sid12_unit_size (sid12_unit_size) */
	REG_DUMP_PRINT_1("   -sid12_unit_size.sid12_unit_size                                    |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb584c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_lines_p_frame                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid12_lines_p_frame_type */
	/* skip, unused field unused_sid12_lines_p_frame (sid12_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid12_lines_p_frame.sid12_lines_p_frame                            |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb5848);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_units_p_line                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid12_units_p_line_type */
	/* skip, unused field unused_sid12_units_p_line (sid12_units_p_line) */
	REG_DUMP_PRINT_1("   -sid12_units_p_line.sid12_units_p_line                              |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb5844);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_str2mmio_store_cmd                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid12_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid12_str2mmio_store_cmd (sid12_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid12_str2mmio_store_cmd.sid12_str2mmio_store_cmd                  |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb5840);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_str2mmio_proc_addr                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid12_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid12_str2mmio_proc_addr (sid12_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid12_str2mmio_proc_addr.sid12_str2mmio_proc_addr                  |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb57cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed11_cur_rcvd_acks                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed11_cur_rcvd_acks_type */
	/* skip, unused field unused_feed11_cur_rcvd_acks (feed11_cur_rcvd_acks) */
	REG_DUMP_PRINT_1("   -feed11_cur_rcvd_acks.feed11_cur_rcvd_acks                          |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb57c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed11_cur_snd_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed11_cur_snd_cmds_type */
	/* skip, unused field unused_feed11_cur_snd_cmds (feed11_cur_snd_cmds) */
	REG_DUMP_PRINT_1("   -feed11_cur_snd_cmds.feed11_cur_snd_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands send for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb57c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed11_cur_line_in                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed11_cur_line_in_type */
	/* skip, unused field unused_feed11_cur_line_in (feed11_cur_line_in) */
	REG_DUMP_PRINT_1("   -feed11_cur_line_in.feed11_cur_line_in                              |         0x%01X  |  [RO][03:00]""The current number of lines in a 2D block that not have been transferred""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb57c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed11_cur_unit_in_line_in                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed11_cur_unit_in_line_in_type */
	/* skip, unused field unused_feed11_cur_unit_in_line_in (feed11_cur_unit_in_line_in) */
	REG_DUMP_PRINT_1("   -feed11_cur_unit_in_line_in.feed11_cur_unit_in_line_in              |         0x%01X  |  [RO][03:00]""The current number of units from the input in the line of a 2D block""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb57b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed11_sync_feeders                                        |  0x%08X  |  ""The feeder will wait with sending a command to the DMA until all feeders with the same bit set are ready to send a command.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed11_sync_feeders_type */
	/* skip, unused field unused_feed11_sync_feeders (feed11_sync_feeders) */
	REG_DUMP_PRINT_1("   -feed11_sync_feeders.feed_sync_0                                    |         0x%01X  |  [RW][00:00]""Sync with all feeders with bit 0 set""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed11_sync_feeders.feed_sync_1                                    |         0x%01X  |  [RW][01:01]""Sync with all feeders with bit 1 set""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0xb57ac);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed11_wait_order                                          |  0x%08X  |  ""Two feeders, set with the same order unit (bit 1..4), will keep the order in feeding.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed11_wait_order_type */
	/* skip, unused field unused_feed11_wait_order (feed11_wait_order) */
	REG_DUMP_PRINT_1("   -feed11_wait_order.feed_order                                       |         0x%01X  |  [RW][00:00]""0: send as first, 1: send as second""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed11_wait_order.enable_order_0                                   |         0x%01X  |  [RW][01:01]""Enable the order for order unit 0""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -feed11_wait_order.enable_order_1                                   |         0x%01X  |  [RW][02:02]""Enable the order for order unit 1""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -feed11_wait_order.enable_order_2                                   |         0x%01X  |  [RW][03:03]""Enable the order for order unit 2""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -feed11_wait_order.enable_order_3                                   |         0x%01X  |  [RW][04:04]""Enable the order for order unit 3""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xb57a8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed11_wait_on_feeders                                     |  0x%08X  |  ""The feeder will wait for other feeders when the have the bit for the same destination set.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed11_wait_on_feeders_type */
	/* skip, unused field unused_feed11_wait_on_feeders (feed11_wait_on_feeders) */
	REG_DUMP_PRINT_1("   -feed11_wait_on_feeders.feed_dest_0                                 |         0x%01X  |  [RW][00:00]""Wait with feeding for all feeders that are currently feeding a line and have bit 0 set""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed11_wait_on_feeders.feed_dest_1                                 |         0x%01X  |  [RW][01:01]""Wait with feeding for all feeders that are currently feeding a line and have bit 1 set""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -feed11_wait_on_feeders.feed_dest_2                                 |         0x%01X  |  [RW][02:02]""Wait with feeding for all feeders that are currently feeding a line and have bit 2 set""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -feed11_wait_on_feeders.feed_dest_3                                 |         0x%01X  |  [RW][03:03]""Wait with feeding for all feeders that are currently feeding a line and have bit 3 set""\n", FIELD_VALUE(val, 3, 3));
	val = REG_DUMP_READ_REGISTER(0xb57a4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed11_eventque_sidpid                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed11_eventque_sidpid_type */
	/* skip, unused field unused_feed11_eventque_sidpid (feed11_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -feed11_eventque_sidpid.feed11_eventque_sidpid                      |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb57a0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed11_height                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed11_height_type */
	/* skip, unused field unused_feed11_height (feed11_height) */
	REG_DUMP_PRINT_1("   -feed11_height.feed11_height                                        |         0x%01X  |  [RW][03:00]""The number of lines needed for a 2D unit block. A transfer will only begin when receiving cmd number (units_p_line_in * (height - 1)) + 1""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb579c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed11_last_units_out                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed11_last_units_out_type */
	/* skip, unused field unused_feed11_last_units_out (feed11_last_units_out) */
	REG_DUMP_PRINT_1("   -feed11_last_units_out.feed11_last_units_out                        |        0x%02X  |  [RW][06:00]""The last unit number to the DMA for the last unit from the input buffer in a line.""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb5798);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed11_units_out_p_in                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed11_units_out_p_in_type */
	/* skip, unused field unused_feed11_units_out_p_in (feed11_units_out_p_in) */
	REG_DUMP_PRINT_1("   -feed11_units_out_p_in.feed11_units_out_p_in                        |        0x%02X  |  [RW][06:00]""The number of units being transferred by the DMA that fit (width wise) in a unit from the input buffer""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb5794);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed11_units_p_line_in                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed11_units_p_line_in_type */
	/* skip, unused field unused_feed11_units_p_line_in (feed11_units_p_line_in) */
	REG_DUMP_PRINT_1("   -feed11_units_p_line_in.feed11_units_p_line_in                      |         0x%01X  |  [RW][03:00]""The number of units per line at the input buffer""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb5790);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed11_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed11_channel_addr_type */
	/* skip, unused field unused_feed11_channel_addr (feed11_channel_addr) */
	REG_DUMP_PRINT_1("   -feed11_channel_addr.feed11_channel_addr                            |  0x%08X  |  [RW][29:00]""The address where the channel in the DMA is located""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb578c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed11_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed11_requester_addr_type */
	/* skip, unused field unused_feed11_requester_addr (feed11_requester_addr) */
	REG_DUMP_PRINT_1("   -feed11_requester_addr.feed11_requester_addr                        |  0x%08X  |  [RW][29:00]""The address where the requester in the DMA is located""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5788);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed11_ack_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed11_ack_addr_type */
	/* skip, unused field unused_feed11_ack_addr (feed11_ack_addr) */
	REG_DUMP_PRINT_1("   -feed11_ack_addr.feed11_ack_addr                                    |  0x%08X  |  [RW][29:00]""The address where the acknowledgement has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5724);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest11_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest11_iwake_threshold_type */
	/* skip, unused field unused_dest11_iwake_threshold (dest11_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest11_iwake_threshold.dest11_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb571c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest11_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest11_st_addr_type */
	REG_DUMP_PRINT_1("   -dest11_st_addr.dest11_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb5718);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest11_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest11_dest_mode_type */
	/* skip, unused field unused_dest11_dest_mode (dest11_dest_mode) */
	REG_DUMP_PRINT_1("   -dest11_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest11_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest11_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest11_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest11_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xb5714);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest11_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest11_term_b_addr_type */
	/* skip, unused field unused_dest11_term_b_addr (dest11_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest11_term_b_addr.dest11_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5710);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest11_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest11_span_b_addr_type */
	/* skip, unused field unused_dest11_span_b_addr (dest11_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest11_span_b_addr.dest11_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb570c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest11_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest11_span_a_addr_type */
	/* skip, unused field unused_dest11_span_a_addr (dest11_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest11_span_a_addr.dest11_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5708);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest11_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest11_channel_addr_type */
	/* skip, unused field unused_dest11_channel_addr (dest11_channel_addr) */
	REG_DUMP_PRINT_1("   -dest11_channel_addr.dest11_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5704);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest11_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest11_requester_addr_type */
	/* skip, unused field unused_dest11_requester_addr (dest11_requester_addr) */
	REG_DUMP_PRINT_1("   -dest11_requester_addr.dest11_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5700);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest11_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest11_feed_addr_type */
	/* skip, unused field unused_dest11_feed_addr (dest11_feed_addr) */
	REG_DUMP_PRINT_1("   -dest11_feed_addr.dest11_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb56e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_dest0_cur_cmds                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid11_dest0_cur_cmds_type */
	/* skip, unused field unused_sid11_dest0_cur_cmds (sid11_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid11_dest0_cur_cmds.sid11_dest0_cur_cmds                          |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb56e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_dest0_sync_state                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid11_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid11_dest0_sync_state.sid11_dest0_sync_state                      |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb56dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_dest0_cur_ack_line                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid11_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid11_dest0_cur_ack_line (sid11_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid11_dest0_cur_ack_line.sid11_dest0_cur_ack_line                  |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb56d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_dest0_cur_ack_unit_in_line                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid11_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid11_dest0_cur_ack_unit_in_line (sid11_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid11_dest0_cur_ack_unit_in_line.sid11_dest0_cur_ack_unit_in_line  |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb56d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_dest0_cur_ack_unit                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid11_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid11_dest0_cur_ack_unit (sid11_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid11_dest0_cur_ack_unit.sid11_dest0_cur_ack_unit                  |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb56cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_main_control_state                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid11_main_control_state_type */
	/* skip, unused field unused_sid11_main_control_state (sid11_main_control_state) */
	REG_DUMP_PRINT_1("   -sid11_main_control_state.sid11_main_control_state                  |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb56c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_s2m_cur_ack_line                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid11_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid11_s2m_cur_ack_line (sid11_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid11_s2m_cur_ack_line.sid11_s2m_cur_ack_line                      |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb56c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_s2m_cur_ack_unit_in_line                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid11_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid11_s2m_cur_ack_unit_in_line (sid11_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid11_s2m_cur_ack_unit_in_line.sid11_s2m_cur_ack_unit_in_line      |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb56c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_s2m_cur_cmds                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid11_s2m_cur_cmds_type */
	/* skip, unused field unused_sid11_s2m_cur_cmds (sid11_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid11_s2m_cur_cmds.sid11_s2m_cur_cmds                              |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb5698);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_error_reg                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid11_error_reg_type */
	REG_DUMP_PRINT_1("   -sid11_error_reg.sid11_error_reg                                    |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb5688);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_eventque_sidpid                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid11_eventque_sidpid_type */
	/* skip, unused field unused_sid11_eventque_sidpid (sid11_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid11_eventque_sidpid.sid11_eventque_sidpid                        |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb5684);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_ack_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid11_ack_addr_type */
	/* skip, unused field unused_sid11_ack_addr (sid11_ack_addr) */
	REG_DUMP_PRINT_1("   -sid11_ack_addr.sid11_ack_addr                                      |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5668);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_dest0_enabled                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid11_dest0_enabled_type */
	/* skip, unused field unused_sid11_dest0_enabled (sid11_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid11_dest0_enabled.sid11_dest0_enabled                            |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 11""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb565c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_first_page_nr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid11_first_page_nr_type */
	/* skip, unused field unused_sid11_first_page_nr (sid11_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid11_first_page_nr.sid11_first_page_nr                            |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb5654);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_units_p_ibuf                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid11_units_p_ibuf_type */
	/* skip, unused field unused_sid11_units_p_ibuf (sid11_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid11_units_p_ibuf.sid11_units_p_ibuf                              |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb5650);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_unit_size                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid11_unit_size_type */
	/* skip, unused field unused_sid11_unit_size (sid11_unit_size) */
	REG_DUMP_PRINT_1("   -sid11_unit_size.sid11_unit_size                                    |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb564c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_lines_p_frame                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid11_lines_p_frame_type */
	/* skip, unused field unused_sid11_lines_p_frame (sid11_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid11_lines_p_frame.sid11_lines_p_frame                            |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb5648);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_units_p_line                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid11_units_p_line_type */
	/* skip, unused field unused_sid11_units_p_line (sid11_units_p_line) */
	REG_DUMP_PRINT_1("   -sid11_units_p_line.sid11_units_p_line                              |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb5644);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_str2mmio_store_cmd                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid11_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid11_str2mmio_store_cmd (sid11_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid11_str2mmio_store_cmd.sid11_str2mmio_store_cmd                  |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb5640);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_str2mmio_proc_addr                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid11_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid11_str2mmio_proc_addr (sid11_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid11_str2mmio_proc_addr.sid11_str2mmio_proc_addr                  |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb55cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed10_cur_rcvd_acks                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed10_cur_rcvd_acks_type */
	/* skip, unused field unused_feed10_cur_rcvd_acks (feed10_cur_rcvd_acks) */
	REG_DUMP_PRINT_1("   -feed10_cur_rcvd_acks.feed10_cur_rcvd_acks                          |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb55c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed10_cur_snd_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed10_cur_snd_cmds_type */
	/* skip, unused field unused_feed10_cur_snd_cmds (feed10_cur_snd_cmds) */
	REG_DUMP_PRINT_1("   -feed10_cur_snd_cmds.feed10_cur_snd_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands send for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb55c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed10_cur_line_in                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed10_cur_line_in_type */
	/* skip, unused field unused_feed10_cur_line_in (feed10_cur_line_in) */
	REG_DUMP_PRINT_1("   -feed10_cur_line_in.feed10_cur_line_in                              |         0x%01X  |  [RO][03:00]""The current number of lines in a 2D block that not have been transferred""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb55c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed10_cur_unit_in_line_in                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed10_cur_unit_in_line_in_type */
	/* skip, unused field unused_feed10_cur_unit_in_line_in (feed10_cur_unit_in_line_in) */
	REG_DUMP_PRINT_1("   -feed10_cur_unit_in_line_in.feed10_cur_unit_in_line_in              |         0x%01X  |  [RO][03:00]""The current number of units from the input in the line of a 2D block""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb55b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed10_sync_feeders                                        |  0x%08X  |  ""The feeder will wait with sending a command to the DMA until all feeders with the same bit set are ready to send a command.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed10_sync_feeders_type */
	/* skip, unused field unused_feed10_sync_feeders (feed10_sync_feeders) */
	REG_DUMP_PRINT_1("   -feed10_sync_feeders.feed_sync_0                                    |         0x%01X  |  [RW][00:00]""Sync with all feeders with bit 0 set""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed10_sync_feeders.feed_sync_1                                    |         0x%01X  |  [RW][01:01]""Sync with all feeders with bit 1 set""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0xb55ac);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed10_wait_order                                          |  0x%08X  |  ""Two feeders, set with the same order unit (bit 1..4), will keep the order in feeding.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed10_wait_order_type */
	/* skip, unused field unused_feed10_wait_order (feed10_wait_order) */
	REG_DUMP_PRINT_1("   -feed10_wait_order.feed_order                                       |         0x%01X  |  [RW][00:00]""0: send as first, 1: send as second""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed10_wait_order.enable_order_0                                   |         0x%01X  |  [RW][01:01]""Enable the order for order unit 0""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -feed10_wait_order.enable_order_1                                   |         0x%01X  |  [RW][02:02]""Enable the order for order unit 1""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -feed10_wait_order.enable_order_2                                   |         0x%01X  |  [RW][03:03]""Enable the order for order unit 2""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -feed10_wait_order.enable_order_3                                   |         0x%01X  |  [RW][04:04]""Enable the order for order unit 3""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xb55a8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed10_wait_on_feeders                                     |  0x%08X  |  ""The feeder will wait for other feeders when the have the bit for the same destination set.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed10_wait_on_feeders_type */
	/* skip, unused field unused_feed10_wait_on_feeders (feed10_wait_on_feeders) */
	REG_DUMP_PRINT_1("   -feed10_wait_on_feeders.feed_dest_0                                 |         0x%01X  |  [RW][00:00]""Wait with feeding for all feeders that are currently feeding a line and have bit 0 set""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed10_wait_on_feeders.feed_dest_1                                 |         0x%01X  |  [RW][01:01]""Wait with feeding for all feeders that are currently feeding a line and have bit 1 set""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -feed10_wait_on_feeders.feed_dest_2                                 |         0x%01X  |  [RW][02:02]""Wait with feeding for all feeders that are currently feeding a line and have bit 2 set""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -feed10_wait_on_feeders.feed_dest_3                                 |         0x%01X  |  [RW][03:03]""Wait with feeding for all feeders that are currently feeding a line and have bit 3 set""\n", FIELD_VALUE(val, 3, 3));
	val = REG_DUMP_READ_REGISTER(0xb55a4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed10_eventque_sidpid                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed10_eventque_sidpid_type */
	/* skip, unused field unused_feed10_eventque_sidpid (feed10_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -feed10_eventque_sidpid.feed10_eventque_sidpid                      |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb55a0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed10_height                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed10_height_type */
	/* skip, unused field unused_feed10_height (feed10_height) */
	REG_DUMP_PRINT_1("   -feed10_height.feed10_height                                        |         0x%01X  |  [RW][03:00]""The number of lines needed for a 2D unit block. A transfer will only begin when receiving cmd number (units_p_line_in * (height - 1)) + 1""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb559c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed10_last_units_out                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed10_last_units_out_type */
	/* skip, unused field unused_feed10_last_units_out (feed10_last_units_out) */
	REG_DUMP_PRINT_1("   -feed10_last_units_out.feed10_last_units_out                        |        0x%02X  |  [RW][06:00]""The last unit number to the DMA for the last unit from the input buffer in a line.""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb5598);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed10_units_out_p_in                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed10_units_out_p_in_type */
	/* skip, unused field unused_feed10_units_out_p_in (feed10_units_out_p_in) */
	REG_DUMP_PRINT_1("   -feed10_units_out_p_in.feed10_units_out_p_in                        |        0x%02X  |  [RW][06:00]""The number of units being transferred by the DMA that fit (width wise) in a unit from the input buffer""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb5594);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed10_units_p_line_in                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed10_units_p_line_in_type */
	/* skip, unused field unused_feed10_units_p_line_in (feed10_units_p_line_in) */
	REG_DUMP_PRINT_1("   -feed10_units_p_line_in.feed10_units_p_line_in                      |         0x%01X  |  [RW][03:00]""The number of units per line at the input buffer""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb5590);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed10_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed10_channel_addr_type */
	/* skip, unused field unused_feed10_channel_addr (feed10_channel_addr) */
	REG_DUMP_PRINT_1("   -feed10_channel_addr.feed10_channel_addr                            |  0x%08X  |  [RW][29:00]""The address where the channel in the DMA is located""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb558c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed10_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed10_requester_addr_type */
	/* skip, unused field unused_feed10_requester_addr (feed10_requester_addr) */
	REG_DUMP_PRINT_1("   -feed10_requester_addr.feed10_requester_addr                        |  0x%08X  |  [RW][29:00]""The address where the requester in the DMA is located""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5588);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed10_ack_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed10_ack_addr_type */
	/* skip, unused field unused_feed10_ack_addr (feed10_ack_addr) */
	REG_DUMP_PRINT_1("   -feed10_ack_addr.feed10_ack_addr                                    |  0x%08X  |  [RW][29:00]""The address where the acknowledgement has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5524);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest10_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest10_iwake_threshold_type */
	/* skip, unused field unused_dest10_iwake_threshold (dest10_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest10_iwake_threshold.dest10_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb551c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest10_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest10_st_addr_type */
	REG_DUMP_PRINT_1("   -dest10_st_addr.dest10_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb5518);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest10_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest10_dest_mode_type */
	/* skip, unused field unused_dest10_dest_mode (dest10_dest_mode) */
	REG_DUMP_PRINT_1("   -dest10_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest10_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest10_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest10_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest10_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xb5514);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest10_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest10_term_b_addr_type */
	/* skip, unused field unused_dest10_term_b_addr (dest10_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest10_term_b_addr.dest10_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5510);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest10_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest10_span_b_addr_type */
	/* skip, unused field unused_dest10_span_b_addr (dest10_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest10_span_b_addr.dest10_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb550c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest10_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest10_span_a_addr_type */
	/* skip, unused field unused_dest10_span_a_addr (dest10_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest10_span_a_addr.dest10_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5508);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest10_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest10_channel_addr_type */
	/* skip, unused field unused_dest10_channel_addr (dest10_channel_addr) */
	REG_DUMP_PRINT_1("   -dest10_channel_addr.dest10_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5504);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest10_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest10_requester_addr_type */
	/* skip, unused field unused_dest10_requester_addr (dest10_requester_addr) */
	REG_DUMP_PRINT_1("   -dest10_requester_addr.dest10_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5500);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest10_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest10_feed_addr_type */
	/* skip, unused field unused_dest10_feed_addr (dest10_feed_addr) */
	REG_DUMP_PRINT_1("   -dest10_feed_addr.dest10_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb54e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_dest0_cur_cmds                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid10_dest0_cur_cmds_type */
	/* skip, unused field unused_sid10_dest0_cur_cmds (sid10_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid10_dest0_cur_cmds.sid10_dest0_cur_cmds                          |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb54e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_dest0_sync_state                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid10_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid10_dest0_sync_state.sid10_dest0_sync_state                      |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb54dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_dest0_cur_ack_line                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid10_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid10_dest0_cur_ack_line (sid10_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid10_dest0_cur_ack_line.sid10_dest0_cur_ack_line                  |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb54d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_dest0_cur_ack_unit_in_line                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid10_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid10_dest0_cur_ack_unit_in_line (sid10_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid10_dest0_cur_ack_unit_in_line.sid10_dest0_cur_ack_unit_in_line  |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb54d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_dest0_cur_ack_unit                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid10_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid10_dest0_cur_ack_unit (sid10_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid10_dest0_cur_ack_unit.sid10_dest0_cur_ack_unit                  |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb54cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_main_control_state                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid10_main_control_state_type */
	/* skip, unused field unused_sid10_main_control_state (sid10_main_control_state) */
	REG_DUMP_PRINT_1("   -sid10_main_control_state.sid10_main_control_state                  |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb54c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_s2m_cur_ack_line                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid10_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid10_s2m_cur_ack_line (sid10_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid10_s2m_cur_ack_line.sid10_s2m_cur_ack_line                      |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb54c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_s2m_cur_ack_unit_in_line                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid10_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid10_s2m_cur_ack_unit_in_line (sid10_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid10_s2m_cur_ack_unit_in_line.sid10_s2m_cur_ack_unit_in_line      |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb54c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_s2m_cur_cmds                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid10_s2m_cur_cmds_type */
	/* skip, unused field unused_sid10_s2m_cur_cmds (sid10_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid10_s2m_cur_cmds.sid10_s2m_cur_cmds                              |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb5498);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_error_reg                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid10_error_reg_type */
	REG_DUMP_PRINT_1("   -sid10_error_reg.sid10_error_reg                                    |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb5488);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_eventque_sidpid                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid10_eventque_sidpid_type */
	/* skip, unused field unused_sid10_eventque_sidpid (sid10_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid10_eventque_sidpid.sid10_eventque_sidpid                        |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb5484);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_ack_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid10_ack_addr_type */
	/* skip, unused field unused_sid10_ack_addr (sid10_ack_addr) */
	REG_DUMP_PRINT_1("   -sid10_ack_addr.sid10_ack_addr                                      |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5468);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_dest0_enabled                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid10_dest0_enabled_type */
	/* skip, unused field unused_sid10_dest0_enabled (sid10_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid10_dest0_enabled.sid10_dest0_enabled                            |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 10""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb545c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_first_page_nr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid10_first_page_nr_type */
	/* skip, unused field unused_sid10_first_page_nr (sid10_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid10_first_page_nr.sid10_first_page_nr                            |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb5454);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_units_p_ibuf                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid10_units_p_ibuf_type */
	/* skip, unused field unused_sid10_units_p_ibuf (sid10_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid10_units_p_ibuf.sid10_units_p_ibuf                              |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb5450);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_unit_size                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid10_unit_size_type */
	/* skip, unused field unused_sid10_unit_size (sid10_unit_size) */
	REG_DUMP_PRINT_1("   -sid10_unit_size.sid10_unit_size                                    |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb544c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_lines_p_frame                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid10_lines_p_frame_type */
	/* skip, unused field unused_sid10_lines_p_frame (sid10_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid10_lines_p_frame.sid10_lines_p_frame                            |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb5448);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_units_p_line                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid10_units_p_line_type */
	/* skip, unused field unused_sid10_units_p_line (sid10_units_p_line) */
	REG_DUMP_PRINT_1("   -sid10_units_p_line.sid10_units_p_line                              |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb5444);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_str2mmio_store_cmd                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid10_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid10_str2mmio_store_cmd (sid10_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid10_str2mmio_store_cmd.sid10_str2mmio_store_cmd                  |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb5440);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_str2mmio_proc_addr                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid10_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid10_str2mmio_proc_addr (sid10_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid10_str2mmio_proc_addr.sid10_str2mmio_proc_addr                  |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb53cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed9_cur_rcvd_acks                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed9_cur_rcvd_acks_type */
	/* skip, unused field unused_feed9_cur_rcvd_acks (feed9_cur_rcvd_acks) */
	REG_DUMP_PRINT_1("   -feed9_cur_rcvd_acks.feed9_cur_rcvd_acks                            |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb53c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed9_cur_snd_cmds                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed9_cur_snd_cmds_type */
	/* skip, unused field unused_feed9_cur_snd_cmds (feed9_cur_snd_cmds) */
	REG_DUMP_PRINT_1("   -feed9_cur_snd_cmds.feed9_cur_snd_cmds                              |      0x%04X  |  [RO][15:00]""The number of commands send for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb53c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed9_cur_line_in                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed9_cur_line_in_type */
	/* skip, unused field unused_feed9_cur_line_in (feed9_cur_line_in) */
	REG_DUMP_PRINT_1("   -feed9_cur_line_in.feed9_cur_line_in                                |         0x%01X  |  [RO][03:00]""The current number of lines in a 2D block that not have been transferred""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb53c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed9_cur_unit_in_line_in                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed9_cur_unit_in_line_in_type */
	/* skip, unused field unused_feed9_cur_unit_in_line_in (feed9_cur_unit_in_line_in) */
	REG_DUMP_PRINT_1("   -feed9_cur_unit_in_line_in.feed9_cur_unit_in_line_in                |         0x%01X  |  [RO][03:00]""The current number of units from the input in the line of a 2D block""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb53b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed9_sync_feeders                                         |  0x%08X  |  ""The feeder will wait with sending a command to the DMA until all feeders with the same bit set are ready to send a command.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed9_sync_feeders_type */
	/* skip, unused field unused_feed9_sync_feeders (feed9_sync_feeders) */
	REG_DUMP_PRINT_1("   -feed9_sync_feeders.feed_sync_0                                     |         0x%01X  |  [RW][00:00]""Sync with all feeders with bit 0 set""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed9_sync_feeders.feed_sync_1                                     |         0x%01X  |  [RW][01:01]""Sync with all feeders with bit 1 set""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0xb53ac);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed9_wait_order                                           |  0x%08X  |  ""Two feeders, set with the same order unit (bit 1..4), will keep the order in feeding.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed9_wait_order_type */
	/* skip, unused field unused_feed9_wait_order (feed9_wait_order) */
	REG_DUMP_PRINT_1("   -feed9_wait_order.feed_order                                        |         0x%01X  |  [RW][00:00]""0: send as first, 1: send as second""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed9_wait_order.enable_order_0                                    |         0x%01X  |  [RW][01:01]""Enable the order for order unit 0""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -feed9_wait_order.enable_order_1                                    |         0x%01X  |  [RW][02:02]""Enable the order for order unit 1""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -feed9_wait_order.enable_order_2                                    |         0x%01X  |  [RW][03:03]""Enable the order for order unit 2""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -feed9_wait_order.enable_order_3                                    |         0x%01X  |  [RW][04:04]""Enable the order for order unit 3""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xb53a8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed9_wait_on_feeders                                      |  0x%08X  |  ""The feeder will wait for other feeders when the have the bit for the same destination set.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed9_wait_on_feeders_type */
	/* skip, unused field unused_feed9_wait_on_feeders (feed9_wait_on_feeders) */
	REG_DUMP_PRINT_1("   -feed9_wait_on_feeders.feed_dest_0                                  |         0x%01X  |  [RW][00:00]""Wait with feeding for all feeders that are currently feeding a line and have bit 0 set""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed9_wait_on_feeders.feed_dest_1                                  |         0x%01X  |  [RW][01:01]""Wait with feeding for all feeders that are currently feeding a line and have bit 1 set""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -feed9_wait_on_feeders.feed_dest_2                                  |         0x%01X  |  [RW][02:02]""Wait with feeding for all feeders that are currently feeding a line and have bit 2 set""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -feed9_wait_on_feeders.feed_dest_3                                  |         0x%01X  |  [RW][03:03]""Wait with feeding for all feeders that are currently feeding a line and have bit 3 set""\n", FIELD_VALUE(val, 3, 3));
	val = REG_DUMP_READ_REGISTER(0xb53a4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed9_eventque_sidpid                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed9_eventque_sidpid_type */
	/* skip, unused field unused_feed9_eventque_sidpid (feed9_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -feed9_eventque_sidpid.feed9_eventque_sidpid                        |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb53a0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed9_height                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed9_height_type */
	/* skip, unused field unused_feed9_height (feed9_height) */
	REG_DUMP_PRINT_1("   -feed9_height.feed9_height                                          |         0x%01X  |  [RW][03:00]""The number of lines needed for a 2D unit block. A transfer will only begin when receiving cmd number (units_p_line_in * (height - 1)) + 1""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb539c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed9_last_units_out                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed9_last_units_out_type */
	/* skip, unused field unused_feed9_last_units_out (feed9_last_units_out) */
	REG_DUMP_PRINT_1("   -feed9_last_units_out.feed9_last_units_out                          |        0x%02X  |  [RW][06:00]""The last unit number to the DMA for the last unit from the input buffer in a line.""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb5398);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed9_units_out_p_in                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed9_units_out_p_in_type */
	/* skip, unused field unused_feed9_units_out_p_in (feed9_units_out_p_in) */
	REG_DUMP_PRINT_1("   -feed9_units_out_p_in.feed9_units_out_p_in                          |        0x%02X  |  [RW][06:00]""The number of units being transferred by the DMA that fit (width wise) in a unit from the input buffer""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb5394);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed9_units_p_line_in                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed9_units_p_line_in_type */
	/* skip, unused field unused_feed9_units_p_line_in (feed9_units_p_line_in) */
	REG_DUMP_PRINT_1("   -feed9_units_p_line_in.feed9_units_p_line_in                        |         0x%01X  |  [RW][03:00]""The number of units per line at the input buffer""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb5390);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed9_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed9_channel_addr_type */
	/* skip, unused field unused_feed9_channel_addr (feed9_channel_addr) */
	REG_DUMP_PRINT_1("   -feed9_channel_addr.feed9_channel_addr                              |  0x%08X  |  [RW][29:00]""The address where the channel in the DMA is located""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb538c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed9_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed9_requester_addr_type */
	/* skip, unused field unused_feed9_requester_addr (feed9_requester_addr) */
	REG_DUMP_PRINT_1("   -feed9_requester_addr.feed9_requester_addr                          |  0x%08X  |  [RW][29:00]""The address where the requester in the DMA is located""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5388);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed9_ack_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed9_ack_addr_type */
	/* skip, unused field unused_feed9_ack_addr (feed9_ack_addr) */
	REG_DUMP_PRINT_1("   -feed9_ack_addr.feed9_ack_addr                                      |  0x%08X  |  [RW][29:00]""The address where the acknowledgement has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5324);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest9_iwake_threshold                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest9_iwake_threshold_type */
	/* skip, unused field unused_dest9_iwake_threshold (dest9_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest9_iwake_threshold.dest9_iwake_threshold                        |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb531c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest9_st_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest9_st_addr_type */
	REG_DUMP_PRINT_1("   -dest9_st_addr.dest9_st_addr                                        |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb5318);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest9_dest_mode                                            |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest9_dest_mode_type */
	/* skip, unused field unused_dest9_dest_mode (dest9_dest_mode) */
	REG_DUMP_PRINT_1("   -dest9_dest_mode.is_ibuf_cntrl_feeder                               |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest9_dest_mode.config_dma                                         |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest9_dest_mode.iwake_enable                                       |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest9_dest_mode.disable_spana_rst                                  |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest9_dest_mode.disable_spanb_rst                                  |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xb5314);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest9_term_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest9_term_b_addr_type */
	/* skip, unused field unused_dest9_term_b_addr (dest9_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest9_term_b_addr.dest9_term_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5310);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest9_span_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest9_span_b_addr_type */
	/* skip, unused field unused_dest9_span_b_addr (dest9_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest9_span_b_addr.dest9_span_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb530c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest9_span_a_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest9_span_a_addr_type */
	/* skip, unused field unused_dest9_span_a_addr (dest9_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest9_span_a_addr.dest9_span_a_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5308);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest9_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest9_channel_addr_type */
	/* skip, unused field unused_dest9_channel_addr (dest9_channel_addr) */
	REG_DUMP_PRINT_1("   -dest9_channel_addr.dest9_channel_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5304);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest9_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest9_requester_addr_type */
	/* skip, unused field unused_dest9_requester_addr (dest9_requester_addr) */
	REG_DUMP_PRINT_1("   -dest9_requester_addr.dest9_requester_addr                          |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5300);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest9_feed_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest9_feed_addr_type */
	/* skip, unused field unused_dest9_feed_addr (dest9_feed_addr) */
	REG_DUMP_PRINT_1("   -dest9_feed_addr.dest9_feed_addr                                    |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb52e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_dest0_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid9_dest0_cur_cmds_type */
	/* skip, unused field unused_sid9_dest0_cur_cmds (sid9_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid9_dest0_cur_cmds.sid9_dest0_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb52e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_dest0_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid9_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid9_dest0_sync_state.sid9_dest0_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb52dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_dest0_cur_ack_line                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid9_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid9_dest0_cur_ack_line (sid9_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid9_dest0_cur_ack_line.sid9_dest0_cur_ack_line                    |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb52d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_dest0_cur_ack_unit_in_line                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid9_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid9_dest0_cur_ack_unit_in_line (sid9_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid9_dest0_cur_ack_unit_in_line.sid9_dest0_cur_ack_unit_in_line    |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb52d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_dest0_cur_ack_unit                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid9_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid9_dest0_cur_ack_unit (sid9_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid9_dest0_cur_ack_unit.sid9_dest0_cur_ack_unit                    |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb52cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_main_control_state                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid9_main_control_state_type */
	/* skip, unused field unused_sid9_main_control_state (sid9_main_control_state) */
	REG_DUMP_PRINT_1("   -sid9_main_control_state.sid9_main_control_state                    |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb52c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_s2m_cur_ack_line                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid9_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid9_s2m_cur_ack_line (sid9_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid9_s2m_cur_ack_line.sid9_s2m_cur_ack_line                        |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb52c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_s2m_cur_ack_unit_in_line                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid9_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid9_s2m_cur_ack_unit_in_line (sid9_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid9_s2m_cur_ack_unit_in_line.sid9_s2m_cur_ack_unit_in_line        |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb52c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_s2m_cur_cmds                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid9_s2m_cur_cmds_type */
	/* skip, unused field unused_sid9_s2m_cur_cmds (sid9_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid9_s2m_cur_cmds.sid9_s2m_cur_cmds                                |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb5298);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_error_reg                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid9_error_reg_type */
	REG_DUMP_PRINT_1("   -sid9_error_reg.sid9_error_reg                                      |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb5288);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_eventque_sidpid                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid9_eventque_sidpid_type */
	/* skip, unused field unused_sid9_eventque_sidpid (sid9_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid9_eventque_sidpid.sid9_eventque_sidpid                          |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb5284);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_ack_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid9_ack_addr_type */
	/* skip, unused field unused_sid9_ack_addr (sid9_ack_addr) */
	REG_DUMP_PRINT_1("   -sid9_ack_addr.sid9_ack_addr                                        |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5268);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_dest0_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid9_dest0_enabled_type */
	/* skip, unused field unused_sid9_dest0_enabled (sid9_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid9_dest0_enabled.sid9_dest0_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 9""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb525c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_first_page_nr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid9_first_page_nr_type */
	/* skip, unused field unused_sid9_first_page_nr (sid9_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid9_first_page_nr.sid9_first_page_nr                              |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb5254);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_units_p_ibuf                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid9_units_p_ibuf_type */
	/* skip, unused field unused_sid9_units_p_ibuf (sid9_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid9_units_p_ibuf.sid9_units_p_ibuf                                |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb5250);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_unit_size                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid9_unit_size_type */
	/* skip, unused field unused_sid9_unit_size (sid9_unit_size) */
	REG_DUMP_PRINT_1("   -sid9_unit_size.sid9_unit_size                                      |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb524c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_lines_p_frame                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid9_lines_p_frame_type */
	/* skip, unused field unused_sid9_lines_p_frame (sid9_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid9_lines_p_frame.sid9_lines_p_frame                              |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb5248);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_units_p_line                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid9_units_p_line_type */
	/* skip, unused field unused_sid9_units_p_line (sid9_units_p_line) */
	REG_DUMP_PRINT_1("   -sid9_units_p_line.sid9_units_p_line                                |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb5244);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_str2mmio_store_cmd                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid9_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid9_str2mmio_store_cmd (sid9_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid9_str2mmio_store_cmd.sid9_str2mmio_store_cmd                    |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb5240);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_str2mmio_proc_addr                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid9_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid9_str2mmio_proc_addr (sid9_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid9_str2mmio_proc_addr.sid9_str2mmio_proc_addr                    |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb51cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed8_cur_rcvd_acks                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed8_cur_rcvd_acks_type */
	/* skip, unused field unused_feed8_cur_rcvd_acks (feed8_cur_rcvd_acks) */
	REG_DUMP_PRINT_1("   -feed8_cur_rcvd_acks.feed8_cur_rcvd_acks                            |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb51c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed8_cur_snd_cmds                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed8_cur_snd_cmds_type */
	/* skip, unused field unused_feed8_cur_snd_cmds (feed8_cur_snd_cmds) */
	REG_DUMP_PRINT_1("   -feed8_cur_snd_cmds.feed8_cur_snd_cmds                              |      0x%04X  |  [RO][15:00]""The number of commands send for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb51c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed8_cur_line_in                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed8_cur_line_in_type */
	/* skip, unused field unused_feed8_cur_line_in (feed8_cur_line_in) */
	REG_DUMP_PRINT_1("   -feed8_cur_line_in.feed8_cur_line_in                                |         0x%01X  |  [RO][03:00]""The current number of lines in a 2D block that not have been transferred""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb51c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed8_cur_unit_in_line_in                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed8_cur_unit_in_line_in_type */
	/* skip, unused field unused_feed8_cur_unit_in_line_in (feed8_cur_unit_in_line_in) */
	REG_DUMP_PRINT_1("   -feed8_cur_unit_in_line_in.feed8_cur_unit_in_line_in                |         0x%01X  |  [RO][03:00]""The current number of units from the input in the line of a 2D block""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb51b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed8_sync_feeders                                         |  0x%08X  |  ""The feeder will wait with sending a command to the DMA until all feeders with the same bit set are ready to send a command.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed8_sync_feeders_type */
	/* skip, unused field unused_feed8_sync_feeders (feed8_sync_feeders) */
	REG_DUMP_PRINT_1("   -feed8_sync_feeders.feed_sync_0                                     |         0x%01X  |  [RW][00:00]""Sync with all feeders with bit 0 set""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed8_sync_feeders.feed_sync_1                                     |         0x%01X  |  [RW][01:01]""Sync with all feeders with bit 1 set""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0xb51ac);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed8_wait_order                                           |  0x%08X  |  ""Two feeders, set with the same order unit (bit 1..4), will keep the order in feeding.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed8_wait_order_type */
	/* skip, unused field unused_feed8_wait_order (feed8_wait_order) */
	REG_DUMP_PRINT_1("   -feed8_wait_order.feed_order                                        |         0x%01X  |  [RW][00:00]""0: send as first, 1: send as second""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed8_wait_order.enable_order_0                                    |         0x%01X  |  [RW][01:01]""Enable the order for order unit 0""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -feed8_wait_order.enable_order_1                                    |         0x%01X  |  [RW][02:02]""Enable the order for order unit 1""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -feed8_wait_order.enable_order_2                                    |         0x%01X  |  [RW][03:03]""Enable the order for order unit 2""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -feed8_wait_order.enable_order_3                                    |         0x%01X  |  [RW][04:04]""Enable the order for order unit 3""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xb51a8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed8_wait_on_feeders                                      |  0x%08X  |  ""The feeder will wait for other feeders when the have the bit for the same destination set.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed8_wait_on_feeders_type */
	/* skip, unused field unused_feed8_wait_on_feeders (feed8_wait_on_feeders) */
	REG_DUMP_PRINT_1("   -feed8_wait_on_feeders.feed_dest_0                                  |         0x%01X  |  [RW][00:00]""Wait with feeding for all feeders that are currently feeding a line and have bit 0 set""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed8_wait_on_feeders.feed_dest_1                                  |         0x%01X  |  [RW][01:01]""Wait with feeding for all feeders that are currently feeding a line and have bit 1 set""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -feed8_wait_on_feeders.feed_dest_2                                  |         0x%01X  |  [RW][02:02]""Wait with feeding for all feeders that are currently feeding a line and have bit 2 set""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -feed8_wait_on_feeders.feed_dest_3                                  |         0x%01X  |  [RW][03:03]""Wait with feeding for all feeders that are currently feeding a line and have bit 3 set""\n", FIELD_VALUE(val, 3, 3));
	val = REG_DUMP_READ_REGISTER(0xb51a4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed8_eventque_sidpid                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed8_eventque_sidpid_type */
	/* skip, unused field unused_feed8_eventque_sidpid (feed8_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -feed8_eventque_sidpid.feed8_eventque_sidpid                        |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb51a0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed8_height                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed8_height_type */
	/* skip, unused field unused_feed8_height (feed8_height) */
	REG_DUMP_PRINT_1("   -feed8_height.feed8_height                                          |         0x%01X  |  [RW][03:00]""The number of lines needed for a 2D unit block. A transfer will only begin when receiving cmd number (units_p_line_in * (height - 1)) + 1""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb519c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed8_last_units_out                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed8_last_units_out_type */
	/* skip, unused field unused_feed8_last_units_out (feed8_last_units_out) */
	REG_DUMP_PRINT_1("   -feed8_last_units_out.feed8_last_units_out                          |        0x%02X  |  [RW][06:00]""The last unit number to the DMA for the last unit from the input buffer in a line.""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb5198);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed8_units_out_p_in                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed8_units_out_p_in_type */
	/* skip, unused field unused_feed8_units_out_p_in (feed8_units_out_p_in) */
	REG_DUMP_PRINT_1("   -feed8_units_out_p_in.feed8_units_out_p_in                          |        0x%02X  |  [RW][06:00]""The number of units being transferred by the DMA that fit (width wise) in a unit from the input buffer""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb5194);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed8_units_p_line_in                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed8_units_p_line_in_type */
	/* skip, unused field unused_feed8_units_p_line_in (feed8_units_p_line_in) */
	REG_DUMP_PRINT_1("   -feed8_units_p_line_in.feed8_units_p_line_in                        |         0x%01X  |  [RW][03:00]""The number of units per line at the input buffer""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb5190);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed8_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed8_channel_addr_type */
	/* skip, unused field unused_feed8_channel_addr (feed8_channel_addr) */
	REG_DUMP_PRINT_1("   -feed8_channel_addr.feed8_channel_addr                              |  0x%08X  |  [RW][29:00]""The address where the channel in the DMA is located""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb518c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed8_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed8_requester_addr_type */
	/* skip, unused field unused_feed8_requester_addr (feed8_requester_addr) */
	REG_DUMP_PRINT_1("   -feed8_requester_addr.feed8_requester_addr                          |  0x%08X  |  [RW][29:00]""The address where the requester in the DMA is located""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5188);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed8_ack_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed8_ack_addr_type */
	/* skip, unused field unused_feed8_ack_addr (feed8_ack_addr) */
	REG_DUMP_PRINT_1("   -feed8_ack_addr.feed8_ack_addr                                      |  0x%08X  |  [RW][29:00]""The address where the acknowledgement has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5124);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest8_iwake_threshold                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest8_iwake_threshold_type */
	/* skip, unused field unused_dest8_iwake_threshold (dest8_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest8_iwake_threshold.dest8_iwake_threshold                        |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb511c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest8_st_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest8_st_addr_type */
	REG_DUMP_PRINT_1("   -dest8_st_addr.dest8_st_addr                                        |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb5118);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest8_dest_mode                                            |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest8_dest_mode_type */
	/* skip, unused field unused_dest8_dest_mode (dest8_dest_mode) */
	REG_DUMP_PRINT_1("   -dest8_dest_mode.is_ibuf_cntrl_feeder                               |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest8_dest_mode.config_dma                                         |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest8_dest_mode.iwake_enable                                       |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest8_dest_mode.disable_spana_rst                                  |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest8_dest_mode.disable_spanb_rst                                  |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xb5114);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest8_term_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest8_term_b_addr_type */
	/* skip, unused field unused_dest8_term_b_addr (dest8_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest8_term_b_addr.dest8_term_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5110);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest8_span_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest8_span_b_addr_type */
	/* skip, unused field unused_dest8_span_b_addr (dest8_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest8_span_b_addr.dest8_span_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb510c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest8_span_a_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest8_span_a_addr_type */
	/* skip, unused field unused_dest8_span_a_addr (dest8_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest8_span_a_addr.dest8_span_a_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5108);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest8_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest8_channel_addr_type */
	/* skip, unused field unused_dest8_channel_addr (dest8_channel_addr) */
	REG_DUMP_PRINT_1("   -dest8_channel_addr.dest8_channel_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5104);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest8_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest8_requester_addr_type */
	/* skip, unused field unused_dest8_requester_addr (dest8_requester_addr) */
	REG_DUMP_PRINT_1("   -dest8_requester_addr.dest8_requester_addr                          |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5100);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest8_feed_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest8_feed_addr_type */
	/* skip, unused field unused_dest8_feed_addr (dest8_feed_addr) */
	REG_DUMP_PRINT_1("   -dest8_feed_addr.dest8_feed_addr                                    |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb50e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_dest0_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid8_dest0_cur_cmds_type */
	/* skip, unused field unused_sid8_dest0_cur_cmds (sid8_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid8_dest0_cur_cmds.sid8_dest0_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb50e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_dest0_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid8_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid8_dest0_sync_state.sid8_dest0_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb50dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_dest0_cur_ack_line                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid8_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid8_dest0_cur_ack_line (sid8_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid8_dest0_cur_ack_line.sid8_dest0_cur_ack_line                    |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb50d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_dest0_cur_ack_unit_in_line                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid8_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid8_dest0_cur_ack_unit_in_line (sid8_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid8_dest0_cur_ack_unit_in_line.sid8_dest0_cur_ack_unit_in_line    |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb50d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_dest0_cur_ack_unit                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid8_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid8_dest0_cur_ack_unit (sid8_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid8_dest0_cur_ack_unit.sid8_dest0_cur_ack_unit                    |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb50cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_main_control_state                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid8_main_control_state_type */
	/* skip, unused field unused_sid8_main_control_state (sid8_main_control_state) */
	REG_DUMP_PRINT_1("   -sid8_main_control_state.sid8_main_control_state                    |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb50c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_s2m_cur_ack_line                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid8_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid8_s2m_cur_ack_line (sid8_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid8_s2m_cur_ack_line.sid8_s2m_cur_ack_line                        |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb50c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_s2m_cur_ack_unit_in_line                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid8_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid8_s2m_cur_ack_unit_in_line (sid8_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid8_s2m_cur_ack_unit_in_line.sid8_s2m_cur_ack_unit_in_line        |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb50c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_s2m_cur_cmds                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid8_s2m_cur_cmds_type */
	/* skip, unused field unused_sid8_s2m_cur_cmds (sid8_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid8_s2m_cur_cmds.sid8_s2m_cur_cmds                                |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb5098);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_error_reg                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid8_error_reg_type */
	REG_DUMP_PRINT_1("   -sid8_error_reg.sid8_error_reg                                      |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb5088);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_eventque_sidpid                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid8_eventque_sidpid_type */
	/* skip, unused field unused_sid8_eventque_sidpid (sid8_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid8_eventque_sidpid.sid8_eventque_sidpid                          |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb5084);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_ack_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid8_ack_addr_type */
	/* skip, unused field unused_sid8_ack_addr (sid8_ack_addr) */
	REG_DUMP_PRINT_1("   -sid8_ack_addr.sid8_ack_addr                                        |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb5068);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_dest0_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid8_dest0_enabled_type */
	/* skip, unused field unused_sid8_dest0_enabled (sid8_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid8_dest0_enabled.sid8_dest0_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 8""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb505c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_first_page_nr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid8_first_page_nr_type */
	/* skip, unused field unused_sid8_first_page_nr (sid8_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid8_first_page_nr.sid8_first_page_nr                              |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb5054);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_units_p_ibuf                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid8_units_p_ibuf_type */
	/* skip, unused field unused_sid8_units_p_ibuf (sid8_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid8_units_p_ibuf.sid8_units_p_ibuf                                |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb5050);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_unit_size                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid8_unit_size_type */
	/* skip, unused field unused_sid8_unit_size (sid8_unit_size) */
	REG_DUMP_PRINT_1("   -sid8_unit_size.sid8_unit_size                                      |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb504c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_lines_p_frame                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid8_lines_p_frame_type */
	/* skip, unused field unused_sid8_lines_p_frame (sid8_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid8_lines_p_frame.sid8_lines_p_frame                              |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb5048);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_units_p_line                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid8_units_p_line_type */
	/* skip, unused field unused_sid8_units_p_line (sid8_units_p_line) */
	REG_DUMP_PRINT_1("   -sid8_units_p_line.sid8_units_p_line                                |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb5044);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_str2mmio_store_cmd                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid8_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid8_str2mmio_store_cmd (sid8_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid8_str2mmio_store_cmd.sid8_str2mmio_store_cmd                    |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb5040);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_str2mmio_proc_addr                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid8_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid8_str2mmio_proc_addr (sid8_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid8_str2mmio_proc_addr.sid8_str2mmio_proc_addr                    |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4fcc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed7_cur_rcvd_acks                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed7_cur_rcvd_acks_type */
	/* skip, unused field unused_feed7_cur_rcvd_acks (feed7_cur_rcvd_acks) */
	REG_DUMP_PRINT_1("   -feed7_cur_rcvd_acks.feed7_cur_rcvd_acks                            |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4fc8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed7_cur_snd_cmds                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed7_cur_snd_cmds_type */
	/* skip, unused field unused_feed7_cur_snd_cmds (feed7_cur_snd_cmds) */
	REG_DUMP_PRINT_1("   -feed7_cur_snd_cmds.feed7_cur_snd_cmds                              |      0x%04X  |  [RO][15:00]""The number of commands send for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4fc4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed7_cur_line_in                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed7_cur_line_in_type */
	/* skip, unused field unused_feed7_cur_line_in (feed7_cur_line_in) */
	REG_DUMP_PRINT_1("   -feed7_cur_line_in.feed7_cur_line_in                                |         0x%01X  |  [RO][03:00]""The current number of lines in a 2D block that not have been transferred""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4fc0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed7_cur_unit_in_line_in                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed7_cur_unit_in_line_in_type */
	/* skip, unused field unused_feed7_cur_unit_in_line_in (feed7_cur_unit_in_line_in) */
	REG_DUMP_PRINT_1("   -feed7_cur_unit_in_line_in.feed7_cur_unit_in_line_in                |         0x%01X  |  [RO][03:00]""The current number of units from the input in the line of a 2D block""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4fb0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed7_sync_feeders                                         |  0x%08X  |  ""The feeder will wait with sending a command to the DMA until all feeders with the same bit set are ready to send a command.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed7_sync_feeders_type */
	/* skip, unused field unused_feed7_sync_feeders (feed7_sync_feeders) */
	REG_DUMP_PRINT_1("   -feed7_sync_feeders.feed_sync_0                                     |         0x%01X  |  [RW][00:00]""Sync with all feeders with bit 0 set""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed7_sync_feeders.feed_sync_1                                     |         0x%01X  |  [RW][01:01]""Sync with all feeders with bit 1 set""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0xb4fac);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed7_wait_order                                           |  0x%08X  |  ""Two feeders, set with the same order unit (bit 1..4), will keep the order in feeding.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed7_wait_order_type */
	/* skip, unused field unused_feed7_wait_order (feed7_wait_order) */
	REG_DUMP_PRINT_1("   -feed7_wait_order.feed_order                                        |         0x%01X  |  [RW][00:00]""0: send as first, 1: send as second""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed7_wait_order.enable_order_0                                    |         0x%01X  |  [RW][01:01]""Enable the order for order unit 0""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -feed7_wait_order.enable_order_1                                    |         0x%01X  |  [RW][02:02]""Enable the order for order unit 1""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -feed7_wait_order.enable_order_2                                    |         0x%01X  |  [RW][03:03]""Enable the order for order unit 2""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -feed7_wait_order.enable_order_3                                    |         0x%01X  |  [RW][04:04]""Enable the order for order unit 3""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xb4fa8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed7_wait_on_feeders                                      |  0x%08X  |  ""The feeder will wait for other feeders when the have the bit for the same destination set.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed7_wait_on_feeders_type */
	/* skip, unused field unused_feed7_wait_on_feeders (feed7_wait_on_feeders) */
	REG_DUMP_PRINT_1("   -feed7_wait_on_feeders.feed_dest_0                                  |         0x%01X  |  [RW][00:00]""Wait with feeding for all feeders that are currently feeding a line and have bit 0 set""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed7_wait_on_feeders.feed_dest_1                                  |         0x%01X  |  [RW][01:01]""Wait with feeding for all feeders that are currently feeding a line and have bit 1 set""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -feed7_wait_on_feeders.feed_dest_2                                  |         0x%01X  |  [RW][02:02]""Wait with feeding for all feeders that are currently feeding a line and have bit 2 set""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -feed7_wait_on_feeders.feed_dest_3                                  |         0x%01X  |  [RW][03:03]""Wait with feeding for all feeders that are currently feeding a line and have bit 3 set""\n", FIELD_VALUE(val, 3, 3));
	val = REG_DUMP_READ_REGISTER(0xb4fa4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed7_eventque_sidpid                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed7_eventque_sidpid_type */
	/* skip, unused field unused_feed7_eventque_sidpid (feed7_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -feed7_eventque_sidpid.feed7_eventque_sidpid                        |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb4fa0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed7_height                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed7_height_type */
	/* skip, unused field unused_feed7_height (feed7_height) */
	REG_DUMP_PRINT_1("   -feed7_height.feed7_height                                          |         0x%01X  |  [RW][03:00]""The number of lines needed for a 2D unit block. A transfer will only begin when receiving cmd number (units_p_line_in * (height - 1)) + 1""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4f9c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed7_last_units_out                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed7_last_units_out_type */
	/* skip, unused field unused_feed7_last_units_out (feed7_last_units_out) */
	REG_DUMP_PRINT_1("   -feed7_last_units_out.feed7_last_units_out                          |        0x%02X  |  [RW][06:00]""The last unit number to the DMA for the last unit from the input buffer in a line.""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb4f98);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed7_units_out_p_in                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed7_units_out_p_in_type */
	/* skip, unused field unused_feed7_units_out_p_in (feed7_units_out_p_in) */
	REG_DUMP_PRINT_1("   -feed7_units_out_p_in.feed7_units_out_p_in                          |        0x%02X  |  [RW][06:00]""The number of units being transferred by the DMA that fit (width wise) in a unit from the input buffer""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb4f94);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed7_units_p_line_in                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed7_units_p_line_in_type */
	/* skip, unused field unused_feed7_units_p_line_in (feed7_units_p_line_in) */
	REG_DUMP_PRINT_1("   -feed7_units_p_line_in.feed7_units_p_line_in                        |         0x%01X  |  [RW][03:00]""The number of units per line at the input buffer""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4f90);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed7_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed7_channel_addr_type */
	/* skip, unused field unused_feed7_channel_addr (feed7_channel_addr) */
	REG_DUMP_PRINT_1("   -feed7_channel_addr.feed7_channel_addr                              |  0x%08X  |  [RW][29:00]""The address where the channel in the DMA is located""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4f8c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed7_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed7_requester_addr_type */
	/* skip, unused field unused_feed7_requester_addr (feed7_requester_addr) */
	REG_DUMP_PRINT_1("   -feed7_requester_addr.feed7_requester_addr                          |  0x%08X  |  [RW][29:00]""The address where the requester in the DMA is located""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4f88);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed7_ack_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed7_ack_addr_type */
	/* skip, unused field unused_feed7_ack_addr (feed7_ack_addr) */
	REG_DUMP_PRINT_1("   -feed7_ack_addr.feed7_ack_addr                                      |  0x%08X  |  [RW][29:00]""The address where the acknowledgement has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4f58);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk7_token                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk7_token_type */
	REG_DUMP_PRINT_1("   -fr_chk7_token.fr_chk7_token                                        |  0x%08X  |  [RW][31:00]""The token that has to be written""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb4f54);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk7_addr                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk7_addr_type */
	/* skip, unused field unused_fr_chk7_addr (fr_chk7_addr) */
	REG_DUMP_PRINT_1("   -fr_chk7_addr.fr_chk7_addr                                          |  0x%08X  |  [RW][29:00]""The address of where the frame check token has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4f50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk7_trigger_repeat_val                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk7_trigger_repeat_val_type */
	/* skip, unused field unused_fr_chk7_trigger_repeat_val (fr_chk7_trigger_repeat_val) */
	REG_DUMP_PRINT_1("   -fr_chk7_trigger_repeat_val.fr_chk7_trigger_repeat_val              |      0x%04X  |  [RW][15:00]""An frame check token is send after each trigger_repeat_val value in case the repetitive enable bit in the check mode is set and the trigger offset has been reached.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4f4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk7_trigger_offset                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk7_trigger_offset_type */
	/* skip, unused field unused_fr_chk7_trigger_offset (fr_chk7_trigger_offset) */
	REG_DUMP_PRINT_1("   -fr_chk7_trigger_offset.fr_chk7_trigger_offset                      |      0x%04X  |  [RW][15:00]""The value of the trigger, when the checked value becomes larger than the this value a frame check token is send""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4f48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk7_sid_proc_id                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk7_sid_proc_id_type */
	/* skip, unused field unused_fr_chk7_sid_proc_id (fr_chk7_sid_proc_id) */
	REG_DUMP_PRINT_1("   -fr_chk7_sid_proc_id.fr_chk7_sid_proc_id                            |         0x%01X  |  [RW][03:00]""The ID of the SID proc that has to be checked""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4f44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk7_check_mode                                         |  0x%08X  |  ""The mode of frame checking""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk7_check_mode_type */
	/* skip, unused field unused_fr_chk7_check_mode (fr_chk7_check_mode) */
	REG_DUMP_PRINT_1("   -fr_chk7_check_mode.check_type                                      |         0x%01X  |  [RW][00:00]""The type of value to be checking, 0: check lines; 1: check units;""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -fr_chk7_check_mode.repetive_enable                                 |         0x%01X  |  [RW][01:01]""Trigger and send and token after each repetitive value after the trigger offset is reached""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0xb4f40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk7_enable                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk7_enable_type */
	/* skip, unused field unused_fr_chk7_enable (fr_chk7_enable) */
	REG_DUMP_PRINT_1("   -fr_chk7_enable.fr_chk7_enable                                      |         0x%01X  |  [RW][00:00]""Enable frame checking for this frame check unit""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb4f24);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest7_iwake_threshold                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest7_iwake_threshold_type */
	/* skip, unused field unused_dest7_iwake_threshold (dest7_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest7_iwake_threshold.dest7_iwake_threshold                        |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb4f1c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest7_st_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest7_st_addr_type */
	REG_DUMP_PRINT_1("   -dest7_st_addr.dest7_st_addr                                        |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb4f18);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest7_dest_mode                                            |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest7_dest_mode_type */
	/* skip, unused field unused_dest7_dest_mode (dest7_dest_mode) */
	REG_DUMP_PRINT_1("   -dest7_dest_mode.is_ibuf_cntrl_feeder                               |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest7_dest_mode.config_dma                                         |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest7_dest_mode.iwake_enable                                       |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest7_dest_mode.disable_spana_rst                                  |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest7_dest_mode.disable_spanb_rst                                  |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xb4f14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest7_term_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest7_term_b_addr_type */
	/* skip, unused field unused_dest7_term_b_addr (dest7_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest7_term_b_addr.dest7_term_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4f10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest7_span_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest7_span_b_addr_type */
	/* skip, unused field unused_dest7_span_b_addr (dest7_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest7_span_b_addr.dest7_span_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4f0c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest7_span_a_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest7_span_a_addr_type */
	/* skip, unused field unused_dest7_span_a_addr (dest7_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest7_span_a_addr.dest7_span_a_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4f08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest7_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest7_channel_addr_type */
	/* skip, unused field unused_dest7_channel_addr (dest7_channel_addr) */
	REG_DUMP_PRINT_1("   -dest7_channel_addr.dest7_channel_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4f04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest7_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest7_requester_addr_type */
	/* skip, unused field unused_dest7_requester_addr (dest7_requester_addr) */
	REG_DUMP_PRINT_1("   -dest7_requester_addr.dest7_requester_addr                          |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4f00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest7_feed_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest7_feed_addr_type */
	/* skip, unused field unused_dest7_feed_addr (dest7_feed_addr) */
	REG_DUMP_PRINT_1("   -dest7_feed_addr.dest7_feed_addr                                    |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4ee4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_dest0_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid7_dest0_cur_cmds_type */
	/* skip, unused field unused_sid7_dest0_cur_cmds (sid7_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid7_dest0_cur_cmds.sid7_dest0_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4ee0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_dest0_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid7_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid7_dest0_sync_state.sid7_dest0_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb4edc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_dest0_cur_ack_line                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid7_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid7_dest0_cur_ack_line (sid7_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid7_dest0_cur_ack_line.sid7_dest0_cur_ack_line                    |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb4ed8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_dest0_cur_ack_unit_in_line                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid7_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid7_dest0_cur_ack_unit_in_line (sid7_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid7_dest0_cur_ack_unit_in_line.sid7_dest0_cur_ack_unit_in_line    |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4ed4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_dest0_cur_ack_unit                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid7_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid7_dest0_cur_ack_unit (sid7_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid7_dest0_cur_ack_unit.sid7_dest0_cur_ack_unit                    |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4ecc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_main_control_state                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid7_main_control_state_type */
	/* skip, unused field unused_sid7_main_control_state (sid7_main_control_state) */
	REG_DUMP_PRINT_1("   -sid7_main_control_state.sid7_main_control_state                    |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb4ec8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_s2m_cur_ack_line                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid7_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid7_s2m_cur_ack_line (sid7_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid7_s2m_cur_ack_line.sid7_s2m_cur_ack_line                        |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb4ec4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_s2m_cur_ack_unit_in_line                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid7_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid7_s2m_cur_ack_unit_in_line (sid7_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid7_s2m_cur_ack_unit_in_line.sid7_s2m_cur_ack_unit_in_line        |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4ec0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_s2m_cur_cmds                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid7_s2m_cur_cmds_type */
	/* skip, unused field unused_sid7_s2m_cur_cmds (sid7_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid7_s2m_cur_cmds.sid7_s2m_cur_cmds                                |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4e98);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_error_reg                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid7_error_reg_type */
	REG_DUMP_PRINT_1("   -sid7_error_reg.sid7_error_reg                                      |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb4e88);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_eventque_sidpid                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid7_eventque_sidpid_type */
	/* skip, unused field unused_sid7_eventque_sidpid (sid7_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid7_eventque_sidpid.sid7_eventque_sidpid                          |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb4e84);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_ack_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid7_ack_addr_type */
	/* skip, unused field unused_sid7_ack_addr (sid7_ack_addr) */
	REG_DUMP_PRINT_1("   -sid7_ack_addr.sid7_ack_addr                                        |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4e68);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_dest0_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid7_dest0_enabled_type */
	/* skip, unused field unused_sid7_dest0_enabled (sid7_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid7_dest0_enabled.sid7_dest0_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 7""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb4e5c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_first_page_nr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid7_first_page_nr_type */
	/* skip, unused field unused_sid7_first_page_nr (sid7_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid7_first_page_nr.sid7_first_page_nr                              |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb4e54);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_units_p_ibuf                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid7_units_p_ibuf_type */
	/* skip, unused field unused_sid7_units_p_ibuf (sid7_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid7_units_p_ibuf.sid7_units_p_ibuf                                |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb4e50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_unit_size                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid7_unit_size_type */
	/* skip, unused field unused_sid7_unit_size (sid7_unit_size) */
	REG_DUMP_PRINT_1("   -sid7_unit_size.sid7_unit_size                                      |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb4e4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_lines_p_frame                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid7_lines_p_frame_type */
	/* skip, unused field unused_sid7_lines_p_frame (sid7_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid7_lines_p_frame.sid7_lines_p_frame                              |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb4e48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_units_p_line                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid7_units_p_line_type */
	/* skip, unused field unused_sid7_units_p_line (sid7_units_p_line) */
	REG_DUMP_PRINT_1("   -sid7_units_p_line.sid7_units_p_line                                |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4e44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_str2mmio_store_cmd                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid7_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid7_str2mmio_store_cmd (sid7_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid7_str2mmio_store_cmd.sid7_str2mmio_store_cmd                    |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb4e40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_str2mmio_proc_addr                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid7_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid7_str2mmio_proc_addr (sid7_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid7_str2mmio_proc_addr.sid7_str2mmio_proc_addr                    |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4dcc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed6_cur_rcvd_acks                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed6_cur_rcvd_acks_type */
	/* skip, unused field unused_feed6_cur_rcvd_acks (feed6_cur_rcvd_acks) */
	REG_DUMP_PRINT_1("   -feed6_cur_rcvd_acks.feed6_cur_rcvd_acks                            |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4dc8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed6_cur_snd_cmds                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed6_cur_snd_cmds_type */
	/* skip, unused field unused_feed6_cur_snd_cmds (feed6_cur_snd_cmds) */
	REG_DUMP_PRINT_1("   -feed6_cur_snd_cmds.feed6_cur_snd_cmds                              |      0x%04X  |  [RO][15:00]""The number of commands send for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4dc4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed6_cur_line_in                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed6_cur_line_in_type */
	/* skip, unused field unused_feed6_cur_line_in (feed6_cur_line_in) */
	REG_DUMP_PRINT_1("   -feed6_cur_line_in.feed6_cur_line_in                                |         0x%01X  |  [RO][03:00]""The current number of lines in a 2D block that not have been transferred""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4dc0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed6_cur_unit_in_line_in                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed6_cur_unit_in_line_in_type */
	/* skip, unused field unused_feed6_cur_unit_in_line_in (feed6_cur_unit_in_line_in) */
	REG_DUMP_PRINT_1("   -feed6_cur_unit_in_line_in.feed6_cur_unit_in_line_in                |         0x%01X  |  [RO][03:00]""The current number of units from the input in the line of a 2D block""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4db0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed6_sync_feeders                                         |  0x%08X  |  ""The feeder will wait with sending a command to the DMA until all feeders with the same bit set are ready to send a command.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed6_sync_feeders_type */
	/* skip, unused field unused_feed6_sync_feeders (feed6_sync_feeders) */
	REG_DUMP_PRINT_1("   -feed6_sync_feeders.feed_sync_0                                     |         0x%01X  |  [RW][00:00]""Sync with all feeders with bit 0 set""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed6_sync_feeders.feed_sync_1                                     |         0x%01X  |  [RW][01:01]""Sync with all feeders with bit 1 set""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0xb4dac);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed6_wait_order                                           |  0x%08X  |  ""Two feeders, set with the same order unit (bit 1..4), will keep the order in feeding.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed6_wait_order_type */
	/* skip, unused field unused_feed6_wait_order (feed6_wait_order) */
	REG_DUMP_PRINT_1("   -feed6_wait_order.feed_order                                        |         0x%01X  |  [RW][00:00]""0: send as first, 1: send as second""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed6_wait_order.enable_order_0                                    |         0x%01X  |  [RW][01:01]""Enable the order for order unit 0""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -feed6_wait_order.enable_order_1                                    |         0x%01X  |  [RW][02:02]""Enable the order for order unit 1""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -feed6_wait_order.enable_order_2                                    |         0x%01X  |  [RW][03:03]""Enable the order for order unit 2""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -feed6_wait_order.enable_order_3                                    |         0x%01X  |  [RW][04:04]""Enable the order for order unit 3""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xb4da8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed6_wait_on_feeders                                      |  0x%08X  |  ""The feeder will wait for other feeders when the have the bit for the same destination set.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed6_wait_on_feeders_type */
	/* skip, unused field unused_feed6_wait_on_feeders (feed6_wait_on_feeders) */
	REG_DUMP_PRINT_1("   -feed6_wait_on_feeders.feed_dest_0                                  |         0x%01X  |  [RW][00:00]""Wait with feeding for all feeders that are currently feeding a line and have bit 0 set""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed6_wait_on_feeders.feed_dest_1                                  |         0x%01X  |  [RW][01:01]""Wait with feeding for all feeders that are currently feeding a line and have bit 1 set""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -feed6_wait_on_feeders.feed_dest_2                                  |         0x%01X  |  [RW][02:02]""Wait with feeding for all feeders that are currently feeding a line and have bit 2 set""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -feed6_wait_on_feeders.feed_dest_3                                  |         0x%01X  |  [RW][03:03]""Wait with feeding for all feeders that are currently feeding a line and have bit 3 set""\n", FIELD_VALUE(val, 3, 3));
	val = REG_DUMP_READ_REGISTER(0xb4da4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed6_eventque_sidpid                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed6_eventque_sidpid_type */
	/* skip, unused field unused_feed6_eventque_sidpid (feed6_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -feed6_eventque_sidpid.feed6_eventque_sidpid                        |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb4da0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed6_height                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed6_height_type */
	/* skip, unused field unused_feed6_height (feed6_height) */
	REG_DUMP_PRINT_1("   -feed6_height.feed6_height                                          |         0x%01X  |  [RW][03:00]""The number of lines needed for a 2D unit block. A transfer will only begin when receiving cmd number (units_p_line_in * (height - 1)) + 1""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4d9c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed6_last_units_out                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed6_last_units_out_type */
	/* skip, unused field unused_feed6_last_units_out (feed6_last_units_out) */
	REG_DUMP_PRINT_1("   -feed6_last_units_out.feed6_last_units_out                          |        0x%02X  |  [RW][06:00]""The last unit number to the DMA for the last unit from the input buffer in a line.""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb4d98);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed6_units_out_p_in                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed6_units_out_p_in_type */
	/* skip, unused field unused_feed6_units_out_p_in (feed6_units_out_p_in) */
	REG_DUMP_PRINT_1("   -feed6_units_out_p_in.feed6_units_out_p_in                          |        0x%02X  |  [RW][06:00]""The number of units being transferred by the DMA that fit (width wise) in a unit from the input buffer""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb4d94);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed6_units_p_line_in                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed6_units_p_line_in_type */
	/* skip, unused field unused_feed6_units_p_line_in (feed6_units_p_line_in) */
	REG_DUMP_PRINT_1("   -feed6_units_p_line_in.feed6_units_p_line_in                        |         0x%01X  |  [RW][03:00]""The number of units per line at the input buffer""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4d90);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed6_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed6_channel_addr_type */
	/* skip, unused field unused_feed6_channel_addr (feed6_channel_addr) */
	REG_DUMP_PRINT_1("   -feed6_channel_addr.feed6_channel_addr                              |  0x%08X  |  [RW][29:00]""The address where the channel in the DMA is located""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4d8c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed6_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed6_requester_addr_type */
	/* skip, unused field unused_feed6_requester_addr (feed6_requester_addr) */
	REG_DUMP_PRINT_1("   -feed6_requester_addr.feed6_requester_addr                          |  0x%08X  |  [RW][29:00]""The address where the requester in the DMA is located""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4d88);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed6_ack_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed6_ack_addr_type */
	/* skip, unused field unused_feed6_ack_addr (feed6_ack_addr) */
	REG_DUMP_PRINT_1("   -feed6_ack_addr.feed6_ack_addr                                      |  0x%08X  |  [RW][29:00]""The address where the acknowledgement has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4d58);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk6_token                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk6_token_type */
	REG_DUMP_PRINT_1("   -fr_chk6_token.fr_chk6_token                                        |  0x%08X  |  [RW][31:00]""The token that has to be written""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb4d54);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk6_addr                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk6_addr_type */
	/* skip, unused field unused_fr_chk6_addr (fr_chk6_addr) */
	REG_DUMP_PRINT_1("   -fr_chk6_addr.fr_chk6_addr                                          |  0x%08X  |  [RW][29:00]""The address of where the frame check token has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4d50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk6_trigger_repeat_val                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk6_trigger_repeat_val_type */
	/* skip, unused field unused_fr_chk6_trigger_repeat_val (fr_chk6_trigger_repeat_val) */
	REG_DUMP_PRINT_1("   -fr_chk6_trigger_repeat_val.fr_chk6_trigger_repeat_val              |      0x%04X  |  [RW][15:00]""An frame check token is send after each trigger_repeat_val value in case the repetitive enable bit in the check mode is set and the trigger offset has been reached.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4d4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk6_trigger_offset                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk6_trigger_offset_type */
	/* skip, unused field unused_fr_chk6_trigger_offset (fr_chk6_trigger_offset) */
	REG_DUMP_PRINT_1("   -fr_chk6_trigger_offset.fr_chk6_trigger_offset                      |      0x%04X  |  [RW][15:00]""The value of the trigger, when the checked value becomes larger than the this value a frame check token is send""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4d48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk6_sid_proc_id                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk6_sid_proc_id_type */
	/* skip, unused field unused_fr_chk6_sid_proc_id (fr_chk6_sid_proc_id) */
	REG_DUMP_PRINT_1("   -fr_chk6_sid_proc_id.fr_chk6_sid_proc_id                            |         0x%01X  |  [RW][03:00]""The ID of the SID proc that has to be checked""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4d44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk6_check_mode                                         |  0x%08X  |  ""The mode of frame checking""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk6_check_mode_type */
	/* skip, unused field unused_fr_chk6_check_mode (fr_chk6_check_mode) */
	REG_DUMP_PRINT_1("   -fr_chk6_check_mode.check_type                                      |         0x%01X  |  [RW][00:00]""The type of value to be checking, 0: check lines; 1: check units;""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -fr_chk6_check_mode.repetive_enable                                 |         0x%01X  |  [RW][01:01]""Trigger and send and token after each repetitive value after the trigger offset is reached""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0xb4d40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk6_enable                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk6_enable_type */
	/* skip, unused field unused_fr_chk6_enable (fr_chk6_enable) */
	REG_DUMP_PRINT_1("   -fr_chk6_enable.fr_chk6_enable                                      |         0x%01X  |  [RW][00:00]""Enable frame checking for this frame check unit""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb4d24);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest6_iwake_threshold                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest6_iwake_threshold_type */
	/* skip, unused field unused_dest6_iwake_threshold (dest6_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest6_iwake_threshold.dest6_iwake_threshold                        |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb4d1c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest6_st_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest6_st_addr_type */
	REG_DUMP_PRINT_1("   -dest6_st_addr.dest6_st_addr                                        |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb4d18);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest6_dest_mode                                            |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest6_dest_mode_type */
	/* skip, unused field unused_dest6_dest_mode (dest6_dest_mode) */
	REG_DUMP_PRINT_1("   -dest6_dest_mode.is_ibuf_cntrl_feeder                               |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest6_dest_mode.config_dma                                         |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest6_dest_mode.iwake_enable                                       |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest6_dest_mode.disable_spana_rst                                  |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest6_dest_mode.disable_spanb_rst                                  |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xb4d14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest6_term_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest6_term_b_addr_type */
	/* skip, unused field unused_dest6_term_b_addr (dest6_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest6_term_b_addr.dest6_term_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4d10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest6_span_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest6_span_b_addr_type */
	/* skip, unused field unused_dest6_span_b_addr (dest6_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest6_span_b_addr.dest6_span_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4d0c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest6_span_a_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest6_span_a_addr_type */
	/* skip, unused field unused_dest6_span_a_addr (dest6_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest6_span_a_addr.dest6_span_a_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4d08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest6_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest6_channel_addr_type */
	/* skip, unused field unused_dest6_channel_addr (dest6_channel_addr) */
	REG_DUMP_PRINT_1("   -dest6_channel_addr.dest6_channel_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4d04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest6_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest6_requester_addr_type */
	/* skip, unused field unused_dest6_requester_addr (dest6_requester_addr) */
	REG_DUMP_PRINT_1("   -dest6_requester_addr.dest6_requester_addr                          |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4d00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest6_feed_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest6_feed_addr_type */
	/* skip, unused field unused_dest6_feed_addr (dest6_feed_addr) */
	REG_DUMP_PRINT_1("   -dest6_feed_addr.dest6_feed_addr                                    |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4ce4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_dest0_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid6_dest0_cur_cmds_type */
	/* skip, unused field unused_sid6_dest0_cur_cmds (sid6_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid6_dest0_cur_cmds.sid6_dest0_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4ce0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_dest0_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid6_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid6_dest0_sync_state.sid6_dest0_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb4cdc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_dest0_cur_ack_line                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid6_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid6_dest0_cur_ack_line (sid6_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid6_dest0_cur_ack_line.sid6_dest0_cur_ack_line                    |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb4cd8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_dest0_cur_ack_unit_in_line                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid6_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid6_dest0_cur_ack_unit_in_line (sid6_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid6_dest0_cur_ack_unit_in_line.sid6_dest0_cur_ack_unit_in_line    |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4cd4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_dest0_cur_ack_unit                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid6_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid6_dest0_cur_ack_unit (sid6_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid6_dest0_cur_ack_unit.sid6_dest0_cur_ack_unit                    |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4ccc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_main_control_state                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid6_main_control_state_type */
	/* skip, unused field unused_sid6_main_control_state (sid6_main_control_state) */
	REG_DUMP_PRINT_1("   -sid6_main_control_state.sid6_main_control_state                    |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb4cc8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_s2m_cur_ack_line                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid6_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid6_s2m_cur_ack_line (sid6_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid6_s2m_cur_ack_line.sid6_s2m_cur_ack_line                        |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb4cc4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_s2m_cur_ack_unit_in_line                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid6_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid6_s2m_cur_ack_unit_in_line (sid6_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid6_s2m_cur_ack_unit_in_line.sid6_s2m_cur_ack_unit_in_line        |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4cc0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_s2m_cur_cmds                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid6_s2m_cur_cmds_type */
	/* skip, unused field unused_sid6_s2m_cur_cmds (sid6_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid6_s2m_cur_cmds.sid6_s2m_cur_cmds                                |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4c98);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_error_reg                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid6_error_reg_type */
	REG_DUMP_PRINT_1("   -sid6_error_reg.sid6_error_reg                                      |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb4c88);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_eventque_sidpid                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid6_eventque_sidpid_type */
	/* skip, unused field unused_sid6_eventque_sidpid (sid6_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid6_eventque_sidpid.sid6_eventque_sidpid                          |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb4c84);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_ack_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid6_ack_addr_type */
	/* skip, unused field unused_sid6_ack_addr (sid6_ack_addr) */
	REG_DUMP_PRINT_1("   -sid6_ack_addr.sid6_ack_addr                                        |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4c68);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_dest0_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid6_dest0_enabled_type */
	/* skip, unused field unused_sid6_dest0_enabled (sid6_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid6_dest0_enabled.sid6_dest0_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 6""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb4c5c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_first_page_nr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid6_first_page_nr_type */
	/* skip, unused field unused_sid6_first_page_nr (sid6_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid6_first_page_nr.sid6_first_page_nr                              |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb4c54);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_units_p_ibuf                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid6_units_p_ibuf_type */
	/* skip, unused field unused_sid6_units_p_ibuf (sid6_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid6_units_p_ibuf.sid6_units_p_ibuf                                |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb4c50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_unit_size                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid6_unit_size_type */
	/* skip, unused field unused_sid6_unit_size (sid6_unit_size) */
	REG_DUMP_PRINT_1("   -sid6_unit_size.sid6_unit_size                                      |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb4c4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_lines_p_frame                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid6_lines_p_frame_type */
	/* skip, unused field unused_sid6_lines_p_frame (sid6_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid6_lines_p_frame.sid6_lines_p_frame                              |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb4c48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_units_p_line                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid6_units_p_line_type */
	/* skip, unused field unused_sid6_units_p_line (sid6_units_p_line) */
	REG_DUMP_PRINT_1("   -sid6_units_p_line.sid6_units_p_line                                |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4c44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_str2mmio_store_cmd                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid6_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid6_str2mmio_store_cmd (sid6_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid6_str2mmio_store_cmd.sid6_str2mmio_store_cmd                    |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb4c40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_str2mmio_proc_addr                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid6_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid6_str2mmio_proc_addr (sid6_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid6_str2mmio_proc_addr.sid6_str2mmio_proc_addr                    |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4bcc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed5_cur_rcvd_acks                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed5_cur_rcvd_acks_type */
	/* skip, unused field unused_feed5_cur_rcvd_acks (feed5_cur_rcvd_acks) */
	REG_DUMP_PRINT_1("   -feed5_cur_rcvd_acks.feed5_cur_rcvd_acks                            |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4bc8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed5_cur_snd_cmds                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed5_cur_snd_cmds_type */
	/* skip, unused field unused_feed5_cur_snd_cmds (feed5_cur_snd_cmds) */
	REG_DUMP_PRINT_1("   -feed5_cur_snd_cmds.feed5_cur_snd_cmds                              |      0x%04X  |  [RO][15:00]""The number of commands send for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4bc4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed5_cur_line_in                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed5_cur_line_in_type */
	/* skip, unused field unused_feed5_cur_line_in (feed5_cur_line_in) */
	REG_DUMP_PRINT_1("   -feed5_cur_line_in.feed5_cur_line_in                                |         0x%01X  |  [RO][03:00]""The current number of lines in a 2D block that not have been transferred""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4bc0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed5_cur_unit_in_line_in                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed5_cur_unit_in_line_in_type */
	/* skip, unused field unused_feed5_cur_unit_in_line_in (feed5_cur_unit_in_line_in) */
	REG_DUMP_PRINT_1("   -feed5_cur_unit_in_line_in.feed5_cur_unit_in_line_in                |         0x%01X  |  [RO][03:00]""The current number of units from the input in the line of a 2D block""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4bb0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed5_sync_feeders                                         |  0x%08X  |  ""The feeder will wait with sending a command to the DMA until all feeders with the same bit set are ready to send a command.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed5_sync_feeders_type */
	/* skip, unused field unused_feed5_sync_feeders (feed5_sync_feeders) */
	REG_DUMP_PRINT_1("   -feed5_sync_feeders.feed_sync_0                                     |         0x%01X  |  [RW][00:00]""Sync with all feeders with bit 0 set""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed5_sync_feeders.feed_sync_1                                     |         0x%01X  |  [RW][01:01]""Sync with all feeders with bit 1 set""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0xb4bac);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed5_wait_order                                           |  0x%08X  |  ""Two feeders, set with the same order unit (bit 1..4), will keep the order in feeding.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed5_wait_order_type */
	/* skip, unused field unused_feed5_wait_order (feed5_wait_order) */
	REG_DUMP_PRINT_1("   -feed5_wait_order.feed_order                                        |         0x%01X  |  [RW][00:00]""0: send as first, 1: send as second""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed5_wait_order.enable_order_0                                    |         0x%01X  |  [RW][01:01]""Enable the order for order unit 0""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -feed5_wait_order.enable_order_1                                    |         0x%01X  |  [RW][02:02]""Enable the order for order unit 1""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -feed5_wait_order.enable_order_2                                    |         0x%01X  |  [RW][03:03]""Enable the order for order unit 2""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -feed5_wait_order.enable_order_3                                    |         0x%01X  |  [RW][04:04]""Enable the order for order unit 3""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xb4ba8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed5_wait_on_feeders                                      |  0x%08X  |  ""The feeder will wait for other feeders when the have the bit for the same destination set.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed5_wait_on_feeders_type */
	/* skip, unused field unused_feed5_wait_on_feeders (feed5_wait_on_feeders) */
	REG_DUMP_PRINT_1("   -feed5_wait_on_feeders.feed_dest_0                                  |         0x%01X  |  [RW][00:00]""Wait with feeding for all feeders that are currently feeding a line and have bit 0 set""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed5_wait_on_feeders.feed_dest_1                                  |         0x%01X  |  [RW][01:01]""Wait with feeding for all feeders that are currently feeding a line and have bit 1 set""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -feed5_wait_on_feeders.feed_dest_2                                  |         0x%01X  |  [RW][02:02]""Wait with feeding for all feeders that are currently feeding a line and have bit 2 set""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -feed5_wait_on_feeders.feed_dest_3                                  |         0x%01X  |  [RW][03:03]""Wait with feeding for all feeders that are currently feeding a line and have bit 3 set""\n", FIELD_VALUE(val, 3, 3));
	val = REG_DUMP_READ_REGISTER(0xb4ba4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed5_eventque_sidpid                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed5_eventque_sidpid_type */
	/* skip, unused field unused_feed5_eventque_sidpid (feed5_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -feed5_eventque_sidpid.feed5_eventque_sidpid                        |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb4ba0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed5_height                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed5_height_type */
	/* skip, unused field unused_feed5_height (feed5_height) */
	REG_DUMP_PRINT_1("   -feed5_height.feed5_height                                          |         0x%01X  |  [RW][03:00]""The number of lines needed for a 2D unit block. A transfer will only begin when receiving cmd number (units_p_line_in * (height - 1)) + 1""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4b9c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed5_last_units_out                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed5_last_units_out_type */
	/* skip, unused field unused_feed5_last_units_out (feed5_last_units_out) */
	REG_DUMP_PRINT_1("   -feed5_last_units_out.feed5_last_units_out                          |        0x%02X  |  [RW][06:00]""The last unit number to the DMA for the last unit from the input buffer in a line.""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb4b98);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed5_units_out_p_in                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed5_units_out_p_in_type */
	/* skip, unused field unused_feed5_units_out_p_in (feed5_units_out_p_in) */
	REG_DUMP_PRINT_1("   -feed5_units_out_p_in.feed5_units_out_p_in                          |        0x%02X  |  [RW][06:00]""The number of units being transferred by the DMA that fit (width wise) in a unit from the input buffer""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb4b94);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed5_units_p_line_in                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed5_units_p_line_in_type */
	/* skip, unused field unused_feed5_units_p_line_in (feed5_units_p_line_in) */
	REG_DUMP_PRINT_1("   -feed5_units_p_line_in.feed5_units_p_line_in                        |         0x%01X  |  [RW][03:00]""The number of units per line at the input buffer""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4b90);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed5_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed5_channel_addr_type */
	/* skip, unused field unused_feed5_channel_addr (feed5_channel_addr) */
	REG_DUMP_PRINT_1("   -feed5_channel_addr.feed5_channel_addr                              |  0x%08X  |  [RW][29:00]""The address where the channel in the DMA is located""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4b8c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed5_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed5_requester_addr_type */
	/* skip, unused field unused_feed5_requester_addr (feed5_requester_addr) */
	REG_DUMP_PRINT_1("   -feed5_requester_addr.feed5_requester_addr                          |  0x%08X  |  [RW][29:00]""The address where the requester in the DMA is located""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4b88);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed5_ack_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed5_ack_addr_type */
	/* skip, unused field unused_feed5_ack_addr (feed5_ack_addr) */
	REG_DUMP_PRINT_1("   -feed5_ack_addr.feed5_ack_addr                                      |  0x%08X  |  [RW][29:00]""The address where the acknowledgement has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4b58);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk5_token                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk5_token_type */
	REG_DUMP_PRINT_1("   -fr_chk5_token.fr_chk5_token                                        |  0x%08X  |  [RW][31:00]""The token that has to be written""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb4b54);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk5_addr                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk5_addr_type */
	/* skip, unused field unused_fr_chk5_addr (fr_chk5_addr) */
	REG_DUMP_PRINT_1("   -fr_chk5_addr.fr_chk5_addr                                          |  0x%08X  |  [RW][29:00]""The address of where the frame check token has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4b50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk5_trigger_repeat_val                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk5_trigger_repeat_val_type */
	/* skip, unused field unused_fr_chk5_trigger_repeat_val (fr_chk5_trigger_repeat_val) */
	REG_DUMP_PRINT_1("   -fr_chk5_trigger_repeat_val.fr_chk5_trigger_repeat_val              |      0x%04X  |  [RW][15:00]""An frame check token is send after each trigger_repeat_val value in case the repetitive enable bit in the check mode is set and the trigger offset has been reached.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4b4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk5_trigger_offset                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk5_trigger_offset_type */
	/* skip, unused field unused_fr_chk5_trigger_offset (fr_chk5_trigger_offset) */
	REG_DUMP_PRINT_1("   -fr_chk5_trigger_offset.fr_chk5_trigger_offset                      |      0x%04X  |  [RW][15:00]""The value of the trigger, when the checked value becomes larger than the this value a frame check token is send""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4b48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk5_sid_proc_id                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk5_sid_proc_id_type */
	/* skip, unused field unused_fr_chk5_sid_proc_id (fr_chk5_sid_proc_id) */
	REG_DUMP_PRINT_1("   -fr_chk5_sid_proc_id.fr_chk5_sid_proc_id                            |         0x%01X  |  [RW][03:00]""The ID of the SID proc that has to be checked""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4b44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk5_check_mode                                         |  0x%08X  |  ""The mode of frame checking""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk5_check_mode_type */
	/* skip, unused field unused_fr_chk5_check_mode (fr_chk5_check_mode) */
	REG_DUMP_PRINT_1("   -fr_chk5_check_mode.check_type                                      |         0x%01X  |  [RW][00:00]""The type of value to be checking, 0: check lines; 1: check units;""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -fr_chk5_check_mode.repetive_enable                                 |         0x%01X  |  [RW][01:01]""Trigger and send and token after each repetitive value after the trigger offset is reached""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0xb4b40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk5_enable                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk5_enable_type */
	/* skip, unused field unused_fr_chk5_enable (fr_chk5_enable) */
	REG_DUMP_PRINT_1("   -fr_chk5_enable.fr_chk5_enable                                      |         0x%01X  |  [RW][00:00]""Enable frame checking for this frame check unit""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb4b24);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest5_iwake_threshold                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest5_iwake_threshold_type */
	/* skip, unused field unused_dest5_iwake_threshold (dest5_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest5_iwake_threshold.dest5_iwake_threshold                        |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb4b1c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest5_st_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest5_st_addr_type */
	REG_DUMP_PRINT_1("   -dest5_st_addr.dest5_st_addr                                        |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb4b18);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest5_dest_mode                                            |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest5_dest_mode_type */
	/* skip, unused field unused_dest5_dest_mode (dest5_dest_mode) */
	REG_DUMP_PRINT_1("   -dest5_dest_mode.is_ibuf_cntrl_feeder                               |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest5_dest_mode.config_dma                                         |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest5_dest_mode.iwake_enable                                       |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest5_dest_mode.disable_spana_rst                                  |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest5_dest_mode.disable_spanb_rst                                  |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xb4b14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest5_term_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest5_term_b_addr_type */
	/* skip, unused field unused_dest5_term_b_addr (dest5_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest5_term_b_addr.dest5_term_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4b10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest5_span_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest5_span_b_addr_type */
	/* skip, unused field unused_dest5_span_b_addr (dest5_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest5_span_b_addr.dest5_span_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4b0c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest5_span_a_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest5_span_a_addr_type */
	/* skip, unused field unused_dest5_span_a_addr (dest5_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest5_span_a_addr.dest5_span_a_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4b08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest5_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest5_channel_addr_type */
	/* skip, unused field unused_dest5_channel_addr (dest5_channel_addr) */
	REG_DUMP_PRINT_1("   -dest5_channel_addr.dest5_channel_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4b04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest5_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest5_requester_addr_type */
	/* skip, unused field unused_dest5_requester_addr (dest5_requester_addr) */
	REG_DUMP_PRINT_1("   -dest5_requester_addr.dest5_requester_addr                          |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4b00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest5_feed_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest5_feed_addr_type */
	/* skip, unused field unused_dest5_feed_addr (dest5_feed_addr) */
	REG_DUMP_PRINT_1("   -dest5_feed_addr.dest5_feed_addr                                    |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4ae4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_dest0_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid5_dest0_cur_cmds_type */
	/* skip, unused field unused_sid5_dest0_cur_cmds (sid5_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid5_dest0_cur_cmds.sid5_dest0_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4ae0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_dest0_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid5_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid5_dest0_sync_state.sid5_dest0_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb4adc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_dest0_cur_ack_line                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid5_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid5_dest0_cur_ack_line (sid5_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid5_dest0_cur_ack_line.sid5_dest0_cur_ack_line                    |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb4ad8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_dest0_cur_ack_unit_in_line                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid5_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid5_dest0_cur_ack_unit_in_line (sid5_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid5_dest0_cur_ack_unit_in_line.sid5_dest0_cur_ack_unit_in_line    |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4ad4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_dest0_cur_ack_unit                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid5_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid5_dest0_cur_ack_unit (sid5_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid5_dest0_cur_ack_unit.sid5_dest0_cur_ack_unit                    |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4acc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_main_control_state                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid5_main_control_state_type */
	/* skip, unused field unused_sid5_main_control_state (sid5_main_control_state) */
	REG_DUMP_PRINT_1("   -sid5_main_control_state.sid5_main_control_state                    |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb4ac8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_s2m_cur_ack_line                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid5_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid5_s2m_cur_ack_line (sid5_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid5_s2m_cur_ack_line.sid5_s2m_cur_ack_line                        |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb4ac4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_s2m_cur_ack_unit_in_line                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid5_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid5_s2m_cur_ack_unit_in_line (sid5_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid5_s2m_cur_ack_unit_in_line.sid5_s2m_cur_ack_unit_in_line        |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4ac0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_s2m_cur_cmds                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid5_s2m_cur_cmds_type */
	/* skip, unused field unused_sid5_s2m_cur_cmds (sid5_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid5_s2m_cur_cmds.sid5_s2m_cur_cmds                                |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4a98);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_error_reg                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid5_error_reg_type */
	REG_DUMP_PRINT_1("   -sid5_error_reg.sid5_error_reg                                      |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb4a88);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_eventque_sidpid                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid5_eventque_sidpid_type */
	/* skip, unused field unused_sid5_eventque_sidpid (sid5_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid5_eventque_sidpid.sid5_eventque_sidpid                          |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb4a84);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_ack_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid5_ack_addr_type */
	/* skip, unused field unused_sid5_ack_addr (sid5_ack_addr) */
	REG_DUMP_PRINT_1("   -sid5_ack_addr.sid5_ack_addr                                        |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4a68);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_dest0_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid5_dest0_enabled_type */
	/* skip, unused field unused_sid5_dest0_enabled (sid5_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid5_dest0_enabled.sid5_dest0_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 5""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb4a5c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_first_page_nr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid5_first_page_nr_type */
	/* skip, unused field unused_sid5_first_page_nr (sid5_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid5_first_page_nr.sid5_first_page_nr                              |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb4a54);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_units_p_ibuf                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid5_units_p_ibuf_type */
	/* skip, unused field unused_sid5_units_p_ibuf (sid5_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid5_units_p_ibuf.sid5_units_p_ibuf                                |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb4a50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_unit_size                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid5_unit_size_type */
	/* skip, unused field unused_sid5_unit_size (sid5_unit_size) */
	REG_DUMP_PRINT_1("   -sid5_unit_size.sid5_unit_size                                      |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb4a4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_lines_p_frame                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid5_lines_p_frame_type */
	/* skip, unused field unused_sid5_lines_p_frame (sid5_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid5_lines_p_frame.sid5_lines_p_frame                              |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb4a48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_units_p_line                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid5_units_p_line_type */
	/* skip, unused field unused_sid5_units_p_line (sid5_units_p_line) */
	REG_DUMP_PRINT_1("   -sid5_units_p_line.sid5_units_p_line                                |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4a44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_str2mmio_store_cmd                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid5_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid5_str2mmio_store_cmd (sid5_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid5_str2mmio_store_cmd.sid5_str2mmio_store_cmd                    |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb4a40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_str2mmio_proc_addr                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid5_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid5_str2mmio_proc_addr (sid5_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid5_str2mmio_proc_addr.sid5_str2mmio_proc_addr                    |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb49cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed4_cur_rcvd_acks                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed4_cur_rcvd_acks_type */
	/* skip, unused field unused_feed4_cur_rcvd_acks (feed4_cur_rcvd_acks) */
	REG_DUMP_PRINT_1("   -feed4_cur_rcvd_acks.feed4_cur_rcvd_acks                            |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb49c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed4_cur_snd_cmds                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed4_cur_snd_cmds_type */
	/* skip, unused field unused_feed4_cur_snd_cmds (feed4_cur_snd_cmds) */
	REG_DUMP_PRINT_1("   -feed4_cur_snd_cmds.feed4_cur_snd_cmds                              |      0x%04X  |  [RO][15:00]""The number of commands send for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb49c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed4_cur_line_in                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed4_cur_line_in_type */
	/* skip, unused field unused_feed4_cur_line_in (feed4_cur_line_in) */
	REG_DUMP_PRINT_1("   -feed4_cur_line_in.feed4_cur_line_in                                |         0x%01X  |  [RO][03:00]""The current number of lines in a 2D block that not have been transferred""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb49c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed4_cur_unit_in_line_in                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed4_cur_unit_in_line_in_type */
	/* skip, unused field unused_feed4_cur_unit_in_line_in (feed4_cur_unit_in_line_in) */
	REG_DUMP_PRINT_1("   -feed4_cur_unit_in_line_in.feed4_cur_unit_in_line_in                |         0x%01X  |  [RO][03:00]""The current number of units from the input in the line of a 2D block""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb49b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed4_sync_feeders                                         |  0x%08X  |  ""The feeder will wait with sending a command to the DMA until all feeders with the same bit set are ready to send a command.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed4_sync_feeders_type */
	/* skip, unused field unused_feed4_sync_feeders (feed4_sync_feeders) */
	REG_DUMP_PRINT_1("   -feed4_sync_feeders.feed_sync_0                                     |         0x%01X  |  [RW][00:00]""Sync with all feeders with bit 0 set""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed4_sync_feeders.feed_sync_1                                     |         0x%01X  |  [RW][01:01]""Sync with all feeders with bit 1 set""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0xb49ac);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed4_wait_order                                           |  0x%08X  |  ""Two feeders, set with the same order unit (bit 1..4), will keep the order in feeding.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed4_wait_order_type */
	/* skip, unused field unused_feed4_wait_order (feed4_wait_order) */
	REG_DUMP_PRINT_1("   -feed4_wait_order.feed_order                                        |         0x%01X  |  [RW][00:00]""0: send as first, 1: send as second""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed4_wait_order.enable_order_0                                    |         0x%01X  |  [RW][01:01]""Enable the order for order unit 0""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -feed4_wait_order.enable_order_1                                    |         0x%01X  |  [RW][02:02]""Enable the order for order unit 1""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -feed4_wait_order.enable_order_2                                    |         0x%01X  |  [RW][03:03]""Enable the order for order unit 2""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -feed4_wait_order.enable_order_3                                    |         0x%01X  |  [RW][04:04]""Enable the order for order unit 3""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xb49a8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed4_wait_on_feeders                                      |  0x%08X  |  ""The feeder will wait for other feeders when the have the bit for the same destination set.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed4_wait_on_feeders_type */
	/* skip, unused field unused_feed4_wait_on_feeders (feed4_wait_on_feeders) */
	REG_DUMP_PRINT_1("   -feed4_wait_on_feeders.feed_dest_0                                  |         0x%01X  |  [RW][00:00]""Wait with feeding for all feeders that are currently feeding a line and have bit 0 set""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed4_wait_on_feeders.feed_dest_1                                  |         0x%01X  |  [RW][01:01]""Wait with feeding for all feeders that are currently feeding a line and have bit 1 set""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -feed4_wait_on_feeders.feed_dest_2                                  |         0x%01X  |  [RW][02:02]""Wait with feeding for all feeders that are currently feeding a line and have bit 2 set""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -feed4_wait_on_feeders.feed_dest_3                                  |         0x%01X  |  [RW][03:03]""Wait with feeding for all feeders that are currently feeding a line and have bit 3 set""\n", FIELD_VALUE(val, 3, 3));
	val = REG_DUMP_READ_REGISTER(0xb49a4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed4_eventque_sidpid                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed4_eventque_sidpid_type */
	/* skip, unused field unused_feed4_eventque_sidpid (feed4_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -feed4_eventque_sidpid.feed4_eventque_sidpid                        |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb49a0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed4_height                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed4_height_type */
	/* skip, unused field unused_feed4_height (feed4_height) */
	REG_DUMP_PRINT_1("   -feed4_height.feed4_height                                          |         0x%01X  |  [RW][03:00]""The number of lines needed for a 2D unit block. A transfer will only begin when receiving cmd number (units_p_line_in * (height - 1)) + 1""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb499c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed4_last_units_out                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed4_last_units_out_type */
	/* skip, unused field unused_feed4_last_units_out (feed4_last_units_out) */
	REG_DUMP_PRINT_1("   -feed4_last_units_out.feed4_last_units_out                          |        0x%02X  |  [RW][06:00]""The last unit number to the DMA for the last unit from the input buffer in a line.""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb4998);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed4_units_out_p_in                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed4_units_out_p_in_type */
	/* skip, unused field unused_feed4_units_out_p_in (feed4_units_out_p_in) */
	REG_DUMP_PRINT_1("   -feed4_units_out_p_in.feed4_units_out_p_in                          |        0x%02X  |  [RW][06:00]""The number of units being transferred by the DMA that fit (width wise) in a unit from the input buffer""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb4994);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed4_units_p_line_in                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed4_units_p_line_in_type */
	/* skip, unused field unused_feed4_units_p_line_in (feed4_units_p_line_in) */
	REG_DUMP_PRINT_1("   -feed4_units_p_line_in.feed4_units_p_line_in                        |         0x%01X  |  [RW][03:00]""The number of units per line at the input buffer""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4990);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed4_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed4_channel_addr_type */
	/* skip, unused field unused_feed4_channel_addr (feed4_channel_addr) */
	REG_DUMP_PRINT_1("   -feed4_channel_addr.feed4_channel_addr                              |  0x%08X  |  [RW][29:00]""The address where the channel in the DMA is located""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb498c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed4_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed4_requester_addr_type */
	/* skip, unused field unused_feed4_requester_addr (feed4_requester_addr) */
	REG_DUMP_PRINT_1("   -feed4_requester_addr.feed4_requester_addr                          |  0x%08X  |  [RW][29:00]""The address where the requester in the DMA is located""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4988);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed4_ack_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed4_ack_addr_type */
	/* skip, unused field unused_feed4_ack_addr (feed4_ack_addr) */
	REG_DUMP_PRINT_1("   -feed4_ack_addr.feed4_ack_addr                                      |  0x%08X  |  [RW][29:00]""The address where the acknowledgement has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4958);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk4_token                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk4_token_type */
	REG_DUMP_PRINT_1("   -fr_chk4_token.fr_chk4_token                                        |  0x%08X  |  [RW][31:00]""The token that has to be written""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb4954);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk4_addr                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk4_addr_type */
	/* skip, unused field unused_fr_chk4_addr (fr_chk4_addr) */
	REG_DUMP_PRINT_1("   -fr_chk4_addr.fr_chk4_addr                                          |  0x%08X  |  [RW][29:00]""The address of where the frame check token has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4950);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk4_trigger_repeat_val                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk4_trigger_repeat_val_type */
	/* skip, unused field unused_fr_chk4_trigger_repeat_val (fr_chk4_trigger_repeat_val) */
	REG_DUMP_PRINT_1("   -fr_chk4_trigger_repeat_val.fr_chk4_trigger_repeat_val              |      0x%04X  |  [RW][15:00]""An frame check token is send after each trigger_repeat_val value in case the repetitive enable bit in the check mode is set and the trigger offset has been reached.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb494c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk4_trigger_offset                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk4_trigger_offset_type */
	/* skip, unused field unused_fr_chk4_trigger_offset (fr_chk4_trigger_offset) */
	REG_DUMP_PRINT_1("   -fr_chk4_trigger_offset.fr_chk4_trigger_offset                      |      0x%04X  |  [RW][15:00]""The value of the trigger, when the checked value becomes larger than the this value a frame check token is send""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4948);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk4_sid_proc_id                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk4_sid_proc_id_type */
	/* skip, unused field unused_fr_chk4_sid_proc_id (fr_chk4_sid_proc_id) */
	REG_DUMP_PRINT_1("   -fr_chk4_sid_proc_id.fr_chk4_sid_proc_id                            |         0x%01X  |  [RW][03:00]""The ID of the SID proc that has to be checked""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4944);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk4_check_mode                                         |  0x%08X  |  ""The mode of frame checking""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk4_check_mode_type */
	/* skip, unused field unused_fr_chk4_check_mode (fr_chk4_check_mode) */
	REG_DUMP_PRINT_1("   -fr_chk4_check_mode.check_type                                      |         0x%01X  |  [RW][00:00]""The type of value to be checking, 0: check lines; 1: check units;""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -fr_chk4_check_mode.repetive_enable                                 |         0x%01X  |  [RW][01:01]""Trigger and send and token after each repetitive value after the trigger offset is reached""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0xb4940);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk4_enable                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk4_enable_type */
	/* skip, unused field unused_fr_chk4_enable (fr_chk4_enable) */
	REG_DUMP_PRINT_1("   -fr_chk4_enable.fr_chk4_enable                                      |         0x%01X  |  [RW][00:00]""Enable frame checking for this frame check unit""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb4924);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest4_iwake_threshold                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest4_iwake_threshold_type */
	/* skip, unused field unused_dest4_iwake_threshold (dest4_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest4_iwake_threshold.dest4_iwake_threshold                        |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb491c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest4_st_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest4_st_addr_type */
	REG_DUMP_PRINT_1("   -dest4_st_addr.dest4_st_addr                                        |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb4918);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest4_dest_mode                                            |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest4_dest_mode_type */
	/* skip, unused field unused_dest4_dest_mode (dest4_dest_mode) */
	REG_DUMP_PRINT_1("   -dest4_dest_mode.is_ibuf_cntrl_feeder                               |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest4_dest_mode.config_dma                                         |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest4_dest_mode.iwake_enable                                       |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest4_dest_mode.disable_spana_rst                                  |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest4_dest_mode.disable_spanb_rst                                  |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xb4914);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest4_term_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest4_term_b_addr_type */
	/* skip, unused field unused_dest4_term_b_addr (dest4_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest4_term_b_addr.dest4_term_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4910);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest4_span_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest4_span_b_addr_type */
	/* skip, unused field unused_dest4_span_b_addr (dest4_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest4_span_b_addr.dest4_span_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb490c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest4_span_a_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest4_span_a_addr_type */
	/* skip, unused field unused_dest4_span_a_addr (dest4_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest4_span_a_addr.dest4_span_a_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4908);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest4_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest4_channel_addr_type */
	/* skip, unused field unused_dest4_channel_addr (dest4_channel_addr) */
	REG_DUMP_PRINT_1("   -dest4_channel_addr.dest4_channel_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4904);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest4_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest4_requester_addr_type */
	/* skip, unused field unused_dest4_requester_addr (dest4_requester_addr) */
	REG_DUMP_PRINT_1("   -dest4_requester_addr.dest4_requester_addr                          |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4900);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest4_feed_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest4_feed_addr_type */
	/* skip, unused field unused_dest4_feed_addr (dest4_feed_addr) */
	REG_DUMP_PRINT_1("   -dest4_feed_addr.dest4_feed_addr                                    |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb48e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_dest0_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid4_dest0_cur_cmds_type */
	/* skip, unused field unused_sid4_dest0_cur_cmds (sid4_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid4_dest0_cur_cmds.sid4_dest0_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb48e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_dest0_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid4_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid4_dest0_sync_state.sid4_dest0_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb48dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_dest0_cur_ack_line                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid4_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid4_dest0_cur_ack_line (sid4_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid4_dest0_cur_ack_line.sid4_dest0_cur_ack_line                    |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb48d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_dest0_cur_ack_unit_in_line                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid4_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid4_dest0_cur_ack_unit_in_line (sid4_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid4_dest0_cur_ack_unit_in_line.sid4_dest0_cur_ack_unit_in_line    |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb48d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_dest0_cur_ack_unit                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid4_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid4_dest0_cur_ack_unit (sid4_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid4_dest0_cur_ack_unit.sid4_dest0_cur_ack_unit                    |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb48cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_main_control_state                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid4_main_control_state_type */
	/* skip, unused field unused_sid4_main_control_state (sid4_main_control_state) */
	REG_DUMP_PRINT_1("   -sid4_main_control_state.sid4_main_control_state                    |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb48c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_s2m_cur_ack_line                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid4_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid4_s2m_cur_ack_line (sid4_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid4_s2m_cur_ack_line.sid4_s2m_cur_ack_line                        |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb48c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_s2m_cur_ack_unit_in_line                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid4_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid4_s2m_cur_ack_unit_in_line (sid4_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid4_s2m_cur_ack_unit_in_line.sid4_s2m_cur_ack_unit_in_line        |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb48c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_s2m_cur_cmds                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid4_s2m_cur_cmds_type */
	/* skip, unused field unused_sid4_s2m_cur_cmds (sid4_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid4_s2m_cur_cmds.sid4_s2m_cur_cmds                                |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4898);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_error_reg                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid4_error_reg_type */
	REG_DUMP_PRINT_1("   -sid4_error_reg.sid4_error_reg                                      |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb4888);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_eventque_sidpid                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid4_eventque_sidpid_type */
	/* skip, unused field unused_sid4_eventque_sidpid (sid4_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid4_eventque_sidpid.sid4_eventque_sidpid                          |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb4884);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_ack_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid4_ack_addr_type */
	/* skip, unused field unused_sid4_ack_addr (sid4_ack_addr) */
	REG_DUMP_PRINT_1("   -sid4_ack_addr.sid4_ack_addr                                        |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4868);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_dest0_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid4_dest0_enabled_type */
	/* skip, unused field unused_sid4_dest0_enabled (sid4_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid4_dest0_enabled.sid4_dest0_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 4""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb485c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_first_page_nr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid4_first_page_nr_type */
	/* skip, unused field unused_sid4_first_page_nr (sid4_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid4_first_page_nr.sid4_first_page_nr                              |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb4854);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_units_p_ibuf                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid4_units_p_ibuf_type */
	/* skip, unused field unused_sid4_units_p_ibuf (sid4_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid4_units_p_ibuf.sid4_units_p_ibuf                                |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb4850);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_unit_size                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid4_unit_size_type */
	/* skip, unused field unused_sid4_unit_size (sid4_unit_size) */
	REG_DUMP_PRINT_1("   -sid4_unit_size.sid4_unit_size                                      |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb484c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_lines_p_frame                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid4_lines_p_frame_type */
	/* skip, unused field unused_sid4_lines_p_frame (sid4_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid4_lines_p_frame.sid4_lines_p_frame                              |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb4848);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_units_p_line                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid4_units_p_line_type */
	/* skip, unused field unused_sid4_units_p_line (sid4_units_p_line) */
	REG_DUMP_PRINT_1("   -sid4_units_p_line.sid4_units_p_line                                |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4844);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_str2mmio_store_cmd                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid4_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid4_str2mmio_store_cmd (sid4_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid4_str2mmio_store_cmd.sid4_str2mmio_store_cmd                    |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb4840);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_str2mmio_proc_addr                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid4_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid4_str2mmio_proc_addr (sid4_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid4_str2mmio_proc_addr.sid4_str2mmio_proc_addr                    |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb47cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed3_cur_rcvd_acks                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed3_cur_rcvd_acks_type */
	/* skip, unused field unused_feed3_cur_rcvd_acks (feed3_cur_rcvd_acks) */
	REG_DUMP_PRINT_1("   -feed3_cur_rcvd_acks.feed3_cur_rcvd_acks                            |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb47c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed3_cur_snd_cmds                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed3_cur_snd_cmds_type */
	/* skip, unused field unused_feed3_cur_snd_cmds (feed3_cur_snd_cmds) */
	REG_DUMP_PRINT_1("   -feed3_cur_snd_cmds.feed3_cur_snd_cmds                              |      0x%04X  |  [RO][15:00]""The number of commands send for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb47c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed3_cur_line_in                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed3_cur_line_in_type */
	/* skip, unused field unused_feed3_cur_line_in (feed3_cur_line_in) */
	REG_DUMP_PRINT_1("   -feed3_cur_line_in.feed3_cur_line_in                                |         0x%01X  |  [RO][03:00]""The current number of lines in a 2D block that not have been transferred""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb47c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed3_cur_unit_in_line_in                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed3_cur_unit_in_line_in_type */
	/* skip, unused field unused_feed3_cur_unit_in_line_in (feed3_cur_unit_in_line_in) */
	REG_DUMP_PRINT_1("   -feed3_cur_unit_in_line_in.feed3_cur_unit_in_line_in                |         0x%01X  |  [RO][03:00]""The current number of units from the input in the line of a 2D block""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb47b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed3_sync_feeders                                         |  0x%08X  |  ""The feeder will wait with sending a command to the DMA until all feeders with the same bit set are ready to send a command.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed3_sync_feeders_type */
	/* skip, unused field unused_feed3_sync_feeders (feed3_sync_feeders) */
	REG_DUMP_PRINT_1("   -feed3_sync_feeders.feed_sync_0                                     |         0x%01X  |  [RW][00:00]""Sync with all feeders with bit 0 set""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed3_sync_feeders.feed_sync_1                                     |         0x%01X  |  [RW][01:01]""Sync with all feeders with bit 1 set""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0xb47ac);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed3_wait_order                                           |  0x%08X  |  ""Two feeders, set with the same order unit (bit 1..4), will keep the order in feeding.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed3_wait_order_type */
	/* skip, unused field unused_feed3_wait_order (feed3_wait_order) */
	REG_DUMP_PRINT_1("   -feed3_wait_order.feed_order                                        |         0x%01X  |  [RW][00:00]""0: send as first, 1: send as second""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed3_wait_order.enable_order_0                                    |         0x%01X  |  [RW][01:01]""Enable the order for order unit 0""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -feed3_wait_order.enable_order_1                                    |         0x%01X  |  [RW][02:02]""Enable the order for order unit 1""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -feed3_wait_order.enable_order_2                                    |         0x%01X  |  [RW][03:03]""Enable the order for order unit 2""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -feed3_wait_order.enable_order_3                                    |         0x%01X  |  [RW][04:04]""Enable the order for order unit 3""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xb47a8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed3_wait_on_feeders                                      |  0x%08X  |  ""The feeder will wait for other feeders when the have the bit for the same destination set.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed3_wait_on_feeders_type */
	/* skip, unused field unused_feed3_wait_on_feeders (feed3_wait_on_feeders) */
	REG_DUMP_PRINT_1("   -feed3_wait_on_feeders.feed_dest_0                                  |         0x%01X  |  [RW][00:00]""Wait with feeding for all feeders that are currently feeding a line and have bit 0 set""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed3_wait_on_feeders.feed_dest_1                                  |         0x%01X  |  [RW][01:01]""Wait with feeding for all feeders that are currently feeding a line and have bit 1 set""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -feed3_wait_on_feeders.feed_dest_2                                  |         0x%01X  |  [RW][02:02]""Wait with feeding for all feeders that are currently feeding a line and have bit 2 set""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -feed3_wait_on_feeders.feed_dest_3                                  |         0x%01X  |  [RW][03:03]""Wait with feeding for all feeders that are currently feeding a line and have bit 3 set""\n", FIELD_VALUE(val, 3, 3));
	val = REG_DUMP_READ_REGISTER(0xb47a4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed3_eventque_sidpid                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed3_eventque_sidpid_type */
	/* skip, unused field unused_feed3_eventque_sidpid (feed3_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -feed3_eventque_sidpid.feed3_eventque_sidpid                        |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb47a0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed3_height                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed3_height_type */
	/* skip, unused field unused_feed3_height (feed3_height) */
	REG_DUMP_PRINT_1("   -feed3_height.feed3_height                                          |         0x%01X  |  [RW][03:00]""The number of lines needed for a 2D unit block. A transfer will only begin when receiving cmd number (units_p_line_in * (height - 1)) + 1""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb479c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed3_last_units_out                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed3_last_units_out_type */
	/* skip, unused field unused_feed3_last_units_out (feed3_last_units_out) */
	REG_DUMP_PRINT_1("   -feed3_last_units_out.feed3_last_units_out                          |        0x%02X  |  [RW][06:00]""The last unit number to the DMA for the last unit from the input buffer in a line.""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb4798);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed3_units_out_p_in                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed3_units_out_p_in_type */
	/* skip, unused field unused_feed3_units_out_p_in (feed3_units_out_p_in) */
	REG_DUMP_PRINT_1("   -feed3_units_out_p_in.feed3_units_out_p_in                          |        0x%02X  |  [RW][06:00]""The number of units being transferred by the DMA that fit (width wise) in a unit from the input buffer""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb4794);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed3_units_p_line_in                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed3_units_p_line_in_type */
	/* skip, unused field unused_feed3_units_p_line_in (feed3_units_p_line_in) */
	REG_DUMP_PRINT_1("   -feed3_units_p_line_in.feed3_units_p_line_in                        |         0x%01X  |  [RW][03:00]""The number of units per line at the input buffer""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4790);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed3_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed3_channel_addr_type */
	/* skip, unused field unused_feed3_channel_addr (feed3_channel_addr) */
	REG_DUMP_PRINT_1("   -feed3_channel_addr.feed3_channel_addr                              |  0x%08X  |  [RW][29:00]""The address where the channel in the DMA is located""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb478c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed3_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed3_requester_addr_type */
	/* skip, unused field unused_feed3_requester_addr (feed3_requester_addr) */
	REG_DUMP_PRINT_1("   -feed3_requester_addr.feed3_requester_addr                          |  0x%08X  |  [RW][29:00]""The address where the requester in the DMA is located""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4788);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed3_ack_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed3_ack_addr_type */
	/* skip, unused field unused_feed3_ack_addr (feed3_ack_addr) */
	REG_DUMP_PRINT_1("   -feed3_ack_addr.feed3_ack_addr                                      |  0x%08X  |  [RW][29:00]""The address where the acknowledgement has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4758);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk3_token                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk3_token_type */
	REG_DUMP_PRINT_1("   -fr_chk3_token.fr_chk3_token                                        |  0x%08X  |  [RW][31:00]""The token that has to be written""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb4754);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk3_addr                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk3_addr_type */
	/* skip, unused field unused_fr_chk3_addr (fr_chk3_addr) */
	REG_DUMP_PRINT_1("   -fr_chk3_addr.fr_chk3_addr                                          |  0x%08X  |  [RW][29:00]""The address of where the frame check token has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4750);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk3_trigger_repeat_val                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk3_trigger_repeat_val_type */
	/* skip, unused field unused_fr_chk3_trigger_repeat_val (fr_chk3_trigger_repeat_val) */
	REG_DUMP_PRINT_1("   -fr_chk3_trigger_repeat_val.fr_chk3_trigger_repeat_val              |      0x%04X  |  [RW][15:00]""An frame check token is send after each trigger_repeat_val value in case the repetitive enable bit in the check mode is set and the trigger offset has been reached.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb474c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk3_trigger_offset                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk3_trigger_offset_type */
	/* skip, unused field unused_fr_chk3_trigger_offset (fr_chk3_trigger_offset) */
	REG_DUMP_PRINT_1("   -fr_chk3_trigger_offset.fr_chk3_trigger_offset                      |      0x%04X  |  [RW][15:00]""The value of the trigger, when the checked value becomes larger than the this value a frame check token is send""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4748);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk3_sid_proc_id                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk3_sid_proc_id_type */
	/* skip, unused field unused_fr_chk3_sid_proc_id (fr_chk3_sid_proc_id) */
	REG_DUMP_PRINT_1("   -fr_chk3_sid_proc_id.fr_chk3_sid_proc_id                            |         0x%01X  |  [RW][03:00]""The ID of the SID proc that has to be checked""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4744);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk3_check_mode                                         |  0x%08X  |  ""The mode of frame checking""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk3_check_mode_type */
	/* skip, unused field unused_fr_chk3_check_mode (fr_chk3_check_mode) */
	REG_DUMP_PRINT_1("   -fr_chk3_check_mode.check_type                                      |         0x%01X  |  [RW][00:00]""The type of value to be checking, 0: check lines; 1: check units;""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -fr_chk3_check_mode.repetive_enable                                 |         0x%01X  |  [RW][01:01]""Trigger and send and token after each repetitive value after the trigger offset is reached""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0xb4740);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk3_enable                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk3_enable_type */
	/* skip, unused field unused_fr_chk3_enable (fr_chk3_enable) */
	REG_DUMP_PRINT_1("   -fr_chk3_enable.fr_chk3_enable                                      |         0x%01X  |  [RW][00:00]""Enable frame checking for this frame check unit""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb4724);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest3_iwake_threshold                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest3_iwake_threshold_type */
	/* skip, unused field unused_dest3_iwake_threshold (dest3_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest3_iwake_threshold.dest3_iwake_threshold                        |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb471c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest3_st_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest3_st_addr_type */
	REG_DUMP_PRINT_1("   -dest3_st_addr.dest3_st_addr                                        |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb4718);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest3_dest_mode                                            |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest3_dest_mode_type */
	/* skip, unused field unused_dest3_dest_mode (dest3_dest_mode) */
	REG_DUMP_PRINT_1("   -dest3_dest_mode.is_ibuf_cntrl_feeder                               |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest3_dest_mode.config_dma                                         |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest3_dest_mode.iwake_enable                                       |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest3_dest_mode.disable_spana_rst                                  |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest3_dest_mode.disable_spanb_rst                                  |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xb4714);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest3_term_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest3_term_b_addr_type */
	/* skip, unused field unused_dest3_term_b_addr (dest3_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest3_term_b_addr.dest3_term_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4710);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest3_span_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest3_span_b_addr_type */
	/* skip, unused field unused_dest3_span_b_addr (dest3_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest3_span_b_addr.dest3_span_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb470c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest3_span_a_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest3_span_a_addr_type */
	/* skip, unused field unused_dest3_span_a_addr (dest3_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest3_span_a_addr.dest3_span_a_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4708);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest3_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest3_channel_addr_type */
	/* skip, unused field unused_dest3_channel_addr (dest3_channel_addr) */
	REG_DUMP_PRINT_1("   -dest3_channel_addr.dest3_channel_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4704);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest3_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest3_requester_addr_type */
	/* skip, unused field unused_dest3_requester_addr (dest3_requester_addr) */
	REG_DUMP_PRINT_1("   -dest3_requester_addr.dest3_requester_addr                          |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4700);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest3_feed_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest3_feed_addr_type */
	/* skip, unused field unused_dest3_feed_addr (dest3_feed_addr) */
	REG_DUMP_PRINT_1("   -dest3_feed_addr.dest3_feed_addr                                    |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb46e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_dest0_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid3_dest0_cur_cmds_type */
	/* skip, unused field unused_sid3_dest0_cur_cmds (sid3_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid3_dest0_cur_cmds.sid3_dest0_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb46e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_dest0_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid3_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid3_dest0_sync_state.sid3_dest0_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb46dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_dest0_cur_ack_line                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid3_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid3_dest0_cur_ack_line (sid3_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid3_dest0_cur_ack_line.sid3_dest0_cur_ack_line                    |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb46d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_dest0_cur_ack_unit_in_line                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid3_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid3_dest0_cur_ack_unit_in_line (sid3_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid3_dest0_cur_ack_unit_in_line.sid3_dest0_cur_ack_unit_in_line    |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb46d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_dest0_cur_ack_unit                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid3_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid3_dest0_cur_ack_unit (sid3_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid3_dest0_cur_ack_unit.sid3_dest0_cur_ack_unit                    |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb46cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_main_control_state                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid3_main_control_state_type */
	/* skip, unused field unused_sid3_main_control_state (sid3_main_control_state) */
	REG_DUMP_PRINT_1("   -sid3_main_control_state.sid3_main_control_state                    |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb46c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_s2m_cur_ack_line                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid3_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid3_s2m_cur_ack_line (sid3_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid3_s2m_cur_ack_line.sid3_s2m_cur_ack_line                        |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb46c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_s2m_cur_ack_unit_in_line                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid3_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid3_s2m_cur_ack_unit_in_line (sid3_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid3_s2m_cur_ack_unit_in_line.sid3_s2m_cur_ack_unit_in_line        |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb46c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_s2m_cur_cmds                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid3_s2m_cur_cmds_type */
	/* skip, unused field unused_sid3_s2m_cur_cmds (sid3_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid3_s2m_cur_cmds.sid3_s2m_cur_cmds                                |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4698);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_error_reg                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid3_error_reg_type */
	REG_DUMP_PRINT_1("   -sid3_error_reg.sid3_error_reg                                      |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb4688);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_eventque_sidpid                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid3_eventque_sidpid_type */
	/* skip, unused field unused_sid3_eventque_sidpid (sid3_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid3_eventque_sidpid.sid3_eventque_sidpid                          |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb4684);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_ack_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid3_ack_addr_type */
	/* skip, unused field unused_sid3_ack_addr (sid3_ack_addr) */
	REG_DUMP_PRINT_1("   -sid3_ack_addr.sid3_ack_addr                                        |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4668);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_dest0_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid3_dest0_enabled_type */
	/* skip, unused field unused_sid3_dest0_enabled (sid3_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid3_dest0_enabled.sid3_dest0_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 3""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb465c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_first_page_nr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid3_first_page_nr_type */
	/* skip, unused field unused_sid3_first_page_nr (sid3_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid3_first_page_nr.sid3_first_page_nr                              |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb4654);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_units_p_ibuf                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid3_units_p_ibuf_type */
	/* skip, unused field unused_sid3_units_p_ibuf (sid3_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid3_units_p_ibuf.sid3_units_p_ibuf                                |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb4650);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_unit_size                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid3_unit_size_type */
	/* skip, unused field unused_sid3_unit_size (sid3_unit_size) */
	REG_DUMP_PRINT_1("   -sid3_unit_size.sid3_unit_size                                      |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb464c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_lines_p_frame                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid3_lines_p_frame_type */
	/* skip, unused field unused_sid3_lines_p_frame (sid3_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid3_lines_p_frame.sid3_lines_p_frame                              |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb4648);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_units_p_line                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid3_units_p_line_type */
	/* skip, unused field unused_sid3_units_p_line (sid3_units_p_line) */
	REG_DUMP_PRINT_1("   -sid3_units_p_line.sid3_units_p_line                                |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4644);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_str2mmio_store_cmd                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid3_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid3_str2mmio_store_cmd (sid3_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid3_str2mmio_store_cmd.sid3_str2mmio_store_cmd                    |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb4640);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_str2mmio_proc_addr                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid3_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid3_str2mmio_proc_addr (sid3_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid3_str2mmio_proc_addr.sid3_str2mmio_proc_addr                    |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb45cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed2_cur_rcvd_acks                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed2_cur_rcvd_acks_type */
	/* skip, unused field unused_feed2_cur_rcvd_acks (feed2_cur_rcvd_acks) */
	REG_DUMP_PRINT_1("   -feed2_cur_rcvd_acks.feed2_cur_rcvd_acks                            |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb45c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed2_cur_snd_cmds                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed2_cur_snd_cmds_type */
	/* skip, unused field unused_feed2_cur_snd_cmds (feed2_cur_snd_cmds) */
	REG_DUMP_PRINT_1("   -feed2_cur_snd_cmds.feed2_cur_snd_cmds                              |      0x%04X  |  [RO][15:00]""The number of commands send for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb45c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed2_cur_line_in                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed2_cur_line_in_type */
	/* skip, unused field unused_feed2_cur_line_in (feed2_cur_line_in) */
	REG_DUMP_PRINT_1("   -feed2_cur_line_in.feed2_cur_line_in                                |         0x%01X  |  [RO][03:00]""The current number of lines in a 2D block that not have been transferred""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb45c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed2_cur_unit_in_line_in                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed2_cur_unit_in_line_in_type */
	/* skip, unused field unused_feed2_cur_unit_in_line_in (feed2_cur_unit_in_line_in) */
	REG_DUMP_PRINT_1("   -feed2_cur_unit_in_line_in.feed2_cur_unit_in_line_in                |         0x%01X  |  [RO][03:00]""The current number of units from the input in the line of a 2D block""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb45b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed2_sync_feeders                                         |  0x%08X  |  ""The feeder will wait with sending a command to the DMA until all feeders with the same bit set are ready to send a command.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed2_sync_feeders_type */
	/* skip, unused field unused_feed2_sync_feeders (feed2_sync_feeders) */
	REG_DUMP_PRINT_1("   -feed2_sync_feeders.feed_sync_0                                     |         0x%01X  |  [RW][00:00]""Sync with all feeders with bit 0 set""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed2_sync_feeders.feed_sync_1                                     |         0x%01X  |  [RW][01:01]""Sync with all feeders with bit 1 set""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0xb45ac);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed2_wait_order                                           |  0x%08X  |  ""Two feeders, set with the same order unit (bit 1..4), will keep the order in feeding.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed2_wait_order_type */
	/* skip, unused field unused_feed2_wait_order (feed2_wait_order) */
	REG_DUMP_PRINT_1("   -feed2_wait_order.feed_order                                        |         0x%01X  |  [RW][00:00]""0: send as first, 1: send as second""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed2_wait_order.enable_order_0                                    |         0x%01X  |  [RW][01:01]""Enable the order for order unit 0""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -feed2_wait_order.enable_order_1                                    |         0x%01X  |  [RW][02:02]""Enable the order for order unit 1""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -feed2_wait_order.enable_order_2                                    |         0x%01X  |  [RW][03:03]""Enable the order for order unit 2""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -feed2_wait_order.enable_order_3                                    |         0x%01X  |  [RW][04:04]""Enable the order for order unit 3""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xb45a8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed2_wait_on_feeders                                      |  0x%08X  |  ""The feeder will wait for other feeders when the have the bit for the same destination set.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed2_wait_on_feeders_type */
	/* skip, unused field unused_feed2_wait_on_feeders (feed2_wait_on_feeders) */
	REG_DUMP_PRINT_1("   -feed2_wait_on_feeders.feed_dest_0                                  |         0x%01X  |  [RW][00:00]""Wait with feeding for all feeders that are currently feeding a line and have bit 0 set""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed2_wait_on_feeders.feed_dest_1                                  |         0x%01X  |  [RW][01:01]""Wait with feeding for all feeders that are currently feeding a line and have bit 1 set""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -feed2_wait_on_feeders.feed_dest_2                                  |         0x%01X  |  [RW][02:02]""Wait with feeding for all feeders that are currently feeding a line and have bit 2 set""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -feed2_wait_on_feeders.feed_dest_3                                  |         0x%01X  |  [RW][03:03]""Wait with feeding for all feeders that are currently feeding a line and have bit 3 set""\n", FIELD_VALUE(val, 3, 3));
	val = REG_DUMP_READ_REGISTER(0xb45a4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed2_eventque_sidpid                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed2_eventque_sidpid_type */
	/* skip, unused field unused_feed2_eventque_sidpid (feed2_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -feed2_eventque_sidpid.feed2_eventque_sidpid                        |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb45a0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed2_height                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed2_height_type */
	/* skip, unused field unused_feed2_height (feed2_height) */
	REG_DUMP_PRINT_1("   -feed2_height.feed2_height                                          |         0x%01X  |  [RW][03:00]""The number of lines needed for a 2D unit block. A transfer will only begin when receiving cmd number (units_p_line_in * (height - 1)) + 1""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb459c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed2_last_units_out                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed2_last_units_out_type */
	/* skip, unused field unused_feed2_last_units_out (feed2_last_units_out) */
	REG_DUMP_PRINT_1("   -feed2_last_units_out.feed2_last_units_out                          |        0x%02X  |  [RW][06:00]""The last unit number to the DMA for the last unit from the input buffer in a line.""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb4598);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed2_units_out_p_in                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed2_units_out_p_in_type */
	/* skip, unused field unused_feed2_units_out_p_in (feed2_units_out_p_in) */
	REG_DUMP_PRINT_1("   -feed2_units_out_p_in.feed2_units_out_p_in                          |        0x%02X  |  [RW][06:00]""The number of units being transferred by the DMA that fit (width wise) in a unit from the input buffer""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb4594);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed2_units_p_line_in                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed2_units_p_line_in_type */
	/* skip, unused field unused_feed2_units_p_line_in (feed2_units_p_line_in) */
	REG_DUMP_PRINT_1("   -feed2_units_p_line_in.feed2_units_p_line_in                        |         0x%01X  |  [RW][03:00]""The number of units per line at the input buffer""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4590);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed2_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed2_channel_addr_type */
	/* skip, unused field unused_feed2_channel_addr (feed2_channel_addr) */
	REG_DUMP_PRINT_1("   -feed2_channel_addr.feed2_channel_addr                              |  0x%08X  |  [RW][29:00]""The address where the channel in the DMA is located""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb458c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed2_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed2_requester_addr_type */
	/* skip, unused field unused_feed2_requester_addr (feed2_requester_addr) */
	REG_DUMP_PRINT_1("   -feed2_requester_addr.feed2_requester_addr                          |  0x%08X  |  [RW][29:00]""The address where the requester in the DMA is located""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4588);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed2_ack_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed2_ack_addr_type */
	/* skip, unused field unused_feed2_ack_addr (feed2_ack_addr) */
	REG_DUMP_PRINT_1("   -feed2_ack_addr.feed2_ack_addr                                      |  0x%08X  |  [RW][29:00]""The address where the acknowledgement has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4558);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk2_token                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk2_token_type */
	REG_DUMP_PRINT_1("   -fr_chk2_token.fr_chk2_token                                        |  0x%08X  |  [RW][31:00]""The token that has to be written""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb4554);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk2_addr                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk2_addr_type */
	/* skip, unused field unused_fr_chk2_addr (fr_chk2_addr) */
	REG_DUMP_PRINT_1("   -fr_chk2_addr.fr_chk2_addr                                          |  0x%08X  |  [RW][29:00]""The address of where the frame check token has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4550);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk2_trigger_repeat_val                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk2_trigger_repeat_val_type */
	/* skip, unused field unused_fr_chk2_trigger_repeat_val (fr_chk2_trigger_repeat_val) */
	REG_DUMP_PRINT_1("   -fr_chk2_trigger_repeat_val.fr_chk2_trigger_repeat_val              |      0x%04X  |  [RW][15:00]""An frame check token is send after each trigger_repeat_val value in case the repetitive enable bit in the check mode is set and the trigger offset has been reached.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb454c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk2_trigger_offset                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk2_trigger_offset_type */
	/* skip, unused field unused_fr_chk2_trigger_offset (fr_chk2_trigger_offset) */
	REG_DUMP_PRINT_1("   -fr_chk2_trigger_offset.fr_chk2_trigger_offset                      |      0x%04X  |  [RW][15:00]""The value of the trigger, when the checked value becomes larger than the this value a frame check token is send""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4548);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk2_sid_proc_id                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk2_sid_proc_id_type */
	/* skip, unused field unused_fr_chk2_sid_proc_id (fr_chk2_sid_proc_id) */
	REG_DUMP_PRINT_1("   -fr_chk2_sid_proc_id.fr_chk2_sid_proc_id                            |         0x%01X  |  [RW][03:00]""The ID of the SID proc that has to be checked""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4544);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk2_check_mode                                         |  0x%08X  |  ""The mode of frame checking""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk2_check_mode_type */
	/* skip, unused field unused_fr_chk2_check_mode (fr_chk2_check_mode) */
	REG_DUMP_PRINT_1("   -fr_chk2_check_mode.check_type                                      |         0x%01X  |  [RW][00:00]""The type of value to be checking, 0: check lines; 1: check units;""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -fr_chk2_check_mode.repetive_enable                                 |         0x%01X  |  [RW][01:01]""Trigger and send and token after each repetitive value after the trigger offset is reached""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0xb4540);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk2_enable                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk2_enable_type */
	/* skip, unused field unused_fr_chk2_enable (fr_chk2_enable) */
	REG_DUMP_PRINT_1("   -fr_chk2_enable.fr_chk2_enable                                      |         0x%01X  |  [RW][00:00]""Enable frame checking for this frame check unit""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb4524);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest2_iwake_threshold                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest2_iwake_threshold_type */
	/* skip, unused field unused_dest2_iwake_threshold (dest2_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest2_iwake_threshold.dest2_iwake_threshold                        |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb451c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest2_st_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest2_st_addr_type */
	REG_DUMP_PRINT_1("   -dest2_st_addr.dest2_st_addr                                        |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb4518);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest2_dest_mode                                            |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest2_dest_mode_type */
	/* skip, unused field unused_dest2_dest_mode (dest2_dest_mode) */
	REG_DUMP_PRINT_1("   -dest2_dest_mode.is_ibuf_cntrl_feeder                               |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest2_dest_mode.config_dma                                         |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest2_dest_mode.iwake_enable                                       |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest2_dest_mode.disable_spana_rst                                  |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest2_dest_mode.disable_spanb_rst                                  |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xb4514);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest2_term_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest2_term_b_addr_type */
	/* skip, unused field unused_dest2_term_b_addr (dest2_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest2_term_b_addr.dest2_term_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4510);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest2_span_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest2_span_b_addr_type */
	/* skip, unused field unused_dest2_span_b_addr (dest2_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest2_span_b_addr.dest2_span_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb450c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest2_span_a_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest2_span_a_addr_type */
	/* skip, unused field unused_dest2_span_a_addr (dest2_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest2_span_a_addr.dest2_span_a_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4508);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest2_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest2_channel_addr_type */
	/* skip, unused field unused_dest2_channel_addr (dest2_channel_addr) */
	REG_DUMP_PRINT_1("   -dest2_channel_addr.dest2_channel_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4504);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest2_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest2_requester_addr_type */
	/* skip, unused field unused_dest2_requester_addr (dest2_requester_addr) */
	REG_DUMP_PRINT_1("   -dest2_requester_addr.dest2_requester_addr                          |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4500);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest2_feed_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest2_feed_addr_type */
	/* skip, unused field unused_dest2_feed_addr (dest2_feed_addr) */
	REG_DUMP_PRINT_1("   -dest2_feed_addr.dest2_feed_addr                                    |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb44e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_dest0_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid2_dest0_cur_cmds_type */
	/* skip, unused field unused_sid2_dest0_cur_cmds (sid2_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid2_dest0_cur_cmds.sid2_dest0_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb44e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_dest0_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid2_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid2_dest0_sync_state.sid2_dest0_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb44dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_dest0_cur_ack_line                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid2_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid2_dest0_cur_ack_line (sid2_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid2_dest0_cur_ack_line.sid2_dest0_cur_ack_line                    |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb44d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_dest0_cur_ack_unit_in_line                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid2_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid2_dest0_cur_ack_unit_in_line (sid2_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid2_dest0_cur_ack_unit_in_line.sid2_dest0_cur_ack_unit_in_line    |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb44d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_dest0_cur_ack_unit                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid2_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid2_dest0_cur_ack_unit (sid2_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid2_dest0_cur_ack_unit.sid2_dest0_cur_ack_unit                    |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb44cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_main_control_state                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid2_main_control_state_type */
	/* skip, unused field unused_sid2_main_control_state (sid2_main_control_state) */
	REG_DUMP_PRINT_1("   -sid2_main_control_state.sid2_main_control_state                    |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb44c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_s2m_cur_ack_line                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid2_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid2_s2m_cur_ack_line (sid2_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid2_s2m_cur_ack_line.sid2_s2m_cur_ack_line                        |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb44c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_s2m_cur_ack_unit_in_line                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid2_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid2_s2m_cur_ack_unit_in_line (sid2_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid2_s2m_cur_ack_unit_in_line.sid2_s2m_cur_ack_unit_in_line        |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb44c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_s2m_cur_cmds                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid2_s2m_cur_cmds_type */
	/* skip, unused field unused_sid2_s2m_cur_cmds (sid2_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid2_s2m_cur_cmds.sid2_s2m_cur_cmds                                |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4498);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_error_reg                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid2_error_reg_type */
	REG_DUMP_PRINT_1("   -sid2_error_reg.sid2_error_reg                                      |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb4488);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_eventque_sidpid                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid2_eventque_sidpid_type */
	/* skip, unused field unused_sid2_eventque_sidpid (sid2_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid2_eventque_sidpid.sid2_eventque_sidpid                          |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb4484);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_ack_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid2_ack_addr_type */
	/* skip, unused field unused_sid2_ack_addr (sid2_ack_addr) */
	REG_DUMP_PRINT_1("   -sid2_ack_addr.sid2_ack_addr                                        |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4468);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_dest0_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid2_dest0_enabled_type */
	/* skip, unused field unused_sid2_dest0_enabled (sid2_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid2_dest0_enabled.sid2_dest0_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 2""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb445c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_first_page_nr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid2_first_page_nr_type */
	/* skip, unused field unused_sid2_first_page_nr (sid2_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid2_first_page_nr.sid2_first_page_nr                              |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb4454);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_units_p_ibuf                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid2_units_p_ibuf_type */
	/* skip, unused field unused_sid2_units_p_ibuf (sid2_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid2_units_p_ibuf.sid2_units_p_ibuf                                |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb4450);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_unit_size                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid2_unit_size_type */
	/* skip, unused field unused_sid2_unit_size (sid2_unit_size) */
	REG_DUMP_PRINT_1("   -sid2_unit_size.sid2_unit_size                                      |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb444c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_lines_p_frame                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid2_lines_p_frame_type */
	/* skip, unused field unused_sid2_lines_p_frame (sid2_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid2_lines_p_frame.sid2_lines_p_frame                              |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb4448);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_units_p_line                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid2_units_p_line_type */
	/* skip, unused field unused_sid2_units_p_line (sid2_units_p_line) */
	REG_DUMP_PRINT_1("   -sid2_units_p_line.sid2_units_p_line                                |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4444);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_str2mmio_store_cmd                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid2_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid2_str2mmio_store_cmd (sid2_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid2_str2mmio_store_cmd.sid2_str2mmio_store_cmd                    |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb4440);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_str2mmio_proc_addr                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid2_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid2_str2mmio_proc_addr (sid2_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid2_str2mmio_proc_addr.sid2_str2mmio_proc_addr                    |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb43cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed1_cur_rcvd_acks                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed1_cur_rcvd_acks_type */
	/* skip, unused field unused_feed1_cur_rcvd_acks (feed1_cur_rcvd_acks) */
	REG_DUMP_PRINT_1("   -feed1_cur_rcvd_acks.feed1_cur_rcvd_acks                            |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb43c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed1_cur_snd_cmds                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed1_cur_snd_cmds_type */
	/* skip, unused field unused_feed1_cur_snd_cmds (feed1_cur_snd_cmds) */
	REG_DUMP_PRINT_1("   -feed1_cur_snd_cmds.feed1_cur_snd_cmds                              |      0x%04X  |  [RO][15:00]""The number of commands send for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb43c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed1_cur_line_in                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed1_cur_line_in_type */
	/* skip, unused field unused_feed1_cur_line_in (feed1_cur_line_in) */
	REG_DUMP_PRINT_1("   -feed1_cur_line_in.feed1_cur_line_in                                |         0x%01X  |  [RO][03:00]""The current number of lines in a 2D block that not have been transferred""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb43c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed1_cur_unit_in_line_in                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed1_cur_unit_in_line_in_type */
	/* skip, unused field unused_feed1_cur_unit_in_line_in (feed1_cur_unit_in_line_in) */
	REG_DUMP_PRINT_1("   -feed1_cur_unit_in_line_in.feed1_cur_unit_in_line_in                |         0x%01X  |  [RO][03:00]""The current number of units from the input in the line of a 2D block""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb43b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed1_sync_feeders                                         |  0x%08X  |  ""The feeder will wait with sending a command to the DMA until all feeders with the same bit set are ready to send a command.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed1_sync_feeders_type */
	/* skip, unused field unused_feed1_sync_feeders (feed1_sync_feeders) */
	REG_DUMP_PRINT_1("   -feed1_sync_feeders.feed_sync_0                                     |         0x%01X  |  [RW][00:00]""Sync with all feeders with bit 0 set""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed1_sync_feeders.feed_sync_1                                     |         0x%01X  |  [RW][01:01]""Sync with all feeders with bit 1 set""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0xb43ac);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed1_wait_order                                           |  0x%08X  |  ""Two feeders, set with the same order unit (bit 1..4), will keep the order in feeding.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed1_wait_order_type */
	/* skip, unused field unused_feed1_wait_order (feed1_wait_order) */
	REG_DUMP_PRINT_1("   -feed1_wait_order.feed_order                                        |         0x%01X  |  [RW][00:00]""0: send as first, 1: send as second""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed1_wait_order.enable_order_0                                    |         0x%01X  |  [RW][01:01]""Enable the order for order unit 0""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -feed1_wait_order.enable_order_1                                    |         0x%01X  |  [RW][02:02]""Enable the order for order unit 1""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -feed1_wait_order.enable_order_2                                    |         0x%01X  |  [RW][03:03]""Enable the order for order unit 2""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -feed1_wait_order.enable_order_3                                    |         0x%01X  |  [RW][04:04]""Enable the order for order unit 3""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xb43a8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed1_wait_on_feeders                                      |  0x%08X  |  ""The feeder will wait for other feeders when the have the bit for the same destination set.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed1_wait_on_feeders_type */
	/* skip, unused field unused_feed1_wait_on_feeders (feed1_wait_on_feeders) */
	REG_DUMP_PRINT_1("   -feed1_wait_on_feeders.feed_dest_0                                  |         0x%01X  |  [RW][00:00]""Wait with feeding for all feeders that are currently feeding a line and have bit 0 set""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed1_wait_on_feeders.feed_dest_1                                  |         0x%01X  |  [RW][01:01]""Wait with feeding for all feeders that are currently feeding a line and have bit 1 set""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -feed1_wait_on_feeders.feed_dest_2                                  |         0x%01X  |  [RW][02:02]""Wait with feeding for all feeders that are currently feeding a line and have bit 2 set""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -feed1_wait_on_feeders.feed_dest_3                                  |         0x%01X  |  [RW][03:03]""Wait with feeding for all feeders that are currently feeding a line and have bit 3 set""\n", FIELD_VALUE(val, 3, 3));
	val = REG_DUMP_READ_REGISTER(0xb43a4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed1_eventque_sidpid                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed1_eventque_sidpid_type */
	/* skip, unused field unused_feed1_eventque_sidpid (feed1_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -feed1_eventque_sidpid.feed1_eventque_sidpid                        |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb43a0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed1_height                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed1_height_type */
	/* skip, unused field unused_feed1_height (feed1_height) */
	REG_DUMP_PRINT_1("   -feed1_height.feed1_height                                          |         0x%01X  |  [RW][03:00]""The number of lines needed for a 2D unit block. A transfer will only begin when receiving cmd number (units_p_line_in * (height - 1)) + 1""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb439c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed1_last_units_out                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed1_last_units_out_type */
	/* skip, unused field unused_feed1_last_units_out (feed1_last_units_out) */
	REG_DUMP_PRINT_1("   -feed1_last_units_out.feed1_last_units_out                          |        0x%02X  |  [RW][06:00]""The last unit number to the DMA for the last unit from the input buffer in a line.""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb4398);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed1_units_out_p_in                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed1_units_out_p_in_type */
	/* skip, unused field unused_feed1_units_out_p_in (feed1_units_out_p_in) */
	REG_DUMP_PRINT_1("   -feed1_units_out_p_in.feed1_units_out_p_in                          |        0x%02X  |  [RW][06:00]""The number of units being transferred by the DMA that fit (width wise) in a unit from the input buffer""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb4394);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed1_units_p_line_in                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed1_units_p_line_in_type */
	/* skip, unused field unused_feed1_units_p_line_in (feed1_units_p_line_in) */
	REG_DUMP_PRINT_1("   -feed1_units_p_line_in.feed1_units_p_line_in                        |         0x%01X  |  [RW][03:00]""The number of units per line at the input buffer""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4390);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed1_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed1_channel_addr_type */
	/* skip, unused field unused_feed1_channel_addr (feed1_channel_addr) */
	REG_DUMP_PRINT_1("   -feed1_channel_addr.feed1_channel_addr                              |  0x%08X  |  [RW][29:00]""The address where the channel in the DMA is located""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb438c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed1_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed1_requester_addr_type */
	/* skip, unused field unused_feed1_requester_addr (feed1_requester_addr) */
	REG_DUMP_PRINT_1("   -feed1_requester_addr.feed1_requester_addr                          |  0x%08X  |  [RW][29:00]""The address where the requester in the DMA is located""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4388);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed1_ack_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed1_ack_addr_type */
	/* skip, unused field unused_feed1_ack_addr (feed1_ack_addr) */
	REG_DUMP_PRINT_1("   -feed1_ack_addr.feed1_ack_addr                                      |  0x%08X  |  [RW][29:00]""The address where the acknowledgement has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4358);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk1_token                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk1_token_type */
	REG_DUMP_PRINT_1("   -fr_chk1_token.fr_chk1_token                                        |  0x%08X  |  [RW][31:00]""The token that has to be written""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb4354);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk1_addr                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk1_addr_type */
	/* skip, unused field unused_fr_chk1_addr (fr_chk1_addr) */
	REG_DUMP_PRINT_1("   -fr_chk1_addr.fr_chk1_addr                                          |  0x%08X  |  [RW][29:00]""The address of where the frame check token has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4350);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk1_trigger_repeat_val                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk1_trigger_repeat_val_type */
	/* skip, unused field unused_fr_chk1_trigger_repeat_val (fr_chk1_trigger_repeat_val) */
	REG_DUMP_PRINT_1("   -fr_chk1_trigger_repeat_val.fr_chk1_trigger_repeat_val              |      0x%04X  |  [RW][15:00]""An frame check token is send after each trigger_repeat_val value in case the repetitive enable bit in the check mode is set and the trigger offset has been reached.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb434c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk1_trigger_offset                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk1_trigger_offset_type */
	/* skip, unused field unused_fr_chk1_trigger_offset (fr_chk1_trigger_offset) */
	REG_DUMP_PRINT_1("   -fr_chk1_trigger_offset.fr_chk1_trigger_offset                      |      0x%04X  |  [RW][15:00]""The value of the trigger, when the checked value becomes larger than the this value a frame check token is send""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4348);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk1_sid_proc_id                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk1_sid_proc_id_type */
	/* skip, unused field unused_fr_chk1_sid_proc_id (fr_chk1_sid_proc_id) */
	REG_DUMP_PRINT_1("   -fr_chk1_sid_proc_id.fr_chk1_sid_proc_id                            |         0x%01X  |  [RW][03:00]""The ID of the SID proc that has to be checked""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4344);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk1_check_mode                                         |  0x%08X  |  ""The mode of frame checking""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk1_check_mode_type */
	/* skip, unused field unused_fr_chk1_check_mode (fr_chk1_check_mode) */
	REG_DUMP_PRINT_1("   -fr_chk1_check_mode.check_type                                      |         0x%01X  |  [RW][00:00]""The type of value to be checking, 0: check lines; 1: check units;""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -fr_chk1_check_mode.repetive_enable                                 |         0x%01X  |  [RW][01:01]""Trigger and send and token after each repetitive value after the trigger offset is reached""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0xb4340);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk1_enable                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk1_enable_type */
	/* skip, unused field unused_fr_chk1_enable (fr_chk1_enable) */
	REG_DUMP_PRINT_1("   -fr_chk1_enable.fr_chk1_enable                                      |         0x%01X  |  [RW][00:00]""Enable frame checking for this frame check unit""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb4324);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest1_iwake_threshold                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest1_iwake_threshold_type */
	/* skip, unused field unused_dest1_iwake_threshold (dest1_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest1_iwake_threshold.dest1_iwake_threshold                        |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb431c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest1_st_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest1_st_addr_type */
	REG_DUMP_PRINT_1("   -dest1_st_addr.dest1_st_addr                                        |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb4318);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest1_dest_mode                                            |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest1_dest_mode_type */
	/* skip, unused field unused_dest1_dest_mode (dest1_dest_mode) */
	REG_DUMP_PRINT_1("   -dest1_dest_mode.is_ibuf_cntrl_feeder                               |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest1_dest_mode.config_dma                                         |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest1_dest_mode.iwake_enable                                       |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest1_dest_mode.disable_spana_rst                                  |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest1_dest_mode.disable_spanb_rst                                  |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xb4314);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest1_term_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest1_term_b_addr_type */
	/* skip, unused field unused_dest1_term_b_addr (dest1_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest1_term_b_addr.dest1_term_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4310);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest1_span_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest1_span_b_addr_type */
	/* skip, unused field unused_dest1_span_b_addr (dest1_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest1_span_b_addr.dest1_span_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb430c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest1_span_a_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest1_span_a_addr_type */
	/* skip, unused field unused_dest1_span_a_addr (dest1_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest1_span_a_addr.dest1_span_a_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4308);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest1_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest1_channel_addr_type */
	/* skip, unused field unused_dest1_channel_addr (dest1_channel_addr) */
	REG_DUMP_PRINT_1("   -dest1_channel_addr.dest1_channel_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4304);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest1_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest1_requester_addr_type */
	/* skip, unused field unused_dest1_requester_addr (dest1_requester_addr) */
	REG_DUMP_PRINT_1("   -dest1_requester_addr.dest1_requester_addr                          |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4300);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest1_feed_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest1_feed_addr_type */
	/* skip, unused field unused_dest1_feed_addr (dest1_feed_addr) */
	REG_DUMP_PRINT_1("   -dest1_feed_addr.dest1_feed_addr                                    |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb42e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_dest0_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid1_dest0_cur_cmds_type */
	/* skip, unused field unused_sid1_dest0_cur_cmds (sid1_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid1_dest0_cur_cmds.sid1_dest0_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb42e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_dest0_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid1_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid1_dest0_sync_state.sid1_dest0_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb42dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_dest0_cur_ack_line                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid1_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid1_dest0_cur_ack_line (sid1_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid1_dest0_cur_ack_line.sid1_dest0_cur_ack_line                    |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb42d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_dest0_cur_ack_unit_in_line                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid1_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid1_dest0_cur_ack_unit_in_line (sid1_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid1_dest0_cur_ack_unit_in_line.sid1_dest0_cur_ack_unit_in_line    |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb42d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_dest0_cur_ack_unit                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid1_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid1_dest0_cur_ack_unit (sid1_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid1_dest0_cur_ack_unit.sid1_dest0_cur_ack_unit                    |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb42cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_main_control_state                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid1_main_control_state_type */
	/* skip, unused field unused_sid1_main_control_state (sid1_main_control_state) */
	REG_DUMP_PRINT_1("   -sid1_main_control_state.sid1_main_control_state                    |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb42c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_s2m_cur_ack_line                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid1_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid1_s2m_cur_ack_line (sid1_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid1_s2m_cur_ack_line.sid1_s2m_cur_ack_line                        |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb42c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_s2m_cur_ack_unit_in_line                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid1_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid1_s2m_cur_ack_unit_in_line (sid1_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid1_s2m_cur_ack_unit_in_line.sid1_s2m_cur_ack_unit_in_line        |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb42c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_s2m_cur_cmds                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid1_s2m_cur_cmds_type */
	/* skip, unused field unused_sid1_s2m_cur_cmds (sid1_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid1_s2m_cur_cmds.sid1_s2m_cur_cmds                                |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4298);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_error_reg                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid1_error_reg_type */
	REG_DUMP_PRINT_1("   -sid1_error_reg.sid1_error_reg                                      |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb4288);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_eventque_sidpid                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid1_eventque_sidpid_type */
	/* skip, unused field unused_sid1_eventque_sidpid (sid1_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid1_eventque_sidpid.sid1_eventque_sidpid                          |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb4284);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_ack_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid1_ack_addr_type */
	/* skip, unused field unused_sid1_ack_addr (sid1_ack_addr) */
	REG_DUMP_PRINT_1("   -sid1_ack_addr.sid1_ack_addr                                        |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4268);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_dest0_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid1_dest0_enabled_type */
	/* skip, unused field unused_sid1_dest0_enabled (sid1_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid1_dest0_enabled.sid1_dest0_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 1""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb4264);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_s2v_n_vec_p_unit                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid1_s2v_n_vec_p_unit_type */
	/* skip, unused field unused_sid1_s2v_n_vec_p_unit (sid1_s2v_n_vec_p_unit) */
	REG_DUMP_PRINT_1("   -sid1_s2v_n_vec_p_unit.sid1_s2v_n_vec_p_unit                        |        0x%02X  |  [RW][07:00]""The number of vectors that have to be requested per unit when a Str2Vec is used instead of a Str2MMIO""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb4260);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_s2v_not_str2mmio                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid1_s2v_not_str2mmio_type */
	/* skip, unused field unused_sid1_s2v_not_str2mmio (sid1_s2v_not_str2mmio) */
	REG_DUMP_PRINT_1("   -sid1_s2v_not_str2mmio.sid1_s2v_not_str2mmio                        |         0x%01X  |  [RW][00:00]""The IBufCntrl should communicate with a Str2Vec instead of a Str2MMIO when set.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb425c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_first_page_nr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid1_first_page_nr_type */
	/* skip, unused field unused_sid1_first_page_nr (sid1_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid1_first_page_nr.sid1_first_page_nr                              |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb4254);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_units_p_ibuf                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid1_units_p_ibuf_type */
	/* skip, unused field unused_sid1_units_p_ibuf (sid1_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid1_units_p_ibuf.sid1_units_p_ibuf                                |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb4250);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_unit_size                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid1_unit_size_type */
	/* skip, unused field unused_sid1_unit_size (sid1_unit_size) */
	REG_DUMP_PRINT_1("   -sid1_unit_size.sid1_unit_size                                      |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb424c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_lines_p_frame                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid1_lines_p_frame_type */
	/* skip, unused field unused_sid1_lines_p_frame (sid1_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid1_lines_p_frame.sid1_lines_p_frame                              |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb4248);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_units_p_line                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid1_units_p_line_type */
	/* skip, unused field unused_sid1_units_p_line (sid1_units_p_line) */
	REG_DUMP_PRINT_1("   -sid1_units_p_line.sid1_units_p_line                                |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4244);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_str2mmio_store_cmd                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid1_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid1_str2mmio_store_cmd (sid1_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid1_str2mmio_store_cmd.sid1_str2mmio_store_cmd                    |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb4240);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_str2mmio_proc_addr                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid1_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid1_str2mmio_proc_addr (sid1_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid1_str2mmio_proc_addr.sid1_str2mmio_proc_addr                    |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb41cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed0_cur_rcvd_acks                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed0_cur_rcvd_acks_type */
	/* skip, unused field unused_feed0_cur_rcvd_acks (feed0_cur_rcvd_acks) */
	REG_DUMP_PRINT_1("   -feed0_cur_rcvd_acks.feed0_cur_rcvd_acks                            |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb41c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed0_cur_snd_cmds                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed0_cur_snd_cmds_type */
	/* skip, unused field unused_feed0_cur_snd_cmds (feed0_cur_snd_cmds) */
	REG_DUMP_PRINT_1("   -feed0_cur_snd_cmds.feed0_cur_snd_cmds                              |      0x%04X  |  [RO][15:00]""The number of commands send for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb41c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed0_cur_line_in                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed0_cur_line_in_type */
	/* skip, unused field unused_feed0_cur_line_in (feed0_cur_line_in) */
	REG_DUMP_PRINT_1("   -feed0_cur_line_in.feed0_cur_line_in                                |         0x%01X  |  [RO][03:00]""The current number of lines in a 2D block that not have been transferred""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb41c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed0_cur_unit_in_line_in                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed0_cur_unit_in_line_in_type */
	/* skip, unused field unused_feed0_cur_unit_in_line_in (feed0_cur_unit_in_line_in) */
	REG_DUMP_PRINT_1("   -feed0_cur_unit_in_line_in.feed0_cur_unit_in_line_in                |         0x%01X  |  [RO][03:00]""The current number of units from the input in the line of a 2D block""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb41b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed0_sync_feeders                                         |  0x%08X  |  ""The feeder will wait with sending a command to the DMA until all feeders with the same bit set are ready to send a command.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed0_sync_feeders_type */
	/* skip, unused field unused_feed0_sync_feeders (feed0_sync_feeders) */
	REG_DUMP_PRINT_1("   -feed0_sync_feeders.feed_sync_0                                     |         0x%01X  |  [RW][00:00]""Sync with all feeders with bit 0 set""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed0_sync_feeders.feed_sync_1                                     |         0x%01X  |  [RW][01:01]""Sync with all feeders with bit 1 set""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0xb41ac);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed0_wait_order                                           |  0x%08X  |  ""Two feeders, set with the same order unit (bit 1..4), will keep the order in feeding.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed0_wait_order_type */
	/* skip, unused field unused_feed0_wait_order (feed0_wait_order) */
	REG_DUMP_PRINT_1("   -feed0_wait_order.feed_order                                        |         0x%01X  |  [RW][00:00]""0: send as first, 1: send as second""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed0_wait_order.enable_order_0                                    |         0x%01X  |  [RW][01:01]""Enable the order for order unit 0""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -feed0_wait_order.enable_order_1                                    |         0x%01X  |  [RW][02:02]""Enable the order for order unit 1""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -feed0_wait_order.enable_order_2                                    |         0x%01X  |  [RW][03:03]""Enable the order for order unit 2""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -feed0_wait_order.enable_order_3                                    |         0x%01X  |  [RW][04:04]""Enable the order for order unit 3""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xb41a8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed0_wait_on_feeders                                      |  0x%08X  |  ""The feeder will wait for other feeders when the have the bit for the same destination set.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed0_wait_on_feeders_type */
	/* skip, unused field unused_feed0_wait_on_feeders (feed0_wait_on_feeders) */
	REG_DUMP_PRINT_1("   -feed0_wait_on_feeders.feed_dest_0                                  |         0x%01X  |  [RW][00:00]""Wait with feeding for all feeders that are currently feeding a line and have bit 0 set""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -feed0_wait_on_feeders.feed_dest_1                                  |         0x%01X  |  [RW][01:01]""Wait with feeding for all feeders that are currently feeding a line and have bit 1 set""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -feed0_wait_on_feeders.feed_dest_2                                  |         0x%01X  |  [RW][02:02]""Wait with feeding for all feeders that are currently feeding a line and have bit 2 set""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -feed0_wait_on_feeders.feed_dest_3                                  |         0x%01X  |  [RW][03:03]""Wait with feeding for all feeders that are currently feeding a line and have bit 3 set""\n", FIELD_VALUE(val, 3, 3));
	val = REG_DUMP_READ_REGISTER(0xb41a4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed0_eventque_sidpid                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed0_eventque_sidpid_type */
	/* skip, unused field unused_feed0_eventque_sidpid (feed0_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -feed0_eventque_sidpid.feed0_eventque_sidpid                        |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb41a0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed0_height                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed0_height_type */
	/* skip, unused field unused_feed0_height (feed0_height) */
	REG_DUMP_PRINT_1("   -feed0_height.feed0_height                                          |         0x%01X  |  [RW][03:00]""The number of lines needed for a 2D unit block. A transfer will only begin when receiving cmd number (units_p_line_in * (height - 1)) + 1""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb419c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed0_last_units_out                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed0_last_units_out_type */
	/* skip, unused field unused_feed0_last_units_out (feed0_last_units_out) */
	REG_DUMP_PRINT_1("   -feed0_last_units_out.feed0_last_units_out                          |        0x%02X  |  [RW][06:00]""The last unit number to the DMA for the last unit from the input buffer in a line.""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb4198);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed0_units_out_p_in                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed0_units_out_p_in_type */
	/* skip, unused field unused_feed0_units_out_p_in (feed0_units_out_p_in) */
	REG_DUMP_PRINT_1("   -feed0_units_out_p_in.feed0_units_out_p_in                          |        0x%02X  |  [RW][06:00]""The number of units being transferred by the DMA that fit (width wise) in a unit from the input buffer""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb4194);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed0_units_p_line_in                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed0_units_p_line_in_type */
	/* skip, unused field unused_feed0_units_p_line_in (feed0_units_p_line_in) */
	REG_DUMP_PRINT_1("   -feed0_units_p_line_in.feed0_units_p_line_in                        |         0x%01X  |  [RW][03:00]""The number of units per line at the input buffer""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4190);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed0_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed0_channel_addr_type */
	/* skip, unused field unused_feed0_channel_addr (feed0_channel_addr) */
	REG_DUMP_PRINT_1("   -feed0_channel_addr.feed0_channel_addr                              |  0x%08X  |  [RW][29:00]""The address where the channel in the DMA is located""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb418c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed0_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed0_requester_addr_type */
	/* skip, unused field unused_feed0_requester_addr (feed0_requester_addr) */
	REG_DUMP_PRINT_1("   -feed0_requester_addr.feed0_requester_addr                          |  0x%08X  |  [RW][29:00]""The address where the requester in the DMA is located""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4188);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.feed0_ack_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_feed0_ack_addr_type */
	/* skip, unused field unused_feed0_ack_addr (feed0_ack_addr) */
	REG_DUMP_PRINT_1("   -feed0_ack_addr.feed0_ack_addr                                      |  0x%08X  |  [RW][29:00]""The address where the acknowledgement has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4158);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk0_token                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk0_token_type */
	REG_DUMP_PRINT_1("   -fr_chk0_token.fr_chk0_token                                        |  0x%08X  |  [RW][31:00]""The token that has to be written""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb4154);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk0_addr                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk0_addr_type */
	/* skip, unused field unused_fr_chk0_addr (fr_chk0_addr) */
	REG_DUMP_PRINT_1("   -fr_chk0_addr.fr_chk0_addr                                          |  0x%08X  |  [RW][29:00]""The address of where the frame check token has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4150);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk0_trigger_repeat_val                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk0_trigger_repeat_val_type */
	/* skip, unused field unused_fr_chk0_trigger_repeat_val (fr_chk0_trigger_repeat_val) */
	REG_DUMP_PRINT_1("   -fr_chk0_trigger_repeat_val.fr_chk0_trigger_repeat_val              |      0x%04X  |  [RW][15:00]""An frame check token is send after each trigger_repeat_val value in case the repetitive enable bit in the check mode is set and the trigger offset has been reached.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb414c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk0_trigger_offset                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk0_trigger_offset_type */
	/* skip, unused field unused_fr_chk0_trigger_offset (fr_chk0_trigger_offset) */
	REG_DUMP_PRINT_1("   -fr_chk0_trigger_offset.fr_chk0_trigger_offset                      |      0x%04X  |  [RW][15:00]""The value of the trigger, when the checked value becomes larger than the this value a frame check token is send""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4148);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk0_sid_proc_id                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk0_sid_proc_id_type */
	/* skip, unused field unused_fr_chk0_sid_proc_id (fr_chk0_sid_proc_id) */
	REG_DUMP_PRINT_1("   -fr_chk0_sid_proc_id.fr_chk0_sid_proc_id                            |         0x%01X  |  [RW][03:00]""The ID of the SID proc that has to be checked""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4144);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk0_check_mode                                         |  0x%08X  |  ""The mode of frame checking""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk0_check_mode_type */
	/* skip, unused field unused_fr_chk0_check_mode (fr_chk0_check_mode) */
	REG_DUMP_PRINT_1("   -fr_chk0_check_mode.check_type                                      |         0x%01X  |  [RW][00:00]""The type of value to be checking, 0: check lines; 1: check units;""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -fr_chk0_check_mode.repetive_enable                                 |         0x%01X  |  [RW][01:01]""Trigger and send and token after each repetitive value after the trigger offset is reached""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0xb4140);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk0_enable                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_fr_chk0_enable_type */
	/* skip, unused field unused_fr_chk0_enable (fr_chk0_enable) */
	REG_DUMP_PRINT_1("   -fr_chk0_enable.fr_chk0_enable                                      |         0x%01X  |  [RW][00:00]""Enable frame checking for this frame check unit""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb4124);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest0_iwake_threshold                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest0_iwake_threshold_type */
	/* skip, unused field unused_dest0_iwake_threshold (dest0_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest0_iwake_threshold.dest0_iwake_threshold                        |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0xb411c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest0_st_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest0_st_addr_type */
	REG_DUMP_PRINT_1("   -dest0_st_addr.dest0_st_addr                                        |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb4118);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest0_dest_mode                                            |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest0_dest_mode_type */
	/* skip, unused field unused_dest0_dest_mode (dest0_dest_mode) */
	REG_DUMP_PRINT_1("   -dest0_dest_mode.is_ibuf_cntrl_feeder                               |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest0_dest_mode.config_dma                                         |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest0_dest_mode.iwake_enable                                       |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest0_dest_mode.disable_spana_rst                                  |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest0_dest_mode.disable_spanb_rst                                  |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0xb4114);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest0_term_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest0_term_b_addr_type */
	/* skip, unused field unused_dest0_term_b_addr (dest0_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest0_term_b_addr.dest0_term_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4110);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest0_span_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest0_span_b_addr_type */
	/* skip, unused field unused_dest0_span_b_addr (dest0_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest0_span_b_addr.dest0_span_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb410c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest0_span_a_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest0_span_a_addr_type */
	/* skip, unused field unused_dest0_span_a_addr (dest0_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest0_span_a_addr.dest0_span_a_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4108);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest0_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest0_channel_addr_type */
	/* skip, unused field unused_dest0_channel_addr (dest0_channel_addr) */
	REG_DUMP_PRINT_1("   -dest0_channel_addr.dest0_channel_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4104);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest0_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest0_requester_addr_type */
	/* skip, unused field unused_dest0_requester_addr (dest0_requester_addr) */
	REG_DUMP_PRINT_1("   -dest0_requester_addr.dest0_requester_addr                          |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4100);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest0_feed_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_dest0_feed_addr_type */
	/* skip, unused field unused_dest0_feed_addr (dest0_feed_addr) */
	REG_DUMP_PRINT_1("   -dest0_feed_addr.dest0_feed_addr                                    |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb40e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_dest0_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid0_dest0_cur_cmds_type */
	/* skip, unused field unused_sid0_dest0_cur_cmds (sid0_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid0_dest0_cur_cmds.sid0_dest0_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb40e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_dest0_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid0_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid0_dest0_sync_state.sid0_dest0_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb40dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_dest0_cur_ack_line                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid0_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid0_dest0_cur_ack_line (sid0_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid0_dest0_cur_ack_line.sid0_dest0_cur_ack_line                    |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb40d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_dest0_cur_ack_unit_in_line                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid0_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid0_dest0_cur_ack_unit_in_line (sid0_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid0_dest0_cur_ack_unit_in_line.sid0_dest0_cur_ack_unit_in_line    |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb40d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_dest0_cur_ack_unit                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid0_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid0_dest0_cur_ack_unit (sid0_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid0_dest0_cur_ack_unit.sid0_dest0_cur_ack_unit                    |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb40cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_main_control_state                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid0_main_control_state_type */
	/* skip, unused field unused_sid0_main_control_state (sid0_main_control_state) */
	REG_DUMP_PRINT_1("   -sid0_main_control_state.sid0_main_control_state                    |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb40c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_s2m_cur_ack_line                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid0_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid0_s2m_cur_ack_line (sid0_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid0_s2m_cur_ack_line.sid0_s2m_cur_ack_line                        |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb40c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_s2m_cur_ack_unit_in_line                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid0_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid0_s2m_cur_ack_unit_in_line (sid0_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid0_s2m_cur_ack_unit_in_line.sid0_s2m_cur_ack_unit_in_line        |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb40c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_s2m_cur_cmds                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid0_s2m_cur_cmds_type */
	/* skip, unused field unused_sid0_s2m_cur_cmds (sid0_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid0_s2m_cur_cmds.sid0_s2m_cur_cmds                                |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4098);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_error_reg                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid0_error_reg_type */
	REG_DUMP_PRINT_1("   -sid0_error_reg.sid0_error_reg                                      |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0xb4088);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_eventque_sidpid                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid0_eventque_sidpid_type */
	/* skip, unused field unused_sid0_eventque_sidpid (sid0_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid0_eventque_sidpid.sid0_eventque_sidpid                          |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb4084);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_ack_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid0_ack_addr_type */
	/* skip, unused field unused_sid0_ack_addr (sid0_ack_addr) */
	REG_DUMP_PRINT_1("   -sid0_ack_addr.sid0_ack_addr                                        |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4068);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_dest0_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid0_dest0_enabled_type */
	/* skip, unused field unused_sid0_dest0_enabled (sid0_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid0_dest0_enabled.sid0_dest0_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 0""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb4064);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_s2v_n_vec_p_unit                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid0_s2v_n_vec_p_unit_type */
	/* skip, unused field unused_sid0_s2v_n_vec_p_unit (sid0_s2v_n_vec_p_unit) */
	REG_DUMP_PRINT_1("   -sid0_s2v_n_vec_p_unit.sid0_s2v_n_vec_p_unit                        |        0x%02X  |  [RW][07:00]""The number of vectors that have to be requested per unit when a Str2Vec is used instead of a Str2MMIO""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0xb4060);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_s2v_not_str2mmio                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid0_s2v_not_str2mmio_type */
	/* skip, unused field unused_sid0_s2v_not_str2mmio (sid0_s2v_not_str2mmio) */
	REG_DUMP_PRINT_1("   -sid0_s2v_not_str2mmio.sid0_s2v_not_str2mmio                        |         0x%01X  |  [RW][00:00]""The IBufCntrl should communicate with a Str2Vec instead of a Str2MMIO when set.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb405c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_first_page_nr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid0_first_page_nr_type */
	/* skip, unused field unused_sid0_first_page_nr (sid0_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid0_first_page_nr.sid0_first_page_nr                              |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0xb4054);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_units_p_ibuf                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid0_units_p_ibuf_type */
	/* skip, unused field unused_sid0_units_p_ibuf (sid0_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid0_units_p_ibuf.sid0_units_p_ibuf                                |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0xb4050);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_unit_size                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid0_unit_size_type */
	/* skip, unused field unused_sid0_unit_size (sid0_unit_size) */
	REG_DUMP_PRINT_1("   -sid0_unit_size.sid0_unit_size                                      |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0xb404c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_lines_p_frame                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid0_lines_p_frame_type */
	/* skip, unused field unused_sid0_lines_p_frame (sid0_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid0_lines_p_frame.sid0_lines_p_frame                              |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0xb4048);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_units_p_line                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid0_units_p_line_type */
	/* skip, unused field unused_sid0_units_p_line (sid0_units_p_line) */
	REG_DUMP_PRINT_1("   -sid0_units_p_line.sid0_units_p_line                                |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0xb4044);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_str2mmio_store_cmd                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid0_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid0_str2mmio_store_cmd (sid0_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid0_str2mmio_store_cmd.sid0_str2mmio_store_cmd                    |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb4040);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_str2mmio_proc_addr                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_sid0_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid0_str2mmio_proc_addr (sid0_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid0_str2mmio_proc_addr.sid0_str2mmio_proc_addr                    |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4028);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.enable_clk_gate                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_enable_clk_gate_type */
	/* skip, unused field unused_enable_clk_gate (enable_clk_gate) */
	REG_DUMP_PRINT_1("   -enable_clk_gate.enable_clk_gate                                    |         0x%01X  |  [RW][00:00]""Enable the automatic clockgating in the IBufCntrl to save power""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb4024);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.gda_address                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_gda_address_type */
	/* skip, unused field unused_gda_address (gda_address) */
	REG_DUMP_PRINT_1("   -gda_address.gda_address                                            |  0x%08X  |  [RW][29:00]""The address of the GDA, this is a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0xb4020);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.gda_enable                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_gda_enable_type */
	/* skip, unused field unused_gda_enable (gda_enable) */
	REG_DUMP_PRINT_1("   -gda_enable.gda_enable                                              |         0x%01X  |  [RW][00:00]""Enable the GDA functionality in the IBufCntrl. Pages will be de-allocated in the GDA when possible.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xb401c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.secure_touch_handling                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_secure_touch_handling_type */
	/* skip, unused field unused_secure_touch_handling (secure_touch_handling) */
	REG_DUMP_PRINT_1("   -secure_touch_handling.secure_touch_handling                        |         0x%01X  |  [RW][01:00]""The mode of how the commands are being handled when secure touch is enabled for a SID processor. 0: fetch next command and process normally; 1: fetch next command and ACK immediatly without processing; 2: wait for fetching the next command until secure touch is disabled""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0xb4018);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.error_irq_en                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_error_irq_en_type */
	/* skip, unused field unused_error_irq_en (error_irq_en) */
	REG_DUMP_PRINT_1("   -error_irq_en.error_irq_en                                          |      0x%04X  |  [RW][15:00]""This register specifies for which SID processor the irq is enabled""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4014);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.error_reg_set                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_error_reg_set_type */
	/* skip, unused field unused_error_reg_set (error_reg_set) */
	REG_DUMP_PRINT_1("   -error_reg_set.error_reg_set                                        |      0x%04X  |  [RO][15:00]""This register specifies which SID processor raised an interrupt and set its error register; the error register of SID x is set when bit x is set""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0xb4010);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.arbiter_status                                             |  0x%08X  |  ""The status of the arbiter in the IBufCntrl. Bit set to one means that part has access.""\n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_arbiter_status_type */
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_0                                          |         0x%01X  |  [RO][00:00]""SID proc 0 requires access""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_1                                          |         0x%01X  |  [RO][01:01]""SID proc 1 requires access""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_2                                          |         0x%01X  |  [RO][02:02]""SID proc 2 requires access""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_3                                          |         0x%01X  |  [RO][03:03]""SID proc 3 requires access""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_4                                          |         0x%01X  |  [RO][04:04]""SID proc 4 requires access""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_5                                          |         0x%01X  |  [RO][05:05]""SID proc 5 requires access""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_6                                          |         0x%01X  |  [RO][06:06]""SID proc 6 requires access""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_7                                          |         0x%01X  |  [RO][07:07]""SID proc 7 requires access""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_8                                          |         0x%01X  |  [RO][08:08]""SID proc 8 requires access""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_9                                          |         0x%01X  |  [RO][09:09]""SID proc 9 requires access""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_10                                         |         0x%01X  |  [RO][10:10]""SID proc 10 requires access""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_11                                         |         0x%01X  |  [RO][11:11]""SID proc 11 requires access""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_12                                         |         0x%01X  |  [RO][12:12]""SID proc 12 requires access""\n", FIELD_VALUE(val, 12, 12));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_13                                         |         0x%01X  |  [RO][13:13]""SID proc 13 requires access""\n", FIELD_VALUE(val, 13, 13));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_14                                         |         0x%01X  |  [RO][14:14]""SID proc 14 requires access""\n", FIELD_VALUE(val, 14, 14));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_15                                         |         0x%01X  |  [RO][15:15]""SID proc 15 requires access""\n", FIELD_VALUE(val, 15, 15));
	REG_DUMP_PRINT_1("   -arbiter_status.feeder_0                                            |         0x%01X  |  [RO][16:16]""Feeder 0 requires access""\n", FIELD_VALUE(val, 16, 16));
	REG_DUMP_PRINT_1("   -arbiter_status.feeder_1                                            |         0x%01X  |  [RO][17:17]""Feeder 1 requires access""\n", FIELD_VALUE(val, 17, 17));
	REG_DUMP_PRINT_1("   -arbiter_status.feeder_2                                            |         0x%01X  |  [RO][18:18]""Feeder 2 requires access""\n", FIELD_VALUE(val, 18, 18));
	REG_DUMP_PRINT_1("   -arbiter_status.feeder_3                                            |         0x%01X  |  [RO][19:19]""Feeder 3 requires access""\n", FIELD_VALUE(val, 19, 19));
	REG_DUMP_PRINT_1("   -arbiter_status.feeder_4                                            |         0x%01X  |  [RO][20:20]""Feeder 4 requires access""\n", FIELD_VALUE(val, 20, 20));
	REG_DUMP_PRINT_1("   -arbiter_status.feeder_5                                            |         0x%01X  |  [RO][21:21]""Feeder 5 requires access""\n", FIELD_VALUE(val, 21, 21));
	REG_DUMP_PRINT_1("   -arbiter_status.feeder_6                                            |         0x%01X  |  [RO][22:22]""Feeder 6 requires access""\n", FIELD_VALUE(val, 22, 22));
	REG_DUMP_PRINT_1("   -arbiter_status.feeder_7                                            |         0x%01X  |  [RO][23:23]""Feeder 7 requires access""\n", FIELD_VALUE(val, 23, 23));
	REG_DUMP_PRINT_1("   -arbiter_status.feeder_8                                            |         0x%01X  |  [RO][24:24]""Feeder 8 requires access""\n", FIELD_VALUE(val, 24, 24));
	REG_DUMP_PRINT_1("   -arbiter_status.feeder_9                                            |         0x%01X  |  [RO][25:25]""Feeder 9 requires access""\n", FIELD_VALUE(val, 25, 25));
	REG_DUMP_PRINT_1("   -arbiter_status.feeder_10                                           |         0x%01X  |  [RO][26:26]""Feeder 10 requires access""\n", FIELD_VALUE(val, 26, 26));
	REG_DUMP_PRINT_1("   -arbiter_status.feeder_11                                           |         0x%01X  |  [RO][27:27]""Feeder 11 requires access""\n", FIELD_VALUE(val, 27, 27));
	REG_DUMP_PRINT_1("   -arbiter_status.feeder_12                                           |         0x%01X  |  [RO][28:28]""Feeder 12 requires access""\n", FIELD_VALUE(val, 28, 28));
	REG_DUMP_PRINT_1("   -arbiter_status.feeder_13                                           |         0x%01X  |  [RO][29:29]""Feeder 13 requires access""\n", FIELD_VALUE(val, 29, 29));
	REG_DUMP_PRINT_1("   -arbiter_status.power_management                                    |         0x%01X  |  [RO][30:30]""Power management block requires access""\n", FIELD_VALUE(val, 30, 30));
	REG_DUMP_PRINT_1("   -arbiter_status.frame_monitor                                       |         0x%01X  |  [RO][31:31]""Frame monitor block requires access""\n", FIELD_VALUE(val, 31, 31));
	val = REG_DUMP_READ_REGISTER(0xb4004);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.iwake_addr                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_is_a_logic_ibuf_ctrl_iwake_addr_type */
	/* skip, unused field unused_iwake_addr (iwake_addr) */
	REG_DUMP_PRINT_1("   -iwake_addr.iwake_addr                                              |  0x%08X  |  [RW][29:00]""The address of where the Iwake and Idone have to be written to. Internally is made sure that all SID procs are done before sending an Idone""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6af24);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest23_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest23_iwake_threshold_type */
	/* skip, unused field unused_dest23_iwake_threshold (dest23_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest23_iwake_threshold.dest23_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6af1c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest23_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest23_st_addr_type */
	REG_DUMP_PRINT_1("   -dest23_st_addr.dest23_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x6af18);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest23_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest23_dest_mode_type */
	/* skip, unused field unused_dest23_dest_mode (dest23_dest_mode) */
	REG_DUMP_PRINT_1("   -dest23_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest23_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest23_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest23_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest23_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x6af14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest23_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest23_term_b_addr_type */
	/* skip, unused field unused_dest23_term_b_addr (dest23_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest23_term_b_addr.dest23_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6af10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest23_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest23_span_b_addr_type */
	/* skip, unused field unused_dest23_span_b_addr (dest23_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest23_span_b_addr.dest23_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6af0c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest23_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest23_span_a_addr_type */
	/* skip, unused field unused_dest23_span_a_addr (dest23_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest23_span_a_addr.dest23_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6af08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest23_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest23_channel_addr_type */
	/* skip, unused field unused_dest23_channel_addr (dest23_channel_addr) */
	REG_DUMP_PRINT_1("   -dest23_channel_addr.dest23_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6af04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest23_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest23_requester_addr_type */
	/* skip, unused field unused_dest23_requester_addr (dest23_requester_addr) */
	REG_DUMP_PRINT_1("   -dest23_requester_addr.dest23_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6af00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest23_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest23_feed_addr_type */
	/* skip, unused field unused_dest23_feed_addr (dest23_feed_addr) */
	REG_DUMP_PRINT_1("   -dest23_feed_addr.dest23_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6ad24);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest22_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest22_iwake_threshold_type */
	/* skip, unused field unused_dest22_iwake_threshold (dest22_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest22_iwake_threshold.dest22_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6ad1c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest22_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest22_st_addr_type */
	REG_DUMP_PRINT_1("   -dest22_st_addr.dest22_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x6ad18);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest22_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest22_dest_mode_type */
	/* skip, unused field unused_dest22_dest_mode (dest22_dest_mode) */
	REG_DUMP_PRINT_1("   -dest22_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest22_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest22_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest22_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest22_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x6ad14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest22_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest22_term_b_addr_type */
	/* skip, unused field unused_dest22_term_b_addr (dest22_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest22_term_b_addr.dest22_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6ad10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest22_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest22_span_b_addr_type */
	/* skip, unused field unused_dest22_span_b_addr (dest22_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest22_span_b_addr.dest22_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6ad0c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest22_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest22_span_a_addr_type */
	/* skip, unused field unused_dest22_span_a_addr (dest22_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest22_span_a_addr.dest22_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6ad08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest22_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest22_channel_addr_type */
	/* skip, unused field unused_dest22_channel_addr (dest22_channel_addr) */
	REG_DUMP_PRINT_1("   -dest22_channel_addr.dest22_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6ad04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest22_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest22_requester_addr_type */
	/* skip, unused field unused_dest22_requester_addr (dest22_requester_addr) */
	REG_DUMP_PRINT_1("   -dest22_requester_addr.dest22_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6ad00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest22_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest22_feed_addr_type */
	/* skip, unused field unused_dest22_feed_addr (dest22_feed_addr) */
	REG_DUMP_PRINT_1("   -dest22_feed_addr.dest22_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6ab24);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest21_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest21_iwake_threshold_type */
	/* skip, unused field unused_dest21_iwake_threshold (dest21_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest21_iwake_threshold.dest21_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6ab1c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest21_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest21_st_addr_type */
	REG_DUMP_PRINT_1("   -dest21_st_addr.dest21_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x6ab18);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest21_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest21_dest_mode_type */
	/* skip, unused field unused_dest21_dest_mode (dest21_dest_mode) */
	REG_DUMP_PRINT_1("   -dest21_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest21_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest21_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest21_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest21_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x6ab14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest21_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest21_term_b_addr_type */
	/* skip, unused field unused_dest21_term_b_addr (dest21_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest21_term_b_addr.dest21_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6ab10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest21_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest21_span_b_addr_type */
	/* skip, unused field unused_dest21_span_b_addr (dest21_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest21_span_b_addr.dest21_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6ab0c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest21_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest21_span_a_addr_type */
	/* skip, unused field unused_dest21_span_a_addr (dest21_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest21_span_a_addr.dest21_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6ab08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest21_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest21_channel_addr_type */
	/* skip, unused field unused_dest21_channel_addr (dest21_channel_addr) */
	REG_DUMP_PRINT_1("   -dest21_channel_addr.dest21_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6ab04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest21_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest21_requester_addr_type */
	/* skip, unused field unused_dest21_requester_addr (dest21_requester_addr) */
	REG_DUMP_PRINT_1("   -dest21_requester_addr.dest21_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6ab00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest21_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest21_feed_addr_type */
	/* skip, unused field unused_dest21_feed_addr (dest21_feed_addr) */
	REG_DUMP_PRINT_1("   -dest21_feed_addr.dest21_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6a924);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest20_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest20_iwake_threshold_type */
	/* skip, unused field unused_dest20_iwake_threshold (dest20_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest20_iwake_threshold.dest20_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6a91c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest20_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest20_st_addr_type */
	REG_DUMP_PRINT_1("   -dest20_st_addr.dest20_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x6a918);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest20_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest20_dest_mode_type */
	/* skip, unused field unused_dest20_dest_mode (dest20_dest_mode) */
	REG_DUMP_PRINT_1("   -dest20_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest20_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest20_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest20_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest20_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x6a914);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest20_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest20_term_b_addr_type */
	/* skip, unused field unused_dest20_term_b_addr (dest20_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest20_term_b_addr.dest20_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6a910);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest20_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest20_span_b_addr_type */
	/* skip, unused field unused_dest20_span_b_addr (dest20_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest20_span_b_addr.dest20_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6a90c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest20_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest20_span_a_addr_type */
	/* skip, unused field unused_dest20_span_a_addr (dest20_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest20_span_a_addr.dest20_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6a908);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest20_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest20_channel_addr_type */
	/* skip, unused field unused_dest20_channel_addr (dest20_channel_addr) */
	REG_DUMP_PRINT_1("   -dest20_channel_addr.dest20_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6a904);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest20_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest20_requester_addr_type */
	/* skip, unused field unused_dest20_requester_addr (dest20_requester_addr) */
	REG_DUMP_PRINT_1("   -dest20_requester_addr.dest20_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6a900);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest20_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest20_feed_addr_type */
	/* skip, unused field unused_dest20_feed_addr (dest20_feed_addr) */
	REG_DUMP_PRINT_1("   -dest20_feed_addr.dest20_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6a724);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest19_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest19_iwake_threshold_type */
	/* skip, unused field unused_dest19_iwake_threshold (dest19_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest19_iwake_threshold.dest19_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6a71c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest19_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest19_st_addr_type */
	REG_DUMP_PRINT_1("   -dest19_st_addr.dest19_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x6a718);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest19_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest19_dest_mode_type */
	/* skip, unused field unused_dest19_dest_mode (dest19_dest_mode) */
	REG_DUMP_PRINT_1("   -dest19_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest19_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest19_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest19_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest19_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x6a714);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest19_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest19_term_b_addr_type */
	/* skip, unused field unused_dest19_term_b_addr (dest19_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest19_term_b_addr.dest19_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6a710);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest19_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest19_span_b_addr_type */
	/* skip, unused field unused_dest19_span_b_addr (dest19_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest19_span_b_addr.dest19_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6a70c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest19_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest19_span_a_addr_type */
	/* skip, unused field unused_dest19_span_a_addr (dest19_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest19_span_a_addr.dest19_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6a708);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest19_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest19_channel_addr_type */
	/* skip, unused field unused_dest19_channel_addr (dest19_channel_addr) */
	REG_DUMP_PRINT_1("   -dest19_channel_addr.dest19_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6a704);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest19_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest19_requester_addr_type */
	/* skip, unused field unused_dest19_requester_addr (dest19_requester_addr) */
	REG_DUMP_PRINT_1("   -dest19_requester_addr.dest19_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6a700);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest19_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest19_feed_addr_type */
	/* skip, unused field unused_dest19_feed_addr (dest19_feed_addr) */
	REG_DUMP_PRINT_1("   -dest19_feed_addr.dest19_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6a524);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest18_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest18_iwake_threshold_type */
	/* skip, unused field unused_dest18_iwake_threshold (dest18_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest18_iwake_threshold.dest18_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6a51c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest18_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest18_st_addr_type */
	REG_DUMP_PRINT_1("   -dest18_st_addr.dest18_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x6a518);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest18_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest18_dest_mode_type */
	/* skip, unused field unused_dest18_dest_mode (dest18_dest_mode) */
	REG_DUMP_PRINT_1("   -dest18_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest18_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest18_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest18_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest18_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x6a514);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest18_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest18_term_b_addr_type */
	/* skip, unused field unused_dest18_term_b_addr (dest18_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest18_term_b_addr.dest18_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6a510);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest18_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest18_span_b_addr_type */
	/* skip, unused field unused_dest18_span_b_addr (dest18_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest18_span_b_addr.dest18_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6a50c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest18_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest18_span_a_addr_type */
	/* skip, unused field unused_dest18_span_a_addr (dest18_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest18_span_a_addr.dest18_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6a508);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest18_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest18_channel_addr_type */
	/* skip, unused field unused_dest18_channel_addr (dest18_channel_addr) */
	REG_DUMP_PRINT_1("   -dest18_channel_addr.dest18_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6a504);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest18_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest18_requester_addr_type */
	/* skip, unused field unused_dest18_requester_addr (dest18_requester_addr) */
	REG_DUMP_PRINT_1("   -dest18_requester_addr.dest18_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6a500);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest18_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest18_feed_addr_type */
	/* skip, unused field unused_dest18_feed_addr (dest18_feed_addr) */
	REG_DUMP_PRINT_1("   -dest18_feed_addr.dest18_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6a324);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest17_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest17_iwake_threshold_type */
	/* skip, unused field unused_dest17_iwake_threshold (dest17_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest17_iwake_threshold.dest17_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6a31c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest17_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest17_st_addr_type */
	REG_DUMP_PRINT_1("   -dest17_st_addr.dest17_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x6a318);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest17_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest17_dest_mode_type */
	/* skip, unused field unused_dest17_dest_mode (dest17_dest_mode) */
	REG_DUMP_PRINT_1("   -dest17_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest17_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest17_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest17_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest17_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x6a314);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest17_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest17_term_b_addr_type */
	/* skip, unused field unused_dest17_term_b_addr (dest17_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest17_term_b_addr.dest17_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6a310);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest17_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest17_span_b_addr_type */
	/* skip, unused field unused_dest17_span_b_addr (dest17_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest17_span_b_addr.dest17_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6a30c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest17_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest17_span_a_addr_type */
	/* skip, unused field unused_dest17_span_a_addr (dest17_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest17_span_a_addr.dest17_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6a308);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest17_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest17_channel_addr_type */
	/* skip, unused field unused_dest17_channel_addr (dest17_channel_addr) */
	REG_DUMP_PRINT_1("   -dest17_channel_addr.dest17_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6a304);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest17_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest17_requester_addr_type */
	/* skip, unused field unused_dest17_requester_addr (dest17_requester_addr) */
	REG_DUMP_PRINT_1("   -dest17_requester_addr.dest17_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6a300);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest17_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest17_feed_addr_type */
	/* skip, unused field unused_dest17_feed_addr (dest17_feed_addr) */
	REG_DUMP_PRINT_1("   -dest17_feed_addr.dest17_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6a124);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest16_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest16_iwake_threshold_type */
	/* skip, unused field unused_dest16_iwake_threshold (dest16_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest16_iwake_threshold.dest16_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6a11c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest16_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest16_st_addr_type */
	REG_DUMP_PRINT_1("   -dest16_st_addr.dest16_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x6a118);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest16_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest16_dest_mode_type */
	/* skip, unused field unused_dest16_dest_mode (dest16_dest_mode) */
	REG_DUMP_PRINT_1("   -dest16_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest16_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest16_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest16_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest16_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x6a114);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest16_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest16_term_b_addr_type */
	/* skip, unused field unused_dest16_term_b_addr (dest16_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest16_term_b_addr.dest16_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6a110);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest16_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest16_span_b_addr_type */
	/* skip, unused field unused_dest16_span_b_addr (dest16_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest16_span_b_addr.dest16_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6a10c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest16_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest16_span_a_addr_type */
	/* skip, unused field unused_dest16_span_a_addr (dest16_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest16_span_a_addr.dest16_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6a108);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest16_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest16_channel_addr_type */
	/* skip, unused field unused_dest16_channel_addr (dest16_channel_addr) */
	REG_DUMP_PRINT_1("   -dest16_channel_addr.dest16_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6a104);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest16_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest16_requester_addr_type */
	/* skip, unused field unused_dest16_requester_addr (dest16_requester_addr) */
	REG_DUMP_PRINT_1("   -dest16_requester_addr.dest16_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6a100);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest16_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest16_feed_addr_type */
	/* skip, unused field unused_dest16_feed_addr (dest16_feed_addr) */
	REG_DUMP_PRINT_1("   -dest16_feed_addr.dest16_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69f24);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest15_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest15_iwake_threshold_type */
	/* skip, unused field unused_dest15_iwake_threshold (dest15_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest15_iwake_threshold.dest15_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x69f1c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest15_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest15_st_addr_type */
	REG_DUMP_PRINT_1("   -dest15_st_addr.dest15_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x69f18);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest15_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest15_dest_mode_type */
	/* skip, unused field unused_dest15_dest_mode (dest15_dest_mode) */
	REG_DUMP_PRINT_1("   -dest15_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest15_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest15_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest15_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest15_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x69f14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest15_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest15_term_b_addr_type */
	/* skip, unused field unused_dest15_term_b_addr (dest15_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest15_term_b_addr.dest15_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69f10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest15_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest15_span_b_addr_type */
	/* skip, unused field unused_dest15_span_b_addr (dest15_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest15_span_b_addr.dest15_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69f0c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest15_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest15_span_a_addr_type */
	/* skip, unused field unused_dest15_span_a_addr (dest15_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest15_span_a_addr.dest15_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69f08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest15_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest15_channel_addr_type */
	/* skip, unused field unused_dest15_channel_addr (dest15_channel_addr) */
	REG_DUMP_PRINT_1("   -dest15_channel_addr.dest15_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69f04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest15_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest15_requester_addr_type */
	/* skip, unused field unused_dest15_requester_addr (dest15_requester_addr) */
	REG_DUMP_PRINT_1("   -dest15_requester_addr.dest15_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69f00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest15_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest15_feed_addr_type */
	/* skip, unused field unused_dest15_feed_addr (dest15_feed_addr) */
	REG_DUMP_PRINT_1("   -dest15_feed_addr.dest15_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69ee4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_dest0_cur_cmds                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid15_dest0_cur_cmds_type */
	/* skip, unused field unused_sid15_dest0_cur_cmds (sid15_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid15_dest0_cur_cmds.sid15_dest0_cur_cmds                          |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x69ee0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_dest0_sync_state                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid15_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid15_dest0_sync_state.sid15_dest0_sync_state                      |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x69edc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_dest0_cur_ack_line                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid15_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid15_dest0_cur_ack_line (sid15_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid15_dest0_cur_ack_line.sid15_dest0_cur_ack_line                  |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x69ed8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_dest0_cur_ack_unit_in_line                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid15_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid15_dest0_cur_ack_unit_in_line (sid15_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid15_dest0_cur_ack_unit_in_line.sid15_dest0_cur_ack_unit_in_line  |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x69ed4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_dest0_cur_ack_unit                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid15_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid15_dest0_cur_ack_unit (sid15_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid15_dest0_cur_ack_unit.sid15_dest0_cur_ack_unit                  |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x69ecc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_main_control_state                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid15_main_control_state_type */
	/* skip, unused field unused_sid15_main_control_state (sid15_main_control_state) */
	REG_DUMP_PRINT_1("   -sid15_main_control_state.sid15_main_control_state                  |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x69ec8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_s2m_cur_ack_line                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid15_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid15_s2m_cur_ack_line (sid15_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid15_s2m_cur_ack_line.sid15_s2m_cur_ack_line                      |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x69ec4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_s2m_cur_ack_unit_in_line                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid15_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid15_s2m_cur_ack_unit_in_line (sid15_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid15_s2m_cur_ack_unit_in_line.sid15_s2m_cur_ack_unit_in_line      |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x69ec0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_s2m_cur_cmds                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid15_s2m_cur_cmds_type */
	/* skip, unused field unused_sid15_s2m_cur_cmds (sid15_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid15_s2m_cur_cmds.sid15_s2m_cur_cmds                              |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x69e98);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_error_reg                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid15_error_reg_type */
	REG_DUMP_PRINT_1("   -sid15_error_reg.sid15_error_reg                                    |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x69e88);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_eventque_sidpid                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid15_eventque_sidpid_type */
	/* skip, unused field unused_sid15_eventque_sidpid (sid15_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid15_eventque_sidpid.sid15_eventque_sidpid                        |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x69e84);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_ack_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid15_ack_addr_type */
	/* skip, unused field unused_sid15_ack_addr (sid15_ack_addr) */
	REG_DUMP_PRINT_1("   -sid15_ack_addr.sid15_ack_addr                                      |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69e68);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_dest0_enabled                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid15_dest0_enabled_type */
	/* skip, unused field unused_sid15_dest0_enabled (sid15_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid15_dest0_enabled.sid15_dest0_enabled                            |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 15""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x69e5c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_first_page_nr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid15_first_page_nr_type */
	/* skip, unused field unused_sid15_first_page_nr (sid15_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid15_first_page_nr.sid15_first_page_nr                            |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x69e58);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_camera_select                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid15_camera_select_type */
	/* skip, unused field unused_sid15_camera_select (sid15_camera_select) */
	REG_DUMP_PRINT_1("   -sid15_camera_select.sid15_camera_select                            |        0x%02X  |  [RW][05:00]""SID proc belongs to this camera, used to determine which secure touch enable signal should be used. This is bit encoded, bit 0 belongs to camera 0, bit 1 to camera 1 etc.""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x69e54);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_units_p_ibuf                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid15_units_p_ibuf_type */
	/* skip, unused field unused_sid15_units_p_ibuf (sid15_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid15_units_p_ibuf.sid15_units_p_ibuf                              |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x69e50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_unit_size                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid15_unit_size_type */
	/* skip, unused field unused_sid15_unit_size (sid15_unit_size) */
	REG_DUMP_PRINT_1("   -sid15_unit_size.sid15_unit_size                                    |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0x69e4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_lines_p_frame                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid15_lines_p_frame_type */
	/* skip, unused field unused_sid15_lines_p_frame (sid15_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid15_lines_p_frame.sid15_lines_p_frame                            |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x69e48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_units_p_line                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid15_units_p_line_type */
	/* skip, unused field unused_sid15_units_p_line (sid15_units_p_line) */
	REG_DUMP_PRINT_1("   -sid15_units_p_line.sid15_units_p_line                              |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x69e44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_str2mmio_store_cmd                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid15_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid15_str2mmio_store_cmd (sid15_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid15_str2mmio_store_cmd.sid15_str2mmio_store_cmd                  |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x69e40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_str2mmio_proc_addr                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid15_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid15_str2mmio_proc_addr (sid15_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid15_str2mmio_proc_addr.sid15_str2mmio_proc_addr                  |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69d24);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest14_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest14_iwake_threshold_type */
	/* skip, unused field unused_dest14_iwake_threshold (dest14_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest14_iwake_threshold.dest14_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x69d1c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest14_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest14_st_addr_type */
	REG_DUMP_PRINT_1("   -dest14_st_addr.dest14_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x69d18);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest14_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest14_dest_mode_type */
	/* skip, unused field unused_dest14_dest_mode (dest14_dest_mode) */
	REG_DUMP_PRINT_1("   -dest14_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest14_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest14_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest14_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest14_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x69d14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest14_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest14_term_b_addr_type */
	/* skip, unused field unused_dest14_term_b_addr (dest14_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest14_term_b_addr.dest14_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69d10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest14_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest14_span_b_addr_type */
	/* skip, unused field unused_dest14_span_b_addr (dest14_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest14_span_b_addr.dest14_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69d0c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest14_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest14_span_a_addr_type */
	/* skip, unused field unused_dest14_span_a_addr (dest14_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest14_span_a_addr.dest14_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69d08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest14_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest14_channel_addr_type */
	/* skip, unused field unused_dest14_channel_addr (dest14_channel_addr) */
	REG_DUMP_PRINT_1("   -dest14_channel_addr.dest14_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69d04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest14_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest14_requester_addr_type */
	/* skip, unused field unused_dest14_requester_addr (dest14_requester_addr) */
	REG_DUMP_PRINT_1("   -dest14_requester_addr.dest14_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69d00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest14_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest14_feed_addr_type */
	/* skip, unused field unused_dest14_feed_addr (dest14_feed_addr) */
	REG_DUMP_PRINT_1("   -dest14_feed_addr.dest14_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69ce4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_dest0_cur_cmds                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid14_dest0_cur_cmds_type */
	/* skip, unused field unused_sid14_dest0_cur_cmds (sid14_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid14_dest0_cur_cmds.sid14_dest0_cur_cmds                          |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x69ce0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_dest0_sync_state                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid14_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid14_dest0_sync_state.sid14_dest0_sync_state                      |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x69cdc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_dest0_cur_ack_line                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid14_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid14_dest0_cur_ack_line (sid14_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid14_dest0_cur_ack_line.sid14_dest0_cur_ack_line                  |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x69cd8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_dest0_cur_ack_unit_in_line                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid14_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid14_dest0_cur_ack_unit_in_line (sid14_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid14_dest0_cur_ack_unit_in_line.sid14_dest0_cur_ack_unit_in_line  |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x69cd4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_dest0_cur_ack_unit                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid14_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid14_dest0_cur_ack_unit (sid14_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid14_dest0_cur_ack_unit.sid14_dest0_cur_ack_unit                  |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x69ccc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_main_control_state                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid14_main_control_state_type */
	/* skip, unused field unused_sid14_main_control_state (sid14_main_control_state) */
	REG_DUMP_PRINT_1("   -sid14_main_control_state.sid14_main_control_state                  |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x69cc8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_s2m_cur_ack_line                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid14_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid14_s2m_cur_ack_line (sid14_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid14_s2m_cur_ack_line.sid14_s2m_cur_ack_line                      |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x69cc4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_s2m_cur_ack_unit_in_line                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid14_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid14_s2m_cur_ack_unit_in_line (sid14_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid14_s2m_cur_ack_unit_in_line.sid14_s2m_cur_ack_unit_in_line      |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x69cc0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_s2m_cur_cmds                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid14_s2m_cur_cmds_type */
	/* skip, unused field unused_sid14_s2m_cur_cmds (sid14_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid14_s2m_cur_cmds.sid14_s2m_cur_cmds                              |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x69c98);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_error_reg                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid14_error_reg_type */
	REG_DUMP_PRINT_1("   -sid14_error_reg.sid14_error_reg                                    |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x69c88);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_eventque_sidpid                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid14_eventque_sidpid_type */
	/* skip, unused field unused_sid14_eventque_sidpid (sid14_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid14_eventque_sidpid.sid14_eventque_sidpid                        |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x69c84);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_ack_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid14_ack_addr_type */
	/* skip, unused field unused_sid14_ack_addr (sid14_ack_addr) */
	REG_DUMP_PRINT_1("   -sid14_ack_addr.sid14_ack_addr                                      |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69c68);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_dest0_enabled                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid14_dest0_enabled_type */
	/* skip, unused field unused_sid14_dest0_enabled (sid14_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid14_dest0_enabled.sid14_dest0_enabled                            |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 14""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x69c5c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_first_page_nr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid14_first_page_nr_type */
	/* skip, unused field unused_sid14_first_page_nr (sid14_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid14_first_page_nr.sid14_first_page_nr                            |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x69c58);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_camera_select                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid14_camera_select_type */
	/* skip, unused field unused_sid14_camera_select (sid14_camera_select) */
	REG_DUMP_PRINT_1("   -sid14_camera_select.sid14_camera_select                            |        0x%02X  |  [RW][05:00]""SID proc belongs to this camera, used to determine which secure touch enable signal should be used. This is bit encoded, bit 0 belongs to camera 0, bit 1 to camera 1 etc.""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x69c54);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_units_p_ibuf                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid14_units_p_ibuf_type */
	/* skip, unused field unused_sid14_units_p_ibuf (sid14_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid14_units_p_ibuf.sid14_units_p_ibuf                              |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x69c50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_unit_size                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid14_unit_size_type */
	/* skip, unused field unused_sid14_unit_size (sid14_unit_size) */
	REG_DUMP_PRINT_1("   -sid14_unit_size.sid14_unit_size                                    |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0x69c4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_lines_p_frame                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid14_lines_p_frame_type */
	/* skip, unused field unused_sid14_lines_p_frame (sid14_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid14_lines_p_frame.sid14_lines_p_frame                            |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x69c48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_units_p_line                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid14_units_p_line_type */
	/* skip, unused field unused_sid14_units_p_line (sid14_units_p_line) */
	REG_DUMP_PRINT_1("   -sid14_units_p_line.sid14_units_p_line                              |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x69c44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_str2mmio_store_cmd                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid14_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid14_str2mmio_store_cmd (sid14_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid14_str2mmio_store_cmd.sid14_str2mmio_store_cmd                  |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x69c40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_str2mmio_proc_addr                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid14_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid14_str2mmio_proc_addr (sid14_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid14_str2mmio_proc_addr.sid14_str2mmio_proc_addr                  |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69b24);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest13_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest13_iwake_threshold_type */
	/* skip, unused field unused_dest13_iwake_threshold (dest13_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest13_iwake_threshold.dest13_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x69b1c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest13_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest13_st_addr_type */
	REG_DUMP_PRINT_1("   -dest13_st_addr.dest13_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x69b18);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest13_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest13_dest_mode_type */
	/* skip, unused field unused_dest13_dest_mode (dest13_dest_mode) */
	REG_DUMP_PRINT_1("   -dest13_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest13_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest13_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest13_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest13_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x69b14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest13_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest13_term_b_addr_type */
	/* skip, unused field unused_dest13_term_b_addr (dest13_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest13_term_b_addr.dest13_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69b10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest13_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest13_span_b_addr_type */
	/* skip, unused field unused_dest13_span_b_addr (dest13_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest13_span_b_addr.dest13_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69b0c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest13_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest13_span_a_addr_type */
	/* skip, unused field unused_dest13_span_a_addr (dest13_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest13_span_a_addr.dest13_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69b08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest13_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest13_channel_addr_type */
	/* skip, unused field unused_dest13_channel_addr (dest13_channel_addr) */
	REG_DUMP_PRINT_1("   -dest13_channel_addr.dest13_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69b04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest13_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest13_requester_addr_type */
	/* skip, unused field unused_dest13_requester_addr (dest13_requester_addr) */
	REG_DUMP_PRINT_1("   -dest13_requester_addr.dest13_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69b00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest13_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest13_feed_addr_type */
	/* skip, unused field unused_dest13_feed_addr (dest13_feed_addr) */
	REG_DUMP_PRINT_1("   -dest13_feed_addr.dest13_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69ae4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_dest0_cur_cmds                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid13_dest0_cur_cmds_type */
	/* skip, unused field unused_sid13_dest0_cur_cmds (sid13_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid13_dest0_cur_cmds.sid13_dest0_cur_cmds                          |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x69ae0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_dest0_sync_state                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid13_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid13_dest0_sync_state.sid13_dest0_sync_state                      |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x69adc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_dest0_cur_ack_line                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid13_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid13_dest0_cur_ack_line (sid13_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid13_dest0_cur_ack_line.sid13_dest0_cur_ack_line                  |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x69ad8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_dest0_cur_ack_unit_in_line                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid13_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid13_dest0_cur_ack_unit_in_line (sid13_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid13_dest0_cur_ack_unit_in_line.sid13_dest0_cur_ack_unit_in_line  |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x69ad4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_dest0_cur_ack_unit                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid13_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid13_dest0_cur_ack_unit (sid13_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid13_dest0_cur_ack_unit.sid13_dest0_cur_ack_unit                  |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x69acc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_main_control_state                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid13_main_control_state_type */
	/* skip, unused field unused_sid13_main_control_state (sid13_main_control_state) */
	REG_DUMP_PRINT_1("   -sid13_main_control_state.sid13_main_control_state                  |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x69ac8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_s2m_cur_ack_line                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid13_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid13_s2m_cur_ack_line (sid13_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid13_s2m_cur_ack_line.sid13_s2m_cur_ack_line                      |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x69ac4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_s2m_cur_ack_unit_in_line                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid13_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid13_s2m_cur_ack_unit_in_line (sid13_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid13_s2m_cur_ack_unit_in_line.sid13_s2m_cur_ack_unit_in_line      |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x69ac0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_s2m_cur_cmds                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid13_s2m_cur_cmds_type */
	/* skip, unused field unused_sid13_s2m_cur_cmds (sid13_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid13_s2m_cur_cmds.sid13_s2m_cur_cmds                              |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x69a98);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_error_reg                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid13_error_reg_type */
	REG_DUMP_PRINT_1("   -sid13_error_reg.sid13_error_reg                                    |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x69a88);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_eventque_sidpid                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid13_eventque_sidpid_type */
	/* skip, unused field unused_sid13_eventque_sidpid (sid13_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid13_eventque_sidpid.sid13_eventque_sidpid                        |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x69a84);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_ack_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid13_ack_addr_type */
	/* skip, unused field unused_sid13_ack_addr (sid13_ack_addr) */
	REG_DUMP_PRINT_1("   -sid13_ack_addr.sid13_ack_addr                                      |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69a68);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_dest0_enabled                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid13_dest0_enabled_type */
	/* skip, unused field unused_sid13_dest0_enabled (sid13_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid13_dest0_enabled.sid13_dest0_enabled                            |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 13""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x69a5c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_first_page_nr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid13_first_page_nr_type */
	/* skip, unused field unused_sid13_first_page_nr (sid13_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid13_first_page_nr.sid13_first_page_nr                            |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x69a58);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_camera_select                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid13_camera_select_type */
	/* skip, unused field unused_sid13_camera_select (sid13_camera_select) */
	REG_DUMP_PRINT_1("   -sid13_camera_select.sid13_camera_select                            |        0x%02X  |  [RW][05:00]""SID proc belongs to this camera, used to determine which secure touch enable signal should be used. This is bit encoded, bit 0 belongs to camera 0, bit 1 to camera 1 etc.""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x69a54);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_units_p_ibuf                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid13_units_p_ibuf_type */
	/* skip, unused field unused_sid13_units_p_ibuf (sid13_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid13_units_p_ibuf.sid13_units_p_ibuf                              |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x69a50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_unit_size                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid13_unit_size_type */
	/* skip, unused field unused_sid13_unit_size (sid13_unit_size) */
	REG_DUMP_PRINT_1("   -sid13_unit_size.sid13_unit_size                                    |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0x69a4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_lines_p_frame                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid13_lines_p_frame_type */
	/* skip, unused field unused_sid13_lines_p_frame (sid13_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid13_lines_p_frame.sid13_lines_p_frame                            |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x69a48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_units_p_line                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid13_units_p_line_type */
	/* skip, unused field unused_sid13_units_p_line (sid13_units_p_line) */
	REG_DUMP_PRINT_1("   -sid13_units_p_line.sid13_units_p_line                              |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x69a44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_str2mmio_store_cmd                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid13_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid13_str2mmio_store_cmd (sid13_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid13_str2mmio_store_cmd.sid13_str2mmio_store_cmd                  |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x69a40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_str2mmio_proc_addr                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid13_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid13_str2mmio_proc_addr (sid13_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid13_str2mmio_proc_addr.sid13_str2mmio_proc_addr                  |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69924);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest12_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest12_iwake_threshold_type */
	/* skip, unused field unused_dest12_iwake_threshold (dest12_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest12_iwake_threshold.dest12_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6991c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest12_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest12_st_addr_type */
	REG_DUMP_PRINT_1("   -dest12_st_addr.dest12_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x69918);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest12_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest12_dest_mode_type */
	/* skip, unused field unused_dest12_dest_mode (dest12_dest_mode) */
	REG_DUMP_PRINT_1("   -dest12_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest12_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest12_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest12_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest12_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x69914);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest12_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest12_term_b_addr_type */
	/* skip, unused field unused_dest12_term_b_addr (dest12_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest12_term_b_addr.dest12_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69910);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest12_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest12_span_b_addr_type */
	/* skip, unused field unused_dest12_span_b_addr (dest12_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest12_span_b_addr.dest12_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6990c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest12_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest12_span_a_addr_type */
	/* skip, unused field unused_dest12_span_a_addr (dest12_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest12_span_a_addr.dest12_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69908);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest12_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest12_channel_addr_type */
	/* skip, unused field unused_dest12_channel_addr (dest12_channel_addr) */
	REG_DUMP_PRINT_1("   -dest12_channel_addr.dest12_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69904);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest12_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest12_requester_addr_type */
	/* skip, unused field unused_dest12_requester_addr (dest12_requester_addr) */
	REG_DUMP_PRINT_1("   -dest12_requester_addr.dest12_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69900);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest12_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest12_feed_addr_type */
	/* skip, unused field unused_dest12_feed_addr (dest12_feed_addr) */
	REG_DUMP_PRINT_1("   -dest12_feed_addr.dest12_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x698e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_dest0_cur_cmds                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid12_dest0_cur_cmds_type */
	/* skip, unused field unused_sid12_dest0_cur_cmds (sid12_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid12_dest0_cur_cmds.sid12_dest0_cur_cmds                          |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x698e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_dest0_sync_state                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid12_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid12_dest0_sync_state.sid12_dest0_sync_state                      |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x698dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_dest0_cur_ack_line                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid12_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid12_dest0_cur_ack_line (sid12_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid12_dest0_cur_ack_line.sid12_dest0_cur_ack_line                  |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x698d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_dest0_cur_ack_unit_in_line                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid12_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid12_dest0_cur_ack_unit_in_line (sid12_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid12_dest0_cur_ack_unit_in_line.sid12_dest0_cur_ack_unit_in_line  |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x698d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_dest0_cur_ack_unit                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid12_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid12_dest0_cur_ack_unit (sid12_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid12_dest0_cur_ack_unit.sid12_dest0_cur_ack_unit                  |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x698cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_main_control_state                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid12_main_control_state_type */
	/* skip, unused field unused_sid12_main_control_state (sid12_main_control_state) */
	REG_DUMP_PRINT_1("   -sid12_main_control_state.sid12_main_control_state                  |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x698c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_s2m_cur_ack_line                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid12_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid12_s2m_cur_ack_line (sid12_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid12_s2m_cur_ack_line.sid12_s2m_cur_ack_line                      |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x698c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_s2m_cur_ack_unit_in_line                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid12_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid12_s2m_cur_ack_unit_in_line (sid12_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid12_s2m_cur_ack_unit_in_line.sid12_s2m_cur_ack_unit_in_line      |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x698c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_s2m_cur_cmds                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid12_s2m_cur_cmds_type */
	/* skip, unused field unused_sid12_s2m_cur_cmds (sid12_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid12_s2m_cur_cmds.sid12_s2m_cur_cmds                              |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x69898);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_error_reg                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid12_error_reg_type */
	REG_DUMP_PRINT_1("   -sid12_error_reg.sid12_error_reg                                    |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x69888);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_eventque_sidpid                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid12_eventque_sidpid_type */
	/* skip, unused field unused_sid12_eventque_sidpid (sid12_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid12_eventque_sidpid.sid12_eventque_sidpid                        |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x69884);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_ack_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid12_ack_addr_type */
	/* skip, unused field unused_sid12_ack_addr (sid12_ack_addr) */
	REG_DUMP_PRINT_1("   -sid12_ack_addr.sid12_ack_addr                                      |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69868);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_dest0_enabled                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid12_dest0_enabled_type */
	/* skip, unused field unused_sid12_dest0_enabled (sid12_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid12_dest0_enabled.sid12_dest0_enabled                            |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 12""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6985c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_first_page_nr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid12_first_page_nr_type */
	/* skip, unused field unused_sid12_first_page_nr (sid12_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid12_first_page_nr.sid12_first_page_nr                            |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x69858);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_camera_select                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid12_camera_select_type */
	/* skip, unused field unused_sid12_camera_select (sid12_camera_select) */
	REG_DUMP_PRINT_1("   -sid12_camera_select.sid12_camera_select                            |        0x%02X  |  [RW][05:00]""SID proc belongs to this camera, used to determine which secure touch enable signal should be used. This is bit encoded, bit 0 belongs to camera 0, bit 1 to camera 1 etc.""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x69854);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_units_p_ibuf                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid12_units_p_ibuf_type */
	/* skip, unused field unused_sid12_units_p_ibuf (sid12_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid12_units_p_ibuf.sid12_units_p_ibuf                              |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x69850);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_unit_size                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid12_unit_size_type */
	/* skip, unused field unused_sid12_unit_size (sid12_unit_size) */
	REG_DUMP_PRINT_1("   -sid12_unit_size.sid12_unit_size                                    |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0x6984c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_lines_p_frame                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid12_lines_p_frame_type */
	/* skip, unused field unused_sid12_lines_p_frame (sid12_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid12_lines_p_frame.sid12_lines_p_frame                            |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x69848);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_units_p_line                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid12_units_p_line_type */
	/* skip, unused field unused_sid12_units_p_line (sid12_units_p_line) */
	REG_DUMP_PRINT_1("   -sid12_units_p_line.sid12_units_p_line                              |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x69844);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_str2mmio_store_cmd                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid12_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid12_str2mmio_store_cmd (sid12_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid12_str2mmio_store_cmd.sid12_str2mmio_store_cmd                  |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x69840);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_str2mmio_proc_addr                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid12_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid12_str2mmio_proc_addr (sid12_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid12_str2mmio_proc_addr.sid12_str2mmio_proc_addr                  |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69724);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest11_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest11_iwake_threshold_type */
	/* skip, unused field unused_dest11_iwake_threshold (dest11_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest11_iwake_threshold.dest11_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6971c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest11_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest11_st_addr_type */
	REG_DUMP_PRINT_1("   -dest11_st_addr.dest11_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x69718);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest11_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest11_dest_mode_type */
	/* skip, unused field unused_dest11_dest_mode (dest11_dest_mode) */
	REG_DUMP_PRINT_1("   -dest11_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest11_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest11_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest11_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest11_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x69714);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest11_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest11_term_b_addr_type */
	/* skip, unused field unused_dest11_term_b_addr (dest11_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest11_term_b_addr.dest11_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69710);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest11_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest11_span_b_addr_type */
	/* skip, unused field unused_dest11_span_b_addr (dest11_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest11_span_b_addr.dest11_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6970c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest11_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest11_span_a_addr_type */
	/* skip, unused field unused_dest11_span_a_addr (dest11_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest11_span_a_addr.dest11_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69708);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest11_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest11_channel_addr_type */
	/* skip, unused field unused_dest11_channel_addr (dest11_channel_addr) */
	REG_DUMP_PRINT_1("   -dest11_channel_addr.dest11_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69704);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest11_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest11_requester_addr_type */
	/* skip, unused field unused_dest11_requester_addr (dest11_requester_addr) */
	REG_DUMP_PRINT_1("   -dest11_requester_addr.dest11_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69700);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest11_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest11_feed_addr_type */
	/* skip, unused field unused_dest11_feed_addr (dest11_feed_addr) */
	REG_DUMP_PRINT_1("   -dest11_feed_addr.dest11_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x696e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_dest0_cur_cmds                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid11_dest0_cur_cmds_type */
	/* skip, unused field unused_sid11_dest0_cur_cmds (sid11_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid11_dest0_cur_cmds.sid11_dest0_cur_cmds                          |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x696e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_dest0_sync_state                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid11_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid11_dest0_sync_state.sid11_dest0_sync_state                      |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x696dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_dest0_cur_ack_line                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid11_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid11_dest0_cur_ack_line (sid11_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid11_dest0_cur_ack_line.sid11_dest0_cur_ack_line                  |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x696d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_dest0_cur_ack_unit_in_line                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid11_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid11_dest0_cur_ack_unit_in_line (sid11_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid11_dest0_cur_ack_unit_in_line.sid11_dest0_cur_ack_unit_in_line  |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x696d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_dest0_cur_ack_unit                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid11_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid11_dest0_cur_ack_unit (sid11_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid11_dest0_cur_ack_unit.sid11_dest0_cur_ack_unit                  |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x696cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_main_control_state                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid11_main_control_state_type */
	/* skip, unused field unused_sid11_main_control_state (sid11_main_control_state) */
	REG_DUMP_PRINT_1("   -sid11_main_control_state.sid11_main_control_state                  |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x696c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_s2m_cur_ack_line                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid11_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid11_s2m_cur_ack_line (sid11_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid11_s2m_cur_ack_line.sid11_s2m_cur_ack_line                      |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x696c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_s2m_cur_ack_unit_in_line                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid11_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid11_s2m_cur_ack_unit_in_line (sid11_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid11_s2m_cur_ack_unit_in_line.sid11_s2m_cur_ack_unit_in_line      |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x696c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_s2m_cur_cmds                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid11_s2m_cur_cmds_type */
	/* skip, unused field unused_sid11_s2m_cur_cmds (sid11_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid11_s2m_cur_cmds.sid11_s2m_cur_cmds                              |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x69698);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_error_reg                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid11_error_reg_type */
	REG_DUMP_PRINT_1("   -sid11_error_reg.sid11_error_reg                                    |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x69688);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_eventque_sidpid                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid11_eventque_sidpid_type */
	/* skip, unused field unused_sid11_eventque_sidpid (sid11_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid11_eventque_sidpid.sid11_eventque_sidpid                        |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x69684);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_ack_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid11_ack_addr_type */
	/* skip, unused field unused_sid11_ack_addr (sid11_ack_addr) */
	REG_DUMP_PRINT_1("   -sid11_ack_addr.sid11_ack_addr                                      |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69668);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_dest0_enabled                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid11_dest0_enabled_type */
	/* skip, unused field unused_sid11_dest0_enabled (sid11_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid11_dest0_enabled.sid11_dest0_enabled                            |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 11""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6965c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_first_page_nr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid11_first_page_nr_type */
	/* skip, unused field unused_sid11_first_page_nr (sid11_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid11_first_page_nr.sid11_first_page_nr                            |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x69658);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_camera_select                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid11_camera_select_type */
	/* skip, unused field unused_sid11_camera_select (sid11_camera_select) */
	REG_DUMP_PRINT_1("   -sid11_camera_select.sid11_camera_select                            |        0x%02X  |  [RW][05:00]""SID proc belongs to this camera, used to determine which secure touch enable signal should be used. This is bit encoded, bit 0 belongs to camera 0, bit 1 to camera 1 etc.""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x69654);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_units_p_ibuf                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid11_units_p_ibuf_type */
	/* skip, unused field unused_sid11_units_p_ibuf (sid11_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid11_units_p_ibuf.sid11_units_p_ibuf                              |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x69650);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_unit_size                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid11_unit_size_type */
	/* skip, unused field unused_sid11_unit_size (sid11_unit_size) */
	REG_DUMP_PRINT_1("   -sid11_unit_size.sid11_unit_size                                    |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0x6964c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_lines_p_frame                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid11_lines_p_frame_type */
	/* skip, unused field unused_sid11_lines_p_frame (sid11_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid11_lines_p_frame.sid11_lines_p_frame                            |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x69648);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_units_p_line                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid11_units_p_line_type */
	/* skip, unused field unused_sid11_units_p_line (sid11_units_p_line) */
	REG_DUMP_PRINT_1("   -sid11_units_p_line.sid11_units_p_line                              |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x69644);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_str2mmio_store_cmd                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid11_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid11_str2mmio_store_cmd (sid11_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid11_str2mmio_store_cmd.sid11_str2mmio_store_cmd                  |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x69640);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_str2mmio_proc_addr                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid11_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid11_str2mmio_proc_addr (sid11_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid11_str2mmio_proc_addr.sid11_str2mmio_proc_addr                  |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69524);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest10_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest10_iwake_threshold_type */
	/* skip, unused field unused_dest10_iwake_threshold (dest10_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest10_iwake_threshold.dest10_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6951c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest10_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest10_st_addr_type */
	REG_DUMP_PRINT_1("   -dest10_st_addr.dest10_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x69518);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest10_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest10_dest_mode_type */
	/* skip, unused field unused_dest10_dest_mode (dest10_dest_mode) */
	REG_DUMP_PRINT_1("   -dest10_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest10_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest10_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest10_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest10_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x69514);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest10_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest10_term_b_addr_type */
	/* skip, unused field unused_dest10_term_b_addr (dest10_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest10_term_b_addr.dest10_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69510);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest10_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest10_span_b_addr_type */
	/* skip, unused field unused_dest10_span_b_addr (dest10_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest10_span_b_addr.dest10_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6950c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest10_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest10_span_a_addr_type */
	/* skip, unused field unused_dest10_span_a_addr (dest10_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest10_span_a_addr.dest10_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69508);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest10_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest10_channel_addr_type */
	/* skip, unused field unused_dest10_channel_addr (dest10_channel_addr) */
	REG_DUMP_PRINT_1("   -dest10_channel_addr.dest10_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69504);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest10_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest10_requester_addr_type */
	/* skip, unused field unused_dest10_requester_addr (dest10_requester_addr) */
	REG_DUMP_PRINT_1("   -dest10_requester_addr.dest10_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69500);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest10_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest10_feed_addr_type */
	/* skip, unused field unused_dest10_feed_addr (dest10_feed_addr) */
	REG_DUMP_PRINT_1("   -dest10_feed_addr.dest10_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x694e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_dest0_cur_cmds                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid10_dest0_cur_cmds_type */
	/* skip, unused field unused_sid10_dest0_cur_cmds (sid10_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid10_dest0_cur_cmds.sid10_dest0_cur_cmds                          |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x694e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_dest0_sync_state                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid10_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid10_dest0_sync_state.sid10_dest0_sync_state                      |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x694dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_dest0_cur_ack_line                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid10_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid10_dest0_cur_ack_line (sid10_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid10_dest0_cur_ack_line.sid10_dest0_cur_ack_line                  |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x694d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_dest0_cur_ack_unit_in_line                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid10_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid10_dest0_cur_ack_unit_in_line (sid10_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid10_dest0_cur_ack_unit_in_line.sid10_dest0_cur_ack_unit_in_line  |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x694d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_dest0_cur_ack_unit                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid10_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid10_dest0_cur_ack_unit (sid10_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid10_dest0_cur_ack_unit.sid10_dest0_cur_ack_unit                  |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x694cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_main_control_state                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid10_main_control_state_type */
	/* skip, unused field unused_sid10_main_control_state (sid10_main_control_state) */
	REG_DUMP_PRINT_1("   -sid10_main_control_state.sid10_main_control_state                  |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x694c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_s2m_cur_ack_line                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid10_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid10_s2m_cur_ack_line (sid10_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid10_s2m_cur_ack_line.sid10_s2m_cur_ack_line                      |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x694c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_s2m_cur_ack_unit_in_line                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid10_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid10_s2m_cur_ack_unit_in_line (sid10_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid10_s2m_cur_ack_unit_in_line.sid10_s2m_cur_ack_unit_in_line      |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x694c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_s2m_cur_cmds                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid10_s2m_cur_cmds_type */
	/* skip, unused field unused_sid10_s2m_cur_cmds (sid10_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid10_s2m_cur_cmds.sid10_s2m_cur_cmds                              |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x69498);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_error_reg                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid10_error_reg_type */
	REG_DUMP_PRINT_1("   -sid10_error_reg.sid10_error_reg                                    |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x69488);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_eventque_sidpid                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid10_eventque_sidpid_type */
	/* skip, unused field unused_sid10_eventque_sidpid (sid10_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid10_eventque_sidpid.sid10_eventque_sidpid                        |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x69484);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_ack_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid10_ack_addr_type */
	/* skip, unused field unused_sid10_ack_addr (sid10_ack_addr) */
	REG_DUMP_PRINT_1("   -sid10_ack_addr.sid10_ack_addr                                      |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69468);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_dest0_enabled                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid10_dest0_enabled_type */
	/* skip, unused field unused_sid10_dest0_enabled (sid10_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid10_dest0_enabled.sid10_dest0_enabled                            |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 10""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6945c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_first_page_nr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid10_first_page_nr_type */
	/* skip, unused field unused_sid10_first_page_nr (sid10_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid10_first_page_nr.sid10_first_page_nr                            |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x69458);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_camera_select                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid10_camera_select_type */
	/* skip, unused field unused_sid10_camera_select (sid10_camera_select) */
	REG_DUMP_PRINT_1("   -sid10_camera_select.sid10_camera_select                            |        0x%02X  |  [RW][05:00]""SID proc belongs to this camera, used to determine which secure touch enable signal should be used. This is bit encoded, bit 0 belongs to camera 0, bit 1 to camera 1 etc.""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x69454);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_units_p_ibuf                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid10_units_p_ibuf_type */
	/* skip, unused field unused_sid10_units_p_ibuf (sid10_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid10_units_p_ibuf.sid10_units_p_ibuf                              |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x69450);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_unit_size                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid10_unit_size_type */
	/* skip, unused field unused_sid10_unit_size (sid10_unit_size) */
	REG_DUMP_PRINT_1("   -sid10_unit_size.sid10_unit_size                                    |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0x6944c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_lines_p_frame                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid10_lines_p_frame_type */
	/* skip, unused field unused_sid10_lines_p_frame (sid10_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid10_lines_p_frame.sid10_lines_p_frame                            |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x69448);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_units_p_line                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid10_units_p_line_type */
	/* skip, unused field unused_sid10_units_p_line (sid10_units_p_line) */
	REG_DUMP_PRINT_1("   -sid10_units_p_line.sid10_units_p_line                              |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x69444);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_str2mmio_store_cmd                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid10_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid10_str2mmio_store_cmd (sid10_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid10_str2mmio_store_cmd.sid10_str2mmio_store_cmd                  |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x69440);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_str2mmio_proc_addr                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid10_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid10_str2mmio_proc_addr (sid10_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid10_str2mmio_proc_addr.sid10_str2mmio_proc_addr                  |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69324);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest9_iwake_threshold                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest9_iwake_threshold_type */
	/* skip, unused field unused_dest9_iwake_threshold (dest9_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest9_iwake_threshold.dest9_iwake_threshold                        |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6931c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest9_st_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest9_st_addr_type */
	REG_DUMP_PRINT_1("   -dest9_st_addr.dest9_st_addr                                        |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x69318);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest9_dest_mode                                            |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest9_dest_mode_type */
	/* skip, unused field unused_dest9_dest_mode (dest9_dest_mode) */
	REG_DUMP_PRINT_1("   -dest9_dest_mode.is_ibuf_cntrl_feeder                               |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest9_dest_mode.config_dma                                         |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest9_dest_mode.iwake_enable                                       |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest9_dest_mode.disable_spana_rst                                  |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest9_dest_mode.disable_spanb_rst                                  |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x69314);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest9_term_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest9_term_b_addr_type */
	/* skip, unused field unused_dest9_term_b_addr (dest9_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest9_term_b_addr.dest9_term_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69310);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest9_span_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest9_span_b_addr_type */
	/* skip, unused field unused_dest9_span_b_addr (dest9_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest9_span_b_addr.dest9_span_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6930c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest9_span_a_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest9_span_a_addr_type */
	/* skip, unused field unused_dest9_span_a_addr (dest9_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest9_span_a_addr.dest9_span_a_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69308);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest9_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest9_channel_addr_type */
	/* skip, unused field unused_dest9_channel_addr (dest9_channel_addr) */
	REG_DUMP_PRINT_1("   -dest9_channel_addr.dest9_channel_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69304);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest9_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest9_requester_addr_type */
	/* skip, unused field unused_dest9_requester_addr (dest9_requester_addr) */
	REG_DUMP_PRINT_1("   -dest9_requester_addr.dest9_requester_addr                          |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69300);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest9_feed_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest9_feed_addr_type */
	/* skip, unused field unused_dest9_feed_addr (dest9_feed_addr) */
	REG_DUMP_PRINT_1("   -dest9_feed_addr.dest9_feed_addr                                    |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x692e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_dest0_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid9_dest0_cur_cmds_type */
	/* skip, unused field unused_sid9_dest0_cur_cmds (sid9_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid9_dest0_cur_cmds.sid9_dest0_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x692e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_dest0_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid9_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid9_dest0_sync_state.sid9_dest0_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x692dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_dest0_cur_ack_line                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid9_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid9_dest0_cur_ack_line (sid9_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid9_dest0_cur_ack_line.sid9_dest0_cur_ack_line                    |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x692d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_dest0_cur_ack_unit_in_line                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid9_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid9_dest0_cur_ack_unit_in_line (sid9_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid9_dest0_cur_ack_unit_in_line.sid9_dest0_cur_ack_unit_in_line    |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x692d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_dest0_cur_ack_unit                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid9_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid9_dest0_cur_ack_unit (sid9_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid9_dest0_cur_ack_unit.sid9_dest0_cur_ack_unit                    |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x692cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_main_control_state                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid9_main_control_state_type */
	/* skip, unused field unused_sid9_main_control_state (sid9_main_control_state) */
	REG_DUMP_PRINT_1("   -sid9_main_control_state.sid9_main_control_state                    |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x692c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_s2m_cur_ack_line                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid9_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid9_s2m_cur_ack_line (sid9_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid9_s2m_cur_ack_line.sid9_s2m_cur_ack_line                        |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x692c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_s2m_cur_ack_unit_in_line                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid9_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid9_s2m_cur_ack_unit_in_line (sid9_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid9_s2m_cur_ack_unit_in_line.sid9_s2m_cur_ack_unit_in_line        |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x692c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_s2m_cur_cmds                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid9_s2m_cur_cmds_type */
	/* skip, unused field unused_sid9_s2m_cur_cmds (sid9_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid9_s2m_cur_cmds.sid9_s2m_cur_cmds                                |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x69298);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_error_reg                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid9_error_reg_type */
	REG_DUMP_PRINT_1("   -sid9_error_reg.sid9_error_reg                                      |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x69288);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_eventque_sidpid                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid9_eventque_sidpid_type */
	/* skip, unused field unused_sid9_eventque_sidpid (sid9_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid9_eventque_sidpid.sid9_eventque_sidpid                          |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x69284);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_ack_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid9_ack_addr_type */
	/* skip, unused field unused_sid9_ack_addr (sid9_ack_addr) */
	REG_DUMP_PRINT_1("   -sid9_ack_addr.sid9_ack_addr                                        |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69268);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_dest0_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid9_dest0_enabled_type */
	/* skip, unused field unused_sid9_dest0_enabled (sid9_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid9_dest0_enabled.sid9_dest0_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 9""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6925c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_first_page_nr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid9_first_page_nr_type */
	/* skip, unused field unused_sid9_first_page_nr (sid9_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid9_first_page_nr.sid9_first_page_nr                              |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x69258);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_camera_select                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid9_camera_select_type */
	/* skip, unused field unused_sid9_camera_select (sid9_camera_select) */
	REG_DUMP_PRINT_1("   -sid9_camera_select.sid9_camera_select                              |        0x%02X  |  [RW][05:00]""SID proc belongs to this camera, used to determine which secure touch enable signal should be used. This is bit encoded, bit 0 belongs to camera 0, bit 1 to camera 1 etc.""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x69254);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_units_p_ibuf                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid9_units_p_ibuf_type */
	/* skip, unused field unused_sid9_units_p_ibuf (sid9_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid9_units_p_ibuf.sid9_units_p_ibuf                                |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x69250);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_unit_size                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid9_unit_size_type */
	/* skip, unused field unused_sid9_unit_size (sid9_unit_size) */
	REG_DUMP_PRINT_1("   -sid9_unit_size.sid9_unit_size                                      |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0x6924c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_lines_p_frame                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid9_lines_p_frame_type */
	/* skip, unused field unused_sid9_lines_p_frame (sid9_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid9_lines_p_frame.sid9_lines_p_frame                              |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x69248);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_units_p_line                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid9_units_p_line_type */
	/* skip, unused field unused_sid9_units_p_line (sid9_units_p_line) */
	REG_DUMP_PRINT_1("   -sid9_units_p_line.sid9_units_p_line                                |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x69244);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_str2mmio_store_cmd                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid9_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid9_str2mmio_store_cmd (sid9_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid9_str2mmio_store_cmd.sid9_str2mmio_store_cmd                    |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x69240);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_str2mmio_proc_addr                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid9_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid9_str2mmio_proc_addr (sid9_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid9_str2mmio_proc_addr.sid9_str2mmio_proc_addr                    |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69124);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest8_iwake_threshold                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest8_iwake_threshold_type */
	/* skip, unused field unused_dest8_iwake_threshold (dest8_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest8_iwake_threshold.dest8_iwake_threshold                        |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6911c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest8_st_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest8_st_addr_type */
	REG_DUMP_PRINT_1("   -dest8_st_addr.dest8_st_addr                                        |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x69118);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest8_dest_mode                                            |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest8_dest_mode_type */
	/* skip, unused field unused_dest8_dest_mode (dest8_dest_mode) */
	REG_DUMP_PRINT_1("   -dest8_dest_mode.is_ibuf_cntrl_feeder                               |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest8_dest_mode.config_dma                                         |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest8_dest_mode.iwake_enable                                       |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest8_dest_mode.disable_spana_rst                                  |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest8_dest_mode.disable_spanb_rst                                  |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x69114);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest8_term_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest8_term_b_addr_type */
	/* skip, unused field unused_dest8_term_b_addr (dest8_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest8_term_b_addr.dest8_term_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69110);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest8_span_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest8_span_b_addr_type */
	/* skip, unused field unused_dest8_span_b_addr (dest8_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest8_span_b_addr.dest8_span_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6910c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest8_span_a_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest8_span_a_addr_type */
	/* skip, unused field unused_dest8_span_a_addr (dest8_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest8_span_a_addr.dest8_span_a_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69108);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest8_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest8_channel_addr_type */
	/* skip, unused field unused_dest8_channel_addr (dest8_channel_addr) */
	REG_DUMP_PRINT_1("   -dest8_channel_addr.dest8_channel_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69104);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest8_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest8_requester_addr_type */
	/* skip, unused field unused_dest8_requester_addr (dest8_requester_addr) */
	REG_DUMP_PRINT_1("   -dest8_requester_addr.dest8_requester_addr                          |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69100);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest8_feed_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest8_feed_addr_type */
	/* skip, unused field unused_dest8_feed_addr (dest8_feed_addr) */
	REG_DUMP_PRINT_1("   -dest8_feed_addr.dest8_feed_addr                                    |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x690e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_dest0_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid8_dest0_cur_cmds_type */
	/* skip, unused field unused_sid8_dest0_cur_cmds (sid8_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid8_dest0_cur_cmds.sid8_dest0_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x690e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_dest0_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid8_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid8_dest0_sync_state.sid8_dest0_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x690dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_dest0_cur_ack_line                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid8_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid8_dest0_cur_ack_line (sid8_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid8_dest0_cur_ack_line.sid8_dest0_cur_ack_line                    |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x690d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_dest0_cur_ack_unit_in_line                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid8_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid8_dest0_cur_ack_unit_in_line (sid8_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid8_dest0_cur_ack_unit_in_line.sid8_dest0_cur_ack_unit_in_line    |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x690d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_dest0_cur_ack_unit                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid8_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid8_dest0_cur_ack_unit (sid8_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid8_dest0_cur_ack_unit.sid8_dest0_cur_ack_unit                    |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x690cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_main_control_state                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid8_main_control_state_type */
	/* skip, unused field unused_sid8_main_control_state (sid8_main_control_state) */
	REG_DUMP_PRINT_1("   -sid8_main_control_state.sid8_main_control_state                    |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x690c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_s2m_cur_ack_line                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid8_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid8_s2m_cur_ack_line (sid8_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid8_s2m_cur_ack_line.sid8_s2m_cur_ack_line                        |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x690c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_s2m_cur_ack_unit_in_line                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid8_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid8_s2m_cur_ack_unit_in_line (sid8_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid8_s2m_cur_ack_unit_in_line.sid8_s2m_cur_ack_unit_in_line        |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x690c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_s2m_cur_cmds                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid8_s2m_cur_cmds_type */
	/* skip, unused field unused_sid8_s2m_cur_cmds (sid8_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid8_s2m_cur_cmds.sid8_s2m_cur_cmds                                |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x69098);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_error_reg                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid8_error_reg_type */
	REG_DUMP_PRINT_1("   -sid8_error_reg.sid8_error_reg                                      |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x69088);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_eventque_sidpid                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid8_eventque_sidpid_type */
	/* skip, unused field unused_sid8_eventque_sidpid (sid8_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid8_eventque_sidpid.sid8_eventque_sidpid                          |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x69084);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_ack_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid8_ack_addr_type */
	/* skip, unused field unused_sid8_ack_addr (sid8_ack_addr) */
	REG_DUMP_PRINT_1("   -sid8_ack_addr.sid8_ack_addr                                        |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x69068);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_dest0_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid8_dest0_enabled_type */
	/* skip, unused field unused_sid8_dest0_enabled (sid8_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid8_dest0_enabled.sid8_dest0_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 8""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6905c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_first_page_nr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid8_first_page_nr_type */
	/* skip, unused field unused_sid8_first_page_nr (sid8_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid8_first_page_nr.sid8_first_page_nr                              |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x69058);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_camera_select                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid8_camera_select_type */
	/* skip, unused field unused_sid8_camera_select (sid8_camera_select) */
	REG_DUMP_PRINT_1("   -sid8_camera_select.sid8_camera_select                              |        0x%02X  |  [RW][05:00]""SID proc belongs to this camera, used to determine which secure touch enable signal should be used. This is bit encoded, bit 0 belongs to camera 0, bit 1 to camera 1 etc.""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x69054);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_units_p_ibuf                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid8_units_p_ibuf_type */
	/* skip, unused field unused_sid8_units_p_ibuf (sid8_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid8_units_p_ibuf.sid8_units_p_ibuf                                |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x69050);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_unit_size                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid8_unit_size_type */
	/* skip, unused field unused_sid8_unit_size (sid8_unit_size) */
	REG_DUMP_PRINT_1("   -sid8_unit_size.sid8_unit_size                                      |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0x6904c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_lines_p_frame                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid8_lines_p_frame_type */
	/* skip, unused field unused_sid8_lines_p_frame (sid8_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid8_lines_p_frame.sid8_lines_p_frame                              |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x69048);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_units_p_line                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid8_units_p_line_type */
	/* skip, unused field unused_sid8_units_p_line (sid8_units_p_line) */
	REG_DUMP_PRINT_1("   -sid8_units_p_line.sid8_units_p_line                                |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x69044);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_str2mmio_store_cmd                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid8_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid8_str2mmio_store_cmd (sid8_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid8_str2mmio_store_cmd.sid8_str2mmio_store_cmd                    |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x69040);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_str2mmio_proc_addr                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid8_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid8_str2mmio_proc_addr (sid8_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid8_str2mmio_proc_addr.sid8_str2mmio_proc_addr                    |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68f58);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk7_token                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk7_token_type */
	REG_DUMP_PRINT_1("   -fr_chk7_token.fr_chk7_token                                        |  0x%08X  |  [RW][31:00]""The token that has to be written""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x68f54);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk7_addr                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk7_addr_type */
	/* skip, unused field unused_fr_chk7_addr (fr_chk7_addr) */
	REG_DUMP_PRINT_1("   -fr_chk7_addr.fr_chk7_addr                                          |  0x%08X  |  [RW][29:00]""The address of where the frame check token has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68f50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk7_trigger_repeat_val                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk7_trigger_repeat_val_type */
	/* skip, unused field unused_fr_chk7_trigger_repeat_val (fr_chk7_trigger_repeat_val) */
	REG_DUMP_PRINT_1("   -fr_chk7_trigger_repeat_val.fr_chk7_trigger_repeat_val              |      0x%04X  |  [RW][15:00]""An frame check token is send after each trigger_repeat_val value in case the repetitive enable bit in the check mode is set and the trigger offset has been reached.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x68f4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk7_trigger_offset                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk7_trigger_offset_type */
	/* skip, unused field unused_fr_chk7_trigger_offset (fr_chk7_trigger_offset) */
	REG_DUMP_PRINT_1("   -fr_chk7_trigger_offset.fr_chk7_trigger_offset                      |      0x%04X  |  [RW][15:00]""The value of the trigger, when the checked value becomes larger than the this value a frame check token is send""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x68f48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk7_sid_proc_id                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk7_sid_proc_id_type */
	/* skip, unused field unused_fr_chk7_sid_proc_id (fr_chk7_sid_proc_id) */
	REG_DUMP_PRINT_1("   -fr_chk7_sid_proc_id.fr_chk7_sid_proc_id                            |         0x%01X  |  [RW][03:00]""The ID of the SID proc that has to be checked""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x68f44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk7_check_mode                                         |  0x%08X  |  ""The mode of frame checking""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk7_check_mode_type */
	/* skip, unused field unused_fr_chk7_check_mode (fr_chk7_check_mode) */
	REG_DUMP_PRINT_1("   -fr_chk7_check_mode.check_type                                      |         0x%01X  |  [RW][00:00]""The type of value to be checking, 0: check lines; 1: check units;""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -fr_chk7_check_mode.repetive_enable                                 |         0x%01X  |  [RW][01:01]""Trigger and send and token after each repetitive value after the trigger offset is reached""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0x68f40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk7_enable                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk7_enable_type */
	/* skip, unused field unused_fr_chk7_enable (fr_chk7_enable) */
	REG_DUMP_PRINT_1("   -fr_chk7_enable.fr_chk7_enable                                      |         0x%01X  |  [RW][00:00]""Enable frame checking for this frame check unit""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x68f24);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest7_iwake_threshold                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest7_iwake_threshold_type */
	/* skip, unused field unused_dest7_iwake_threshold (dest7_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest7_iwake_threshold.dest7_iwake_threshold                        |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x68f1c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest7_st_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest7_st_addr_type */
	REG_DUMP_PRINT_1("   -dest7_st_addr.dest7_st_addr                                        |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x68f18);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest7_dest_mode                                            |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest7_dest_mode_type */
	/* skip, unused field unused_dest7_dest_mode (dest7_dest_mode) */
	REG_DUMP_PRINT_1("   -dest7_dest_mode.is_ibuf_cntrl_feeder                               |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest7_dest_mode.config_dma                                         |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest7_dest_mode.iwake_enable                                       |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest7_dest_mode.disable_spana_rst                                  |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest7_dest_mode.disable_spanb_rst                                  |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x68f14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest7_term_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest7_term_b_addr_type */
	/* skip, unused field unused_dest7_term_b_addr (dest7_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest7_term_b_addr.dest7_term_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68f10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest7_span_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest7_span_b_addr_type */
	/* skip, unused field unused_dest7_span_b_addr (dest7_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest7_span_b_addr.dest7_span_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68f0c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest7_span_a_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest7_span_a_addr_type */
	/* skip, unused field unused_dest7_span_a_addr (dest7_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest7_span_a_addr.dest7_span_a_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68f08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest7_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest7_channel_addr_type */
	/* skip, unused field unused_dest7_channel_addr (dest7_channel_addr) */
	REG_DUMP_PRINT_1("   -dest7_channel_addr.dest7_channel_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68f04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest7_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest7_requester_addr_type */
	/* skip, unused field unused_dest7_requester_addr (dest7_requester_addr) */
	REG_DUMP_PRINT_1("   -dest7_requester_addr.dest7_requester_addr                          |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68f00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest7_feed_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest7_feed_addr_type */
	/* skip, unused field unused_dest7_feed_addr (dest7_feed_addr) */
	REG_DUMP_PRINT_1("   -dest7_feed_addr.dest7_feed_addr                                    |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68eec);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_dest1_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid7_dest1_cur_cmds_type */
	/* skip, unused field unused_sid7_dest1_cur_cmds (sid7_dest1_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid7_dest1_cur_cmds.sid7_dest1_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x68ee8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_dest1_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid7_dest1_sync_state_type */
	REG_DUMP_PRINT_1("   -sid7_dest1_sync_state.sid7_dest1_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 1. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x68ee4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_dest0_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid7_dest0_cur_cmds_type */
	/* skip, unused field unused_sid7_dest0_cur_cmds (sid7_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid7_dest0_cur_cmds.sid7_dest0_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x68ee0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_dest0_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid7_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid7_dest0_sync_state.sid7_dest0_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x68edc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_dest0_cur_ack_line                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid7_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid7_dest0_cur_ack_line (sid7_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid7_dest0_cur_ack_line.sid7_dest0_cur_ack_line                    |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x68ed8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_dest0_cur_ack_unit_in_line                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid7_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid7_dest0_cur_ack_unit_in_line (sid7_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid7_dest0_cur_ack_unit_in_line.sid7_dest0_cur_ack_unit_in_line    |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x68ed4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_dest0_cur_ack_unit                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid7_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid7_dest0_cur_ack_unit (sid7_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid7_dest0_cur_ack_unit.sid7_dest0_cur_ack_unit                    |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x68ecc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_main_control_state                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid7_main_control_state_type */
	/* skip, unused field unused_sid7_main_control_state (sid7_main_control_state) */
	REG_DUMP_PRINT_1("   -sid7_main_control_state.sid7_main_control_state                    |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x68ec8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_s2m_cur_ack_line                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid7_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid7_s2m_cur_ack_line (sid7_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid7_s2m_cur_ack_line.sid7_s2m_cur_ack_line                        |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x68ec4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_s2m_cur_ack_unit_in_line                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid7_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid7_s2m_cur_ack_unit_in_line (sid7_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid7_s2m_cur_ack_unit_in_line.sid7_s2m_cur_ack_unit_in_line        |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x68ec0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_s2m_cur_cmds                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid7_s2m_cur_cmds_type */
	/* skip, unused field unused_sid7_s2m_cur_cmds (sid7_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid7_s2m_cur_cmds.sid7_s2m_cur_cmds                                |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x68e98);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_error_reg                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid7_error_reg_type */
	REG_DUMP_PRINT_1("   -sid7_error_reg.sid7_error_reg                                      |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x68e88);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_eventque_sidpid                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid7_eventque_sidpid_type */
	/* skip, unused field unused_sid7_eventque_sidpid (sid7_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid7_eventque_sidpid.sid7_eventque_sidpid                          |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x68e84);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_ack_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid7_ack_addr_type */
	/* skip, unused field unused_sid7_ack_addr (sid7_ack_addr) */
	REG_DUMP_PRINT_1("   -sid7_ack_addr.sid7_ack_addr                                        |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68e6c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_dest1_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid7_dest1_enabled_type */
	/* skip, unused field unused_sid7_dest1_enabled (sid7_dest1_enabled) */
	REG_DUMP_PRINT_1("   -sid7_dest1_enabled.sid7_dest1_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 1 is enabled, not present when only one destination sync is there for SID proc 7""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x68e68);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_dest0_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid7_dest0_enabled_type */
	/* skip, unused field unused_sid7_dest0_enabled (sid7_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid7_dest0_enabled.sid7_dest0_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 7""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x68e5c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_first_page_nr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid7_first_page_nr_type */
	/* skip, unused field unused_sid7_first_page_nr (sid7_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid7_first_page_nr.sid7_first_page_nr                              |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x68e58);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_camera_select                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid7_camera_select_type */
	/* skip, unused field unused_sid7_camera_select (sid7_camera_select) */
	REG_DUMP_PRINT_1("   -sid7_camera_select.sid7_camera_select                              |        0x%02X  |  [RW][05:00]""SID proc belongs to this camera, used to determine which secure touch enable signal should be used. This is bit encoded, bit 0 belongs to camera 0, bit 1 to camera 1 etc.""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x68e54);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_units_p_ibuf                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid7_units_p_ibuf_type */
	/* skip, unused field unused_sid7_units_p_ibuf (sid7_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid7_units_p_ibuf.sid7_units_p_ibuf                                |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x68e50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_unit_size                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid7_unit_size_type */
	/* skip, unused field unused_sid7_unit_size (sid7_unit_size) */
	REG_DUMP_PRINT_1("   -sid7_unit_size.sid7_unit_size                                      |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0x68e4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_lines_p_frame                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid7_lines_p_frame_type */
	/* skip, unused field unused_sid7_lines_p_frame (sid7_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid7_lines_p_frame.sid7_lines_p_frame                              |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x68e48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_units_p_line                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid7_units_p_line_type */
	/* skip, unused field unused_sid7_units_p_line (sid7_units_p_line) */
	REG_DUMP_PRINT_1("   -sid7_units_p_line.sid7_units_p_line                                |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x68e44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_str2mmio_store_cmd                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid7_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid7_str2mmio_store_cmd (sid7_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid7_str2mmio_store_cmd.sid7_str2mmio_store_cmd                    |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x68e40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_str2mmio_proc_addr                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid7_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid7_str2mmio_proc_addr (sid7_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid7_str2mmio_proc_addr.sid7_str2mmio_proc_addr                    |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68d58);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk6_token                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk6_token_type */
	REG_DUMP_PRINT_1("   -fr_chk6_token.fr_chk6_token                                        |  0x%08X  |  [RW][31:00]""The token that has to be written""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x68d54);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk6_addr                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk6_addr_type */
	/* skip, unused field unused_fr_chk6_addr (fr_chk6_addr) */
	REG_DUMP_PRINT_1("   -fr_chk6_addr.fr_chk6_addr                                          |  0x%08X  |  [RW][29:00]""The address of where the frame check token has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68d50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk6_trigger_repeat_val                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk6_trigger_repeat_val_type */
	/* skip, unused field unused_fr_chk6_trigger_repeat_val (fr_chk6_trigger_repeat_val) */
	REG_DUMP_PRINT_1("   -fr_chk6_trigger_repeat_val.fr_chk6_trigger_repeat_val              |      0x%04X  |  [RW][15:00]""An frame check token is send after each trigger_repeat_val value in case the repetitive enable bit in the check mode is set and the trigger offset has been reached.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x68d4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk6_trigger_offset                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk6_trigger_offset_type */
	/* skip, unused field unused_fr_chk6_trigger_offset (fr_chk6_trigger_offset) */
	REG_DUMP_PRINT_1("   -fr_chk6_trigger_offset.fr_chk6_trigger_offset                      |      0x%04X  |  [RW][15:00]""The value of the trigger, when the checked value becomes larger than the this value a frame check token is send""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x68d48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk6_sid_proc_id                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk6_sid_proc_id_type */
	/* skip, unused field unused_fr_chk6_sid_proc_id (fr_chk6_sid_proc_id) */
	REG_DUMP_PRINT_1("   -fr_chk6_sid_proc_id.fr_chk6_sid_proc_id                            |         0x%01X  |  [RW][03:00]""The ID of the SID proc that has to be checked""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x68d44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk6_check_mode                                         |  0x%08X  |  ""The mode of frame checking""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk6_check_mode_type */
	/* skip, unused field unused_fr_chk6_check_mode (fr_chk6_check_mode) */
	REG_DUMP_PRINT_1("   -fr_chk6_check_mode.check_type                                      |         0x%01X  |  [RW][00:00]""The type of value to be checking, 0: check lines; 1: check units;""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -fr_chk6_check_mode.repetive_enable                                 |         0x%01X  |  [RW][01:01]""Trigger and send and token after each repetitive value after the trigger offset is reached""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0x68d40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk6_enable                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk6_enable_type */
	/* skip, unused field unused_fr_chk6_enable (fr_chk6_enable) */
	REG_DUMP_PRINT_1("   -fr_chk6_enable.fr_chk6_enable                                      |         0x%01X  |  [RW][00:00]""Enable frame checking for this frame check unit""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x68d24);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest6_iwake_threshold                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest6_iwake_threshold_type */
	/* skip, unused field unused_dest6_iwake_threshold (dest6_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest6_iwake_threshold.dest6_iwake_threshold                        |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x68d1c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest6_st_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest6_st_addr_type */
	REG_DUMP_PRINT_1("   -dest6_st_addr.dest6_st_addr                                        |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x68d18);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest6_dest_mode                                            |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest6_dest_mode_type */
	/* skip, unused field unused_dest6_dest_mode (dest6_dest_mode) */
	REG_DUMP_PRINT_1("   -dest6_dest_mode.is_ibuf_cntrl_feeder                               |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest6_dest_mode.config_dma                                         |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest6_dest_mode.iwake_enable                                       |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest6_dest_mode.disable_spana_rst                                  |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest6_dest_mode.disable_spanb_rst                                  |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x68d14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest6_term_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest6_term_b_addr_type */
	/* skip, unused field unused_dest6_term_b_addr (dest6_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest6_term_b_addr.dest6_term_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68d10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest6_span_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest6_span_b_addr_type */
	/* skip, unused field unused_dest6_span_b_addr (dest6_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest6_span_b_addr.dest6_span_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68d0c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest6_span_a_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest6_span_a_addr_type */
	/* skip, unused field unused_dest6_span_a_addr (dest6_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest6_span_a_addr.dest6_span_a_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68d08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest6_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest6_channel_addr_type */
	/* skip, unused field unused_dest6_channel_addr (dest6_channel_addr) */
	REG_DUMP_PRINT_1("   -dest6_channel_addr.dest6_channel_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68d04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest6_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest6_requester_addr_type */
	/* skip, unused field unused_dest6_requester_addr (dest6_requester_addr) */
	REG_DUMP_PRINT_1("   -dest6_requester_addr.dest6_requester_addr                          |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68d00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest6_feed_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest6_feed_addr_type */
	/* skip, unused field unused_dest6_feed_addr (dest6_feed_addr) */
	REG_DUMP_PRINT_1("   -dest6_feed_addr.dest6_feed_addr                                    |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68cec);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_dest1_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid6_dest1_cur_cmds_type */
	/* skip, unused field unused_sid6_dest1_cur_cmds (sid6_dest1_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid6_dest1_cur_cmds.sid6_dest1_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x68ce8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_dest1_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid6_dest1_sync_state_type */
	REG_DUMP_PRINT_1("   -sid6_dest1_sync_state.sid6_dest1_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 1. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x68ce4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_dest0_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid6_dest0_cur_cmds_type */
	/* skip, unused field unused_sid6_dest0_cur_cmds (sid6_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid6_dest0_cur_cmds.sid6_dest0_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x68ce0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_dest0_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid6_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid6_dest0_sync_state.sid6_dest0_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x68cdc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_dest0_cur_ack_line                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid6_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid6_dest0_cur_ack_line (sid6_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid6_dest0_cur_ack_line.sid6_dest0_cur_ack_line                    |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x68cd8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_dest0_cur_ack_unit_in_line                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid6_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid6_dest0_cur_ack_unit_in_line (sid6_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid6_dest0_cur_ack_unit_in_line.sid6_dest0_cur_ack_unit_in_line    |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x68cd4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_dest0_cur_ack_unit                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid6_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid6_dest0_cur_ack_unit (sid6_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid6_dest0_cur_ack_unit.sid6_dest0_cur_ack_unit                    |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x68ccc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_main_control_state                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid6_main_control_state_type */
	/* skip, unused field unused_sid6_main_control_state (sid6_main_control_state) */
	REG_DUMP_PRINT_1("   -sid6_main_control_state.sid6_main_control_state                    |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x68cc8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_s2m_cur_ack_line                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid6_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid6_s2m_cur_ack_line (sid6_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid6_s2m_cur_ack_line.sid6_s2m_cur_ack_line                        |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x68cc4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_s2m_cur_ack_unit_in_line                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid6_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid6_s2m_cur_ack_unit_in_line (sid6_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid6_s2m_cur_ack_unit_in_line.sid6_s2m_cur_ack_unit_in_line        |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x68cc0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_s2m_cur_cmds                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid6_s2m_cur_cmds_type */
	/* skip, unused field unused_sid6_s2m_cur_cmds (sid6_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid6_s2m_cur_cmds.sid6_s2m_cur_cmds                                |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x68c98);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_error_reg                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid6_error_reg_type */
	REG_DUMP_PRINT_1("   -sid6_error_reg.sid6_error_reg                                      |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x68c88);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_eventque_sidpid                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid6_eventque_sidpid_type */
	/* skip, unused field unused_sid6_eventque_sidpid (sid6_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid6_eventque_sidpid.sid6_eventque_sidpid                          |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x68c84);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_ack_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid6_ack_addr_type */
	/* skip, unused field unused_sid6_ack_addr (sid6_ack_addr) */
	REG_DUMP_PRINT_1("   -sid6_ack_addr.sid6_ack_addr                                        |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68c6c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_dest1_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid6_dest1_enabled_type */
	/* skip, unused field unused_sid6_dest1_enabled (sid6_dest1_enabled) */
	REG_DUMP_PRINT_1("   -sid6_dest1_enabled.sid6_dest1_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 1 is enabled, not present when only one destination sync is there for SID proc 6""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x68c68);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_dest0_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid6_dest0_enabled_type */
	/* skip, unused field unused_sid6_dest0_enabled (sid6_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid6_dest0_enabled.sid6_dest0_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 6""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x68c5c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_first_page_nr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid6_first_page_nr_type */
	/* skip, unused field unused_sid6_first_page_nr (sid6_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid6_first_page_nr.sid6_first_page_nr                              |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x68c58);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_camera_select                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid6_camera_select_type */
	/* skip, unused field unused_sid6_camera_select (sid6_camera_select) */
	REG_DUMP_PRINT_1("   -sid6_camera_select.sid6_camera_select                              |        0x%02X  |  [RW][05:00]""SID proc belongs to this camera, used to determine which secure touch enable signal should be used. This is bit encoded, bit 0 belongs to camera 0, bit 1 to camera 1 etc.""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x68c54);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_units_p_ibuf                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid6_units_p_ibuf_type */
	/* skip, unused field unused_sid6_units_p_ibuf (sid6_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid6_units_p_ibuf.sid6_units_p_ibuf                                |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x68c50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_unit_size                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid6_unit_size_type */
	/* skip, unused field unused_sid6_unit_size (sid6_unit_size) */
	REG_DUMP_PRINT_1("   -sid6_unit_size.sid6_unit_size                                      |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0x68c4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_lines_p_frame                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid6_lines_p_frame_type */
	/* skip, unused field unused_sid6_lines_p_frame (sid6_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid6_lines_p_frame.sid6_lines_p_frame                              |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x68c48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_units_p_line                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid6_units_p_line_type */
	/* skip, unused field unused_sid6_units_p_line (sid6_units_p_line) */
	REG_DUMP_PRINT_1("   -sid6_units_p_line.sid6_units_p_line                                |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x68c44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_str2mmio_store_cmd                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid6_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid6_str2mmio_store_cmd (sid6_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid6_str2mmio_store_cmd.sid6_str2mmio_store_cmd                    |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x68c40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_str2mmio_proc_addr                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid6_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid6_str2mmio_proc_addr (sid6_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid6_str2mmio_proc_addr.sid6_str2mmio_proc_addr                    |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68b58);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk5_token                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk5_token_type */
	REG_DUMP_PRINT_1("   -fr_chk5_token.fr_chk5_token                                        |  0x%08X  |  [RW][31:00]""The token that has to be written""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x68b54);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk5_addr                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk5_addr_type */
	/* skip, unused field unused_fr_chk5_addr (fr_chk5_addr) */
	REG_DUMP_PRINT_1("   -fr_chk5_addr.fr_chk5_addr                                          |  0x%08X  |  [RW][29:00]""The address of where the frame check token has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68b50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk5_trigger_repeat_val                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk5_trigger_repeat_val_type */
	/* skip, unused field unused_fr_chk5_trigger_repeat_val (fr_chk5_trigger_repeat_val) */
	REG_DUMP_PRINT_1("   -fr_chk5_trigger_repeat_val.fr_chk5_trigger_repeat_val              |      0x%04X  |  [RW][15:00]""An frame check token is send after each trigger_repeat_val value in case the repetitive enable bit in the check mode is set and the trigger offset has been reached.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x68b4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk5_trigger_offset                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk5_trigger_offset_type */
	/* skip, unused field unused_fr_chk5_trigger_offset (fr_chk5_trigger_offset) */
	REG_DUMP_PRINT_1("   -fr_chk5_trigger_offset.fr_chk5_trigger_offset                      |      0x%04X  |  [RW][15:00]""The value of the trigger, when the checked value becomes larger than the this value a frame check token is send""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x68b48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk5_sid_proc_id                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk5_sid_proc_id_type */
	/* skip, unused field unused_fr_chk5_sid_proc_id (fr_chk5_sid_proc_id) */
	REG_DUMP_PRINT_1("   -fr_chk5_sid_proc_id.fr_chk5_sid_proc_id                            |         0x%01X  |  [RW][03:00]""The ID of the SID proc that has to be checked""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x68b44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk5_check_mode                                         |  0x%08X  |  ""The mode of frame checking""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk5_check_mode_type */
	/* skip, unused field unused_fr_chk5_check_mode (fr_chk5_check_mode) */
	REG_DUMP_PRINT_1("   -fr_chk5_check_mode.check_type                                      |         0x%01X  |  [RW][00:00]""The type of value to be checking, 0: check lines; 1: check units;""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -fr_chk5_check_mode.repetive_enable                                 |         0x%01X  |  [RW][01:01]""Trigger and send and token after each repetitive value after the trigger offset is reached""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0x68b40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk5_enable                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk5_enable_type */
	/* skip, unused field unused_fr_chk5_enable (fr_chk5_enable) */
	REG_DUMP_PRINT_1("   -fr_chk5_enable.fr_chk5_enable                                      |         0x%01X  |  [RW][00:00]""Enable frame checking for this frame check unit""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x68b24);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest5_iwake_threshold                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest5_iwake_threshold_type */
	/* skip, unused field unused_dest5_iwake_threshold (dest5_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest5_iwake_threshold.dest5_iwake_threshold                        |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x68b1c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest5_st_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest5_st_addr_type */
	REG_DUMP_PRINT_1("   -dest5_st_addr.dest5_st_addr                                        |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x68b18);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest5_dest_mode                                            |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest5_dest_mode_type */
	/* skip, unused field unused_dest5_dest_mode (dest5_dest_mode) */
	REG_DUMP_PRINT_1("   -dest5_dest_mode.is_ibuf_cntrl_feeder                               |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest5_dest_mode.config_dma                                         |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest5_dest_mode.iwake_enable                                       |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest5_dest_mode.disable_spana_rst                                  |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest5_dest_mode.disable_spanb_rst                                  |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x68b14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest5_term_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest5_term_b_addr_type */
	/* skip, unused field unused_dest5_term_b_addr (dest5_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest5_term_b_addr.dest5_term_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68b10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest5_span_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest5_span_b_addr_type */
	/* skip, unused field unused_dest5_span_b_addr (dest5_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest5_span_b_addr.dest5_span_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68b0c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest5_span_a_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest5_span_a_addr_type */
	/* skip, unused field unused_dest5_span_a_addr (dest5_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest5_span_a_addr.dest5_span_a_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68b08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest5_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest5_channel_addr_type */
	/* skip, unused field unused_dest5_channel_addr (dest5_channel_addr) */
	REG_DUMP_PRINT_1("   -dest5_channel_addr.dest5_channel_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68b04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest5_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest5_requester_addr_type */
	/* skip, unused field unused_dest5_requester_addr (dest5_requester_addr) */
	REG_DUMP_PRINT_1("   -dest5_requester_addr.dest5_requester_addr                          |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68b00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest5_feed_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest5_feed_addr_type */
	/* skip, unused field unused_dest5_feed_addr (dest5_feed_addr) */
	REG_DUMP_PRINT_1("   -dest5_feed_addr.dest5_feed_addr                                    |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68aec);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_dest1_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid5_dest1_cur_cmds_type */
	/* skip, unused field unused_sid5_dest1_cur_cmds (sid5_dest1_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid5_dest1_cur_cmds.sid5_dest1_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x68ae8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_dest1_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid5_dest1_sync_state_type */
	REG_DUMP_PRINT_1("   -sid5_dest1_sync_state.sid5_dest1_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 1. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x68ae4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_dest0_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid5_dest0_cur_cmds_type */
	/* skip, unused field unused_sid5_dest0_cur_cmds (sid5_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid5_dest0_cur_cmds.sid5_dest0_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x68ae0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_dest0_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid5_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid5_dest0_sync_state.sid5_dest0_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x68adc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_dest0_cur_ack_line                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid5_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid5_dest0_cur_ack_line (sid5_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid5_dest0_cur_ack_line.sid5_dest0_cur_ack_line                    |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x68ad8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_dest0_cur_ack_unit_in_line                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid5_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid5_dest0_cur_ack_unit_in_line (sid5_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid5_dest0_cur_ack_unit_in_line.sid5_dest0_cur_ack_unit_in_line    |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x68ad4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_dest0_cur_ack_unit                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid5_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid5_dest0_cur_ack_unit (sid5_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid5_dest0_cur_ack_unit.sid5_dest0_cur_ack_unit                    |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x68acc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_main_control_state                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid5_main_control_state_type */
	/* skip, unused field unused_sid5_main_control_state (sid5_main_control_state) */
	REG_DUMP_PRINT_1("   -sid5_main_control_state.sid5_main_control_state                    |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x68ac8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_s2m_cur_ack_line                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid5_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid5_s2m_cur_ack_line (sid5_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid5_s2m_cur_ack_line.sid5_s2m_cur_ack_line                        |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x68ac4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_s2m_cur_ack_unit_in_line                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid5_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid5_s2m_cur_ack_unit_in_line (sid5_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid5_s2m_cur_ack_unit_in_line.sid5_s2m_cur_ack_unit_in_line        |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x68ac0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_s2m_cur_cmds                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid5_s2m_cur_cmds_type */
	/* skip, unused field unused_sid5_s2m_cur_cmds (sid5_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid5_s2m_cur_cmds.sid5_s2m_cur_cmds                                |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x68a98);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_error_reg                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid5_error_reg_type */
	REG_DUMP_PRINT_1("   -sid5_error_reg.sid5_error_reg                                      |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x68a88);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_eventque_sidpid                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid5_eventque_sidpid_type */
	/* skip, unused field unused_sid5_eventque_sidpid (sid5_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid5_eventque_sidpid.sid5_eventque_sidpid                          |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x68a84);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_ack_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid5_ack_addr_type */
	/* skip, unused field unused_sid5_ack_addr (sid5_ack_addr) */
	REG_DUMP_PRINT_1("   -sid5_ack_addr.sid5_ack_addr                                        |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68a6c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_dest1_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid5_dest1_enabled_type */
	/* skip, unused field unused_sid5_dest1_enabled (sid5_dest1_enabled) */
	REG_DUMP_PRINT_1("   -sid5_dest1_enabled.sid5_dest1_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 1 is enabled, not present when only one destination sync is there for SID proc 5""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x68a68);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_dest0_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid5_dest0_enabled_type */
	/* skip, unused field unused_sid5_dest0_enabled (sid5_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid5_dest0_enabled.sid5_dest0_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 5""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x68a5c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_first_page_nr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid5_first_page_nr_type */
	/* skip, unused field unused_sid5_first_page_nr (sid5_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid5_first_page_nr.sid5_first_page_nr                              |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x68a58);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_camera_select                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid5_camera_select_type */
	/* skip, unused field unused_sid5_camera_select (sid5_camera_select) */
	REG_DUMP_PRINT_1("   -sid5_camera_select.sid5_camera_select                              |        0x%02X  |  [RW][05:00]""SID proc belongs to this camera, used to determine which secure touch enable signal should be used. This is bit encoded, bit 0 belongs to camera 0, bit 1 to camera 1 etc.""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x68a54);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_units_p_ibuf                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid5_units_p_ibuf_type */
	/* skip, unused field unused_sid5_units_p_ibuf (sid5_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid5_units_p_ibuf.sid5_units_p_ibuf                                |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x68a50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_unit_size                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid5_unit_size_type */
	/* skip, unused field unused_sid5_unit_size (sid5_unit_size) */
	REG_DUMP_PRINT_1("   -sid5_unit_size.sid5_unit_size                                      |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0x68a4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_lines_p_frame                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid5_lines_p_frame_type */
	/* skip, unused field unused_sid5_lines_p_frame (sid5_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid5_lines_p_frame.sid5_lines_p_frame                              |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x68a48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_units_p_line                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid5_units_p_line_type */
	/* skip, unused field unused_sid5_units_p_line (sid5_units_p_line) */
	REG_DUMP_PRINT_1("   -sid5_units_p_line.sid5_units_p_line                                |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x68a44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_str2mmio_store_cmd                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid5_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid5_str2mmio_store_cmd (sid5_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid5_str2mmio_store_cmd.sid5_str2mmio_store_cmd                    |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x68a40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_str2mmio_proc_addr                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid5_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid5_str2mmio_proc_addr (sid5_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid5_str2mmio_proc_addr.sid5_str2mmio_proc_addr                    |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68958);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk4_token                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk4_token_type */
	REG_DUMP_PRINT_1("   -fr_chk4_token.fr_chk4_token                                        |  0x%08X  |  [RW][31:00]""The token that has to be written""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x68954);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk4_addr                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk4_addr_type */
	/* skip, unused field unused_fr_chk4_addr (fr_chk4_addr) */
	REG_DUMP_PRINT_1("   -fr_chk4_addr.fr_chk4_addr                                          |  0x%08X  |  [RW][29:00]""The address of where the frame check token has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68950);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk4_trigger_repeat_val                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk4_trigger_repeat_val_type */
	/* skip, unused field unused_fr_chk4_trigger_repeat_val (fr_chk4_trigger_repeat_val) */
	REG_DUMP_PRINT_1("   -fr_chk4_trigger_repeat_val.fr_chk4_trigger_repeat_val              |      0x%04X  |  [RW][15:00]""An frame check token is send after each trigger_repeat_val value in case the repetitive enable bit in the check mode is set and the trigger offset has been reached.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x6894c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk4_trigger_offset                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk4_trigger_offset_type */
	/* skip, unused field unused_fr_chk4_trigger_offset (fr_chk4_trigger_offset) */
	REG_DUMP_PRINT_1("   -fr_chk4_trigger_offset.fr_chk4_trigger_offset                      |      0x%04X  |  [RW][15:00]""The value of the trigger, when the checked value becomes larger than the this value a frame check token is send""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x68948);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk4_sid_proc_id                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk4_sid_proc_id_type */
	/* skip, unused field unused_fr_chk4_sid_proc_id (fr_chk4_sid_proc_id) */
	REG_DUMP_PRINT_1("   -fr_chk4_sid_proc_id.fr_chk4_sid_proc_id                            |         0x%01X  |  [RW][03:00]""The ID of the SID proc that has to be checked""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x68944);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk4_check_mode                                         |  0x%08X  |  ""The mode of frame checking""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk4_check_mode_type */
	/* skip, unused field unused_fr_chk4_check_mode (fr_chk4_check_mode) */
	REG_DUMP_PRINT_1("   -fr_chk4_check_mode.check_type                                      |         0x%01X  |  [RW][00:00]""The type of value to be checking, 0: check lines; 1: check units;""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -fr_chk4_check_mode.repetive_enable                                 |         0x%01X  |  [RW][01:01]""Trigger and send and token after each repetitive value after the trigger offset is reached""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0x68940);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk4_enable                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk4_enable_type */
	/* skip, unused field unused_fr_chk4_enable (fr_chk4_enable) */
	REG_DUMP_PRINT_1("   -fr_chk4_enable.fr_chk4_enable                                      |         0x%01X  |  [RW][00:00]""Enable frame checking for this frame check unit""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x68924);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest4_iwake_threshold                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest4_iwake_threshold_type */
	/* skip, unused field unused_dest4_iwake_threshold (dest4_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest4_iwake_threshold.dest4_iwake_threshold                        |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6891c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest4_st_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest4_st_addr_type */
	REG_DUMP_PRINT_1("   -dest4_st_addr.dest4_st_addr                                        |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x68918);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest4_dest_mode                                            |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest4_dest_mode_type */
	/* skip, unused field unused_dest4_dest_mode (dest4_dest_mode) */
	REG_DUMP_PRINT_1("   -dest4_dest_mode.is_ibuf_cntrl_feeder                               |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest4_dest_mode.config_dma                                         |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest4_dest_mode.iwake_enable                                       |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest4_dest_mode.disable_spana_rst                                  |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest4_dest_mode.disable_spanb_rst                                  |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x68914);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest4_term_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest4_term_b_addr_type */
	/* skip, unused field unused_dest4_term_b_addr (dest4_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest4_term_b_addr.dest4_term_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68910);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest4_span_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest4_span_b_addr_type */
	/* skip, unused field unused_dest4_span_b_addr (dest4_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest4_span_b_addr.dest4_span_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6890c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest4_span_a_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest4_span_a_addr_type */
	/* skip, unused field unused_dest4_span_a_addr (dest4_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest4_span_a_addr.dest4_span_a_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68908);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest4_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest4_channel_addr_type */
	/* skip, unused field unused_dest4_channel_addr (dest4_channel_addr) */
	REG_DUMP_PRINT_1("   -dest4_channel_addr.dest4_channel_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68904);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest4_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest4_requester_addr_type */
	/* skip, unused field unused_dest4_requester_addr (dest4_requester_addr) */
	REG_DUMP_PRINT_1("   -dest4_requester_addr.dest4_requester_addr                          |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68900);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest4_feed_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest4_feed_addr_type */
	/* skip, unused field unused_dest4_feed_addr (dest4_feed_addr) */
	REG_DUMP_PRINT_1("   -dest4_feed_addr.dest4_feed_addr                                    |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x688ec);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_dest1_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid4_dest1_cur_cmds_type */
	/* skip, unused field unused_sid4_dest1_cur_cmds (sid4_dest1_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid4_dest1_cur_cmds.sid4_dest1_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x688e8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_dest1_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid4_dest1_sync_state_type */
	REG_DUMP_PRINT_1("   -sid4_dest1_sync_state.sid4_dest1_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 1. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x688e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_dest0_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid4_dest0_cur_cmds_type */
	/* skip, unused field unused_sid4_dest0_cur_cmds (sid4_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid4_dest0_cur_cmds.sid4_dest0_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x688e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_dest0_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid4_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid4_dest0_sync_state.sid4_dest0_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x688dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_dest0_cur_ack_line                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid4_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid4_dest0_cur_ack_line (sid4_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid4_dest0_cur_ack_line.sid4_dest0_cur_ack_line                    |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x688d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_dest0_cur_ack_unit_in_line                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid4_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid4_dest0_cur_ack_unit_in_line (sid4_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid4_dest0_cur_ack_unit_in_line.sid4_dest0_cur_ack_unit_in_line    |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x688d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_dest0_cur_ack_unit                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid4_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid4_dest0_cur_ack_unit (sid4_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid4_dest0_cur_ack_unit.sid4_dest0_cur_ack_unit                    |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x688cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_main_control_state                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid4_main_control_state_type */
	/* skip, unused field unused_sid4_main_control_state (sid4_main_control_state) */
	REG_DUMP_PRINT_1("   -sid4_main_control_state.sid4_main_control_state                    |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x688c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_s2m_cur_ack_line                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid4_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid4_s2m_cur_ack_line (sid4_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid4_s2m_cur_ack_line.sid4_s2m_cur_ack_line                        |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x688c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_s2m_cur_ack_unit_in_line                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid4_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid4_s2m_cur_ack_unit_in_line (sid4_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid4_s2m_cur_ack_unit_in_line.sid4_s2m_cur_ack_unit_in_line        |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x688c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_s2m_cur_cmds                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid4_s2m_cur_cmds_type */
	/* skip, unused field unused_sid4_s2m_cur_cmds (sid4_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid4_s2m_cur_cmds.sid4_s2m_cur_cmds                                |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x68898);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_error_reg                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid4_error_reg_type */
	REG_DUMP_PRINT_1("   -sid4_error_reg.sid4_error_reg                                      |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x68888);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_eventque_sidpid                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid4_eventque_sidpid_type */
	/* skip, unused field unused_sid4_eventque_sidpid (sid4_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid4_eventque_sidpid.sid4_eventque_sidpid                          |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x68884);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_ack_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid4_ack_addr_type */
	/* skip, unused field unused_sid4_ack_addr (sid4_ack_addr) */
	REG_DUMP_PRINT_1("   -sid4_ack_addr.sid4_ack_addr                                        |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6886c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_dest1_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid4_dest1_enabled_type */
	/* skip, unused field unused_sid4_dest1_enabled (sid4_dest1_enabled) */
	REG_DUMP_PRINT_1("   -sid4_dest1_enabled.sid4_dest1_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 1 is enabled, not present when only one destination sync is there for SID proc 4""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x68868);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_dest0_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid4_dest0_enabled_type */
	/* skip, unused field unused_sid4_dest0_enabled (sid4_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid4_dest0_enabled.sid4_dest0_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 4""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6885c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_first_page_nr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid4_first_page_nr_type */
	/* skip, unused field unused_sid4_first_page_nr (sid4_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid4_first_page_nr.sid4_first_page_nr                              |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x68858);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_camera_select                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid4_camera_select_type */
	/* skip, unused field unused_sid4_camera_select (sid4_camera_select) */
	REG_DUMP_PRINT_1("   -sid4_camera_select.sid4_camera_select                              |        0x%02X  |  [RW][05:00]""SID proc belongs to this camera, used to determine which secure touch enable signal should be used. This is bit encoded, bit 0 belongs to camera 0, bit 1 to camera 1 etc.""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x68854);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_units_p_ibuf                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid4_units_p_ibuf_type */
	/* skip, unused field unused_sid4_units_p_ibuf (sid4_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid4_units_p_ibuf.sid4_units_p_ibuf                                |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x68850);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_unit_size                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid4_unit_size_type */
	/* skip, unused field unused_sid4_unit_size (sid4_unit_size) */
	REG_DUMP_PRINT_1("   -sid4_unit_size.sid4_unit_size                                      |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0x6884c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_lines_p_frame                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid4_lines_p_frame_type */
	/* skip, unused field unused_sid4_lines_p_frame (sid4_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid4_lines_p_frame.sid4_lines_p_frame                              |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x68848);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_units_p_line                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid4_units_p_line_type */
	/* skip, unused field unused_sid4_units_p_line (sid4_units_p_line) */
	REG_DUMP_PRINT_1("   -sid4_units_p_line.sid4_units_p_line                                |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x68844);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_str2mmio_store_cmd                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid4_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid4_str2mmio_store_cmd (sid4_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid4_str2mmio_store_cmd.sid4_str2mmio_store_cmd                    |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x68840);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_str2mmio_proc_addr                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid4_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid4_str2mmio_proc_addr (sid4_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid4_str2mmio_proc_addr.sid4_str2mmio_proc_addr                    |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68758);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk3_token                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk3_token_type */
	REG_DUMP_PRINT_1("   -fr_chk3_token.fr_chk3_token                                        |  0x%08X  |  [RW][31:00]""The token that has to be written""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x68754);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk3_addr                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk3_addr_type */
	/* skip, unused field unused_fr_chk3_addr (fr_chk3_addr) */
	REG_DUMP_PRINT_1("   -fr_chk3_addr.fr_chk3_addr                                          |  0x%08X  |  [RW][29:00]""The address of where the frame check token has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68750);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk3_trigger_repeat_val                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk3_trigger_repeat_val_type */
	/* skip, unused field unused_fr_chk3_trigger_repeat_val (fr_chk3_trigger_repeat_val) */
	REG_DUMP_PRINT_1("   -fr_chk3_trigger_repeat_val.fr_chk3_trigger_repeat_val              |      0x%04X  |  [RW][15:00]""An frame check token is send after each trigger_repeat_val value in case the repetitive enable bit in the check mode is set and the trigger offset has been reached.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x6874c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk3_trigger_offset                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk3_trigger_offset_type */
	/* skip, unused field unused_fr_chk3_trigger_offset (fr_chk3_trigger_offset) */
	REG_DUMP_PRINT_1("   -fr_chk3_trigger_offset.fr_chk3_trigger_offset                      |      0x%04X  |  [RW][15:00]""The value of the trigger, when the checked value becomes larger than the this value a frame check token is send""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x68748);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk3_sid_proc_id                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk3_sid_proc_id_type */
	/* skip, unused field unused_fr_chk3_sid_proc_id (fr_chk3_sid_proc_id) */
	REG_DUMP_PRINT_1("   -fr_chk3_sid_proc_id.fr_chk3_sid_proc_id                            |         0x%01X  |  [RW][03:00]""The ID of the SID proc that has to be checked""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x68744);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk3_check_mode                                         |  0x%08X  |  ""The mode of frame checking""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk3_check_mode_type */
	/* skip, unused field unused_fr_chk3_check_mode (fr_chk3_check_mode) */
	REG_DUMP_PRINT_1("   -fr_chk3_check_mode.check_type                                      |         0x%01X  |  [RW][00:00]""The type of value to be checking, 0: check lines; 1: check units;""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -fr_chk3_check_mode.repetive_enable                                 |         0x%01X  |  [RW][01:01]""Trigger and send and token after each repetitive value after the trigger offset is reached""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0x68740);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk3_enable                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk3_enable_type */
	/* skip, unused field unused_fr_chk3_enable (fr_chk3_enable) */
	REG_DUMP_PRINT_1("   -fr_chk3_enable.fr_chk3_enable                                      |         0x%01X  |  [RW][00:00]""Enable frame checking for this frame check unit""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x68724);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest3_iwake_threshold                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest3_iwake_threshold_type */
	/* skip, unused field unused_dest3_iwake_threshold (dest3_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest3_iwake_threshold.dest3_iwake_threshold                        |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6871c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest3_st_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest3_st_addr_type */
	REG_DUMP_PRINT_1("   -dest3_st_addr.dest3_st_addr                                        |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x68718);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest3_dest_mode                                            |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest3_dest_mode_type */
	/* skip, unused field unused_dest3_dest_mode (dest3_dest_mode) */
	REG_DUMP_PRINT_1("   -dest3_dest_mode.is_ibuf_cntrl_feeder                               |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest3_dest_mode.config_dma                                         |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest3_dest_mode.iwake_enable                                       |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest3_dest_mode.disable_spana_rst                                  |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest3_dest_mode.disable_spanb_rst                                  |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x68714);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest3_term_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest3_term_b_addr_type */
	/* skip, unused field unused_dest3_term_b_addr (dest3_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest3_term_b_addr.dest3_term_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68710);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest3_span_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest3_span_b_addr_type */
	/* skip, unused field unused_dest3_span_b_addr (dest3_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest3_span_b_addr.dest3_span_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6870c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest3_span_a_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest3_span_a_addr_type */
	/* skip, unused field unused_dest3_span_a_addr (dest3_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest3_span_a_addr.dest3_span_a_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68708);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest3_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest3_channel_addr_type */
	/* skip, unused field unused_dest3_channel_addr (dest3_channel_addr) */
	REG_DUMP_PRINT_1("   -dest3_channel_addr.dest3_channel_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68704);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest3_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest3_requester_addr_type */
	/* skip, unused field unused_dest3_requester_addr (dest3_requester_addr) */
	REG_DUMP_PRINT_1("   -dest3_requester_addr.dest3_requester_addr                          |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68700);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest3_feed_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest3_feed_addr_type */
	/* skip, unused field unused_dest3_feed_addr (dest3_feed_addr) */
	REG_DUMP_PRINT_1("   -dest3_feed_addr.dest3_feed_addr                                    |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x686ec);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_dest1_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid3_dest1_cur_cmds_type */
	/* skip, unused field unused_sid3_dest1_cur_cmds (sid3_dest1_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid3_dest1_cur_cmds.sid3_dest1_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x686e8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_dest1_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid3_dest1_sync_state_type */
	REG_DUMP_PRINT_1("   -sid3_dest1_sync_state.sid3_dest1_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 1. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x686e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_dest0_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid3_dest0_cur_cmds_type */
	/* skip, unused field unused_sid3_dest0_cur_cmds (sid3_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid3_dest0_cur_cmds.sid3_dest0_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x686e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_dest0_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid3_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid3_dest0_sync_state.sid3_dest0_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x686dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_dest0_cur_ack_line                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid3_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid3_dest0_cur_ack_line (sid3_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid3_dest0_cur_ack_line.sid3_dest0_cur_ack_line                    |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x686d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_dest0_cur_ack_unit_in_line                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid3_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid3_dest0_cur_ack_unit_in_line (sid3_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid3_dest0_cur_ack_unit_in_line.sid3_dest0_cur_ack_unit_in_line    |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x686d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_dest0_cur_ack_unit                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid3_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid3_dest0_cur_ack_unit (sid3_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid3_dest0_cur_ack_unit.sid3_dest0_cur_ack_unit                    |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x686cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_main_control_state                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid3_main_control_state_type */
	/* skip, unused field unused_sid3_main_control_state (sid3_main_control_state) */
	REG_DUMP_PRINT_1("   -sid3_main_control_state.sid3_main_control_state                    |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x686c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_s2m_cur_ack_line                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid3_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid3_s2m_cur_ack_line (sid3_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid3_s2m_cur_ack_line.sid3_s2m_cur_ack_line                        |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x686c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_s2m_cur_ack_unit_in_line                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid3_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid3_s2m_cur_ack_unit_in_line (sid3_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid3_s2m_cur_ack_unit_in_line.sid3_s2m_cur_ack_unit_in_line        |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x686c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_s2m_cur_cmds                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid3_s2m_cur_cmds_type */
	/* skip, unused field unused_sid3_s2m_cur_cmds (sid3_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid3_s2m_cur_cmds.sid3_s2m_cur_cmds                                |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x68698);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_error_reg                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid3_error_reg_type */
	REG_DUMP_PRINT_1("   -sid3_error_reg.sid3_error_reg                                      |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x68688);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_eventque_sidpid                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid3_eventque_sidpid_type */
	/* skip, unused field unused_sid3_eventque_sidpid (sid3_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid3_eventque_sidpid.sid3_eventque_sidpid                          |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x68684);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_ack_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid3_ack_addr_type */
	/* skip, unused field unused_sid3_ack_addr (sid3_ack_addr) */
	REG_DUMP_PRINT_1("   -sid3_ack_addr.sid3_ack_addr                                        |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6866c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_dest1_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid3_dest1_enabled_type */
	/* skip, unused field unused_sid3_dest1_enabled (sid3_dest1_enabled) */
	REG_DUMP_PRINT_1("   -sid3_dest1_enabled.sid3_dest1_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 1 is enabled, not present when only one destination sync is there for SID proc 3""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x68668);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_dest0_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid3_dest0_enabled_type */
	/* skip, unused field unused_sid3_dest0_enabled (sid3_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid3_dest0_enabled.sid3_dest0_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 3""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6865c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_first_page_nr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid3_first_page_nr_type */
	/* skip, unused field unused_sid3_first_page_nr (sid3_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid3_first_page_nr.sid3_first_page_nr                              |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x68658);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_camera_select                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid3_camera_select_type */
	/* skip, unused field unused_sid3_camera_select (sid3_camera_select) */
	REG_DUMP_PRINT_1("   -sid3_camera_select.sid3_camera_select                              |        0x%02X  |  [RW][05:00]""SID proc belongs to this camera, used to determine which secure touch enable signal should be used. This is bit encoded, bit 0 belongs to camera 0, bit 1 to camera 1 etc.""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x68654);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_units_p_ibuf                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid3_units_p_ibuf_type */
	/* skip, unused field unused_sid3_units_p_ibuf (sid3_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid3_units_p_ibuf.sid3_units_p_ibuf                                |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x68650);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_unit_size                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid3_unit_size_type */
	/* skip, unused field unused_sid3_unit_size (sid3_unit_size) */
	REG_DUMP_PRINT_1("   -sid3_unit_size.sid3_unit_size                                      |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0x6864c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_lines_p_frame                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid3_lines_p_frame_type */
	/* skip, unused field unused_sid3_lines_p_frame (sid3_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid3_lines_p_frame.sid3_lines_p_frame                              |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x68648);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_units_p_line                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid3_units_p_line_type */
	/* skip, unused field unused_sid3_units_p_line (sid3_units_p_line) */
	REG_DUMP_PRINT_1("   -sid3_units_p_line.sid3_units_p_line                                |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x68644);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_str2mmio_store_cmd                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid3_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid3_str2mmio_store_cmd (sid3_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid3_str2mmio_store_cmd.sid3_str2mmio_store_cmd                    |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x68640);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_str2mmio_proc_addr                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid3_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid3_str2mmio_proc_addr (sid3_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid3_str2mmio_proc_addr.sid3_str2mmio_proc_addr                    |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68558);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk2_token                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk2_token_type */
	REG_DUMP_PRINT_1("   -fr_chk2_token.fr_chk2_token                                        |  0x%08X  |  [RW][31:00]""The token that has to be written""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x68554);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk2_addr                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk2_addr_type */
	/* skip, unused field unused_fr_chk2_addr (fr_chk2_addr) */
	REG_DUMP_PRINT_1("   -fr_chk2_addr.fr_chk2_addr                                          |  0x%08X  |  [RW][29:00]""The address of where the frame check token has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68550);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk2_trigger_repeat_val                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk2_trigger_repeat_val_type */
	/* skip, unused field unused_fr_chk2_trigger_repeat_val (fr_chk2_trigger_repeat_val) */
	REG_DUMP_PRINT_1("   -fr_chk2_trigger_repeat_val.fr_chk2_trigger_repeat_val              |      0x%04X  |  [RW][15:00]""An frame check token is send after each trigger_repeat_val value in case the repetitive enable bit in the check mode is set and the trigger offset has been reached.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x6854c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk2_trigger_offset                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk2_trigger_offset_type */
	/* skip, unused field unused_fr_chk2_trigger_offset (fr_chk2_trigger_offset) */
	REG_DUMP_PRINT_1("   -fr_chk2_trigger_offset.fr_chk2_trigger_offset                      |      0x%04X  |  [RW][15:00]""The value of the trigger, when the checked value becomes larger than the this value a frame check token is send""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x68548);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk2_sid_proc_id                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk2_sid_proc_id_type */
	/* skip, unused field unused_fr_chk2_sid_proc_id (fr_chk2_sid_proc_id) */
	REG_DUMP_PRINT_1("   -fr_chk2_sid_proc_id.fr_chk2_sid_proc_id                            |         0x%01X  |  [RW][03:00]""The ID of the SID proc that has to be checked""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x68544);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk2_check_mode                                         |  0x%08X  |  ""The mode of frame checking""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk2_check_mode_type */
	/* skip, unused field unused_fr_chk2_check_mode (fr_chk2_check_mode) */
	REG_DUMP_PRINT_1("   -fr_chk2_check_mode.check_type                                      |         0x%01X  |  [RW][00:00]""The type of value to be checking, 0: check lines; 1: check units;""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -fr_chk2_check_mode.repetive_enable                                 |         0x%01X  |  [RW][01:01]""Trigger and send and token after each repetitive value after the trigger offset is reached""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0x68540);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk2_enable                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk2_enable_type */
	/* skip, unused field unused_fr_chk2_enable (fr_chk2_enable) */
	REG_DUMP_PRINT_1("   -fr_chk2_enable.fr_chk2_enable                                      |         0x%01X  |  [RW][00:00]""Enable frame checking for this frame check unit""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x68524);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest2_iwake_threshold                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest2_iwake_threshold_type */
	/* skip, unused field unused_dest2_iwake_threshold (dest2_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest2_iwake_threshold.dest2_iwake_threshold                        |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6851c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest2_st_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest2_st_addr_type */
	REG_DUMP_PRINT_1("   -dest2_st_addr.dest2_st_addr                                        |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x68518);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest2_dest_mode                                            |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest2_dest_mode_type */
	/* skip, unused field unused_dest2_dest_mode (dest2_dest_mode) */
	REG_DUMP_PRINT_1("   -dest2_dest_mode.is_ibuf_cntrl_feeder                               |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest2_dest_mode.config_dma                                         |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest2_dest_mode.iwake_enable                                       |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest2_dest_mode.disable_spana_rst                                  |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest2_dest_mode.disable_spanb_rst                                  |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x68514);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest2_term_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest2_term_b_addr_type */
	/* skip, unused field unused_dest2_term_b_addr (dest2_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest2_term_b_addr.dest2_term_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68510);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest2_span_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest2_span_b_addr_type */
	/* skip, unused field unused_dest2_span_b_addr (dest2_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest2_span_b_addr.dest2_span_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6850c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest2_span_a_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest2_span_a_addr_type */
	/* skip, unused field unused_dest2_span_a_addr (dest2_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest2_span_a_addr.dest2_span_a_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68508);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest2_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest2_channel_addr_type */
	/* skip, unused field unused_dest2_channel_addr (dest2_channel_addr) */
	REG_DUMP_PRINT_1("   -dest2_channel_addr.dest2_channel_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68504);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest2_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest2_requester_addr_type */
	/* skip, unused field unused_dest2_requester_addr (dest2_requester_addr) */
	REG_DUMP_PRINT_1("   -dest2_requester_addr.dest2_requester_addr                          |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68500);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest2_feed_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest2_feed_addr_type */
	/* skip, unused field unused_dest2_feed_addr (dest2_feed_addr) */
	REG_DUMP_PRINT_1("   -dest2_feed_addr.dest2_feed_addr                                    |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x684ec);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_dest1_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid2_dest1_cur_cmds_type */
	/* skip, unused field unused_sid2_dest1_cur_cmds (sid2_dest1_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid2_dest1_cur_cmds.sid2_dest1_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x684e8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_dest1_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid2_dest1_sync_state_type */
	REG_DUMP_PRINT_1("   -sid2_dest1_sync_state.sid2_dest1_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 1. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x684e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_dest0_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid2_dest0_cur_cmds_type */
	/* skip, unused field unused_sid2_dest0_cur_cmds (sid2_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid2_dest0_cur_cmds.sid2_dest0_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x684e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_dest0_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid2_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid2_dest0_sync_state.sid2_dest0_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x684dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_dest0_cur_ack_line                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid2_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid2_dest0_cur_ack_line (sid2_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid2_dest0_cur_ack_line.sid2_dest0_cur_ack_line                    |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x684d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_dest0_cur_ack_unit_in_line                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid2_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid2_dest0_cur_ack_unit_in_line (sid2_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid2_dest0_cur_ack_unit_in_line.sid2_dest0_cur_ack_unit_in_line    |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x684d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_dest0_cur_ack_unit                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid2_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid2_dest0_cur_ack_unit (sid2_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid2_dest0_cur_ack_unit.sid2_dest0_cur_ack_unit                    |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x684cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_main_control_state                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid2_main_control_state_type */
	/* skip, unused field unused_sid2_main_control_state (sid2_main_control_state) */
	REG_DUMP_PRINT_1("   -sid2_main_control_state.sid2_main_control_state                    |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x684c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_s2m_cur_ack_line                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid2_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid2_s2m_cur_ack_line (sid2_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid2_s2m_cur_ack_line.sid2_s2m_cur_ack_line                        |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x684c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_s2m_cur_ack_unit_in_line                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid2_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid2_s2m_cur_ack_unit_in_line (sid2_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid2_s2m_cur_ack_unit_in_line.sid2_s2m_cur_ack_unit_in_line        |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x684c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_s2m_cur_cmds                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid2_s2m_cur_cmds_type */
	/* skip, unused field unused_sid2_s2m_cur_cmds (sid2_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid2_s2m_cur_cmds.sid2_s2m_cur_cmds                                |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x68498);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_error_reg                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid2_error_reg_type */
	REG_DUMP_PRINT_1("   -sid2_error_reg.sid2_error_reg                                      |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x68488);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_eventque_sidpid                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid2_eventque_sidpid_type */
	/* skip, unused field unused_sid2_eventque_sidpid (sid2_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid2_eventque_sidpid.sid2_eventque_sidpid                          |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x68484);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_ack_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid2_ack_addr_type */
	/* skip, unused field unused_sid2_ack_addr (sid2_ack_addr) */
	REG_DUMP_PRINT_1("   -sid2_ack_addr.sid2_ack_addr                                        |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6846c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_dest1_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid2_dest1_enabled_type */
	/* skip, unused field unused_sid2_dest1_enabled (sid2_dest1_enabled) */
	REG_DUMP_PRINT_1("   -sid2_dest1_enabled.sid2_dest1_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 1 is enabled, not present when only one destination sync is there for SID proc 2""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x68468);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_dest0_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid2_dest0_enabled_type */
	/* skip, unused field unused_sid2_dest0_enabled (sid2_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid2_dest0_enabled.sid2_dest0_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 2""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6845c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_first_page_nr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid2_first_page_nr_type */
	/* skip, unused field unused_sid2_first_page_nr (sid2_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid2_first_page_nr.sid2_first_page_nr                              |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x68458);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_camera_select                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid2_camera_select_type */
	/* skip, unused field unused_sid2_camera_select (sid2_camera_select) */
	REG_DUMP_PRINT_1("   -sid2_camera_select.sid2_camera_select                              |        0x%02X  |  [RW][05:00]""SID proc belongs to this camera, used to determine which secure touch enable signal should be used. This is bit encoded, bit 0 belongs to camera 0, bit 1 to camera 1 etc.""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x68454);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_units_p_ibuf                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid2_units_p_ibuf_type */
	/* skip, unused field unused_sid2_units_p_ibuf (sid2_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid2_units_p_ibuf.sid2_units_p_ibuf                                |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x68450);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_unit_size                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid2_unit_size_type */
	/* skip, unused field unused_sid2_unit_size (sid2_unit_size) */
	REG_DUMP_PRINT_1("   -sid2_unit_size.sid2_unit_size                                      |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0x6844c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_lines_p_frame                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid2_lines_p_frame_type */
	/* skip, unused field unused_sid2_lines_p_frame (sid2_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid2_lines_p_frame.sid2_lines_p_frame                              |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x68448);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_units_p_line                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid2_units_p_line_type */
	/* skip, unused field unused_sid2_units_p_line (sid2_units_p_line) */
	REG_DUMP_PRINT_1("   -sid2_units_p_line.sid2_units_p_line                                |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x68444);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_str2mmio_store_cmd                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid2_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid2_str2mmio_store_cmd (sid2_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid2_str2mmio_store_cmd.sid2_str2mmio_store_cmd                    |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x68440);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_str2mmio_proc_addr                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid2_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid2_str2mmio_proc_addr (sid2_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid2_str2mmio_proc_addr.sid2_str2mmio_proc_addr                    |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68358);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk1_token                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk1_token_type */
	REG_DUMP_PRINT_1("   -fr_chk1_token.fr_chk1_token                                        |  0x%08X  |  [RW][31:00]""The token that has to be written""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x68354);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk1_addr                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk1_addr_type */
	/* skip, unused field unused_fr_chk1_addr (fr_chk1_addr) */
	REG_DUMP_PRINT_1("   -fr_chk1_addr.fr_chk1_addr                                          |  0x%08X  |  [RW][29:00]""The address of where the frame check token has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68350);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk1_trigger_repeat_val                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk1_trigger_repeat_val_type */
	/* skip, unused field unused_fr_chk1_trigger_repeat_val (fr_chk1_trigger_repeat_val) */
	REG_DUMP_PRINT_1("   -fr_chk1_trigger_repeat_val.fr_chk1_trigger_repeat_val              |      0x%04X  |  [RW][15:00]""An frame check token is send after each trigger_repeat_val value in case the repetitive enable bit in the check mode is set and the trigger offset has been reached.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x6834c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk1_trigger_offset                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk1_trigger_offset_type */
	/* skip, unused field unused_fr_chk1_trigger_offset (fr_chk1_trigger_offset) */
	REG_DUMP_PRINT_1("   -fr_chk1_trigger_offset.fr_chk1_trigger_offset                      |      0x%04X  |  [RW][15:00]""The value of the trigger, when the checked value becomes larger than the this value a frame check token is send""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x68348);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk1_sid_proc_id                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk1_sid_proc_id_type */
	/* skip, unused field unused_fr_chk1_sid_proc_id (fr_chk1_sid_proc_id) */
	REG_DUMP_PRINT_1("   -fr_chk1_sid_proc_id.fr_chk1_sid_proc_id                            |         0x%01X  |  [RW][03:00]""The ID of the SID proc that has to be checked""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x68344);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk1_check_mode                                         |  0x%08X  |  ""The mode of frame checking""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk1_check_mode_type */
	/* skip, unused field unused_fr_chk1_check_mode (fr_chk1_check_mode) */
	REG_DUMP_PRINT_1("   -fr_chk1_check_mode.check_type                                      |         0x%01X  |  [RW][00:00]""The type of value to be checking, 0: check lines; 1: check units;""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -fr_chk1_check_mode.repetive_enable                                 |         0x%01X  |  [RW][01:01]""Trigger and send and token after each repetitive value after the trigger offset is reached""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0x68340);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk1_enable                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk1_enable_type */
	/* skip, unused field unused_fr_chk1_enable (fr_chk1_enable) */
	REG_DUMP_PRINT_1("   -fr_chk1_enable.fr_chk1_enable                                      |         0x%01X  |  [RW][00:00]""Enable frame checking for this frame check unit""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x68324);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest1_iwake_threshold                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest1_iwake_threshold_type */
	/* skip, unused field unused_dest1_iwake_threshold (dest1_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest1_iwake_threshold.dest1_iwake_threshold                        |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6831c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest1_st_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest1_st_addr_type */
	REG_DUMP_PRINT_1("   -dest1_st_addr.dest1_st_addr                                        |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x68318);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest1_dest_mode                                            |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest1_dest_mode_type */
	/* skip, unused field unused_dest1_dest_mode (dest1_dest_mode) */
	REG_DUMP_PRINT_1("   -dest1_dest_mode.is_ibuf_cntrl_feeder                               |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest1_dest_mode.config_dma                                         |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest1_dest_mode.iwake_enable                                       |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest1_dest_mode.disable_spana_rst                                  |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest1_dest_mode.disable_spanb_rst                                  |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x68314);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest1_term_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest1_term_b_addr_type */
	/* skip, unused field unused_dest1_term_b_addr (dest1_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest1_term_b_addr.dest1_term_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68310);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest1_span_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest1_span_b_addr_type */
	/* skip, unused field unused_dest1_span_b_addr (dest1_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest1_span_b_addr.dest1_span_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6830c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest1_span_a_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest1_span_a_addr_type */
	/* skip, unused field unused_dest1_span_a_addr (dest1_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest1_span_a_addr.dest1_span_a_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68308);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest1_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest1_channel_addr_type */
	/* skip, unused field unused_dest1_channel_addr (dest1_channel_addr) */
	REG_DUMP_PRINT_1("   -dest1_channel_addr.dest1_channel_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68304);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest1_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest1_requester_addr_type */
	/* skip, unused field unused_dest1_requester_addr (dest1_requester_addr) */
	REG_DUMP_PRINT_1("   -dest1_requester_addr.dest1_requester_addr                          |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68300);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest1_feed_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest1_feed_addr_type */
	/* skip, unused field unused_dest1_feed_addr (dest1_feed_addr) */
	REG_DUMP_PRINT_1("   -dest1_feed_addr.dest1_feed_addr                                    |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x682ec);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_dest1_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid1_dest1_cur_cmds_type */
	/* skip, unused field unused_sid1_dest1_cur_cmds (sid1_dest1_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid1_dest1_cur_cmds.sid1_dest1_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x682e8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_dest1_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid1_dest1_sync_state_type */
	REG_DUMP_PRINT_1("   -sid1_dest1_sync_state.sid1_dest1_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 1. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x682e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_dest0_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid1_dest0_cur_cmds_type */
	/* skip, unused field unused_sid1_dest0_cur_cmds (sid1_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid1_dest0_cur_cmds.sid1_dest0_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x682e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_dest0_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid1_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid1_dest0_sync_state.sid1_dest0_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x682dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_dest0_cur_ack_line                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid1_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid1_dest0_cur_ack_line (sid1_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid1_dest0_cur_ack_line.sid1_dest0_cur_ack_line                    |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x682d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_dest0_cur_ack_unit_in_line                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid1_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid1_dest0_cur_ack_unit_in_line (sid1_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid1_dest0_cur_ack_unit_in_line.sid1_dest0_cur_ack_unit_in_line    |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x682d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_dest0_cur_ack_unit                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid1_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid1_dest0_cur_ack_unit (sid1_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid1_dest0_cur_ack_unit.sid1_dest0_cur_ack_unit                    |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x682cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_main_control_state                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid1_main_control_state_type */
	/* skip, unused field unused_sid1_main_control_state (sid1_main_control_state) */
	REG_DUMP_PRINT_1("   -sid1_main_control_state.sid1_main_control_state                    |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x682c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_s2m_cur_ack_line                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid1_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid1_s2m_cur_ack_line (sid1_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid1_s2m_cur_ack_line.sid1_s2m_cur_ack_line                        |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x682c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_s2m_cur_ack_unit_in_line                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid1_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid1_s2m_cur_ack_unit_in_line (sid1_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid1_s2m_cur_ack_unit_in_line.sid1_s2m_cur_ack_unit_in_line        |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x682c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_s2m_cur_cmds                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid1_s2m_cur_cmds_type */
	/* skip, unused field unused_sid1_s2m_cur_cmds (sid1_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid1_s2m_cur_cmds.sid1_s2m_cur_cmds                                |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x68298);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_error_reg                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid1_error_reg_type */
	REG_DUMP_PRINT_1("   -sid1_error_reg.sid1_error_reg                                      |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x68288);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_eventque_sidpid                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid1_eventque_sidpid_type */
	/* skip, unused field unused_sid1_eventque_sidpid (sid1_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid1_eventque_sidpid.sid1_eventque_sidpid                          |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x68284);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_ack_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid1_ack_addr_type */
	/* skip, unused field unused_sid1_ack_addr (sid1_ack_addr) */
	REG_DUMP_PRINT_1("   -sid1_ack_addr.sid1_ack_addr                                        |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6826c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_dest1_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid1_dest1_enabled_type */
	/* skip, unused field unused_sid1_dest1_enabled (sid1_dest1_enabled) */
	REG_DUMP_PRINT_1("   -sid1_dest1_enabled.sid1_dest1_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 1 is enabled, not present when only one destination sync is there for SID proc 1""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x68268);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_dest0_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid1_dest0_enabled_type */
	/* skip, unused field unused_sid1_dest0_enabled (sid1_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid1_dest0_enabled.sid1_dest0_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 1""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6825c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_first_page_nr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid1_first_page_nr_type */
	/* skip, unused field unused_sid1_first_page_nr (sid1_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid1_first_page_nr.sid1_first_page_nr                              |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x68258);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_camera_select                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid1_camera_select_type */
	/* skip, unused field unused_sid1_camera_select (sid1_camera_select) */
	REG_DUMP_PRINT_1("   -sid1_camera_select.sid1_camera_select                              |        0x%02X  |  [RW][05:00]""SID proc belongs to this camera, used to determine which secure touch enable signal should be used. This is bit encoded, bit 0 belongs to camera 0, bit 1 to camera 1 etc.""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x68254);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_units_p_ibuf                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid1_units_p_ibuf_type */
	/* skip, unused field unused_sid1_units_p_ibuf (sid1_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid1_units_p_ibuf.sid1_units_p_ibuf                                |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x68250);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_unit_size                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid1_unit_size_type */
	/* skip, unused field unused_sid1_unit_size (sid1_unit_size) */
	REG_DUMP_PRINT_1("   -sid1_unit_size.sid1_unit_size                                      |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0x6824c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_lines_p_frame                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid1_lines_p_frame_type */
	/* skip, unused field unused_sid1_lines_p_frame (sid1_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid1_lines_p_frame.sid1_lines_p_frame                              |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x68248);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_units_p_line                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid1_units_p_line_type */
	/* skip, unused field unused_sid1_units_p_line (sid1_units_p_line) */
	REG_DUMP_PRINT_1("   -sid1_units_p_line.sid1_units_p_line                                |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x68244);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_str2mmio_store_cmd                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid1_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid1_str2mmio_store_cmd (sid1_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid1_str2mmio_store_cmd.sid1_str2mmio_store_cmd                    |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x68240);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_str2mmio_proc_addr                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid1_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid1_str2mmio_proc_addr (sid1_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid1_str2mmio_proc_addr.sid1_str2mmio_proc_addr                    |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68158);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk0_token                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk0_token_type */
	REG_DUMP_PRINT_1("   -fr_chk0_token.fr_chk0_token                                        |  0x%08X  |  [RW][31:00]""The token that has to be written""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x68154);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk0_addr                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk0_addr_type */
	/* skip, unused field unused_fr_chk0_addr (fr_chk0_addr) */
	REG_DUMP_PRINT_1("   -fr_chk0_addr.fr_chk0_addr                                          |  0x%08X  |  [RW][29:00]""The address of where the frame check token has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68150);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk0_trigger_repeat_val                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk0_trigger_repeat_val_type */
	/* skip, unused field unused_fr_chk0_trigger_repeat_val (fr_chk0_trigger_repeat_val) */
	REG_DUMP_PRINT_1("   -fr_chk0_trigger_repeat_val.fr_chk0_trigger_repeat_val              |      0x%04X  |  [RW][15:00]""An frame check token is send after each trigger_repeat_val value in case the repetitive enable bit in the check mode is set and the trigger offset has been reached.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x6814c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk0_trigger_offset                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk0_trigger_offset_type */
	/* skip, unused field unused_fr_chk0_trigger_offset (fr_chk0_trigger_offset) */
	REG_DUMP_PRINT_1("   -fr_chk0_trigger_offset.fr_chk0_trigger_offset                      |      0x%04X  |  [RW][15:00]""The value of the trigger, when the checked value becomes larger than the this value a frame check token is send""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x68148);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk0_sid_proc_id                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk0_sid_proc_id_type */
	/* skip, unused field unused_fr_chk0_sid_proc_id (fr_chk0_sid_proc_id) */
	REG_DUMP_PRINT_1("   -fr_chk0_sid_proc_id.fr_chk0_sid_proc_id                            |         0x%01X  |  [RW][03:00]""The ID of the SID proc that has to be checked""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x68144);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk0_check_mode                                         |  0x%08X  |  ""The mode of frame checking""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk0_check_mode_type */
	/* skip, unused field unused_fr_chk0_check_mode (fr_chk0_check_mode) */
	REG_DUMP_PRINT_1("   -fr_chk0_check_mode.check_type                                      |         0x%01X  |  [RW][00:00]""The type of value to be checking, 0: check lines; 1: check units;""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -fr_chk0_check_mode.repetive_enable                                 |         0x%01X  |  [RW][01:01]""Trigger and send and token after each repetitive value after the trigger offset is reached""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0x68140);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk0_enable                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_fr_chk0_enable_type */
	/* skip, unused field unused_fr_chk0_enable (fr_chk0_enable) */
	REG_DUMP_PRINT_1("   -fr_chk0_enable.fr_chk0_enable                                      |         0x%01X  |  [RW][00:00]""Enable frame checking for this frame check unit""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x68124);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest0_iwake_threshold                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest0_iwake_threshold_type */
	/* skip, unused field unused_dest0_iwake_threshold (dest0_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest0_iwake_threshold.dest0_iwake_threshold                        |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6811c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest0_st_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest0_st_addr_type */
	REG_DUMP_PRINT_1("   -dest0_st_addr.dest0_st_addr                                        |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x68118);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest0_dest_mode                                            |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest0_dest_mode_type */
	/* skip, unused field unused_dest0_dest_mode (dest0_dest_mode) */
	REG_DUMP_PRINT_1("   -dest0_dest_mode.is_ibuf_cntrl_feeder                               |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest0_dest_mode.config_dma                                         |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest0_dest_mode.iwake_enable                                       |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest0_dest_mode.disable_spana_rst                                  |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest0_dest_mode.disable_spanb_rst                                  |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x68114);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest0_term_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest0_term_b_addr_type */
	/* skip, unused field unused_dest0_term_b_addr (dest0_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest0_term_b_addr.dest0_term_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68110);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest0_span_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest0_span_b_addr_type */
	/* skip, unused field unused_dest0_span_b_addr (dest0_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest0_span_b_addr.dest0_span_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6810c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest0_span_a_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest0_span_a_addr_type */
	/* skip, unused field unused_dest0_span_a_addr (dest0_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest0_span_a_addr.dest0_span_a_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68108);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest0_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest0_channel_addr_type */
	/* skip, unused field unused_dest0_channel_addr (dest0_channel_addr) */
	REG_DUMP_PRINT_1("   -dest0_channel_addr.dest0_channel_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68104);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest0_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest0_requester_addr_type */
	/* skip, unused field unused_dest0_requester_addr (dest0_requester_addr) */
	REG_DUMP_PRINT_1("   -dest0_requester_addr.dest0_requester_addr                          |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68100);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest0_feed_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_dest0_feed_addr_type */
	/* skip, unused field unused_dest0_feed_addr (dest0_feed_addr) */
	REG_DUMP_PRINT_1("   -dest0_feed_addr.dest0_feed_addr                                    |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x680ec);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_dest1_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid0_dest1_cur_cmds_type */
	/* skip, unused field unused_sid0_dest1_cur_cmds (sid0_dest1_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid0_dest1_cur_cmds.sid0_dest1_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x680e8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_dest1_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid0_dest1_sync_state_type */
	REG_DUMP_PRINT_1("   -sid0_dest1_sync_state.sid0_dest1_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 1. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x680e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_dest0_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid0_dest0_cur_cmds_type */
	/* skip, unused field unused_sid0_dest0_cur_cmds (sid0_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid0_dest0_cur_cmds.sid0_dest0_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x680e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_dest0_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid0_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid0_dest0_sync_state.sid0_dest0_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x680dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_dest0_cur_ack_line                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid0_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid0_dest0_cur_ack_line (sid0_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid0_dest0_cur_ack_line.sid0_dest0_cur_ack_line                    |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x680d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_dest0_cur_ack_unit_in_line                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid0_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid0_dest0_cur_ack_unit_in_line (sid0_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid0_dest0_cur_ack_unit_in_line.sid0_dest0_cur_ack_unit_in_line    |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x680d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_dest0_cur_ack_unit                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid0_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid0_dest0_cur_ack_unit (sid0_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid0_dest0_cur_ack_unit.sid0_dest0_cur_ack_unit                    |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x680cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_main_control_state                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid0_main_control_state_type */
	/* skip, unused field unused_sid0_main_control_state (sid0_main_control_state) */
	REG_DUMP_PRINT_1("   -sid0_main_control_state.sid0_main_control_state                    |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x680c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_s2m_cur_ack_line                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid0_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid0_s2m_cur_ack_line (sid0_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid0_s2m_cur_ack_line.sid0_s2m_cur_ack_line                        |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x680c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_s2m_cur_ack_unit_in_line                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid0_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid0_s2m_cur_ack_unit_in_line (sid0_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid0_s2m_cur_ack_unit_in_line.sid0_s2m_cur_ack_unit_in_line        |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x680c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_s2m_cur_cmds                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid0_s2m_cur_cmds_type */
	/* skip, unused field unused_sid0_s2m_cur_cmds (sid0_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid0_s2m_cur_cmds.sid0_s2m_cur_cmds                                |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x68098);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_error_reg                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid0_error_reg_type */
	REG_DUMP_PRINT_1("   -sid0_error_reg.sid0_error_reg                                      |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x68088);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_eventque_sidpid                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid0_eventque_sidpid_type */
	/* skip, unused field unused_sid0_eventque_sidpid (sid0_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid0_eventque_sidpid.sid0_eventque_sidpid                          |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x68084);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_ack_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid0_ack_addr_type */
	/* skip, unused field unused_sid0_ack_addr (sid0_ack_addr) */
	REG_DUMP_PRINT_1("   -sid0_ack_addr.sid0_ack_addr                                        |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6806c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_dest1_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid0_dest1_enabled_type */
	/* skip, unused field unused_sid0_dest1_enabled (sid0_dest1_enabled) */
	REG_DUMP_PRINT_1("   -sid0_dest1_enabled.sid0_dest1_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 1 is enabled, not present when only one destination sync is there for SID proc 0""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x68068);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_dest0_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid0_dest0_enabled_type */
	/* skip, unused field unused_sid0_dest0_enabled (sid0_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid0_dest0_enabled.sid0_dest0_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 0""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6805c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_first_page_nr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid0_first_page_nr_type */
	/* skip, unused field unused_sid0_first_page_nr (sid0_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid0_first_page_nr.sid0_first_page_nr                              |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x68058);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_camera_select                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid0_camera_select_type */
	/* skip, unused field unused_sid0_camera_select (sid0_camera_select) */
	REG_DUMP_PRINT_1("   -sid0_camera_select.sid0_camera_select                              |        0x%02X  |  [RW][05:00]""SID proc belongs to this camera, used to determine which secure touch enable signal should be used. This is bit encoded, bit 0 belongs to camera 0, bit 1 to camera 1 etc.""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x68054);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_units_p_ibuf                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid0_units_p_ibuf_type */
	/* skip, unused field unused_sid0_units_p_ibuf (sid0_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid0_units_p_ibuf.sid0_units_p_ibuf                                |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x68050);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_unit_size                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid0_unit_size_type */
	/* skip, unused field unused_sid0_unit_size (sid0_unit_size) */
	REG_DUMP_PRINT_1("   -sid0_unit_size.sid0_unit_size                                      |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0x6804c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_lines_p_frame                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid0_lines_p_frame_type */
	/* skip, unused field unused_sid0_lines_p_frame (sid0_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid0_lines_p_frame.sid0_lines_p_frame                              |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x68048);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_units_p_line                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid0_units_p_line_type */
	/* skip, unused field unused_sid0_units_p_line (sid0_units_p_line) */
	REG_DUMP_PRINT_1("   -sid0_units_p_line.sid0_units_p_line                                |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x68044);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_str2mmio_store_cmd                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid0_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid0_str2mmio_store_cmd (sid0_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid0_str2mmio_store_cmd.sid0_str2mmio_store_cmd                    |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x68040);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_str2mmio_proc_addr                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_sid0_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid0_str2mmio_proc_addr (sid0_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid0_str2mmio_proc_addr.sid0_str2mmio_proc_addr                    |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68028);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.enable_clk_gate                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_enable_clk_gate_type */
	/* skip, unused field unused_enable_clk_gate (enable_clk_gate) */
	REG_DUMP_PRINT_1("   -enable_clk_gate.enable_clk_gate                                    |         0x%01X  |  [RW][00:00]""Enable the automatic clockgating in the IBufCntrl to save power""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x68024);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.gda_address                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_gda_address_type */
	/* skip, unused field unused_gda_address (gda_address) */
	REG_DUMP_PRINT_1("   -gda_address.gda_address                                            |  0x%08X  |  [RW][29:00]""The address of the GDA, this is a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x68020);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.gda_enable                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_gda_enable_type */
	/* skip, unused field unused_gda_enable (gda_enable) */
	REG_DUMP_PRINT_1("   -gda_enable.gda_enable                                              |         0x%01X  |  [RW][00:00]""Enable the GDA functionality in the IBufCntrl. Pages will be de-allocated in the GDA when possible.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6801c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.secure_touch_handling                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_secure_touch_handling_type */
	/* skip, unused field unused_secure_touch_handling (secure_touch_handling) */
	REG_DUMP_PRINT_1("   -secure_touch_handling.secure_touch_handling                        |         0x%01X  |  [RW][01:00]""The mode of how the commands are being handled when secure touch is enabled for a SID processor. 0: fetch next command and process normally; 1: fetch next command and ACK immediatly without processing; 2: wait for fetching the next command until secure touch is disabled""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x68018);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.error_irq_en                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_error_irq_en_type */
	/* skip, unused field unused_error_irq_en (error_irq_en) */
	REG_DUMP_PRINT_1("   -error_irq_en.error_irq_en                                          |      0x%04X  |  [RW][15:00]""This register specifies for which SID processor the irq is enabled""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x68014);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.error_reg_set                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_error_reg_set_type */
	/* skip, unused field unused_error_reg_set (error_reg_set) */
	REG_DUMP_PRINT_1("   -error_reg_set.error_reg_set                                        |      0x%04X  |  [RO][15:00]""This register specifies which SID processor raised an interrupt and set its error register; the error register of SID x is set when bit x is set""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x68010);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.arbiter_status                                             |  0x%08X  |  ""The status of the arbiter in the IBufCntrl. Bit set to one means that part has access.""\n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_arbiter_status_type */
	/* skip, unused field unused_arbiter_status (arbiter_status) */
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_0                                          |         0x%01X  |  [RO][00:00]""SID proc 0 requires access""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_1                                          |         0x%01X  |  [RO][01:01]""SID proc 1 requires access""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_2                                          |         0x%01X  |  [RO][02:02]""SID proc 2 requires access""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_3                                          |         0x%01X  |  [RO][03:03]""SID proc 3 requires access""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_4                                          |         0x%01X  |  [RO][04:04]""SID proc 4 requires access""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_5                                          |         0x%01X  |  [RO][05:05]""SID proc 5 requires access""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_6                                          |         0x%01X  |  [RO][06:06]""SID proc 6 requires access""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_7                                          |         0x%01X  |  [RO][07:07]""SID proc 7 requires access""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_8                                          |         0x%01X  |  [RO][08:08]""SID proc 8 requires access""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_9                                          |         0x%01X  |  [RO][09:09]""SID proc 9 requires access""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_10                                         |         0x%01X  |  [RO][10:10]""SID proc 10 requires access""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_11                                         |         0x%01X  |  [RO][11:11]""SID proc 11 requires access""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_12                                         |         0x%01X  |  [RO][12:12]""SID proc 12 requires access""\n", FIELD_VALUE(val, 12, 12));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_13                                         |         0x%01X  |  [RO][13:13]""SID proc 13 requires access""\n", FIELD_VALUE(val, 13, 13));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_14                                         |         0x%01X  |  [RO][14:14]""SID proc 14 requires access""\n", FIELD_VALUE(val, 14, 14));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_15                                         |         0x%01X  |  [RO][15:15]""SID proc 15 requires access""\n", FIELD_VALUE(val, 15, 15));
	REG_DUMP_PRINT_1("   -arbiter_status.power_management                                    |         0x%01X  |  [RO][16:16]""Power management block requires access""\n", FIELD_VALUE(val, 16, 16));
	REG_DUMP_PRINT_1("   -arbiter_status.frame_monitor                                       |         0x%01X  |  [RO][17:17]""Frame monitor block requires access""\n", FIELD_VALUE(val, 17, 17));
	REG_DUMP_PRINT_1("   -arbiter_status.GDA_dealloc                                         |         0x%01X  |  [RO][18:18]""GDA deallocation arbiter (collection of all SID procs) requires access""\n", FIELD_VALUE(val, 18, 18));
	val = REG_DUMP_READ_REGISTER(0x68004);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.iwake_addr                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_3ph_logic_ibuf_ctrl_iwake_addr_type */
	/* skip, unused field unused_iwake_addr (iwake_addr) */
	REG_DUMP_PRINT_1("   -iwake_addr.iwake_addr                                              |  0x%08X  |  [RW][29:00]""The address of where the Iwake and Idone have to be written to. Internally is made sure that all SID procs are done before sending an Idone""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62f24);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest23_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest23_iwake_threshold_type */
	/* skip, unused field unused_dest23_iwake_threshold (dest23_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest23_iwake_threshold.dest23_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x62f1c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest23_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest23_st_addr_type */
	REG_DUMP_PRINT_1("   -dest23_st_addr.dest23_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x62f18);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest23_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest23_dest_mode_type */
	/* skip, unused field unused_dest23_dest_mode (dest23_dest_mode) */
	REG_DUMP_PRINT_1("   -dest23_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest23_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest23_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest23_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest23_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x62f14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest23_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest23_term_b_addr_type */
	/* skip, unused field unused_dest23_term_b_addr (dest23_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest23_term_b_addr.dest23_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62f10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest23_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest23_span_b_addr_type */
	/* skip, unused field unused_dest23_span_b_addr (dest23_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest23_span_b_addr.dest23_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62f0c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest23_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest23_span_a_addr_type */
	/* skip, unused field unused_dest23_span_a_addr (dest23_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest23_span_a_addr.dest23_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62f08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest23_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest23_channel_addr_type */
	/* skip, unused field unused_dest23_channel_addr (dest23_channel_addr) */
	REG_DUMP_PRINT_1("   -dest23_channel_addr.dest23_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62f04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest23_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest23_requester_addr_type */
	/* skip, unused field unused_dest23_requester_addr (dest23_requester_addr) */
	REG_DUMP_PRINT_1("   -dest23_requester_addr.dest23_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62f00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest23_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest23_feed_addr_type */
	/* skip, unused field unused_dest23_feed_addr (dest23_feed_addr) */
	REG_DUMP_PRINT_1("   -dest23_feed_addr.dest23_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62d24);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest22_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest22_iwake_threshold_type */
	/* skip, unused field unused_dest22_iwake_threshold (dest22_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest22_iwake_threshold.dest22_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x62d1c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest22_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest22_st_addr_type */
	REG_DUMP_PRINT_1("   -dest22_st_addr.dest22_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x62d18);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest22_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest22_dest_mode_type */
	/* skip, unused field unused_dest22_dest_mode (dest22_dest_mode) */
	REG_DUMP_PRINT_1("   -dest22_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest22_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest22_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest22_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest22_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x62d14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest22_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest22_term_b_addr_type */
	/* skip, unused field unused_dest22_term_b_addr (dest22_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest22_term_b_addr.dest22_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62d10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest22_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest22_span_b_addr_type */
	/* skip, unused field unused_dest22_span_b_addr (dest22_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest22_span_b_addr.dest22_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62d0c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest22_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest22_span_a_addr_type */
	/* skip, unused field unused_dest22_span_a_addr (dest22_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest22_span_a_addr.dest22_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62d08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest22_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest22_channel_addr_type */
	/* skip, unused field unused_dest22_channel_addr (dest22_channel_addr) */
	REG_DUMP_PRINT_1("   -dest22_channel_addr.dest22_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62d04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest22_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest22_requester_addr_type */
	/* skip, unused field unused_dest22_requester_addr (dest22_requester_addr) */
	REG_DUMP_PRINT_1("   -dest22_requester_addr.dest22_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62d00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest22_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest22_feed_addr_type */
	/* skip, unused field unused_dest22_feed_addr (dest22_feed_addr) */
	REG_DUMP_PRINT_1("   -dest22_feed_addr.dest22_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62b24);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest21_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest21_iwake_threshold_type */
	/* skip, unused field unused_dest21_iwake_threshold (dest21_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest21_iwake_threshold.dest21_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x62b1c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest21_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest21_st_addr_type */
	REG_DUMP_PRINT_1("   -dest21_st_addr.dest21_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x62b18);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest21_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest21_dest_mode_type */
	/* skip, unused field unused_dest21_dest_mode (dest21_dest_mode) */
	REG_DUMP_PRINT_1("   -dest21_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest21_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest21_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest21_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest21_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x62b14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest21_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest21_term_b_addr_type */
	/* skip, unused field unused_dest21_term_b_addr (dest21_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest21_term_b_addr.dest21_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62b10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest21_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest21_span_b_addr_type */
	/* skip, unused field unused_dest21_span_b_addr (dest21_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest21_span_b_addr.dest21_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62b0c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest21_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest21_span_a_addr_type */
	/* skip, unused field unused_dest21_span_a_addr (dest21_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest21_span_a_addr.dest21_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62b08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest21_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest21_channel_addr_type */
	/* skip, unused field unused_dest21_channel_addr (dest21_channel_addr) */
	REG_DUMP_PRINT_1("   -dest21_channel_addr.dest21_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62b04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest21_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest21_requester_addr_type */
	/* skip, unused field unused_dest21_requester_addr (dest21_requester_addr) */
	REG_DUMP_PRINT_1("   -dest21_requester_addr.dest21_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62b00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest21_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest21_feed_addr_type */
	/* skip, unused field unused_dest21_feed_addr (dest21_feed_addr) */
	REG_DUMP_PRINT_1("   -dest21_feed_addr.dest21_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62924);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest20_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest20_iwake_threshold_type */
	/* skip, unused field unused_dest20_iwake_threshold (dest20_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest20_iwake_threshold.dest20_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6291c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest20_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest20_st_addr_type */
	REG_DUMP_PRINT_1("   -dest20_st_addr.dest20_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x62918);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest20_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest20_dest_mode_type */
	/* skip, unused field unused_dest20_dest_mode (dest20_dest_mode) */
	REG_DUMP_PRINT_1("   -dest20_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest20_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest20_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest20_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest20_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x62914);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest20_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest20_term_b_addr_type */
	/* skip, unused field unused_dest20_term_b_addr (dest20_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest20_term_b_addr.dest20_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62910);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest20_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest20_span_b_addr_type */
	/* skip, unused field unused_dest20_span_b_addr (dest20_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest20_span_b_addr.dest20_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6290c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest20_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest20_span_a_addr_type */
	/* skip, unused field unused_dest20_span_a_addr (dest20_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest20_span_a_addr.dest20_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62908);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest20_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest20_channel_addr_type */
	/* skip, unused field unused_dest20_channel_addr (dest20_channel_addr) */
	REG_DUMP_PRINT_1("   -dest20_channel_addr.dest20_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62904);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest20_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest20_requester_addr_type */
	/* skip, unused field unused_dest20_requester_addr (dest20_requester_addr) */
	REG_DUMP_PRINT_1("   -dest20_requester_addr.dest20_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62900);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest20_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest20_feed_addr_type */
	/* skip, unused field unused_dest20_feed_addr (dest20_feed_addr) */
	REG_DUMP_PRINT_1("   -dest20_feed_addr.dest20_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62724);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest19_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest19_iwake_threshold_type */
	/* skip, unused field unused_dest19_iwake_threshold (dest19_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest19_iwake_threshold.dest19_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6271c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest19_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest19_st_addr_type */
	REG_DUMP_PRINT_1("   -dest19_st_addr.dest19_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x62718);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest19_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest19_dest_mode_type */
	/* skip, unused field unused_dest19_dest_mode (dest19_dest_mode) */
	REG_DUMP_PRINT_1("   -dest19_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest19_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest19_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest19_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest19_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x62714);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest19_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest19_term_b_addr_type */
	/* skip, unused field unused_dest19_term_b_addr (dest19_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest19_term_b_addr.dest19_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62710);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest19_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest19_span_b_addr_type */
	/* skip, unused field unused_dest19_span_b_addr (dest19_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest19_span_b_addr.dest19_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6270c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest19_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest19_span_a_addr_type */
	/* skip, unused field unused_dest19_span_a_addr (dest19_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest19_span_a_addr.dest19_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62708);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest19_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest19_channel_addr_type */
	/* skip, unused field unused_dest19_channel_addr (dest19_channel_addr) */
	REG_DUMP_PRINT_1("   -dest19_channel_addr.dest19_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62704);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest19_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest19_requester_addr_type */
	/* skip, unused field unused_dest19_requester_addr (dest19_requester_addr) */
	REG_DUMP_PRINT_1("   -dest19_requester_addr.dest19_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62700);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest19_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest19_feed_addr_type */
	/* skip, unused field unused_dest19_feed_addr (dest19_feed_addr) */
	REG_DUMP_PRINT_1("   -dest19_feed_addr.dest19_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62524);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest18_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest18_iwake_threshold_type */
	/* skip, unused field unused_dest18_iwake_threshold (dest18_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest18_iwake_threshold.dest18_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6251c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest18_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest18_st_addr_type */
	REG_DUMP_PRINT_1("   -dest18_st_addr.dest18_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x62518);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest18_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest18_dest_mode_type */
	/* skip, unused field unused_dest18_dest_mode (dest18_dest_mode) */
	REG_DUMP_PRINT_1("   -dest18_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest18_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest18_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest18_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest18_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x62514);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest18_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest18_term_b_addr_type */
	/* skip, unused field unused_dest18_term_b_addr (dest18_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest18_term_b_addr.dest18_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62510);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest18_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest18_span_b_addr_type */
	/* skip, unused field unused_dest18_span_b_addr (dest18_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest18_span_b_addr.dest18_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6250c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest18_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest18_span_a_addr_type */
	/* skip, unused field unused_dest18_span_a_addr (dest18_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest18_span_a_addr.dest18_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62508);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest18_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest18_channel_addr_type */
	/* skip, unused field unused_dest18_channel_addr (dest18_channel_addr) */
	REG_DUMP_PRINT_1("   -dest18_channel_addr.dest18_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62504);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest18_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest18_requester_addr_type */
	/* skip, unused field unused_dest18_requester_addr (dest18_requester_addr) */
	REG_DUMP_PRINT_1("   -dest18_requester_addr.dest18_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62500);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest18_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest18_feed_addr_type */
	/* skip, unused field unused_dest18_feed_addr (dest18_feed_addr) */
	REG_DUMP_PRINT_1("   -dest18_feed_addr.dest18_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62324);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest17_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest17_iwake_threshold_type */
	/* skip, unused field unused_dest17_iwake_threshold (dest17_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest17_iwake_threshold.dest17_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6231c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest17_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest17_st_addr_type */
	REG_DUMP_PRINT_1("   -dest17_st_addr.dest17_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x62318);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest17_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest17_dest_mode_type */
	/* skip, unused field unused_dest17_dest_mode (dest17_dest_mode) */
	REG_DUMP_PRINT_1("   -dest17_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest17_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest17_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest17_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest17_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x62314);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest17_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest17_term_b_addr_type */
	/* skip, unused field unused_dest17_term_b_addr (dest17_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest17_term_b_addr.dest17_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62310);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest17_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest17_span_b_addr_type */
	/* skip, unused field unused_dest17_span_b_addr (dest17_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest17_span_b_addr.dest17_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6230c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest17_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest17_span_a_addr_type */
	/* skip, unused field unused_dest17_span_a_addr (dest17_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest17_span_a_addr.dest17_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62308);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest17_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest17_channel_addr_type */
	/* skip, unused field unused_dest17_channel_addr (dest17_channel_addr) */
	REG_DUMP_PRINT_1("   -dest17_channel_addr.dest17_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62304);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest17_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest17_requester_addr_type */
	/* skip, unused field unused_dest17_requester_addr (dest17_requester_addr) */
	REG_DUMP_PRINT_1("   -dest17_requester_addr.dest17_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62300);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest17_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest17_feed_addr_type */
	/* skip, unused field unused_dest17_feed_addr (dest17_feed_addr) */
	REG_DUMP_PRINT_1("   -dest17_feed_addr.dest17_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62124);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest16_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest16_iwake_threshold_type */
	/* skip, unused field unused_dest16_iwake_threshold (dest16_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest16_iwake_threshold.dest16_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6211c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest16_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest16_st_addr_type */
	REG_DUMP_PRINT_1("   -dest16_st_addr.dest16_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x62118);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest16_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest16_dest_mode_type */
	/* skip, unused field unused_dest16_dest_mode (dest16_dest_mode) */
	REG_DUMP_PRINT_1("   -dest16_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest16_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest16_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest16_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest16_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x62114);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest16_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest16_term_b_addr_type */
	/* skip, unused field unused_dest16_term_b_addr (dest16_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest16_term_b_addr.dest16_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62110);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest16_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest16_span_b_addr_type */
	/* skip, unused field unused_dest16_span_b_addr (dest16_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest16_span_b_addr.dest16_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6210c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest16_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest16_span_a_addr_type */
	/* skip, unused field unused_dest16_span_a_addr (dest16_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest16_span_a_addr.dest16_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62108);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest16_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest16_channel_addr_type */
	/* skip, unused field unused_dest16_channel_addr (dest16_channel_addr) */
	REG_DUMP_PRINT_1("   -dest16_channel_addr.dest16_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62104);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest16_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest16_requester_addr_type */
	/* skip, unused field unused_dest16_requester_addr (dest16_requester_addr) */
	REG_DUMP_PRINT_1("   -dest16_requester_addr.dest16_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x62100);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest16_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest16_feed_addr_type */
	/* skip, unused field unused_dest16_feed_addr (dest16_feed_addr) */
	REG_DUMP_PRINT_1("   -dest16_feed_addr.dest16_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61f24);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest15_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest15_iwake_threshold_type */
	/* skip, unused field unused_dest15_iwake_threshold (dest15_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest15_iwake_threshold.dest15_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x61f1c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest15_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest15_st_addr_type */
	REG_DUMP_PRINT_1("   -dest15_st_addr.dest15_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x61f18);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest15_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest15_dest_mode_type */
	/* skip, unused field unused_dest15_dest_mode (dest15_dest_mode) */
	REG_DUMP_PRINT_1("   -dest15_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest15_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest15_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest15_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest15_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x61f14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest15_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest15_term_b_addr_type */
	/* skip, unused field unused_dest15_term_b_addr (dest15_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest15_term_b_addr.dest15_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61f10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest15_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest15_span_b_addr_type */
	/* skip, unused field unused_dest15_span_b_addr (dest15_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest15_span_b_addr.dest15_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61f0c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest15_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest15_span_a_addr_type */
	/* skip, unused field unused_dest15_span_a_addr (dest15_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest15_span_a_addr.dest15_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61f08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest15_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest15_channel_addr_type */
	/* skip, unused field unused_dest15_channel_addr (dest15_channel_addr) */
	REG_DUMP_PRINT_1("   -dest15_channel_addr.dest15_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61f04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest15_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest15_requester_addr_type */
	/* skip, unused field unused_dest15_requester_addr (dest15_requester_addr) */
	REG_DUMP_PRINT_1("   -dest15_requester_addr.dest15_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61f00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest15_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest15_feed_addr_type */
	/* skip, unused field unused_dest15_feed_addr (dest15_feed_addr) */
	REG_DUMP_PRINT_1("   -dest15_feed_addr.dest15_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61ee4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_dest0_cur_cmds                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid15_dest0_cur_cmds_type */
	/* skip, unused field unused_sid15_dest0_cur_cmds (sid15_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid15_dest0_cur_cmds.sid15_dest0_cur_cmds                          |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x61ee0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_dest0_sync_state                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid15_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid15_dest0_sync_state.sid15_dest0_sync_state                      |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x61edc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_dest0_cur_ack_line                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid15_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid15_dest0_cur_ack_line (sid15_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid15_dest0_cur_ack_line.sid15_dest0_cur_ack_line                  |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x61ed8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_dest0_cur_ack_unit_in_line                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid15_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid15_dest0_cur_ack_unit_in_line (sid15_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid15_dest0_cur_ack_unit_in_line.sid15_dest0_cur_ack_unit_in_line  |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x61ed4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_dest0_cur_ack_unit                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid15_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid15_dest0_cur_ack_unit (sid15_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid15_dest0_cur_ack_unit.sid15_dest0_cur_ack_unit                  |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x61ecc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_main_control_state                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid15_main_control_state_type */
	/* skip, unused field unused_sid15_main_control_state (sid15_main_control_state) */
	REG_DUMP_PRINT_1("   -sid15_main_control_state.sid15_main_control_state                  |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x61ec8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_s2m_cur_ack_line                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid15_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid15_s2m_cur_ack_line (sid15_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid15_s2m_cur_ack_line.sid15_s2m_cur_ack_line                      |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x61ec4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_s2m_cur_ack_unit_in_line                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid15_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid15_s2m_cur_ack_unit_in_line (sid15_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid15_s2m_cur_ack_unit_in_line.sid15_s2m_cur_ack_unit_in_line      |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x61ec0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_s2m_cur_cmds                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid15_s2m_cur_cmds_type */
	/* skip, unused field unused_sid15_s2m_cur_cmds (sid15_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid15_s2m_cur_cmds.sid15_s2m_cur_cmds                              |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x61e98);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_error_reg                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid15_error_reg_type */
	REG_DUMP_PRINT_1("   -sid15_error_reg.sid15_error_reg                                    |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x61e88);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_eventque_sidpid                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid15_eventque_sidpid_type */
	/* skip, unused field unused_sid15_eventque_sidpid (sid15_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid15_eventque_sidpid.sid15_eventque_sidpid                        |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x61e84);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_ack_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid15_ack_addr_type */
	/* skip, unused field unused_sid15_ack_addr (sid15_ack_addr) */
	REG_DUMP_PRINT_1("   -sid15_ack_addr.sid15_ack_addr                                      |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61e68);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_dest0_enabled                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid15_dest0_enabled_type */
	/* skip, unused field unused_sid15_dest0_enabled (sid15_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid15_dest0_enabled.sid15_dest0_enabled                            |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 15""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x61e5c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_first_page_nr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid15_first_page_nr_type */
	/* skip, unused field unused_sid15_first_page_nr (sid15_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid15_first_page_nr.sid15_first_page_nr                            |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x61e58);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_camera_select                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid15_camera_select_type */
	/* skip, unused field unused_sid15_camera_select (sid15_camera_select) */
	REG_DUMP_PRINT_1("   -sid15_camera_select.sid15_camera_select                            |         0x%01X  |  [RW][03:00]""SID proc belongs to this camera, used to determine which secure touch enable signal should be used. This is bit encoded, bit 0 belongs to camera 0, bit 1 to camera 1 etc.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x61e54);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_units_p_ibuf                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid15_units_p_ibuf_type */
	/* skip, unused field unused_sid15_units_p_ibuf (sid15_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid15_units_p_ibuf.sid15_units_p_ibuf                              |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x61e50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_unit_size                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid15_unit_size_type */
	/* skip, unused field unused_sid15_unit_size (sid15_unit_size) */
	REG_DUMP_PRINT_1("   -sid15_unit_size.sid15_unit_size                                    |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0x61e4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_lines_p_frame                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid15_lines_p_frame_type */
	/* skip, unused field unused_sid15_lines_p_frame (sid15_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid15_lines_p_frame.sid15_lines_p_frame                            |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x61e48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_units_p_line                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid15_units_p_line_type */
	/* skip, unused field unused_sid15_units_p_line (sid15_units_p_line) */
	REG_DUMP_PRINT_1("   -sid15_units_p_line.sid15_units_p_line                              |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x61e44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_str2mmio_store_cmd                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid15_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid15_str2mmio_store_cmd (sid15_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid15_str2mmio_store_cmd.sid15_str2mmio_store_cmd                  |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x61e40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid15_str2mmio_proc_addr                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid15_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid15_str2mmio_proc_addr (sid15_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid15_str2mmio_proc_addr.sid15_str2mmio_proc_addr                  |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61d24);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest14_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest14_iwake_threshold_type */
	/* skip, unused field unused_dest14_iwake_threshold (dest14_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest14_iwake_threshold.dest14_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x61d1c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest14_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest14_st_addr_type */
	REG_DUMP_PRINT_1("   -dest14_st_addr.dest14_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x61d18);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest14_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest14_dest_mode_type */
	/* skip, unused field unused_dest14_dest_mode (dest14_dest_mode) */
	REG_DUMP_PRINT_1("   -dest14_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest14_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest14_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest14_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest14_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x61d14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest14_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest14_term_b_addr_type */
	/* skip, unused field unused_dest14_term_b_addr (dest14_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest14_term_b_addr.dest14_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61d10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest14_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest14_span_b_addr_type */
	/* skip, unused field unused_dest14_span_b_addr (dest14_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest14_span_b_addr.dest14_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61d0c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest14_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest14_span_a_addr_type */
	/* skip, unused field unused_dest14_span_a_addr (dest14_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest14_span_a_addr.dest14_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61d08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest14_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest14_channel_addr_type */
	/* skip, unused field unused_dest14_channel_addr (dest14_channel_addr) */
	REG_DUMP_PRINT_1("   -dest14_channel_addr.dest14_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61d04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest14_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest14_requester_addr_type */
	/* skip, unused field unused_dest14_requester_addr (dest14_requester_addr) */
	REG_DUMP_PRINT_1("   -dest14_requester_addr.dest14_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61d00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest14_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest14_feed_addr_type */
	/* skip, unused field unused_dest14_feed_addr (dest14_feed_addr) */
	REG_DUMP_PRINT_1("   -dest14_feed_addr.dest14_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61ce4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_dest0_cur_cmds                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid14_dest0_cur_cmds_type */
	/* skip, unused field unused_sid14_dest0_cur_cmds (sid14_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid14_dest0_cur_cmds.sid14_dest0_cur_cmds                          |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x61ce0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_dest0_sync_state                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid14_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid14_dest0_sync_state.sid14_dest0_sync_state                      |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x61cdc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_dest0_cur_ack_line                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid14_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid14_dest0_cur_ack_line (sid14_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid14_dest0_cur_ack_line.sid14_dest0_cur_ack_line                  |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x61cd8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_dest0_cur_ack_unit_in_line                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid14_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid14_dest0_cur_ack_unit_in_line (sid14_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid14_dest0_cur_ack_unit_in_line.sid14_dest0_cur_ack_unit_in_line  |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x61cd4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_dest0_cur_ack_unit                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid14_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid14_dest0_cur_ack_unit (sid14_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid14_dest0_cur_ack_unit.sid14_dest0_cur_ack_unit                  |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x61ccc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_main_control_state                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid14_main_control_state_type */
	/* skip, unused field unused_sid14_main_control_state (sid14_main_control_state) */
	REG_DUMP_PRINT_1("   -sid14_main_control_state.sid14_main_control_state                  |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x61cc8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_s2m_cur_ack_line                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid14_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid14_s2m_cur_ack_line (sid14_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid14_s2m_cur_ack_line.sid14_s2m_cur_ack_line                      |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x61cc4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_s2m_cur_ack_unit_in_line                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid14_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid14_s2m_cur_ack_unit_in_line (sid14_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid14_s2m_cur_ack_unit_in_line.sid14_s2m_cur_ack_unit_in_line      |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x61cc0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_s2m_cur_cmds                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid14_s2m_cur_cmds_type */
	/* skip, unused field unused_sid14_s2m_cur_cmds (sid14_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid14_s2m_cur_cmds.sid14_s2m_cur_cmds                              |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x61c98);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_error_reg                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid14_error_reg_type */
	REG_DUMP_PRINT_1("   -sid14_error_reg.sid14_error_reg                                    |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x61c88);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_eventque_sidpid                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid14_eventque_sidpid_type */
	/* skip, unused field unused_sid14_eventque_sidpid (sid14_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid14_eventque_sidpid.sid14_eventque_sidpid                        |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x61c84);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_ack_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid14_ack_addr_type */
	/* skip, unused field unused_sid14_ack_addr (sid14_ack_addr) */
	REG_DUMP_PRINT_1("   -sid14_ack_addr.sid14_ack_addr                                      |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61c68);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_dest0_enabled                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid14_dest0_enabled_type */
	/* skip, unused field unused_sid14_dest0_enabled (sid14_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid14_dest0_enabled.sid14_dest0_enabled                            |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 14""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x61c5c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_first_page_nr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid14_first_page_nr_type */
	/* skip, unused field unused_sid14_first_page_nr (sid14_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid14_first_page_nr.sid14_first_page_nr                            |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x61c58);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_camera_select                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid14_camera_select_type */
	/* skip, unused field unused_sid14_camera_select (sid14_camera_select) */
	REG_DUMP_PRINT_1("   -sid14_camera_select.sid14_camera_select                            |         0x%01X  |  [RW][03:00]""SID proc belongs to this camera, used to determine which secure touch enable signal should be used. This is bit encoded, bit 0 belongs to camera 0, bit 1 to camera 1 etc.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x61c54);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_units_p_ibuf                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid14_units_p_ibuf_type */
	/* skip, unused field unused_sid14_units_p_ibuf (sid14_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid14_units_p_ibuf.sid14_units_p_ibuf                              |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x61c50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_unit_size                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid14_unit_size_type */
	/* skip, unused field unused_sid14_unit_size (sid14_unit_size) */
	REG_DUMP_PRINT_1("   -sid14_unit_size.sid14_unit_size                                    |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0x61c4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_lines_p_frame                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid14_lines_p_frame_type */
	/* skip, unused field unused_sid14_lines_p_frame (sid14_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid14_lines_p_frame.sid14_lines_p_frame                            |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x61c48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_units_p_line                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid14_units_p_line_type */
	/* skip, unused field unused_sid14_units_p_line (sid14_units_p_line) */
	REG_DUMP_PRINT_1("   -sid14_units_p_line.sid14_units_p_line                              |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x61c44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_str2mmio_store_cmd                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid14_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid14_str2mmio_store_cmd (sid14_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid14_str2mmio_store_cmd.sid14_str2mmio_store_cmd                  |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x61c40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid14_str2mmio_proc_addr                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid14_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid14_str2mmio_proc_addr (sid14_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid14_str2mmio_proc_addr.sid14_str2mmio_proc_addr                  |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61b24);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest13_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest13_iwake_threshold_type */
	/* skip, unused field unused_dest13_iwake_threshold (dest13_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest13_iwake_threshold.dest13_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x61b1c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest13_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest13_st_addr_type */
	REG_DUMP_PRINT_1("   -dest13_st_addr.dest13_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x61b18);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest13_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest13_dest_mode_type */
	/* skip, unused field unused_dest13_dest_mode (dest13_dest_mode) */
	REG_DUMP_PRINT_1("   -dest13_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest13_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest13_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest13_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest13_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x61b14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest13_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest13_term_b_addr_type */
	/* skip, unused field unused_dest13_term_b_addr (dest13_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest13_term_b_addr.dest13_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61b10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest13_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest13_span_b_addr_type */
	/* skip, unused field unused_dest13_span_b_addr (dest13_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest13_span_b_addr.dest13_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61b0c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest13_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest13_span_a_addr_type */
	/* skip, unused field unused_dest13_span_a_addr (dest13_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest13_span_a_addr.dest13_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61b08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest13_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest13_channel_addr_type */
	/* skip, unused field unused_dest13_channel_addr (dest13_channel_addr) */
	REG_DUMP_PRINT_1("   -dest13_channel_addr.dest13_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61b04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest13_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest13_requester_addr_type */
	/* skip, unused field unused_dest13_requester_addr (dest13_requester_addr) */
	REG_DUMP_PRINT_1("   -dest13_requester_addr.dest13_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61b00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest13_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest13_feed_addr_type */
	/* skip, unused field unused_dest13_feed_addr (dest13_feed_addr) */
	REG_DUMP_PRINT_1("   -dest13_feed_addr.dest13_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61ae4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_dest0_cur_cmds                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid13_dest0_cur_cmds_type */
	/* skip, unused field unused_sid13_dest0_cur_cmds (sid13_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid13_dest0_cur_cmds.sid13_dest0_cur_cmds                          |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x61ae0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_dest0_sync_state                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid13_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid13_dest0_sync_state.sid13_dest0_sync_state                      |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x61adc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_dest0_cur_ack_line                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid13_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid13_dest0_cur_ack_line (sid13_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid13_dest0_cur_ack_line.sid13_dest0_cur_ack_line                  |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x61ad8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_dest0_cur_ack_unit_in_line                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid13_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid13_dest0_cur_ack_unit_in_line (sid13_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid13_dest0_cur_ack_unit_in_line.sid13_dest0_cur_ack_unit_in_line  |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x61ad4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_dest0_cur_ack_unit                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid13_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid13_dest0_cur_ack_unit (sid13_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid13_dest0_cur_ack_unit.sid13_dest0_cur_ack_unit                  |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x61acc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_main_control_state                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid13_main_control_state_type */
	/* skip, unused field unused_sid13_main_control_state (sid13_main_control_state) */
	REG_DUMP_PRINT_1("   -sid13_main_control_state.sid13_main_control_state                  |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x61ac8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_s2m_cur_ack_line                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid13_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid13_s2m_cur_ack_line (sid13_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid13_s2m_cur_ack_line.sid13_s2m_cur_ack_line                      |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x61ac4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_s2m_cur_ack_unit_in_line                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid13_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid13_s2m_cur_ack_unit_in_line (sid13_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid13_s2m_cur_ack_unit_in_line.sid13_s2m_cur_ack_unit_in_line      |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x61ac0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_s2m_cur_cmds                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid13_s2m_cur_cmds_type */
	/* skip, unused field unused_sid13_s2m_cur_cmds (sid13_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid13_s2m_cur_cmds.sid13_s2m_cur_cmds                              |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x61a98);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_error_reg                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid13_error_reg_type */
	REG_DUMP_PRINT_1("   -sid13_error_reg.sid13_error_reg                                    |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x61a88);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_eventque_sidpid                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid13_eventque_sidpid_type */
	/* skip, unused field unused_sid13_eventque_sidpid (sid13_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid13_eventque_sidpid.sid13_eventque_sidpid                        |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x61a84);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_ack_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid13_ack_addr_type */
	/* skip, unused field unused_sid13_ack_addr (sid13_ack_addr) */
	REG_DUMP_PRINT_1("   -sid13_ack_addr.sid13_ack_addr                                      |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61a68);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_dest0_enabled                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid13_dest0_enabled_type */
	/* skip, unused field unused_sid13_dest0_enabled (sid13_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid13_dest0_enabled.sid13_dest0_enabled                            |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 13""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x61a5c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_first_page_nr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid13_first_page_nr_type */
	/* skip, unused field unused_sid13_first_page_nr (sid13_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid13_first_page_nr.sid13_first_page_nr                            |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x61a58);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_camera_select                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid13_camera_select_type */
	/* skip, unused field unused_sid13_camera_select (sid13_camera_select) */
	REG_DUMP_PRINT_1("   -sid13_camera_select.sid13_camera_select                            |         0x%01X  |  [RW][03:00]""SID proc belongs to this camera, used to determine which secure touch enable signal should be used. This is bit encoded, bit 0 belongs to camera 0, bit 1 to camera 1 etc.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x61a54);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_units_p_ibuf                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid13_units_p_ibuf_type */
	/* skip, unused field unused_sid13_units_p_ibuf (sid13_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid13_units_p_ibuf.sid13_units_p_ibuf                              |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x61a50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_unit_size                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid13_unit_size_type */
	/* skip, unused field unused_sid13_unit_size (sid13_unit_size) */
	REG_DUMP_PRINT_1("   -sid13_unit_size.sid13_unit_size                                    |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0x61a4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_lines_p_frame                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid13_lines_p_frame_type */
	/* skip, unused field unused_sid13_lines_p_frame (sid13_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid13_lines_p_frame.sid13_lines_p_frame                            |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x61a48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_units_p_line                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid13_units_p_line_type */
	/* skip, unused field unused_sid13_units_p_line (sid13_units_p_line) */
	REG_DUMP_PRINT_1("   -sid13_units_p_line.sid13_units_p_line                              |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x61a44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_str2mmio_store_cmd                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid13_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid13_str2mmio_store_cmd (sid13_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid13_str2mmio_store_cmd.sid13_str2mmio_store_cmd                  |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x61a40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid13_str2mmio_proc_addr                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid13_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid13_str2mmio_proc_addr (sid13_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid13_str2mmio_proc_addr.sid13_str2mmio_proc_addr                  |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61924);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest12_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest12_iwake_threshold_type */
	/* skip, unused field unused_dest12_iwake_threshold (dest12_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest12_iwake_threshold.dest12_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6191c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest12_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest12_st_addr_type */
	REG_DUMP_PRINT_1("   -dest12_st_addr.dest12_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x61918);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest12_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest12_dest_mode_type */
	/* skip, unused field unused_dest12_dest_mode (dest12_dest_mode) */
	REG_DUMP_PRINT_1("   -dest12_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest12_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest12_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest12_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest12_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x61914);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest12_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest12_term_b_addr_type */
	/* skip, unused field unused_dest12_term_b_addr (dest12_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest12_term_b_addr.dest12_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61910);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest12_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest12_span_b_addr_type */
	/* skip, unused field unused_dest12_span_b_addr (dest12_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest12_span_b_addr.dest12_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6190c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest12_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest12_span_a_addr_type */
	/* skip, unused field unused_dest12_span_a_addr (dest12_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest12_span_a_addr.dest12_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61908);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest12_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest12_channel_addr_type */
	/* skip, unused field unused_dest12_channel_addr (dest12_channel_addr) */
	REG_DUMP_PRINT_1("   -dest12_channel_addr.dest12_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61904);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest12_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest12_requester_addr_type */
	/* skip, unused field unused_dest12_requester_addr (dest12_requester_addr) */
	REG_DUMP_PRINT_1("   -dest12_requester_addr.dest12_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61900);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest12_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest12_feed_addr_type */
	/* skip, unused field unused_dest12_feed_addr (dest12_feed_addr) */
	REG_DUMP_PRINT_1("   -dest12_feed_addr.dest12_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x618e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_dest0_cur_cmds                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid12_dest0_cur_cmds_type */
	/* skip, unused field unused_sid12_dest0_cur_cmds (sid12_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid12_dest0_cur_cmds.sid12_dest0_cur_cmds                          |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x618e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_dest0_sync_state                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid12_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid12_dest0_sync_state.sid12_dest0_sync_state                      |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x618dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_dest0_cur_ack_line                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid12_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid12_dest0_cur_ack_line (sid12_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid12_dest0_cur_ack_line.sid12_dest0_cur_ack_line                  |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x618d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_dest0_cur_ack_unit_in_line                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid12_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid12_dest0_cur_ack_unit_in_line (sid12_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid12_dest0_cur_ack_unit_in_line.sid12_dest0_cur_ack_unit_in_line  |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x618d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_dest0_cur_ack_unit                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid12_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid12_dest0_cur_ack_unit (sid12_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid12_dest0_cur_ack_unit.sid12_dest0_cur_ack_unit                  |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x618cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_main_control_state                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid12_main_control_state_type */
	/* skip, unused field unused_sid12_main_control_state (sid12_main_control_state) */
	REG_DUMP_PRINT_1("   -sid12_main_control_state.sid12_main_control_state                  |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x618c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_s2m_cur_ack_line                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid12_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid12_s2m_cur_ack_line (sid12_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid12_s2m_cur_ack_line.sid12_s2m_cur_ack_line                      |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x618c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_s2m_cur_ack_unit_in_line                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid12_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid12_s2m_cur_ack_unit_in_line (sid12_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid12_s2m_cur_ack_unit_in_line.sid12_s2m_cur_ack_unit_in_line      |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x618c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_s2m_cur_cmds                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid12_s2m_cur_cmds_type */
	/* skip, unused field unused_sid12_s2m_cur_cmds (sid12_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid12_s2m_cur_cmds.sid12_s2m_cur_cmds                              |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x61898);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_error_reg                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid12_error_reg_type */
	REG_DUMP_PRINT_1("   -sid12_error_reg.sid12_error_reg                                    |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x61888);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_eventque_sidpid                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid12_eventque_sidpid_type */
	/* skip, unused field unused_sid12_eventque_sidpid (sid12_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid12_eventque_sidpid.sid12_eventque_sidpid                        |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x61884);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_ack_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid12_ack_addr_type */
	/* skip, unused field unused_sid12_ack_addr (sid12_ack_addr) */
	REG_DUMP_PRINT_1("   -sid12_ack_addr.sid12_ack_addr                                      |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61868);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_dest0_enabled                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid12_dest0_enabled_type */
	/* skip, unused field unused_sid12_dest0_enabled (sid12_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid12_dest0_enabled.sid12_dest0_enabled                            |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 12""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6185c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_first_page_nr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid12_first_page_nr_type */
	/* skip, unused field unused_sid12_first_page_nr (sid12_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid12_first_page_nr.sid12_first_page_nr                            |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x61858);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_camera_select                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid12_camera_select_type */
	/* skip, unused field unused_sid12_camera_select (sid12_camera_select) */
	REG_DUMP_PRINT_1("   -sid12_camera_select.sid12_camera_select                            |         0x%01X  |  [RW][03:00]""SID proc belongs to this camera, used to determine which secure touch enable signal should be used. This is bit encoded, bit 0 belongs to camera 0, bit 1 to camera 1 etc.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x61854);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_units_p_ibuf                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid12_units_p_ibuf_type */
	/* skip, unused field unused_sid12_units_p_ibuf (sid12_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid12_units_p_ibuf.sid12_units_p_ibuf                              |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x61850);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_unit_size                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid12_unit_size_type */
	/* skip, unused field unused_sid12_unit_size (sid12_unit_size) */
	REG_DUMP_PRINT_1("   -sid12_unit_size.sid12_unit_size                                    |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0x6184c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_lines_p_frame                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid12_lines_p_frame_type */
	/* skip, unused field unused_sid12_lines_p_frame (sid12_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid12_lines_p_frame.sid12_lines_p_frame                            |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x61848);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_units_p_line                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid12_units_p_line_type */
	/* skip, unused field unused_sid12_units_p_line (sid12_units_p_line) */
	REG_DUMP_PRINT_1("   -sid12_units_p_line.sid12_units_p_line                              |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x61844);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_str2mmio_store_cmd                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid12_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid12_str2mmio_store_cmd (sid12_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid12_str2mmio_store_cmd.sid12_str2mmio_store_cmd                  |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x61840);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid12_str2mmio_proc_addr                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid12_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid12_str2mmio_proc_addr (sid12_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid12_str2mmio_proc_addr.sid12_str2mmio_proc_addr                  |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61724);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest11_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest11_iwake_threshold_type */
	/* skip, unused field unused_dest11_iwake_threshold (dest11_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest11_iwake_threshold.dest11_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6171c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest11_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest11_st_addr_type */
	REG_DUMP_PRINT_1("   -dest11_st_addr.dest11_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x61718);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest11_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest11_dest_mode_type */
	/* skip, unused field unused_dest11_dest_mode (dest11_dest_mode) */
	REG_DUMP_PRINT_1("   -dest11_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest11_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest11_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest11_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest11_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x61714);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest11_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest11_term_b_addr_type */
	/* skip, unused field unused_dest11_term_b_addr (dest11_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest11_term_b_addr.dest11_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61710);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest11_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest11_span_b_addr_type */
	/* skip, unused field unused_dest11_span_b_addr (dest11_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest11_span_b_addr.dest11_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6170c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest11_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest11_span_a_addr_type */
	/* skip, unused field unused_dest11_span_a_addr (dest11_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest11_span_a_addr.dest11_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61708);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest11_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest11_channel_addr_type */
	/* skip, unused field unused_dest11_channel_addr (dest11_channel_addr) */
	REG_DUMP_PRINT_1("   -dest11_channel_addr.dest11_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61704);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest11_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest11_requester_addr_type */
	/* skip, unused field unused_dest11_requester_addr (dest11_requester_addr) */
	REG_DUMP_PRINT_1("   -dest11_requester_addr.dest11_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61700);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest11_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest11_feed_addr_type */
	/* skip, unused field unused_dest11_feed_addr (dest11_feed_addr) */
	REG_DUMP_PRINT_1("   -dest11_feed_addr.dest11_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x616e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_dest0_cur_cmds                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid11_dest0_cur_cmds_type */
	/* skip, unused field unused_sid11_dest0_cur_cmds (sid11_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid11_dest0_cur_cmds.sid11_dest0_cur_cmds                          |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x616e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_dest0_sync_state                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid11_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid11_dest0_sync_state.sid11_dest0_sync_state                      |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x616dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_dest0_cur_ack_line                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid11_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid11_dest0_cur_ack_line (sid11_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid11_dest0_cur_ack_line.sid11_dest0_cur_ack_line                  |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x616d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_dest0_cur_ack_unit_in_line                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid11_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid11_dest0_cur_ack_unit_in_line (sid11_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid11_dest0_cur_ack_unit_in_line.sid11_dest0_cur_ack_unit_in_line  |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x616d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_dest0_cur_ack_unit                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid11_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid11_dest0_cur_ack_unit (sid11_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid11_dest0_cur_ack_unit.sid11_dest0_cur_ack_unit                  |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x616cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_main_control_state                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid11_main_control_state_type */
	/* skip, unused field unused_sid11_main_control_state (sid11_main_control_state) */
	REG_DUMP_PRINT_1("   -sid11_main_control_state.sid11_main_control_state                  |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x616c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_s2m_cur_ack_line                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid11_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid11_s2m_cur_ack_line (sid11_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid11_s2m_cur_ack_line.sid11_s2m_cur_ack_line                      |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x616c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_s2m_cur_ack_unit_in_line                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid11_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid11_s2m_cur_ack_unit_in_line (sid11_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid11_s2m_cur_ack_unit_in_line.sid11_s2m_cur_ack_unit_in_line      |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x616c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_s2m_cur_cmds                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid11_s2m_cur_cmds_type */
	/* skip, unused field unused_sid11_s2m_cur_cmds (sid11_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid11_s2m_cur_cmds.sid11_s2m_cur_cmds                              |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x61698);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_error_reg                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid11_error_reg_type */
	REG_DUMP_PRINT_1("   -sid11_error_reg.sid11_error_reg                                    |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x61688);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_eventque_sidpid                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid11_eventque_sidpid_type */
	/* skip, unused field unused_sid11_eventque_sidpid (sid11_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid11_eventque_sidpid.sid11_eventque_sidpid                        |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x61684);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_ack_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid11_ack_addr_type */
	/* skip, unused field unused_sid11_ack_addr (sid11_ack_addr) */
	REG_DUMP_PRINT_1("   -sid11_ack_addr.sid11_ack_addr                                      |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61668);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_dest0_enabled                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid11_dest0_enabled_type */
	/* skip, unused field unused_sid11_dest0_enabled (sid11_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid11_dest0_enabled.sid11_dest0_enabled                            |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 11""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6165c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_first_page_nr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid11_first_page_nr_type */
	/* skip, unused field unused_sid11_first_page_nr (sid11_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid11_first_page_nr.sid11_first_page_nr                            |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x61658);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_camera_select                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid11_camera_select_type */
	/* skip, unused field unused_sid11_camera_select (sid11_camera_select) */
	REG_DUMP_PRINT_1("   -sid11_camera_select.sid11_camera_select                            |         0x%01X  |  [RW][03:00]""SID proc belongs to this camera, used to determine which secure touch enable signal should be used. This is bit encoded, bit 0 belongs to camera 0, bit 1 to camera 1 etc.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x61654);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_units_p_ibuf                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid11_units_p_ibuf_type */
	/* skip, unused field unused_sid11_units_p_ibuf (sid11_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid11_units_p_ibuf.sid11_units_p_ibuf                              |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x61650);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_unit_size                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid11_unit_size_type */
	/* skip, unused field unused_sid11_unit_size (sid11_unit_size) */
	REG_DUMP_PRINT_1("   -sid11_unit_size.sid11_unit_size                                    |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0x6164c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_lines_p_frame                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid11_lines_p_frame_type */
	/* skip, unused field unused_sid11_lines_p_frame (sid11_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid11_lines_p_frame.sid11_lines_p_frame                            |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x61648);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_units_p_line                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid11_units_p_line_type */
	/* skip, unused field unused_sid11_units_p_line (sid11_units_p_line) */
	REG_DUMP_PRINT_1("   -sid11_units_p_line.sid11_units_p_line                              |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x61644);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_str2mmio_store_cmd                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid11_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid11_str2mmio_store_cmd (sid11_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid11_str2mmio_store_cmd.sid11_str2mmio_store_cmd                  |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x61640);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid11_str2mmio_proc_addr                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid11_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid11_str2mmio_proc_addr (sid11_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid11_str2mmio_proc_addr.sid11_str2mmio_proc_addr                  |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61524);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest10_iwake_threshold                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest10_iwake_threshold_type */
	/* skip, unused field unused_dest10_iwake_threshold (dest10_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest10_iwake_threshold.dest10_iwake_threshold                      |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6151c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest10_st_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest10_st_addr_type */
	REG_DUMP_PRINT_1("   -dest10_st_addr.dest10_st_addr                                      |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x61518);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest10_dest_mode                                           |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest10_dest_mode_type */
	/* skip, unused field unused_dest10_dest_mode (dest10_dest_mode) */
	REG_DUMP_PRINT_1("   -dest10_dest_mode.is_ibuf_cntrl_feeder                              |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest10_dest_mode.config_dma                                        |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest10_dest_mode.iwake_enable                                      |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest10_dest_mode.disable_spana_rst                                 |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest10_dest_mode.disable_spanb_rst                                 |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x61514);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest10_term_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest10_term_b_addr_type */
	/* skip, unused field unused_dest10_term_b_addr (dest10_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest10_term_b_addr.dest10_term_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61510);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest10_span_b_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest10_span_b_addr_type */
	/* skip, unused field unused_dest10_span_b_addr (dest10_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest10_span_b_addr.dest10_span_b_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6150c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest10_span_a_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest10_span_a_addr_type */
	/* skip, unused field unused_dest10_span_a_addr (dest10_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest10_span_a_addr.dest10_span_a_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61508);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest10_channel_addr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest10_channel_addr_type */
	/* skip, unused field unused_dest10_channel_addr (dest10_channel_addr) */
	REG_DUMP_PRINT_1("   -dest10_channel_addr.dest10_channel_addr                            |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61504);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest10_requester_addr                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest10_requester_addr_type */
	/* skip, unused field unused_dest10_requester_addr (dest10_requester_addr) */
	REG_DUMP_PRINT_1("   -dest10_requester_addr.dest10_requester_addr                        |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61500);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest10_feed_addr                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest10_feed_addr_type */
	/* skip, unused field unused_dest10_feed_addr (dest10_feed_addr) */
	REG_DUMP_PRINT_1("   -dest10_feed_addr.dest10_feed_addr                                  |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x614e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_dest0_cur_cmds                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid10_dest0_cur_cmds_type */
	/* skip, unused field unused_sid10_dest0_cur_cmds (sid10_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid10_dest0_cur_cmds.sid10_dest0_cur_cmds                          |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x614e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_dest0_sync_state                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid10_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid10_dest0_sync_state.sid10_dest0_sync_state                      |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x614dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_dest0_cur_ack_line                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid10_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid10_dest0_cur_ack_line (sid10_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid10_dest0_cur_ack_line.sid10_dest0_cur_ack_line                  |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x614d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_dest0_cur_ack_unit_in_line                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid10_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid10_dest0_cur_ack_unit_in_line (sid10_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid10_dest0_cur_ack_unit_in_line.sid10_dest0_cur_ack_unit_in_line  |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x614d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_dest0_cur_ack_unit                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid10_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid10_dest0_cur_ack_unit (sid10_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid10_dest0_cur_ack_unit.sid10_dest0_cur_ack_unit                  |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x614cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_main_control_state                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid10_main_control_state_type */
	/* skip, unused field unused_sid10_main_control_state (sid10_main_control_state) */
	REG_DUMP_PRINT_1("   -sid10_main_control_state.sid10_main_control_state                  |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x614c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_s2m_cur_ack_line                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid10_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid10_s2m_cur_ack_line (sid10_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid10_s2m_cur_ack_line.sid10_s2m_cur_ack_line                      |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x614c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_s2m_cur_ack_unit_in_line                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid10_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid10_s2m_cur_ack_unit_in_line (sid10_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid10_s2m_cur_ack_unit_in_line.sid10_s2m_cur_ack_unit_in_line      |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x614c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_s2m_cur_cmds                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid10_s2m_cur_cmds_type */
	/* skip, unused field unused_sid10_s2m_cur_cmds (sid10_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid10_s2m_cur_cmds.sid10_s2m_cur_cmds                              |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x61498);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_error_reg                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid10_error_reg_type */
	REG_DUMP_PRINT_1("   -sid10_error_reg.sid10_error_reg                                    |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x61488);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_eventque_sidpid                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid10_eventque_sidpid_type */
	/* skip, unused field unused_sid10_eventque_sidpid (sid10_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid10_eventque_sidpid.sid10_eventque_sidpid                        |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x61484);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_ack_addr                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid10_ack_addr_type */
	/* skip, unused field unused_sid10_ack_addr (sid10_ack_addr) */
	REG_DUMP_PRINT_1("   -sid10_ack_addr.sid10_ack_addr                                      |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61468);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_dest0_enabled                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid10_dest0_enabled_type */
	/* skip, unused field unused_sid10_dest0_enabled (sid10_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid10_dest0_enabled.sid10_dest0_enabled                            |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 10""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6145c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_first_page_nr                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid10_first_page_nr_type */
	/* skip, unused field unused_sid10_first_page_nr (sid10_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid10_first_page_nr.sid10_first_page_nr                            |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x61458);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_camera_select                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid10_camera_select_type */
	/* skip, unused field unused_sid10_camera_select (sid10_camera_select) */
	REG_DUMP_PRINT_1("   -sid10_camera_select.sid10_camera_select                            |         0x%01X  |  [RW][03:00]""SID proc belongs to this camera, used to determine which secure touch enable signal should be used. This is bit encoded, bit 0 belongs to camera 0, bit 1 to camera 1 etc.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x61454);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_units_p_ibuf                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid10_units_p_ibuf_type */
	/* skip, unused field unused_sid10_units_p_ibuf (sid10_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid10_units_p_ibuf.sid10_units_p_ibuf                              |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x61450);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_unit_size                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid10_unit_size_type */
	/* skip, unused field unused_sid10_unit_size (sid10_unit_size) */
	REG_DUMP_PRINT_1("   -sid10_unit_size.sid10_unit_size                                    |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0x6144c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_lines_p_frame                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid10_lines_p_frame_type */
	/* skip, unused field unused_sid10_lines_p_frame (sid10_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid10_lines_p_frame.sid10_lines_p_frame                            |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x61448);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_units_p_line                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid10_units_p_line_type */
	/* skip, unused field unused_sid10_units_p_line (sid10_units_p_line) */
	REG_DUMP_PRINT_1("   -sid10_units_p_line.sid10_units_p_line                              |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x61444);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_str2mmio_store_cmd                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid10_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid10_str2mmio_store_cmd (sid10_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid10_str2mmio_store_cmd.sid10_str2mmio_store_cmd                  |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x61440);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid10_str2mmio_proc_addr                                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid10_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid10_str2mmio_proc_addr (sid10_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid10_str2mmio_proc_addr.sid10_str2mmio_proc_addr                  |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61324);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest9_iwake_threshold                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest9_iwake_threshold_type */
	/* skip, unused field unused_dest9_iwake_threshold (dest9_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest9_iwake_threshold.dest9_iwake_threshold                        |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6131c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest9_st_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest9_st_addr_type */
	REG_DUMP_PRINT_1("   -dest9_st_addr.dest9_st_addr                                        |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x61318);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest9_dest_mode                                            |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest9_dest_mode_type */
	/* skip, unused field unused_dest9_dest_mode (dest9_dest_mode) */
	REG_DUMP_PRINT_1("   -dest9_dest_mode.is_ibuf_cntrl_feeder                               |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest9_dest_mode.config_dma                                         |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest9_dest_mode.iwake_enable                                       |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest9_dest_mode.disable_spana_rst                                  |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest9_dest_mode.disable_spanb_rst                                  |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x61314);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest9_term_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest9_term_b_addr_type */
	/* skip, unused field unused_dest9_term_b_addr (dest9_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest9_term_b_addr.dest9_term_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61310);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest9_span_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest9_span_b_addr_type */
	/* skip, unused field unused_dest9_span_b_addr (dest9_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest9_span_b_addr.dest9_span_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6130c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest9_span_a_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest9_span_a_addr_type */
	/* skip, unused field unused_dest9_span_a_addr (dest9_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest9_span_a_addr.dest9_span_a_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61308);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest9_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest9_channel_addr_type */
	/* skip, unused field unused_dest9_channel_addr (dest9_channel_addr) */
	REG_DUMP_PRINT_1("   -dest9_channel_addr.dest9_channel_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61304);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest9_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest9_requester_addr_type */
	/* skip, unused field unused_dest9_requester_addr (dest9_requester_addr) */
	REG_DUMP_PRINT_1("   -dest9_requester_addr.dest9_requester_addr                          |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61300);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest9_feed_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest9_feed_addr_type */
	/* skip, unused field unused_dest9_feed_addr (dest9_feed_addr) */
	REG_DUMP_PRINT_1("   -dest9_feed_addr.dest9_feed_addr                                    |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x612e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_dest0_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid9_dest0_cur_cmds_type */
	/* skip, unused field unused_sid9_dest0_cur_cmds (sid9_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid9_dest0_cur_cmds.sid9_dest0_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x612e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_dest0_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid9_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid9_dest0_sync_state.sid9_dest0_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x612dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_dest0_cur_ack_line                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid9_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid9_dest0_cur_ack_line (sid9_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid9_dest0_cur_ack_line.sid9_dest0_cur_ack_line                    |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x612d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_dest0_cur_ack_unit_in_line                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid9_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid9_dest0_cur_ack_unit_in_line (sid9_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid9_dest0_cur_ack_unit_in_line.sid9_dest0_cur_ack_unit_in_line    |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x612d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_dest0_cur_ack_unit                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid9_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid9_dest0_cur_ack_unit (sid9_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid9_dest0_cur_ack_unit.sid9_dest0_cur_ack_unit                    |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x612cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_main_control_state                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid9_main_control_state_type */
	/* skip, unused field unused_sid9_main_control_state (sid9_main_control_state) */
	REG_DUMP_PRINT_1("   -sid9_main_control_state.sid9_main_control_state                    |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x612c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_s2m_cur_ack_line                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid9_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid9_s2m_cur_ack_line (sid9_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid9_s2m_cur_ack_line.sid9_s2m_cur_ack_line                        |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x612c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_s2m_cur_ack_unit_in_line                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid9_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid9_s2m_cur_ack_unit_in_line (sid9_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid9_s2m_cur_ack_unit_in_line.sid9_s2m_cur_ack_unit_in_line        |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x612c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_s2m_cur_cmds                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid9_s2m_cur_cmds_type */
	/* skip, unused field unused_sid9_s2m_cur_cmds (sid9_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid9_s2m_cur_cmds.sid9_s2m_cur_cmds                                |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x61298);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_error_reg                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid9_error_reg_type */
	REG_DUMP_PRINT_1("   -sid9_error_reg.sid9_error_reg                                      |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x61288);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_eventque_sidpid                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid9_eventque_sidpid_type */
	/* skip, unused field unused_sid9_eventque_sidpid (sid9_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid9_eventque_sidpid.sid9_eventque_sidpid                          |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x61284);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_ack_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid9_ack_addr_type */
	/* skip, unused field unused_sid9_ack_addr (sid9_ack_addr) */
	REG_DUMP_PRINT_1("   -sid9_ack_addr.sid9_ack_addr                                        |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61268);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_dest0_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid9_dest0_enabled_type */
	/* skip, unused field unused_sid9_dest0_enabled (sid9_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid9_dest0_enabled.sid9_dest0_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 9""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6125c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_first_page_nr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid9_first_page_nr_type */
	/* skip, unused field unused_sid9_first_page_nr (sid9_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid9_first_page_nr.sid9_first_page_nr                              |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x61258);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_camera_select                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid9_camera_select_type */
	/* skip, unused field unused_sid9_camera_select (sid9_camera_select) */
	REG_DUMP_PRINT_1("   -sid9_camera_select.sid9_camera_select                              |         0x%01X  |  [RW][03:00]""SID proc belongs to this camera, used to determine which secure touch enable signal should be used. This is bit encoded, bit 0 belongs to camera 0, bit 1 to camera 1 etc.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x61254);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_units_p_ibuf                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid9_units_p_ibuf_type */
	/* skip, unused field unused_sid9_units_p_ibuf (sid9_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid9_units_p_ibuf.sid9_units_p_ibuf                                |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x61250);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_unit_size                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid9_unit_size_type */
	/* skip, unused field unused_sid9_unit_size (sid9_unit_size) */
	REG_DUMP_PRINT_1("   -sid9_unit_size.sid9_unit_size                                      |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0x6124c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_lines_p_frame                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid9_lines_p_frame_type */
	/* skip, unused field unused_sid9_lines_p_frame (sid9_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid9_lines_p_frame.sid9_lines_p_frame                              |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x61248);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_units_p_line                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid9_units_p_line_type */
	/* skip, unused field unused_sid9_units_p_line (sid9_units_p_line) */
	REG_DUMP_PRINT_1("   -sid9_units_p_line.sid9_units_p_line                                |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x61244);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_str2mmio_store_cmd                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid9_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid9_str2mmio_store_cmd (sid9_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid9_str2mmio_store_cmd.sid9_str2mmio_store_cmd                    |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x61240);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid9_str2mmio_proc_addr                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid9_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid9_str2mmio_proc_addr (sid9_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid9_str2mmio_proc_addr.sid9_str2mmio_proc_addr                    |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61124);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest8_iwake_threshold                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest8_iwake_threshold_type */
	/* skip, unused field unused_dest8_iwake_threshold (dest8_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest8_iwake_threshold.dest8_iwake_threshold                        |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6111c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest8_st_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest8_st_addr_type */
	REG_DUMP_PRINT_1("   -dest8_st_addr.dest8_st_addr                                        |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x61118);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest8_dest_mode                                            |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest8_dest_mode_type */
	/* skip, unused field unused_dest8_dest_mode (dest8_dest_mode) */
	REG_DUMP_PRINT_1("   -dest8_dest_mode.is_ibuf_cntrl_feeder                               |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest8_dest_mode.config_dma                                         |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest8_dest_mode.iwake_enable                                       |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest8_dest_mode.disable_spana_rst                                  |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest8_dest_mode.disable_spanb_rst                                  |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x61114);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest8_term_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest8_term_b_addr_type */
	/* skip, unused field unused_dest8_term_b_addr (dest8_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest8_term_b_addr.dest8_term_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61110);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest8_span_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest8_span_b_addr_type */
	/* skip, unused field unused_dest8_span_b_addr (dest8_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest8_span_b_addr.dest8_span_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6110c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest8_span_a_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest8_span_a_addr_type */
	/* skip, unused field unused_dest8_span_a_addr (dest8_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest8_span_a_addr.dest8_span_a_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61108);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest8_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest8_channel_addr_type */
	/* skip, unused field unused_dest8_channel_addr (dest8_channel_addr) */
	REG_DUMP_PRINT_1("   -dest8_channel_addr.dest8_channel_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61104);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest8_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest8_requester_addr_type */
	/* skip, unused field unused_dest8_requester_addr (dest8_requester_addr) */
	REG_DUMP_PRINT_1("   -dest8_requester_addr.dest8_requester_addr                          |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61100);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest8_feed_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest8_feed_addr_type */
	/* skip, unused field unused_dest8_feed_addr (dest8_feed_addr) */
	REG_DUMP_PRINT_1("   -dest8_feed_addr.dest8_feed_addr                                    |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x610e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_dest0_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid8_dest0_cur_cmds_type */
	/* skip, unused field unused_sid8_dest0_cur_cmds (sid8_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid8_dest0_cur_cmds.sid8_dest0_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x610e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_dest0_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid8_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid8_dest0_sync_state.sid8_dest0_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x610dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_dest0_cur_ack_line                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid8_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid8_dest0_cur_ack_line (sid8_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid8_dest0_cur_ack_line.sid8_dest0_cur_ack_line                    |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x610d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_dest0_cur_ack_unit_in_line                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid8_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid8_dest0_cur_ack_unit_in_line (sid8_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid8_dest0_cur_ack_unit_in_line.sid8_dest0_cur_ack_unit_in_line    |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x610d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_dest0_cur_ack_unit                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid8_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid8_dest0_cur_ack_unit (sid8_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid8_dest0_cur_ack_unit.sid8_dest0_cur_ack_unit                    |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x610cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_main_control_state                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid8_main_control_state_type */
	/* skip, unused field unused_sid8_main_control_state (sid8_main_control_state) */
	REG_DUMP_PRINT_1("   -sid8_main_control_state.sid8_main_control_state                    |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x610c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_s2m_cur_ack_line                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid8_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid8_s2m_cur_ack_line (sid8_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid8_s2m_cur_ack_line.sid8_s2m_cur_ack_line                        |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x610c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_s2m_cur_ack_unit_in_line                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid8_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid8_s2m_cur_ack_unit_in_line (sid8_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid8_s2m_cur_ack_unit_in_line.sid8_s2m_cur_ack_unit_in_line        |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x610c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_s2m_cur_cmds                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid8_s2m_cur_cmds_type */
	/* skip, unused field unused_sid8_s2m_cur_cmds (sid8_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid8_s2m_cur_cmds.sid8_s2m_cur_cmds                                |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x61098);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_error_reg                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid8_error_reg_type */
	REG_DUMP_PRINT_1("   -sid8_error_reg.sid8_error_reg                                      |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x61088);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_eventque_sidpid                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid8_eventque_sidpid_type */
	/* skip, unused field unused_sid8_eventque_sidpid (sid8_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid8_eventque_sidpid.sid8_eventque_sidpid                          |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x61084);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_ack_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid8_ack_addr_type */
	/* skip, unused field unused_sid8_ack_addr (sid8_ack_addr) */
	REG_DUMP_PRINT_1("   -sid8_ack_addr.sid8_ack_addr                                        |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x61068);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_dest0_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid8_dest0_enabled_type */
	/* skip, unused field unused_sid8_dest0_enabled (sid8_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid8_dest0_enabled.sid8_dest0_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 8""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6105c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_first_page_nr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid8_first_page_nr_type */
	/* skip, unused field unused_sid8_first_page_nr (sid8_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid8_first_page_nr.sid8_first_page_nr                              |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x61058);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_camera_select                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid8_camera_select_type */
	/* skip, unused field unused_sid8_camera_select (sid8_camera_select) */
	REG_DUMP_PRINT_1("   -sid8_camera_select.sid8_camera_select                              |         0x%01X  |  [RW][03:00]""SID proc belongs to this camera, used to determine which secure touch enable signal should be used. This is bit encoded, bit 0 belongs to camera 0, bit 1 to camera 1 etc.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x61054);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_units_p_ibuf                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid8_units_p_ibuf_type */
	/* skip, unused field unused_sid8_units_p_ibuf (sid8_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid8_units_p_ibuf.sid8_units_p_ibuf                                |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x61050);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_unit_size                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid8_unit_size_type */
	/* skip, unused field unused_sid8_unit_size (sid8_unit_size) */
	REG_DUMP_PRINT_1("   -sid8_unit_size.sid8_unit_size                                      |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0x6104c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_lines_p_frame                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid8_lines_p_frame_type */
	/* skip, unused field unused_sid8_lines_p_frame (sid8_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid8_lines_p_frame.sid8_lines_p_frame                              |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x61048);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_units_p_line                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid8_units_p_line_type */
	/* skip, unused field unused_sid8_units_p_line (sid8_units_p_line) */
	REG_DUMP_PRINT_1("   -sid8_units_p_line.sid8_units_p_line                                |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x61044);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_str2mmio_store_cmd                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid8_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid8_str2mmio_store_cmd (sid8_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid8_str2mmio_store_cmd.sid8_str2mmio_store_cmd                    |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x61040);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid8_str2mmio_proc_addr                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid8_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid8_str2mmio_proc_addr (sid8_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid8_str2mmio_proc_addr.sid8_str2mmio_proc_addr                    |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60f58);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk7_token                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk7_token_type */
	REG_DUMP_PRINT_1("   -fr_chk7_token.fr_chk7_token                                        |  0x%08X  |  [RW][31:00]""The token that has to be written""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x60f54);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk7_addr                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk7_addr_type */
	/* skip, unused field unused_fr_chk7_addr (fr_chk7_addr) */
	REG_DUMP_PRINT_1("   -fr_chk7_addr.fr_chk7_addr                                          |  0x%08X  |  [RW][29:00]""The address of where the frame check token has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60f50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk7_trigger_repeat_val                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk7_trigger_repeat_val_type */
	/* skip, unused field unused_fr_chk7_trigger_repeat_val (fr_chk7_trigger_repeat_val) */
	REG_DUMP_PRINT_1("   -fr_chk7_trigger_repeat_val.fr_chk7_trigger_repeat_val              |      0x%04X  |  [RW][15:00]""An frame check token is send after each trigger_repeat_val value in case the repetitive enable bit in the check mode is set and the trigger offset has been reached.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x60f4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk7_trigger_offset                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk7_trigger_offset_type */
	/* skip, unused field unused_fr_chk7_trigger_offset (fr_chk7_trigger_offset) */
	REG_DUMP_PRINT_1("   -fr_chk7_trigger_offset.fr_chk7_trigger_offset                      |      0x%04X  |  [RW][15:00]""The value of the trigger, when the checked value becomes larger than the this value a frame check token is send""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x60f48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk7_sid_proc_id                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk7_sid_proc_id_type */
	/* skip, unused field unused_fr_chk7_sid_proc_id (fr_chk7_sid_proc_id) */
	REG_DUMP_PRINT_1("   -fr_chk7_sid_proc_id.fr_chk7_sid_proc_id                            |         0x%01X  |  [RW][03:00]""The ID of the SID proc that has to be checked""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x60f44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk7_check_mode                                         |  0x%08X  |  ""The mode of frame checking""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk7_check_mode_type */
	/* skip, unused field unused_fr_chk7_check_mode (fr_chk7_check_mode) */
	REG_DUMP_PRINT_1("   -fr_chk7_check_mode.check_type                                      |         0x%01X  |  [RW][00:00]""The type of value to be checking, 0: check lines; 1: check units;""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -fr_chk7_check_mode.repetive_enable                                 |         0x%01X  |  [RW][01:01]""Trigger and send and token after each repetitive value after the trigger offset is reached""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0x60f40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk7_enable                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk7_enable_type */
	/* skip, unused field unused_fr_chk7_enable (fr_chk7_enable) */
	REG_DUMP_PRINT_1("   -fr_chk7_enable.fr_chk7_enable                                      |         0x%01X  |  [RW][00:00]""Enable frame checking for this frame check unit""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x60f24);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest7_iwake_threshold                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest7_iwake_threshold_type */
	/* skip, unused field unused_dest7_iwake_threshold (dest7_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest7_iwake_threshold.dest7_iwake_threshold                        |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x60f1c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest7_st_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest7_st_addr_type */
	REG_DUMP_PRINT_1("   -dest7_st_addr.dest7_st_addr                                        |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x60f18);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest7_dest_mode                                            |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest7_dest_mode_type */
	/* skip, unused field unused_dest7_dest_mode (dest7_dest_mode) */
	REG_DUMP_PRINT_1("   -dest7_dest_mode.is_ibuf_cntrl_feeder                               |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest7_dest_mode.config_dma                                         |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest7_dest_mode.iwake_enable                                       |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest7_dest_mode.disable_spana_rst                                  |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest7_dest_mode.disable_spanb_rst                                  |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x60f14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest7_term_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest7_term_b_addr_type */
	/* skip, unused field unused_dest7_term_b_addr (dest7_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest7_term_b_addr.dest7_term_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60f10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest7_span_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest7_span_b_addr_type */
	/* skip, unused field unused_dest7_span_b_addr (dest7_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest7_span_b_addr.dest7_span_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60f0c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest7_span_a_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest7_span_a_addr_type */
	/* skip, unused field unused_dest7_span_a_addr (dest7_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest7_span_a_addr.dest7_span_a_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60f08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest7_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest7_channel_addr_type */
	/* skip, unused field unused_dest7_channel_addr (dest7_channel_addr) */
	REG_DUMP_PRINT_1("   -dest7_channel_addr.dest7_channel_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60f04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest7_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest7_requester_addr_type */
	/* skip, unused field unused_dest7_requester_addr (dest7_requester_addr) */
	REG_DUMP_PRINT_1("   -dest7_requester_addr.dest7_requester_addr                          |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60f00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest7_feed_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest7_feed_addr_type */
	/* skip, unused field unused_dest7_feed_addr (dest7_feed_addr) */
	REG_DUMP_PRINT_1("   -dest7_feed_addr.dest7_feed_addr                                    |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60eec);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_dest1_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid7_dest1_cur_cmds_type */
	/* skip, unused field unused_sid7_dest1_cur_cmds (sid7_dest1_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid7_dest1_cur_cmds.sid7_dest1_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x60ee8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_dest1_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid7_dest1_sync_state_type */
	REG_DUMP_PRINT_1("   -sid7_dest1_sync_state.sid7_dest1_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 1. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x60ee4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_dest0_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid7_dest0_cur_cmds_type */
	/* skip, unused field unused_sid7_dest0_cur_cmds (sid7_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid7_dest0_cur_cmds.sid7_dest0_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x60ee0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_dest0_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid7_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid7_dest0_sync_state.sid7_dest0_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x60edc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_dest0_cur_ack_line                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid7_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid7_dest0_cur_ack_line (sid7_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid7_dest0_cur_ack_line.sid7_dest0_cur_ack_line                    |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x60ed8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_dest0_cur_ack_unit_in_line                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid7_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid7_dest0_cur_ack_unit_in_line (sid7_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid7_dest0_cur_ack_unit_in_line.sid7_dest0_cur_ack_unit_in_line    |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x60ed4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_dest0_cur_ack_unit                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid7_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid7_dest0_cur_ack_unit (sid7_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid7_dest0_cur_ack_unit.sid7_dest0_cur_ack_unit                    |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x60ecc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_main_control_state                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid7_main_control_state_type */
	/* skip, unused field unused_sid7_main_control_state (sid7_main_control_state) */
	REG_DUMP_PRINT_1("   -sid7_main_control_state.sid7_main_control_state                    |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x60ec8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_s2m_cur_ack_line                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid7_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid7_s2m_cur_ack_line (sid7_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid7_s2m_cur_ack_line.sid7_s2m_cur_ack_line                        |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x60ec4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_s2m_cur_ack_unit_in_line                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid7_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid7_s2m_cur_ack_unit_in_line (sid7_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid7_s2m_cur_ack_unit_in_line.sid7_s2m_cur_ack_unit_in_line        |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x60ec0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_s2m_cur_cmds                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid7_s2m_cur_cmds_type */
	/* skip, unused field unused_sid7_s2m_cur_cmds (sid7_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid7_s2m_cur_cmds.sid7_s2m_cur_cmds                                |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x60e98);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_error_reg                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid7_error_reg_type */
	REG_DUMP_PRINT_1("   -sid7_error_reg.sid7_error_reg                                      |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x60e88);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_eventque_sidpid                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid7_eventque_sidpid_type */
	/* skip, unused field unused_sid7_eventque_sidpid (sid7_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid7_eventque_sidpid.sid7_eventque_sidpid                          |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x60e84);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_ack_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid7_ack_addr_type */
	/* skip, unused field unused_sid7_ack_addr (sid7_ack_addr) */
	REG_DUMP_PRINT_1("   -sid7_ack_addr.sid7_ack_addr                                        |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60e6c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_dest1_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid7_dest1_enabled_type */
	/* skip, unused field unused_sid7_dest1_enabled (sid7_dest1_enabled) */
	REG_DUMP_PRINT_1("   -sid7_dest1_enabled.sid7_dest1_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 1 is enabled, not present when only one destination sync is there for SID proc 7""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x60e68);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_dest0_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid7_dest0_enabled_type */
	/* skip, unused field unused_sid7_dest0_enabled (sid7_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid7_dest0_enabled.sid7_dest0_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 7""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x60e5c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_first_page_nr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid7_first_page_nr_type */
	/* skip, unused field unused_sid7_first_page_nr (sid7_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid7_first_page_nr.sid7_first_page_nr                              |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x60e58);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_camera_select                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid7_camera_select_type */
	/* skip, unused field unused_sid7_camera_select (sid7_camera_select) */
	REG_DUMP_PRINT_1("   -sid7_camera_select.sid7_camera_select                              |         0x%01X  |  [RW][03:00]""SID proc belongs to this camera, used to determine which secure touch enable signal should be used. This is bit encoded, bit 0 belongs to camera 0, bit 1 to camera 1 etc.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x60e54);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_units_p_ibuf                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid7_units_p_ibuf_type */
	/* skip, unused field unused_sid7_units_p_ibuf (sid7_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid7_units_p_ibuf.sid7_units_p_ibuf                                |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x60e50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_unit_size                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid7_unit_size_type */
	/* skip, unused field unused_sid7_unit_size (sid7_unit_size) */
	REG_DUMP_PRINT_1("   -sid7_unit_size.sid7_unit_size                                      |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0x60e4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_lines_p_frame                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid7_lines_p_frame_type */
	/* skip, unused field unused_sid7_lines_p_frame (sid7_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid7_lines_p_frame.sid7_lines_p_frame                              |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x60e48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_units_p_line                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid7_units_p_line_type */
	/* skip, unused field unused_sid7_units_p_line (sid7_units_p_line) */
	REG_DUMP_PRINT_1("   -sid7_units_p_line.sid7_units_p_line                                |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x60e44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_str2mmio_store_cmd                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid7_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid7_str2mmio_store_cmd (sid7_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid7_str2mmio_store_cmd.sid7_str2mmio_store_cmd                    |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x60e40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid7_str2mmio_proc_addr                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid7_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid7_str2mmio_proc_addr (sid7_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid7_str2mmio_proc_addr.sid7_str2mmio_proc_addr                    |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60d58);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk6_token                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk6_token_type */
	REG_DUMP_PRINT_1("   -fr_chk6_token.fr_chk6_token                                        |  0x%08X  |  [RW][31:00]""The token that has to be written""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x60d54);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk6_addr                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk6_addr_type */
	/* skip, unused field unused_fr_chk6_addr (fr_chk6_addr) */
	REG_DUMP_PRINT_1("   -fr_chk6_addr.fr_chk6_addr                                          |  0x%08X  |  [RW][29:00]""The address of where the frame check token has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60d50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk6_trigger_repeat_val                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk6_trigger_repeat_val_type */
	/* skip, unused field unused_fr_chk6_trigger_repeat_val (fr_chk6_trigger_repeat_val) */
	REG_DUMP_PRINT_1("   -fr_chk6_trigger_repeat_val.fr_chk6_trigger_repeat_val              |      0x%04X  |  [RW][15:00]""An frame check token is send after each trigger_repeat_val value in case the repetitive enable bit in the check mode is set and the trigger offset has been reached.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x60d4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk6_trigger_offset                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk6_trigger_offset_type */
	/* skip, unused field unused_fr_chk6_trigger_offset (fr_chk6_trigger_offset) */
	REG_DUMP_PRINT_1("   -fr_chk6_trigger_offset.fr_chk6_trigger_offset                      |      0x%04X  |  [RW][15:00]""The value of the trigger, when the checked value becomes larger than the this value a frame check token is send""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x60d48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk6_sid_proc_id                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk6_sid_proc_id_type */
	/* skip, unused field unused_fr_chk6_sid_proc_id (fr_chk6_sid_proc_id) */
	REG_DUMP_PRINT_1("   -fr_chk6_sid_proc_id.fr_chk6_sid_proc_id                            |         0x%01X  |  [RW][03:00]""The ID of the SID proc that has to be checked""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x60d44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk6_check_mode                                         |  0x%08X  |  ""The mode of frame checking""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk6_check_mode_type */
	/* skip, unused field unused_fr_chk6_check_mode (fr_chk6_check_mode) */
	REG_DUMP_PRINT_1("   -fr_chk6_check_mode.check_type                                      |         0x%01X  |  [RW][00:00]""The type of value to be checking, 0: check lines; 1: check units;""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -fr_chk6_check_mode.repetive_enable                                 |         0x%01X  |  [RW][01:01]""Trigger and send and token after each repetitive value after the trigger offset is reached""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0x60d40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk6_enable                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk6_enable_type */
	/* skip, unused field unused_fr_chk6_enable (fr_chk6_enable) */
	REG_DUMP_PRINT_1("   -fr_chk6_enable.fr_chk6_enable                                      |         0x%01X  |  [RW][00:00]""Enable frame checking for this frame check unit""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x60d24);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest6_iwake_threshold                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest6_iwake_threshold_type */
	/* skip, unused field unused_dest6_iwake_threshold (dest6_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest6_iwake_threshold.dest6_iwake_threshold                        |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x60d1c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest6_st_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest6_st_addr_type */
	REG_DUMP_PRINT_1("   -dest6_st_addr.dest6_st_addr                                        |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x60d18);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest6_dest_mode                                            |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest6_dest_mode_type */
	/* skip, unused field unused_dest6_dest_mode (dest6_dest_mode) */
	REG_DUMP_PRINT_1("   -dest6_dest_mode.is_ibuf_cntrl_feeder                               |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest6_dest_mode.config_dma                                         |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest6_dest_mode.iwake_enable                                       |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest6_dest_mode.disable_spana_rst                                  |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest6_dest_mode.disable_spanb_rst                                  |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x60d14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest6_term_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest6_term_b_addr_type */
	/* skip, unused field unused_dest6_term_b_addr (dest6_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest6_term_b_addr.dest6_term_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60d10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest6_span_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest6_span_b_addr_type */
	/* skip, unused field unused_dest6_span_b_addr (dest6_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest6_span_b_addr.dest6_span_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60d0c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest6_span_a_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest6_span_a_addr_type */
	/* skip, unused field unused_dest6_span_a_addr (dest6_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest6_span_a_addr.dest6_span_a_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60d08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest6_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest6_channel_addr_type */
	/* skip, unused field unused_dest6_channel_addr (dest6_channel_addr) */
	REG_DUMP_PRINT_1("   -dest6_channel_addr.dest6_channel_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60d04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest6_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest6_requester_addr_type */
	/* skip, unused field unused_dest6_requester_addr (dest6_requester_addr) */
	REG_DUMP_PRINT_1("   -dest6_requester_addr.dest6_requester_addr                          |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60d00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest6_feed_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest6_feed_addr_type */
	/* skip, unused field unused_dest6_feed_addr (dest6_feed_addr) */
	REG_DUMP_PRINT_1("   -dest6_feed_addr.dest6_feed_addr                                    |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60cec);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_dest1_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid6_dest1_cur_cmds_type */
	/* skip, unused field unused_sid6_dest1_cur_cmds (sid6_dest1_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid6_dest1_cur_cmds.sid6_dest1_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x60ce8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_dest1_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid6_dest1_sync_state_type */
	REG_DUMP_PRINT_1("   -sid6_dest1_sync_state.sid6_dest1_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 1. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x60ce4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_dest0_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid6_dest0_cur_cmds_type */
	/* skip, unused field unused_sid6_dest0_cur_cmds (sid6_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid6_dest0_cur_cmds.sid6_dest0_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x60ce0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_dest0_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid6_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid6_dest0_sync_state.sid6_dest0_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x60cdc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_dest0_cur_ack_line                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid6_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid6_dest0_cur_ack_line (sid6_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid6_dest0_cur_ack_line.sid6_dest0_cur_ack_line                    |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x60cd8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_dest0_cur_ack_unit_in_line                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid6_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid6_dest0_cur_ack_unit_in_line (sid6_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid6_dest0_cur_ack_unit_in_line.sid6_dest0_cur_ack_unit_in_line    |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x60cd4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_dest0_cur_ack_unit                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid6_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid6_dest0_cur_ack_unit (sid6_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid6_dest0_cur_ack_unit.sid6_dest0_cur_ack_unit                    |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x60ccc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_main_control_state                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid6_main_control_state_type */
	/* skip, unused field unused_sid6_main_control_state (sid6_main_control_state) */
	REG_DUMP_PRINT_1("   -sid6_main_control_state.sid6_main_control_state                    |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x60cc8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_s2m_cur_ack_line                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid6_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid6_s2m_cur_ack_line (sid6_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid6_s2m_cur_ack_line.sid6_s2m_cur_ack_line                        |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x60cc4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_s2m_cur_ack_unit_in_line                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid6_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid6_s2m_cur_ack_unit_in_line (sid6_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid6_s2m_cur_ack_unit_in_line.sid6_s2m_cur_ack_unit_in_line        |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x60cc0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_s2m_cur_cmds                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid6_s2m_cur_cmds_type */
	/* skip, unused field unused_sid6_s2m_cur_cmds (sid6_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid6_s2m_cur_cmds.sid6_s2m_cur_cmds                                |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x60c98);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_error_reg                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid6_error_reg_type */
	REG_DUMP_PRINT_1("   -sid6_error_reg.sid6_error_reg                                      |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x60c88);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_eventque_sidpid                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid6_eventque_sidpid_type */
	/* skip, unused field unused_sid6_eventque_sidpid (sid6_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid6_eventque_sidpid.sid6_eventque_sidpid                          |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x60c84);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_ack_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid6_ack_addr_type */
	/* skip, unused field unused_sid6_ack_addr (sid6_ack_addr) */
	REG_DUMP_PRINT_1("   -sid6_ack_addr.sid6_ack_addr                                        |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60c6c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_dest1_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid6_dest1_enabled_type */
	/* skip, unused field unused_sid6_dest1_enabled (sid6_dest1_enabled) */
	REG_DUMP_PRINT_1("   -sid6_dest1_enabled.sid6_dest1_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 1 is enabled, not present when only one destination sync is there for SID proc 6""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x60c68);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_dest0_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid6_dest0_enabled_type */
	/* skip, unused field unused_sid6_dest0_enabled (sid6_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid6_dest0_enabled.sid6_dest0_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 6""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x60c5c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_first_page_nr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid6_first_page_nr_type */
	/* skip, unused field unused_sid6_first_page_nr (sid6_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid6_first_page_nr.sid6_first_page_nr                              |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x60c58);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_camera_select                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid6_camera_select_type */
	/* skip, unused field unused_sid6_camera_select (sid6_camera_select) */
	REG_DUMP_PRINT_1("   -sid6_camera_select.sid6_camera_select                              |         0x%01X  |  [RW][03:00]""SID proc belongs to this camera, used to determine which secure touch enable signal should be used. This is bit encoded, bit 0 belongs to camera 0, bit 1 to camera 1 etc.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x60c54);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_units_p_ibuf                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid6_units_p_ibuf_type */
	/* skip, unused field unused_sid6_units_p_ibuf (sid6_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid6_units_p_ibuf.sid6_units_p_ibuf                                |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x60c50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_unit_size                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid6_unit_size_type */
	/* skip, unused field unused_sid6_unit_size (sid6_unit_size) */
	REG_DUMP_PRINT_1("   -sid6_unit_size.sid6_unit_size                                      |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0x60c4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_lines_p_frame                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid6_lines_p_frame_type */
	/* skip, unused field unused_sid6_lines_p_frame (sid6_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid6_lines_p_frame.sid6_lines_p_frame                              |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x60c48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_units_p_line                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid6_units_p_line_type */
	/* skip, unused field unused_sid6_units_p_line (sid6_units_p_line) */
	REG_DUMP_PRINT_1("   -sid6_units_p_line.sid6_units_p_line                                |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x60c44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_str2mmio_store_cmd                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid6_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid6_str2mmio_store_cmd (sid6_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid6_str2mmio_store_cmd.sid6_str2mmio_store_cmd                    |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x60c40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid6_str2mmio_proc_addr                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid6_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid6_str2mmio_proc_addr (sid6_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid6_str2mmio_proc_addr.sid6_str2mmio_proc_addr                    |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60b58);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk5_token                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk5_token_type */
	REG_DUMP_PRINT_1("   -fr_chk5_token.fr_chk5_token                                        |  0x%08X  |  [RW][31:00]""The token that has to be written""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x60b54);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk5_addr                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk5_addr_type */
	/* skip, unused field unused_fr_chk5_addr (fr_chk5_addr) */
	REG_DUMP_PRINT_1("   -fr_chk5_addr.fr_chk5_addr                                          |  0x%08X  |  [RW][29:00]""The address of where the frame check token has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60b50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk5_trigger_repeat_val                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk5_trigger_repeat_val_type */
	/* skip, unused field unused_fr_chk5_trigger_repeat_val (fr_chk5_trigger_repeat_val) */
	REG_DUMP_PRINT_1("   -fr_chk5_trigger_repeat_val.fr_chk5_trigger_repeat_val              |      0x%04X  |  [RW][15:00]""An frame check token is send after each trigger_repeat_val value in case the repetitive enable bit in the check mode is set and the trigger offset has been reached.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x60b4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk5_trigger_offset                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk5_trigger_offset_type */
	/* skip, unused field unused_fr_chk5_trigger_offset (fr_chk5_trigger_offset) */
	REG_DUMP_PRINT_1("   -fr_chk5_trigger_offset.fr_chk5_trigger_offset                      |      0x%04X  |  [RW][15:00]""The value of the trigger, when the checked value becomes larger than the this value a frame check token is send""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x60b48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk5_sid_proc_id                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk5_sid_proc_id_type */
	/* skip, unused field unused_fr_chk5_sid_proc_id (fr_chk5_sid_proc_id) */
	REG_DUMP_PRINT_1("   -fr_chk5_sid_proc_id.fr_chk5_sid_proc_id                            |         0x%01X  |  [RW][03:00]""The ID of the SID proc that has to be checked""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x60b44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk5_check_mode                                         |  0x%08X  |  ""The mode of frame checking""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk5_check_mode_type */
	/* skip, unused field unused_fr_chk5_check_mode (fr_chk5_check_mode) */
	REG_DUMP_PRINT_1("   -fr_chk5_check_mode.check_type                                      |         0x%01X  |  [RW][00:00]""The type of value to be checking, 0: check lines; 1: check units;""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -fr_chk5_check_mode.repetive_enable                                 |         0x%01X  |  [RW][01:01]""Trigger and send and token after each repetitive value after the trigger offset is reached""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0x60b40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk5_enable                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk5_enable_type */
	/* skip, unused field unused_fr_chk5_enable (fr_chk5_enable) */
	REG_DUMP_PRINT_1("   -fr_chk5_enable.fr_chk5_enable                                      |         0x%01X  |  [RW][00:00]""Enable frame checking for this frame check unit""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x60b24);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest5_iwake_threshold                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest5_iwake_threshold_type */
	/* skip, unused field unused_dest5_iwake_threshold (dest5_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest5_iwake_threshold.dest5_iwake_threshold                        |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x60b1c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest5_st_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest5_st_addr_type */
	REG_DUMP_PRINT_1("   -dest5_st_addr.dest5_st_addr                                        |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x60b18);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest5_dest_mode                                            |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest5_dest_mode_type */
	/* skip, unused field unused_dest5_dest_mode (dest5_dest_mode) */
	REG_DUMP_PRINT_1("   -dest5_dest_mode.is_ibuf_cntrl_feeder                               |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest5_dest_mode.config_dma                                         |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest5_dest_mode.iwake_enable                                       |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest5_dest_mode.disable_spana_rst                                  |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest5_dest_mode.disable_spanb_rst                                  |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x60b14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest5_term_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest5_term_b_addr_type */
	/* skip, unused field unused_dest5_term_b_addr (dest5_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest5_term_b_addr.dest5_term_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60b10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest5_span_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest5_span_b_addr_type */
	/* skip, unused field unused_dest5_span_b_addr (dest5_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest5_span_b_addr.dest5_span_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60b0c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest5_span_a_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest5_span_a_addr_type */
	/* skip, unused field unused_dest5_span_a_addr (dest5_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest5_span_a_addr.dest5_span_a_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60b08);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest5_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest5_channel_addr_type */
	/* skip, unused field unused_dest5_channel_addr (dest5_channel_addr) */
	REG_DUMP_PRINT_1("   -dest5_channel_addr.dest5_channel_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60b04);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest5_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest5_requester_addr_type */
	/* skip, unused field unused_dest5_requester_addr (dest5_requester_addr) */
	REG_DUMP_PRINT_1("   -dest5_requester_addr.dest5_requester_addr                          |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60b00);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest5_feed_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest5_feed_addr_type */
	/* skip, unused field unused_dest5_feed_addr (dest5_feed_addr) */
	REG_DUMP_PRINT_1("   -dest5_feed_addr.dest5_feed_addr                                    |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60aec);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_dest1_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid5_dest1_cur_cmds_type */
	/* skip, unused field unused_sid5_dest1_cur_cmds (sid5_dest1_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid5_dest1_cur_cmds.sid5_dest1_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x60ae8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_dest1_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid5_dest1_sync_state_type */
	REG_DUMP_PRINT_1("   -sid5_dest1_sync_state.sid5_dest1_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 1. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x60ae4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_dest0_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid5_dest0_cur_cmds_type */
	/* skip, unused field unused_sid5_dest0_cur_cmds (sid5_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid5_dest0_cur_cmds.sid5_dest0_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x60ae0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_dest0_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid5_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid5_dest0_sync_state.sid5_dest0_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x60adc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_dest0_cur_ack_line                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid5_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid5_dest0_cur_ack_line (sid5_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid5_dest0_cur_ack_line.sid5_dest0_cur_ack_line                    |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x60ad8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_dest0_cur_ack_unit_in_line                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid5_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid5_dest0_cur_ack_unit_in_line (sid5_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid5_dest0_cur_ack_unit_in_line.sid5_dest0_cur_ack_unit_in_line    |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x60ad4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_dest0_cur_ack_unit                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid5_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid5_dest0_cur_ack_unit (sid5_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid5_dest0_cur_ack_unit.sid5_dest0_cur_ack_unit                    |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x60acc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_main_control_state                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid5_main_control_state_type */
	/* skip, unused field unused_sid5_main_control_state (sid5_main_control_state) */
	REG_DUMP_PRINT_1("   -sid5_main_control_state.sid5_main_control_state                    |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x60ac8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_s2m_cur_ack_line                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid5_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid5_s2m_cur_ack_line (sid5_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid5_s2m_cur_ack_line.sid5_s2m_cur_ack_line                        |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x60ac4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_s2m_cur_ack_unit_in_line                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid5_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid5_s2m_cur_ack_unit_in_line (sid5_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid5_s2m_cur_ack_unit_in_line.sid5_s2m_cur_ack_unit_in_line        |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x60ac0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_s2m_cur_cmds                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid5_s2m_cur_cmds_type */
	/* skip, unused field unused_sid5_s2m_cur_cmds (sid5_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid5_s2m_cur_cmds.sid5_s2m_cur_cmds                                |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x60a98);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_error_reg                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid5_error_reg_type */
	REG_DUMP_PRINT_1("   -sid5_error_reg.sid5_error_reg                                      |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x60a88);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_eventque_sidpid                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid5_eventque_sidpid_type */
	/* skip, unused field unused_sid5_eventque_sidpid (sid5_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid5_eventque_sidpid.sid5_eventque_sidpid                          |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x60a84);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_ack_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid5_ack_addr_type */
	/* skip, unused field unused_sid5_ack_addr (sid5_ack_addr) */
	REG_DUMP_PRINT_1("   -sid5_ack_addr.sid5_ack_addr                                        |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60a6c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_dest1_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid5_dest1_enabled_type */
	/* skip, unused field unused_sid5_dest1_enabled (sid5_dest1_enabled) */
	REG_DUMP_PRINT_1("   -sid5_dest1_enabled.sid5_dest1_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 1 is enabled, not present when only one destination sync is there for SID proc 5""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x60a68);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_dest0_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid5_dest0_enabled_type */
	/* skip, unused field unused_sid5_dest0_enabled (sid5_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid5_dest0_enabled.sid5_dest0_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 5""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x60a5c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_first_page_nr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid5_first_page_nr_type */
	/* skip, unused field unused_sid5_first_page_nr (sid5_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid5_first_page_nr.sid5_first_page_nr                              |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x60a58);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_camera_select                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid5_camera_select_type */
	/* skip, unused field unused_sid5_camera_select (sid5_camera_select) */
	REG_DUMP_PRINT_1("   -sid5_camera_select.sid5_camera_select                              |         0x%01X  |  [RW][03:00]""SID proc belongs to this camera, used to determine which secure touch enable signal should be used. This is bit encoded, bit 0 belongs to camera 0, bit 1 to camera 1 etc.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x60a54);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_units_p_ibuf                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid5_units_p_ibuf_type */
	/* skip, unused field unused_sid5_units_p_ibuf (sid5_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid5_units_p_ibuf.sid5_units_p_ibuf                                |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x60a50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_unit_size                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid5_unit_size_type */
	/* skip, unused field unused_sid5_unit_size (sid5_unit_size) */
	REG_DUMP_PRINT_1("   -sid5_unit_size.sid5_unit_size                                      |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0x60a4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_lines_p_frame                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid5_lines_p_frame_type */
	/* skip, unused field unused_sid5_lines_p_frame (sid5_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid5_lines_p_frame.sid5_lines_p_frame                              |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x60a48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_units_p_line                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid5_units_p_line_type */
	/* skip, unused field unused_sid5_units_p_line (sid5_units_p_line) */
	REG_DUMP_PRINT_1("   -sid5_units_p_line.sid5_units_p_line                                |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x60a44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_str2mmio_store_cmd                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid5_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid5_str2mmio_store_cmd (sid5_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid5_str2mmio_store_cmd.sid5_str2mmio_store_cmd                    |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x60a40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid5_str2mmio_proc_addr                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid5_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid5_str2mmio_proc_addr (sid5_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid5_str2mmio_proc_addr.sid5_str2mmio_proc_addr                    |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60958);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk4_token                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk4_token_type */
	REG_DUMP_PRINT_1("   -fr_chk4_token.fr_chk4_token                                        |  0x%08X  |  [RW][31:00]""The token that has to be written""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x60954);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk4_addr                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk4_addr_type */
	/* skip, unused field unused_fr_chk4_addr (fr_chk4_addr) */
	REG_DUMP_PRINT_1("   -fr_chk4_addr.fr_chk4_addr                                          |  0x%08X  |  [RW][29:00]""The address of where the frame check token has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60950);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk4_trigger_repeat_val                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk4_trigger_repeat_val_type */
	/* skip, unused field unused_fr_chk4_trigger_repeat_val (fr_chk4_trigger_repeat_val) */
	REG_DUMP_PRINT_1("   -fr_chk4_trigger_repeat_val.fr_chk4_trigger_repeat_val              |      0x%04X  |  [RW][15:00]""An frame check token is send after each trigger_repeat_val value in case the repetitive enable bit in the check mode is set and the trigger offset has been reached.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x6094c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk4_trigger_offset                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk4_trigger_offset_type */
	/* skip, unused field unused_fr_chk4_trigger_offset (fr_chk4_trigger_offset) */
	REG_DUMP_PRINT_1("   -fr_chk4_trigger_offset.fr_chk4_trigger_offset                      |      0x%04X  |  [RW][15:00]""The value of the trigger, when the checked value becomes larger than the this value a frame check token is send""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x60948);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk4_sid_proc_id                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk4_sid_proc_id_type */
	/* skip, unused field unused_fr_chk4_sid_proc_id (fr_chk4_sid_proc_id) */
	REG_DUMP_PRINT_1("   -fr_chk4_sid_proc_id.fr_chk4_sid_proc_id                            |         0x%01X  |  [RW][03:00]""The ID of the SID proc that has to be checked""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x60944);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk4_check_mode                                         |  0x%08X  |  ""The mode of frame checking""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk4_check_mode_type */
	/* skip, unused field unused_fr_chk4_check_mode (fr_chk4_check_mode) */
	REG_DUMP_PRINT_1("   -fr_chk4_check_mode.check_type                                      |         0x%01X  |  [RW][00:00]""The type of value to be checking, 0: check lines; 1: check units;""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -fr_chk4_check_mode.repetive_enable                                 |         0x%01X  |  [RW][01:01]""Trigger and send and token after each repetitive value after the trigger offset is reached""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0x60940);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk4_enable                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk4_enable_type */
	/* skip, unused field unused_fr_chk4_enable (fr_chk4_enable) */
	REG_DUMP_PRINT_1("   -fr_chk4_enable.fr_chk4_enable                                      |         0x%01X  |  [RW][00:00]""Enable frame checking for this frame check unit""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x60924);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest4_iwake_threshold                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest4_iwake_threshold_type */
	/* skip, unused field unused_dest4_iwake_threshold (dest4_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest4_iwake_threshold.dest4_iwake_threshold                        |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6091c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest4_st_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest4_st_addr_type */
	REG_DUMP_PRINT_1("   -dest4_st_addr.dest4_st_addr                                        |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x60918);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest4_dest_mode                                            |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest4_dest_mode_type */
	/* skip, unused field unused_dest4_dest_mode (dest4_dest_mode) */
	REG_DUMP_PRINT_1("   -dest4_dest_mode.is_ibuf_cntrl_feeder                               |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest4_dest_mode.config_dma                                         |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest4_dest_mode.iwake_enable                                       |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest4_dest_mode.disable_spana_rst                                  |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest4_dest_mode.disable_spanb_rst                                  |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x60914);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest4_term_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest4_term_b_addr_type */
	/* skip, unused field unused_dest4_term_b_addr (dest4_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest4_term_b_addr.dest4_term_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60910);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest4_span_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest4_span_b_addr_type */
	/* skip, unused field unused_dest4_span_b_addr (dest4_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest4_span_b_addr.dest4_span_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6090c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest4_span_a_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest4_span_a_addr_type */
	/* skip, unused field unused_dest4_span_a_addr (dest4_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest4_span_a_addr.dest4_span_a_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60908);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest4_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest4_channel_addr_type */
	/* skip, unused field unused_dest4_channel_addr (dest4_channel_addr) */
	REG_DUMP_PRINT_1("   -dest4_channel_addr.dest4_channel_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60904);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest4_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest4_requester_addr_type */
	/* skip, unused field unused_dest4_requester_addr (dest4_requester_addr) */
	REG_DUMP_PRINT_1("   -dest4_requester_addr.dest4_requester_addr                          |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60900);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest4_feed_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest4_feed_addr_type */
	/* skip, unused field unused_dest4_feed_addr (dest4_feed_addr) */
	REG_DUMP_PRINT_1("   -dest4_feed_addr.dest4_feed_addr                                    |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x608ec);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_dest1_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid4_dest1_cur_cmds_type */
	/* skip, unused field unused_sid4_dest1_cur_cmds (sid4_dest1_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid4_dest1_cur_cmds.sid4_dest1_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x608e8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_dest1_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid4_dest1_sync_state_type */
	REG_DUMP_PRINT_1("   -sid4_dest1_sync_state.sid4_dest1_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 1. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x608e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_dest0_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid4_dest0_cur_cmds_type */
	/* skip, unused field unused_sid4_dest0_cur_cmds (sid4_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid4_dest0_cur_cmds.sid4_dest0_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x608e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_dest0_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid4_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid4_dest0_sync_state.sid4_dest0_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x608dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_dest0_cur_ack_line                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid4_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid4_dest0_cur_ack_line (sid4_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid4_dest0_cur_ack_line.sid4_dest0_cur_ack_line                    |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x608d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_dest0_cur_ack_unit_in_line                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid4_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid4_dest0_cur_ack_unit_in_line (sid4_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid4_dest0_cur_ack_unit_in_line.sid4_dest0_cur_ack_unit_in_line    |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x608d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_dest0_cur_ack_unit                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid4_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid4_dest0_cur_ack_unit (sid4_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid4_dest0_cur_ack_unit.sid4_dest0_cur_ack_unit                    |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x608cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_main_control_state                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid4_main_control_state_type */
	/* skip, unused field unused_sid4_main_control_state (sid4_main_control_state) */
	REG_DUMP_PRINT_1("   -sid4_main_control_state.sid4_main_control_state                    |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x608c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_s2m_cur_ack_line                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid4_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid4_s2m_cur_ack_line (sid4_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid4_s2m_cur_ack_line.sid4_s2m_cur_ack_line                        |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x608c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_s2m_cur_ack_unit_in_line                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid4_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid4_s2m_cur_ack_unit_in_line (sid4_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid4_s2m_cur_ack_unit_in_line.sid4_s2m_cur_ack_unit_in_line        |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x608c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_s2m_cur_cmds                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid4_s2m_cur_cmds_type */
	/* skip, unused field unused_sid4_s2m_cur_cmds (sid4_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid4_s2m_cur_cmds.sid4_s2m_cur_cmds                                |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x60898);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_error_reg                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid4_error_reg_type */
	REG_DUMP_PRINT_1("   -sid4_error_reg.sid4_error_reg                                      |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x60888);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_eventque_sidpid                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid4_eventque_sidpid_type */
	/* skip, unused field unused_sid4_eventque_sidpid (sid4_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid4_eventque_sidpid.sid4_eventque_sidpid                          |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x60884);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_ack_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid4_ack_addr_type */
	/* skip, unused field unused_sid4_ack_addr (sid4_ack_addr) */
	REG_DUMP_PRINT_1("   -sid4_ack_addr.sid4_ack_addr                                        |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6086c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_dest1_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid4_dest1_enabled_type */
	/* skip, unused field unused_sid4_dest1_enabled (sid4_dest1_enabled) */
	REG_DUMP_PRINT_1("   -sid4_dest1_enabled.sid4_dest1_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 1 is enabled, not present when only one destination sync is there for SID proc 4""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x60868);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_dest0_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid4_dest0_enabled_type */
	/* skip, unused field unused_sid4_dest0_enabled (sid4_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid4_dest0_enabled.sid4_dest0_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 4""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6085c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_first_page_nr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid4_first_page_nr_type */
	/* skip, unused field unused_sid4_first_page_nr (sid4_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid4_first_page_nr.sid4_first_page_nr                              |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x60858);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_camera_select                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid4_camera_select_type */
	/* skip, unused field unused_sid4_camera_select (sid4_camera_select) */
	REG_DUMP_PRINT_1("   -sid4_camera_select.sid4_camera_select                              |         0x%01X  |  [RW][03:00]""SID proc belongs to this camera, used to determine which secure touch enable signal should be used. This is bit encoded, bit 0 belongs to camera 0, bit 1 to camera 1 etc.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x60854);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_units_p_ibuf                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid4_units_p_ibuf_type */
	/* skip, unused field unused_sid4_units_p_ibuf (sid4_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid4_units_p_ibuf.sid4_units_p_ibuf                                |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x60850);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_unit_size                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid4_unit_size_type */
	/* skip, unused field unused_sid4_unit_size (sid4_unit_size) */
	REG_DUMP_PRINT_1("   -sid4_unit_size.sid4_unit_size                                      |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0x6084c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_lines_p_frame                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid4_lines_p_frame_type */
	/* skip, unused field unused_sid4_lines_p_frame (sid4_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid4_lines_p_frame.sid4_lines_p_frame                              |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x60848);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_units_p_line                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid4_units_p_line_type */
	/* skip, unused field unused_sid4_units_p_line (sid4_units_p_line) */
	REG_DUMP_PRINT_1("   -sid4_units_p_line.sid4_units_p_line                                |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x60844);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_str2mmio_store_cmd                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid4_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid4_str2mmio_store_cmd (sid4_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid4_str2mmio_store_cmd.sid4_str2mmio_store_cmd                    |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x60840);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid4_str2mmio_proc_addr                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid4_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid4_str2mmio_proc_addr (sid4_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid4_str2mmio_proc_addr.sid4_str2mmio_proc_addr                    |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60758);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk3_token                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk3_token_type */
	REG_DUMP_PRINT_1("   -fr_chk3_token.fr_chk3_token                                        |  0x%08X  |  [RW][31:00]""The token that has to be written""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x60754);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk3_addr                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk3_addr_type */
	/* skip, unused field unused_fr_chk3_addr (fr_chk3_addr) */
	REG_DUMP_PRINT_1("   -fr_chk3_addr.fr_chk3_addr                                          |  0x%08X  |  [RW][29:00]""The address of where the frame check token has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60750);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk3_trigger_repeat_val                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk3_trigger_repeat_val_type */
	/* skip, unused field unused_fr_chk3_trigger_repeat_val (fr_chk3_trigger_repeat_val) */
	REG_DUMP_PRINT_1("   -fr_chk3_trigger_repeat_val.fr_chk3_trigger_repeat_val              |      0x%04X  |  [RW][15:00]""An frame check token is send after each trigger_repeat_val value in case the repetitive enable bit in the check mode is set and the trigger offset has been reached.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x6074c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk3_trigger_offset                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk3_trigger_offset_type */
	/* skip, unused field unused_fr_chk3_trigger_offset (fr_chk3_trigger_offset) */
	REG_DUMP_PRINT_1("   -fr_chk3_trigger_offset.fr_chk3_trigger_offset                      |      0x%04X  |  [RW][15:00]""The value of the trigger, when the checked value becomes larger than the this value a frame check token is send""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x60748);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk3_sid_proc_id                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk3_sid_proc_id_type */
	/* skip, unused field unused_fr_chk3_sid_proc_id (fr_chk3_sid_proc_id) */
	REG_DUMP_PRINT_1("   -fr_chk3_sid_proc_id.fr_chk3_sid_proc_id                            |         0x%01X  |  [RW][03:00]""The ID of the SID proc that has to be checked""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x60744);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk3_check_mode                                         |  0x%08X  |  ""The mode of frame checking""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk3_check_mode_type */
	/* skip, unused field unused_fr_chk3_check_mode (fr_chk3_check_mode) */
	REG_DUMP_PRINT_1("   -fr_chk3_check_mode.check_type                                      |         0x%01X  |  [RW][00:00]""The type of value to be checking, 0: check lines; 1: check units;""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -fr_chk3_check_mode.repetive_enable                                 |         0x%01X  |  [RW][01:01]""Trigger and send and token after each repetitive value after the trigger offset is reached""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0x60740);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk3_enable                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk3_enable_type */
	/* skip, unused field unused_fr_chk3_enable (fr_chk3_enable) */
	REG_DUMP_PRINT_1("   -fr_chk3_enable.fr_chk3_enable                                      |         0x%01X  |  [RW][00:00]""Enable frame checking for this frame check unit""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x60724);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest3_iwake_threshold                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest3_iwake_threshold_type */
	/* skip, unused field unused_dest3_iwake_threshold (dest3_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest3_iwake_threshold.dest3_iwake_threshold                        |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6071c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest3_st_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest3_st_addr_type */
	REG_DUMP_PRINT_1("   -dest3_st_addr.dest3_st_addr                                        |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x60718);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest3_dest_mode                                            |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest3_dest_mode_type */
	/* skip, unused field unused_dest3_dest_mode (dest3_dest_mode) */
	REG_DUMP_PRINT_1("   -dest3_dest_mode.is_ibuf_cntrl_feeder                               |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest3_dest_mode.config_dma                                         |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest3_dest_mode.iwake_enable                                       |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest3_dest_mode.disable_spana_rst                                  |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest3_dest_mode.disable_spanb_rst                                  |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x60714);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest3_term_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest3_term_b_addr_type */
	/* skip, unused field unused_dest3_term_b_addr (dest3_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest3_term_b_addr.dest3_term_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60710);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest3_span_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest3_span_b_addr_type */
	/* skip, unused field unused_dest3_span_b_addr (dest3_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest3_span_b_addr.dest3_span_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6070c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest3_span_a_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest3_span_a_addr_type */
	/* skip, unused field unused_dest3_span_a_addr (dest3_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest3_span_a_addr.dest3_span_a_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60708);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest3_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest3_channel_addr_type */
	/* skip, unused field unused_dest3_channel_addr (dest3_channel_addr) */
	REG_DUMP_PRINT_1("   -dest3_channel_addr.dest3_channel_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60704);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest3_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest3_requester_addr_type */
	/* skip, unused field unused_dest3_requester_addr (dest3_requester_addr) */
	REG_DUMP_PRINT_1("   -dest3_requester_addr.dest3_requester_addr                          |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60700);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest3_feed_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest3_feed_addr_type */
	/* skip, unused field unused_dest3_feed_addr (dest3_feed_addr) */
	REG_DUMP_PRINT_1("   -dest3_feed_addr.dest3_feed_addr                                    |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x606ec);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_dest1_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid3_dest1_cur_cmds_type */
	/* skip, unused field unused_sid3_dest1_cur_cmds (sid3_dest1_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid3_dest1_cur_cmds.sid3_dest1_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x606e8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_dest1_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid3_dest1_sync_state_type */
	REG_DUMP_PRINT_1("   -sid3_dest1_sync_state.sid3_dest1_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 1. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x606e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_dest0_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid3_dest0_cur_cmds_type */
	/* skip, unused field unused_sid3_dest0_cur_cmds (sid3_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid3_dest0_cur_cmds.sid3_dest0_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x606e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_dest0_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid3_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid3_dest0_sync_state.sid3_dest0_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x606dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_dest0_cur_ack_line                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid3_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid3_dest0_cur_ack_line (sid3_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid3_dest0_cur_ack_line.sid3_dest0_cur_ack_line                    |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x606d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_dest0_cur_ack_unit_in_line                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid3_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid3_dest0_cur_ack_unit_in_line (sid3_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid3_dest0_cur_ack_unit_in_line.sid3_dest0_cur_ack_unit_in_line    |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x606d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_dest0_cur_ack_unit                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid3_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid3_dest0_cur_ack_unit (sid3_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid3_dest0_cur_ack_unit.sid3_dest0_cur_ack_unit                    |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x606cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_main_control_state                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid3_main_control_state_type */
	/* skip, unused field unused_sid3_main_control_state (sid3_main_control_state) */
	REG_DUMP_PRINT_1("   -sid3_main_control_state.sid3_main_control_state                    |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x606c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_s2m_cur_ack_line                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid3_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid3_s2m_cur_ack_line (sid3_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid3_s2m_cur_ack_line.sid3_s2m_cur_ack_line                        |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x606c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_s2m_cur_ack_unit_in_line                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid3_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid3_s2m_cur_ack_unit_in_line (sid3_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid3_s2m_cur_ack_unit_in_line.sid3_s2m_cur_ack_unit_in_line        |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x606c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_s2m_cur_cmds                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid3_s2m_cur_cmds_type */
	/* skip, unused field unused_sid3_s2m_cur_cmds (sid3_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid3_s2m_cur_cmds.sid3_s2m_cur_cmds                                |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x60698);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_error_reg                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid3_error_reg_type */
	REG_DUMP_PRINT_1("   -sid3_error_reg.sid3_error_reg                                      |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x60688);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_eventque_sidpid                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid3_eventque_sidpid_type */
	/* skip, unused field unused_sid3_eventque_sidpid (sid3_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid3_eventque_sidpid.sid3_eventque_sidpid                          |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x60684);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_ack_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid3_ack_addr_type */
	/* skip, unused field unused_sid3_ack_addr (sid3_ack_addr) */
	REG_DUMP_PRINT_1("   -sid3_ack_addr.sid3_ack_addr                                        |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6066c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_dest1_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid3_dest1_enabled_type */
	/* skip, unused field unused_sid3_dest1_enabled (sid3_dest1_enabled) */
	REG_DUMP_PRINT_1("   -sid3_dest1_enabled.sid3_dest1_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 1 is enabled, not present when only one destination sync is there for SID proc 3""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x60668);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_dest0_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid3_dest0_enabled_type */
	/* skip, unused field unused_sid3_dest0_enabled (sid3_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid3_dest0_enabled.sid3_dest0_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 3""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6065c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_first_page_nr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid3_first_page_nr_type */
	/* skip, unused field unused_sid3_first_page_nr (sid3_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid3_first_page_nr.sid3_first_page_nr                              |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x60658);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_camera_select                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid3_camera_select_type */
	/* skip, unused field unused_sid3_camera_select (sid3_camera_select) */
	REG_DUMP_PRINT_1("   -sid3_camera_select.sid3_camera_select                              |         0x%01X  |  [RW][03:00]""SID proc belongs to this camera, used to determine which secure touch enable signal should be used. This is bit encoded, bit 0 belongs to camera 0, bit 1 to camera 1 etc.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x60654);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_units_p_ibuf                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid3_units_p_ibuf_type */
	/* skip, unused field unused_sid3_units_p_ibuf (sid3_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid3_units_p_ibuf.sid3_units_p_ibuf                                |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x60650);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_unit_size                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid3_unit_size_type */
	/* skip, unused field unused_sid3_unit_size (sid3_unit_size) */
	REG_DUMP_PRINT_1("   -sid3_unit_size.sid3_unit_size                                      |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0x6064c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_lines_p_frame                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid3_lines_p_frame_type */
	/* skip, unused field unused_sid3_lines_p_frame (sid3_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid3_lines_p_frame.sid3_lines_p_frame                              |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x60648);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_units_p_line                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid3_units_p_line_type */
	/* skip, unused field unused_sid3_units_p_line (sid3_units_p_line) */
	REG_DUMP_PRINT_1("   -sid3_units_p_line.sid3_units_p_line                                |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x60644);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_str2mmio_store_cmd                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid3_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid3_str2mmio_store_cmd (sid3_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid3_str2mmio_store_cmd.sid3_str2mmio_store_cmd                    |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x60640);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid3_str2mmio_proc_addr                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid3_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid3_str2mmio_proc_addr (sid3_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid3_str2mmio_proc_addr.sid3_str2mmio_proc_addr                    |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60558);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk2_token                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk2_token_type */
	REG_DUMP_PRINT_1("   -fr_chk2_token.fr_chk2_token                                        |  0x%08X  |  [RW][31:00]""The token that has to be written""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x60554);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk2_addr                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk2_addr_type */
	/* skip, unused field unused_fr_chk2_addr (fr_chk2_addr) */
	REG_DUMP_PRINT_1("   -fr_chk2_addr.fr_chk2_addr                                          |  0x%08X  |  [RW][29:00]""The address of where the frame check token has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60550);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk2_trigger_repeat_val                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk2_trigger_repeat_val_type */
	/* skip, unused field unused_fr_chk2_trigger_repeat_val (fr_chk2_trigger_repeat_val) */
	REG_DUMP_PRINT_1("   -fr_chk2_trigger_repeat_val.fr_chk2_trigger_repeat_val              |      0x%04X  |  [RW][15:00]""An frame check token is send after each trigger_repeat_val value in case the repetitive enable bit in the check mode is set and the trigger offset has been reached.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x6054c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk2_trigger_offset                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk2_trigger_offset_type */
	/* skip, unused field unused_fr_chk2_trigger_offset (fr_chk2_trigger_offset) */
	REG_DUMP_PRINT_1("   -fr_chk2_trigger_offset.fr_chk2_trigger_offset                      |      0x%04X  |  [RW][15:00]""The value of the trigger, when the checked value becomes larger than the this value a frame check token is send""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x60548);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk2_sid_proc_id                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk2_sid_proc_id_type */
	/* skip, unused field unused_fr_chk2_sid_proc_id (fr_chk2_sid_proc_id) */
	REG_DUMP_PRINT_1("   -fr_chk2_sid_proc_id.fr_chk2_sid_proc_id                            |         0x%01X  |  [RW][03:00]""The ID of the SID proc that has to be checked""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x60544);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk2_check_mode                                         |  0x%08X  |  ""The mode of frame checking""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk2_check_mode_type */
	/* skip, unused field unused_fr_chk2_check_mode (fr_chk2_check_mode) */
	REG_DUMP_PRINT_1("   -fr_chk2_check_mode.check_type                                      |         0x%01X  |  [RW][00:00]""The type of value to be checking, 0: check lines; 1: check units;""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -fr_chk2_check_mode.repetive_enable                                 |         0x%01X  |  [RW][01:01]""Trigger and send and token after each repetitive value after the trigger offset is reached""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0x60540);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk2_enable                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk2_enable_type */
	/* skip, unused field unused_fr_chk2_enable (fr_chk2_enable) */
	REG_DUMP_PRINT_1("   -fr_chk2_enable.fr_chk2_enable                                      |         0x%01X  |  [RW][00:00]""Enable frame checking for this frame check unit""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x60524);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest2_iwake_threshold                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest2_iwake_threshold_type */
	/* skip, unused field unused_dest2_iwake_threshold (dest2_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest2_iwake_threshold.dest2_iwake_threshold                        |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6051c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest2_st_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest2_st_addr_type */
	REG_DUMP_PRINT_1("   -dest2_st_addr.dest2_st_addr                                        |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x60518);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest2_dest_mode                                            |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest2_dest_mode_type */
	/* skip, unused field unused_dest2_dest_mode (dest2_dest_mode) */
	REG_DUMP_PRINT_1("   -dest2_dest_mode.is_ibuf_cntrl_feeder                               |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest2_dest_mode.config_dma                                         |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest2_dest_mode.iwake_enable                                       |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest2_dest_mode.disable_spana_rst                                  |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest2_dest_mode.disable_spanb_rst                                  |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x60514);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest2_term_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest2_term_b_addr_type */
	/* skip, unused field unused_dest2_term_b_addr (dest2_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest2_term_b_addr.dest2_term_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60510);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest2_span_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest2_span_b_addr_type */
	/* skip, unused field unused_dest2_span_b_addr (dest2_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest2_span_b_addr.dest2_span_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6050c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest2_span_a_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest2_span_a_addr_type */
	/* skip, unused field unused_dest2_span_a_addr (dest2_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest2_span_a_addr.dest2_span_a_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60508);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest2_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest2_channel_addr_type */
	/* skip, unused field unused_dest2_channel_addr (dest2_channel_addr) */
	REG_DUMP_PRINT_1("   -dest2_channel_addr.dest2_channel_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60504);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest2_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest2_requester_addr_type */
	/* skip, unused field unused_dest2_requester_addr (dest2_requester_addr) */
	REG_DUMP_PRINT_1("   -dest2_requester_addr.dest2_requester_addr                          |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60500);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest2_feed_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest2_feed_addr_type */
	/* skip, unused field unused_dest2_feed_addr (dest2_feed_addr) */
	REG_DUMP_PRINT_1("   -dest2_feed_addr.dest2_feed_addr                                    |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x604ec);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_dest1_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid2_dest1_cur_cmds_type */
	/* skip, unused field unused_sid2_dest1_cur_cmds (sid2_dest1_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid2_dest1_cur_cmds.sid2_dest1_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x604e8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_dest1_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid2_dest1_sync_state_type */
	REG_DUMP_PRINT_1("   -sid2_dest1_sync_state.sid2_dest1_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 1. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x604e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_dest0_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid2_dest0_cur_cmds_type */
	/* skip, unused field unused_sid2_dest0_cur_cmds (sid2_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid2_dest0_cur_cmds.sid2_dest0_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x604e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_dest0_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid2_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid2_dest0_sync_state.sid2_dest0_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x604dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_dest0_cur_ack_line                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid2_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid2_dest0_cur_ack_line (sid2_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid2_dest0_cur_ack_line.sid2_dest0_cur_ack_line                    |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x604d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_dest0_cur_ack_unit_in_line                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid2_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid2_dest0_cur_ack_unit_in_line (sid2_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid2_dest0_cur_ack_unit_in_line.sid2_dest0_cur_ack_unit_in_line    |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x604d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_dest0_cur_ack_unit                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid2_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid2_dest0_cur_ack_unit (sid2_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid2_dest0_cur_ack_unit.sid2_dest0_cur_ack_unit                    |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x604cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_main_control_state                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid2_main_control_state_type */
	/* skip, unused field unused_sid2_main_control_state (sid2_main_control_state) */
	REG_DUMP_PRINT_1("   -sid2_main_control_state.sid2_main_control_state                    |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x604c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_s2m_cur_ack_line                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid2_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid2_s2m_cur_ack_line (sid2_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid2_s2m_cur_ack_line.sid2_s2m_cur_ack_line                        |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x604c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_s2m_cur_ack_unit_in_line                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid2_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid2_s2m_cur_ack_unit_in_line (sid2_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid2_s2m_cur_ack_unit_in_line.sid2_s2m_cur_ack_unit_in_line        |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x604c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_s2m_cur_cmds                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid2_s2m_cur_cmds_type */
	/* skip, unused field unused_sid2_s2m_cur_cmds (sid2_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid2_s2m_cur_cmds.sid2_s2m_cur_cmds                                |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x60498);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_error_reg                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid2_error_reg_type */
	REG_DUMP_PRINT_1("   -sid2_error_reg.sid2_error_reg                                      |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x60488);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_eventque_sidpid                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid2_eventque_sidpid_type */
	/* skip, unused field unused_sid2_eventque_sidpid (sid2_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid2_eventque_sidpid.sid2_eventque_sidpid                          |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x60484);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_ack_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid2_ack_addr_type */
	/* skip, unused field unused_sid2_ack_addr (sid2_ack_addr) */
	REG_DUMP_PRINT_1("   -sid2_ack_addr.sid2_ack_addr                                        |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6046c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_dest1_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid2_dest1_enabled_type */
	/* skip, unused field unused_sid2_dest1_enabled (sid2_dest1_enabled) */
	REG_DUMP_PRINT_1("   -sid2_dest1_enabled.sid2_dest1_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 1 is enabled, not present when only one destination sync is there for SID proc 2""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x60468);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_dest0_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid2_dest0_enabled_type */
	/* skip, unused field unused_sid2_dest0_enabled (sid2_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid2_dest0_enabled.sid2_dest0_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 2""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6045c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_first_page_nr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid2_first_page_nr_type */
	/* skip, unused field unused_sid2_first_page_nr (sid2_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid2_first_page_nr.sid2_first_page_nr                              |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x60458);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_camera_select                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid2_camera_select_type */
	/* skip, unused field unused_sid2_camera_select (sid2_camera_select) */
	REG_DUMP_PRINT_1("   -sid2_camera_select.sid2_camera_select                              |         0x%01X  |  [RW][03:00]""SID proc belongs to this camera, used to determine which secure touch enable signal should be used. This is bit encoded, bit 0 belongs to camera 0, bit 1 to camera 1 etc.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x60454);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_units_p_ibuf                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid2_units_p_ibuf_type */
	/* skip, unused field unused_sid2_units_p_ibuf (sid2_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid2_units_p_ibuf.sid2_units_p_ibuf                                |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x60450);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_unit_size                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid2_unit_size_type */
	/* skip, unused field unused_sid2_unit_size (sid2_unit_size) */
	REG_DUMP_PRINT_1("   -sid2_unit_size.sid2_unit_size                                      |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0x6044c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_lines_p_frame                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid2_lines_p_frame_type */
	/* skip, unused field unused_sid2_lines_p_frame (sid2_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid2_lines_p_frame.sid2_lines_p_frame                              |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x60448);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_units_p_line                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid2_units_p_line_type */
	/* skip, unused field unused_sid2_units_p_line (sid2_units_p_line) */
	REG_DUMP_PRINT_1("   -sid2_units_p_line.sid2_units_p_line                                |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x60444);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_str2mmio_store_cmd                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid2_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid2_str2mmio_store_cmd (sid2_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid2_str2mmio_store_cmd.sid2_str2mmio_store_cmd                    |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x60440);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid2_str2mmio_proc_addr                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid2_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid2_str2mmio_proc_addr (sid2_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid2_str2mmio_proc_addr.sid2_str2mmio_proc_addr                    |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60358);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk1_token                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk1_token_type */
	REG_DUMP_PRINT_1("   -fr_chk1_token.fr_chk1_token                                        |  0x%08X  |  [RW][31:00]""The token that has to be written""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x60354);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk1_addr                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk1_addr_type */
	/* skip, unused field unused_fr_chk1_addr (fr_chk1_addr) */
	REG_DUMP_PRINT_1("   -fr_chk1_addr.fr_chk1_addr                                          |  0x%08X  |  [RW][29:00]""The address of where the frame check token has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60350);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk1_trigger_repeat_val                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk1_trigger_repeat_val_type */
	/* skip, unused field unused_fr_chk1_trigger_repeat_val (fr_chk1_trigger_repeat_val) */
	REG_DUMP_PRINT_1("   -fr_chk1_trigger_repeat_val.fr_chk1_trigger_repeat_val              |      0x%04X  |  [RW][15:00]""An frame check token is send after each trigger_repeat_val value in case the repetitive enable bit in the check mode is set and the trigger offset has been reached.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x6034c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk1_trigger_offset                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk1_trigger_offset_type */
	/* skip, unused field unused_fr_chk1_trigger_offset (fr_chk1_trigger_offset) */
	REG_DUMP_PRINT_1("   -fr_chk1_trigger_offset.fr_chk1_trigger_offset                      |      0x%04X  |  [RW][15:00]""The value of the trigger, when the checked value becomes larger than the this value a frame check token is send""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x60348);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk1_sid_proc_id                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk1_sid_proc_id_type */
	/* skip, unused field unused_fr_chk1_sid_proc_id (fr_chk1_sid_proc_id) */
	REG_DUMP_PRINT_1("   -fr_chk1_sid_proc_id.fr_chk1_sid_proc_id                            |         0x%01X  |  [RW][03:00]""The ID of the SID proc that has to be checked""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x60344);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk1_check_mode                                         |  0x%08X  |  ""The mode of frame checking""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk1_check_mode_type */
	/* skip, unused field unused_fr_chk1_check_mode (fr_chk1_check_mode) */
	REG_DUMP_PRINT_1("   -fr_chk1_check_mode.check_type                                      |         0x%01X  |  [RW][00:00]""The type of value to be checking, 0: check lines; 1: check units;""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -fr_chk1_check_mode.repetive_enable                                 |         0x%01X  |  [RW][01:01]""Trigger and send and token after each repetitive value after the trigger offset is reached""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0x60340);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk1_enable                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk1_enable_type */
	/* skip, unused field unused_fr_chk1_enable (fr_chk1_enable) */
	REG_DUMP_PRINT_1("   -fr_chk1_enable.fr_chk1_enable                                      |         0x%01X  |  [RW][00:00]""Enable frame checking for this frame check unit""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x60324);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest1_iwake_threshold                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest1_iwake_threshold_type */
	/* skip, unused field unused_dest1_iwake_threshold (dest1_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest1_iwake_threshold.dest1_iwake_threshold                        |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6031c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest1_st_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest1_st_addr_type */
	REG_DUMP_PRINT_1("   -dest1_st_addr.dest1_st_addr                                        |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x60318);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest1_dest_mode                                            |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest1_dest_mode_type */
	/* skip, unused field unused_dest1_dest_mode (dest1_dest_mode) */
	REG_DUMP_PRINT_1("   -dest1_dest_mode.is_ibuf_cntrl_feeder                               |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest1_dest_mode.config_dma                                         |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest1_dest_mode.iwake_enable                                       |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest1_dest_mode.disable_spana_rst                                  |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest1_dest_mode.disable_spanb_rst                                  |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x60314);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest1_term_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest1_term_b_addr_type */
	/* skip, unused field unused_dest1_term_b_addr (dest1_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest1_term_b_addr.dest1_term_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60310);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest1_span_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest1_span_b_addr_type */
	/* skip, unused field unused_dest1_span_b_addr (dest1_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest1_span_b_addr.dest1_span_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6030c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest1_span_a_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest1_span_a_addr_type */
	/* skip, unused field unused_dest1_span_a_addr (dest1_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest1_span_a_addr.dest1_span_a_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60308);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest1_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest1_channel_addr_type */
	/* skip, unused field unused_dest1_channel_addr (dest1_channel_addr) */
	REG_DUMP_PRINT_1("   -dest1_channel_addr.dest1_channel_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60304);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest1_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest1_requester_addr_type */
	/* skip, unused field unused_dest1_requester_addr (dest1_requester_addr) */
	REG_DUMP_PRINT_1("   -dest1_requester_addr.dest1_requester_addr                          |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60300);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest1_feed_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest1_feed_addr_type */
	/* skip, unused field unused_dest1_feed_addr (dest1_feed_addr) */
	REG_DUMP_PRINT_1("   -dest1_feed_addr.dest1_feed_addr                                    |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x602ec);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_dest1_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid1_dest1_cur_cmds_type */
	/* skip, unused field unused_sid1_dest1_cur_cmds (sid1_dest1_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid1_dest1_cur_cmds.sid1_dest1_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x602e8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_dest1_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid1_dest1_sync_state_type */
	REG_DUMP_PRINT_1("   -sid1_dest1_sync_state.sid1_dest1_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 1. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x602e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_dest0_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid1_dest0_cur_cmds_type */
	/* skip, unused field unused_sid1_dest0_cur_cmds (sid1_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid1_dest0_cur_cmds.sid1_dest0_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x602e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_dest0_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid1_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid1_dest0_sync_state.sid1_dest0_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x602dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_dest0_cur_ack_line                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid1_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid1_dest0_cur_ack_line (sid1_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid1_dest0_cur_ack_line.sid1_dest0_cur_ack_line                    |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x602d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_dest0_cur_ack_unit_in_line                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid1_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid1_dest0_cur_ack_unit_in_line (sid1_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid1_dest0_cur_ack_unit_in_line.sid1_dest0_cur_ack_unit_in_line    |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x602d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_dest0_cur_ack_unit                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid1_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid1_dest0_cur_ack_unit (sid1_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid1_dest0_cur_ack_unit.sid1_dest0_cur_ack_unit                    |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x602cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_main_control_state                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid1_main_control_state_type */
	/* skip, unused field unused_sid1_main_control_state (sid1_main_control_state) */
	REG_DUMP_PRINT_1("   -sid1_main_control_state.sid1_main_control_state                    |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x602c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_s2m_cur_ack_line                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid1_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid1_s2m_cur_ack_line (sid1_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid1_s2m_cur_ack_line.sid1_s2m_cur_ack_line                        |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x602c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_s2m_cur_ack_unit_in_line                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid1_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid1_s2m_cur_ack_unit_in_line (sid1_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid1_s2m_cur_ack_unit_in_line.sid1_s2m_cur_ack_unit_in_line        |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x602c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_s2m_cur_cmds                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid1_s2m_cur_cmds_type */
	/* skip, unused field unused_sid1_s2m_cur_cmds (sid1_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid1_s2m_cur_cmds.sid1_s2m_cur_cmds                                |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x60298);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_error_reg                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid1_error_reg_type */
	REG_DUMP_PRINT_1("   -sid1_error_reg.sid1_error_reg                                      |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x60288);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_eventque_sidpid                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid1_eventque_sidpid_type */
	/* skip, unused field unused_sid1_eventque_sidpid (sid1_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid1_eventque_sidpid.sid1_eventque_sidpid                          |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x60284);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_ack_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid1_ack_addr_type */
	/* skip, unused field unused_sid1_ack_addr (sid1_ack_addr) */
	REG_DUMP_PRINT_1("   -sid1_ack_addr.sid1_ack_addr                                        |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6026c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_dest1_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid1_dest1_enabled_type */
	/* skip, unused field unused_sid1_dest1_enabled (sid1_dest1_enabled) */
	REG_DUMP_PRINT_1("   -sid1_dest1_enabled.sid1_dest1_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 1 is enabled, not present when only one destination sync is there for SID proc 1""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x60268);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_dest0_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid1_dest0_enabled_type */
	/* skip, unused field unused_sid1_dest0_enabled (sid1_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid1_dest0_enabled.sid1_dest0_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 1""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6025c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_first_page_nr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid1_first_page_nr_type */
	/* skip, unused field unused_sid1_first_page_nr (sid1_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid1_first_page_nr.sid1_first_page_nr                              |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x60258);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_camera_select                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid1_camera_select_type */
	/* skip, unused field unused_sid1_camera_select (sid1_camera_select) */
	REG_DUMP_PRINT_1("   -sid1_camera_select.sid1_camera_select                              |         0x%01X  |  [RW][03:00]""SID proc belongs to this camera, used to determine which secure touch enable signal should be used. This is bit encoded, bit 0 belongs to camera 0, bit 1 to camera 1 etc.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x60254);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_units_p_ibuf                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid1_units_p_ibuf_type */
	/* skip, unused field unused_sid1_units_p_ibuf (sid1_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid1_units_p_ibuf.sid1_units_p_ibuf                                |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x60250);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_unit_size                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid1_unit_size_type */
	/* skip, unused field unused_sid1_unit_size (sid1_unit_size) */
	REG_DUMP_PRINT_1("   -sid1_unit_size.sid1_unit_size                                      |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0x6024c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_lines_p_frame                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid1_lines_p_frame_type */
	/* skip, unused field unused_sid1_lines_p_frame (sid1_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid1_lines_p_frame.sid1_lines_p_frame                              |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x60248);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_units_p_line                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid1_units_p_line_type */
	/* skip, unused field unused_sid1_units_p_line (sid1_units_p_line) */
	REG_DUMP_PRINT_1("   -sid1_units_p_line.sid1_units_p_line                                |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x60244);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_str2mmio_store_cmd                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid1_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid1_str2mmio_store_cmd (sid1_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid1_str2mmio_store_cmd.sid1_str2mmio_store_cmd                    |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x60240);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid1_str2mmio_proc_addr                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid1_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid1_str2mmio_proc_addr (sid1_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid1_str2mmio_proc_addr.sid1_str2mmio_proc_addr                    |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60158);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk0_token                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk0_token_type */
	REG_DUMP_PRINT_1("   -fr_chk0_token.fr_chk0_token                                        |  0x%08X  |  [RW][31:00]""The token that has to be written""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x60154);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk0_addr                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk0_addr_type */
	/* skip, unused field unused_fr_chk0_addr (fr_chk0_addr) */
	REG_DUMP_PRINT_1("   -fr_chk0_addr.fr_chk0_addr                                          |  0x%08X  |  [RW][29:00]""The address of where the frame check token has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60150);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk0_trigger_repeat_val                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk0_trigger_repeat_val_type */
	/* skip, unused field unused_fr_chk0_trigger_repeat_val (fr_chk0_trigger_repeat_val) */
	REG_DUMP_PRINT_1("   -fr_chk0_trigger_repeat_val.fr_chk0_trigger_repeat_val              |      0x%04X  |  [RW][15:00]""An frame check token is send after each trigger_repeat_val value in case the repetitive enable bit in the check mode is set and the trigger offset has been reached.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x6014c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk0_trigger_offset                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk0_trigger_offset_type */
	/* skip, unused field unused_fr_chk0_trigger_offset (fr_chk0_trigger_offset) */
	REG_DUMP_PRINT_1("   -fr_chk0_trigger_offset.fr_chk0_trigger_offset                      |      0x%04X  |  [RW][15:00]""The value of the trigger, when the checked value becomes larger than the this value a frame check token is send""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x60148);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk0_sid_proc_id                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk0_sid_proc_id_type */
	/* skip, unused field unused_fr_chk0_sid_proc_id (fr_chk0_sid_proc_id) */
	REG_DUMP_PRINT_1("   -fr_chk0_sid_proc_id.fr_chk0_sid_proc_id                            |         0x%01X  |  [RW][03:00]""The ID of the SID proc that has to be checked""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x60144);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk0_check_mode                                         |  0x%08X  |  ""The mode of frame checking""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk0_check_mode_type */
	/* skip, unused field unused_fr_chk0_check_mode (fr_chk0_check_mode) */
	REG_DUMP_PRINT_1("   -fr_chk0_check_mode.check_type                                      |         0x%01X  |  [RW][00:00]""The type of value to be checking, 0: check lines; 1: check units;""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -fr_chk0_check_mode.repetive_enable                                 |         0x%01X  |  [RW][01:01]""Trigger and send and token after each repetitive value after the trigger offset is reached""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0x60140);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.fr_chk0_enable                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_fr_chk0_enable_type */
	/* skip, unused field unused_fr_chk0_enable (fr_chk0_enable) */
	REG_DUMP_PRINT_1("   -fr_chk0_enable.fr_chk0_enable                                      |         0x%01X  |  [RW][00:00]""Enable frame checking for this frame check unit""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x60124);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest0_iwake_threshold                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest0_iwake_threshold_type */
	/* skip, unused field unused_dest0_iwake_threshold (dest0_iwake_threshold) */
	REG_DUMP_PRINT_1("   -dest0_iwake_threshold.dest0_iwake_threshold                        |        0x%02X  |  [RW][06:00]""The threshold of the number of units before sending an Iwake. This is only used when iwake is enabled for the destination""\n", FIELD_VALUE(val, 0, 6));
	val = REG_DUMP_READ_REGISTER(0x6011c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest0_st_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest0_st_addr_type */
	REG_DUMP_PRINT_1("   -dest0_st_addr.dest0_st_addr                                        |  0x%08X  |  [RW][31:00]""The start address, when the start address token is not used (cmd 0x2 & 0x3). This is a byte addressable value""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x60118);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest0_dest_mode                                            |  0x%08X  |  ""The mode of the destination: if the destination is a DMA or IBufCntrl, if the DMA has to be configured etc""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest0_dest_mode_type */
	/* skip, unused field unused_dest0_dest_mode (dest0_dest_mode) */
	REG_DUMP_PRINT_1("   -dest0_dest_mode.is_ibuf_cntrl_feeder                               |         0x%01X  |  [RW][00:00]""when set the destination is a IBufCntrl feeder and not a DMA""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -dest0_dest_mode.config_dma                                         |         0x%01X  |  [RW][01:01]""Configure the DMA when a init command is received when enabled: Region origins *1, Active ack mode*2, Ack data*2. *1: the origin of B is always configured after receiving a store frame command as this value is part of the command. *2: The active ack mode and ack data is set before each store command when IWake is enabled as the amount of data moved is not static""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -dest0_dest_mode.iwake_enable                                       |         0x%01X  |  [RW][02:02]""Enable the power management by enable the Iwake for the current destination""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -dest0_dest_mode.disable_spana_rst                                  |         0x%01X  |  [RW][03:03]""disable_spana_rst: don't reset span A at the start of a new frame""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -dest0_dest_mode.disable_spanb_rst                                  |         0x%01X  |  [RW][04:04]""disable_spanb_rst: don't reset span B at the start of a new frame""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x60114);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest0_term_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest0_term_b_addr_type */
	/* skip, unused field unused_dest0_term_b_addr (dest0_term_b_addr) */
	REG_DUMP_PRINT_1("   -dest0_term_b_addr.dest0_term_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA terminal b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60110);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest0_span_b_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest0_span_b_addr_type */
	/* skip, unused field unused_dest0_span_b_addr (dest0_span_b_addr) */
	REG_DUMP_PRINT_1("   -dest0_span_b_addr.dest0_span_b_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span b register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6010c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest0_span_a_addr                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest0_span_a_addr_type */
	/* skip, unused field unused_dest0_span_a_addr (dest0_span_a_addr) */
	REG_DUMP_PRINT_1("   -dest0_span_a_addr.dest0_span_a_addr                                |  0x%08X  |  [RW][29:00]""The address of the DMA span a register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60108);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest0_channel_addr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest0_channel_addr_type */
	/* skip, unused field unused_dest0_channel_addr (dest0_channel_addr) */
	REG_DUMP_PRINT_1("   -dest0_channel_addr.dest0_channel_addr                              |  0x%08X  |  [RW][29:00]""The address of the DMA channel register set. This is a word addressable value.""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60104);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest0_requester_addr                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest0_requester_addr_type */
	/* skip, unused field unused_dest0_requester_addr (dest0_requester_addr) */
	REG_DUMP_PRINT_1("   -dest0_requester_addr.dest0_requester_addr                          |  0x%08X  |  [RW][29:00]""The address of the DMA requester register set""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60100);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.dest0_feed_addr                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_dest0_feed_addr_type */
	/* skip, unused field unused_dest0_feed_addr (dest0_feed_addr) */
	REG_DUMP_PRINT_1("   -dest0_feed_addr.dest0_feed_addr                                    |  0x%08X  |  [RW][29:00]""The address where the IBufCntrl feeder is located (in case the destination is a feeder)""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x600ec);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_dest1_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid0_dest1_cur_cmds_type */
	/* skip, unused field unused_sid0_dest1_cur_cmds (sid0_dest1_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid0_dest1_cur_cmds.sid0_dest1_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x600e8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_dest1_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid0_dest1_sync_state_type */
	REG_DUMP_PRINT_1("   -sid0_dest1_sync_state.sid0_dest1_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 1. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x600e4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_dest0_cur_cmds                                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid0_dest0_cur_cmds_type */
	/* skip, unused field unused_sid0_dest0_cur_cmds (sid0_dest0_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid0_dest0_cur_cmds.sid0_dest0_cur_cmds                            |      0x%04X  |  [RO][15:00]""The number of commands issued for the current frame""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x600e0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_dest0_sync_state                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid0_dest0_sync_state_type */
	REG_DUMP_PRINT_1("   -sid0_dest0_sync_state.sid0_dest0_sync_state                        |  0x%08X  |  [RO][31:00]""The status of the event controller that is used to sync with destination 0. Event control state: 0 IDLE; 1 WAIT SYNC; 2 WAIT ACTIVE; 3 AREA BUSY; 4 WAIT ACK; 5 DEST AVAILABLE; 6 DEST CMD;""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x600dc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_dest0_cur_ack_line                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid0_dest0_cur_ack_line_type */
	/* skip, unused field unused_sid0_dest0_cur_ack_line (sid0_dest0_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid0_dest0_cur_ack_line.sid0_dest0_cur_ack_line                    |      0x%04X  |  [RO][13:00]""The number of acked lines for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x600d8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_dest0_cur_ack_unit_in_line                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid0_dest0_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid0_dest0_cur_ack_unit_in_line (sid0_dest0_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid0_dest0_cur_ack_unit_in_line.sid0_dest0_cur_ack_unit_in_line    |         0x%01X  |  [RO][03:00]""The number of acked units for the current line in a frame for destination 0""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x600d4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_dest0_cur_ack_unit                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid0_dest0_cur_ack_unit_type */
	/* skip, unused field unused_sid0_dest0_cur_ack_unit (sid0_dest0_cur_ack_unit) */
	REG_DUMP_PRINT_1("   -sid0_dest0_cur_ack_unit.sid0_dest0_cur_ack_unit                    |      0x%04X  |  [RO][15:00]""The number of acks received for the current frame for destination 0""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x600cc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_main_control_state                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid0_main_control_state_type */
	/* skip, unused field unused_sid0_main_control_state (sid0_main_control_state) */
	REG_DUMP_PRINT_1("   -sid0_main_control_state.sid0_main_control_state                    |       0x%03X  |  [RO][09:00]""The status of the main controller that is used to receive and process the commands, return acknowledgements and sync with the Str2MMIO. [3..0] Main control state: 0 IDLE; 1 INIT; 2 INIT COPY CFG; 3 INIT ACK; 4 STORE SYNC; 5 SET ADDR; 6 CHECK LINES; 7 STORE LINE; 8 NXT CMD CHECK; 9 NXT CMD IS STORE; 10 NXT CMD WAIT, wait until prev cmd done; 11 SEND ACK; 12 STORE CMD; 13 CHECK BUFFER; [4] Ibuf_busy, input buffer has data present that still has to be stored; [5] wire_max_cmds_reached, maximum outstanding Str2MMIO commands reached; [6] wire_ack_accept, acknowledgement accept for internal acks generated by main cntrl; [7] in_false_cmd, false command being streamed in the ack fifo selection; [8]wire_sel_ack_selected[0], 0: false ack; 1: internal main cntrl ack; [9] wire_lpf_error_rcvd, received empty Str2MMIO ack, stop processing.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x600c8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_s2m_cur_ack_line                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid0_s2m_cur_ack_line_type */
	/* skip, unused field unused_sid0_s2m_cur_ack_line (sid0_s2m_cur_ack_line) */
	REG_DUMP_PRINT_1("   -sid0_s2m_cur_ack_line.sid0_s2m_cur_ack_line                        |      0x%04X  |  [RO][13:00]""The number of acked lines by the Str2MMIO for the current frame""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x600c4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_s2m_cur_ack_unit_in_line                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid0_s2m_cur_ack_unit_in_line_type */
	/* skip, unused field unused_sid0_s2m_cur_ack_unit_in_line (sid0_s2m_cur_ack_unit_in_line) */
	REG_DUMP_PRINT_1("   -sid0_s2m_cur_ack_unit_in_line.sid0_s2m_cur_ack_unit_in_line        |         0x%01X  |  [RO][03:00]""The number of acked units by the Str2MMIO for the current line in a frame""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x600c0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_s2m_cur_cmds                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid0_s2m_cur_cmds_type */
	/* skip, unused field unused_sid0_s2m_cur_cmds (sid0_s2m_cur_cmds) */
	REG_DUMP_PRINT_1("   -sid0_s2m_cur_cmds.sid0_s2m_cur_cmds                                |      0x%04X  |  [RO][15:00]""The number of send commands to the Str2MMIO for the current frame. ""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x60098);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_error_reg                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid0_error_reg_type */
	REG_DUMP_PRINT_1("   -sid0_error_reg.sid0_error_reg                                      |  0x%08X  |  [RO][31:00]""The error code and data is present in this register after an error. The content can only be clear by srst and writing a '1' into sid#_clear_error_reg""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x60088);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_eventque_sidpid                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid0_eventque_sidpid_type */
	/* skip, unused field unused_sid0_eventque_sidpid (sid0_eventque_sidpid) */
	REG_DUMP_PRINT_1("   -sid0_eventque_sidpid.sid0_eventque_sidpid                          |       0x%03X  |  [RW][11:00]""The (combined) sid and pid fields in the token that will be written to the event que""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x60084);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_ack_addr                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid0_ack_addr_type */
	/* skip, unused field unused_sid0_ack_addr (sid0_ack_addr) */
	REG_DUMP_PRINT_1("   -sid0_ack_addr.sid0_ack_addr                                        |  0x%08X  |  [RW][29:00]""The address where the acknowledge has to be written to""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x6006c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_dest1_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid0_dest1_enabled_type */
	/* skip, unused field unused_sid0_dest1_enabled (sid0_dest1_enabled) */
	REG_DUMP_PRINT_1("   -sid0_dest1_enabled.sid0_dest1_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 1 is enabled, not present when only one destination sync is there for SID proc 0""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x60068);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_dest0_enabled                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid0_dest0_enabled_type */
	/* skip, unused field unused_sid0_dest0_enabled (sid0_dest0_enabled) */
	REG_DUMP_PRINT_1("   -sid0_dest0_enabled.sid0_dest0_enabled                              |         0x%01X  |  [RW][00:00]""If the destination sync controller 0 is enabled, not present when only one destination sync is there for SID proc 0""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6005c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_first_page_nr                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid0_first_page_nr_type */
	/* skip, unused field unused_sid0_first_page_nr (sid0_first_page_nr) */
	REG_DUMP_PRINT_1("   -sid0_first_page_nr.sid0_first_page_nr                              |       0x%03X  |  [RW][11:00]""The page number where each frame is starting from, this is used for de-allocating the correct page in the GDA.""\n", FIELD_VALUE(val, 0, 11));
	val = REG_DUMP_READ_REGISTER(0x60058);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_camera_select                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid0_camera_select_type */
	/* skip, unused field unused_sid0_camera_select (sid0_camera_select) */
	REG_DUMP_PRINT_1("   -sid0_camera_select.sid0_camera_select                              |         0x%01X  |  [RW][03:00]""SID proc belongs to this camera, used to determine which secure touch enable signal should be used. This is bit encoded, bit 0 belongs to camera 0, bit 1 to camera 1 etc.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x60054);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_units_p_ibuf                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid0_units_p_ibuf_type */
	/* skip, unused field unused_sid0_units_p_ibuf (sid0_units_p_ibuf) */
	REG_DUMP_PRINT_1("   -sid0_units_p_ibuf.sid0_units_p_ibuf                                |       0x%03X  |  [RW][09:00]""The number of units that fit in the input buffer for proc #. This number should equal the total number of units covered by the span in the DMA and the buffer settings of the Str2MMIO.""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x60050);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_unit_size                                             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid0_unit_size_type */
	/* skip, unused field unused_sid0_unit_size (sid0_unit_size) */
	REG_DUMP_PRINT_1("   -sid0_unit_size.sid0_unit_size                                      |       0x%03X  |  [RW][08:00]""The size of a unit, given in the number of words. This information is used by the GDA deallocation process to determine when a page can be deallocated.""\n", FIELD_VALUE(val, 0, 8));
	val = REG_DUMP_READ_REGISTER(0x6004c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_lines_p_frame                                         |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid0_lines_p_frame_type */
	/* skip, unused field unused_sid0_lines_p_frame (sid0_lines_p_frame) */
	REG_DUMP_PRINT_1("   -sid0_lines_p_frame.sid0_lines_p_frame                              |      0x%04X  |  [RW][13:00]""The number of lines per frame.""\n", FIELD_VALUE(val, 0, 13));
	val = REG_DUMP_READ_REGISTER(0x60048);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_units_p_line                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid0_units_p_line_type */
	/* skip, unused field unused_sid0_units_p_line (sid0_units_p_line) */
	REG_DUMP_PRINT_1("   -sid0_units_p_line.sid0_units_p_line                                |         0x%01X  |  [RW][03:00]""The number of units per line. This is how many stores have to be given to the Str2MMIO for one line. ""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x60044);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_str2mmio_store_cmd                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid0_str2mmio_store_cmd_type */
	/* skip, unused field unused_sid0_str2mmio_store_cmd (sid0_str2mmio_store_cmd) */
	REG_DUMP_PRINT_1("   -sid0_str2mmio_store_cmd.sid0_str2mmio_store_cmd                    |         0x%01X  |  [RW][00:00]""The store command to the Str2MMIO; 1: store packets; 0: store words""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x60040);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.sid0_str2mmio_proc_addr                                    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_sid0_str2mmio_proc_addr_type */
	/* skip, unused field unused_sid0_str2mmio_proc_addr (sid0_str2mmio_proc_addr) */
	REG_DUMP_PRINT_1("   -sid0_str2mmio_proc_addr.sid0_str2mmio_proc_addr                    |  0x%08X  |  [RW][29:00]""The address where the SID reg bank location in the Str2MMIO is located, this a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60028);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.enable_clk_gate                                            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_enable_clk_gate_type */
	/* skip, unused field unused_enable_clk_gate (enable_clk_gate) */
	REG_DUMP_PRINT_1("   -enable_clk_gate.enable_clk_gate                                    |         0x%01X  |  [RW][00:00]""Enable the automatic clockgating in the IBufCntrl to save power""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x60024);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.gda_address                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_gda_address_type */
	/* skip, unused field unused_gda_address (gda_address) */
	REG_DUMP_PRINT_1("   -gda_address.gda_address                                            |  0x%08X  |  [RW][29:00]""The address of the GDA, this is a word addressable value""\n", FIELD_VALUE(val, 0, 29));
	val = REG_DUMP_READ_REGISTER(0x60020);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.gda_enable                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_gda_enable_type */
	/* skip, unused field unused_gda_enable (gda_enable) */
	REG_DUMP_PRINT_1("   -gda_enable.gda_enable                                              |         0x%01X  |  [RW][00:00]""Enable the GDA functionality in the IBufCntrl. Pages will be de-allocated in the GDA when possible.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x6001c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.secure_touch_handling                                      |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_secure_touch_handling_type */
	/* skip, unused field unused_secure_touch_handling (secure_touch_handling) */
	REG_DUMP_PRINT_1("   -secure_touch_handling.secure_touch_handling                        |         0x%01X  |  [RW][01:00]""The mode of how the commands are being handled when secure touch is enabled for a SID processor. 0: fetch next command and process normally; 1: fetch next command and ACK immediatly without processing; 2: wait for fetching the next command until secure touch is disabled""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x60018);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.error_irq_en                                               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_error_irq_en_type */
	/* skip, unused field unused_error_irq_en (error_irq_en) */
	REG_DUMP_PRINT_1("   -error_irq_en.error_irq_en                                          |      0x%04X  |  [RW][15:00]""This register specifies for which SID processor the irq is enabled""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x60014);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.error_reg_set                                              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_error_reg_set_type */
	/* skip, unused field unused_error_reg_set (error_reg_set) */
	REG_DUMP_PRINT_1("   -error_reg_set.error_reg_set                                        |      0x%04X  |  [RO][15:00]""This register specifies which SID processor raised an interrupt and set its error register; the error register of SID x is set when bit x is set""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x60010);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.arbiter_status                                             |  0x%08X  |  ""The status of the arbiter in the IBufCntrl. Bit set to one means that part has access.""\n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_arbiter_status_type */
	/* skip, unused field unused_arbiter_status (arbiter_status) */
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_0                                          |         0x%01X  |  [RO][00:00]""SID proc 0 requires access""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_1                                          |         0x%01X  |  [RO][01:01]""SID proc 1 requires access""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_2                                          |         0x%01X  |  [RO][02:02]""SID proc 2 requires access""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_3                                          |         0x%01X  |  [RO][03:03]""SID proc 3 requires access""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_4                                          |         0x%01X  |  [RO][04:04]""SID proc 4 requires access""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_5                                          |         0x%01X  |  [RO][05:05]""SID proc 5 requires access""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_6                                          |         0x%01X  |  [RO][06:06]""SID proc 6 requires access""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_7                                          |         0x%01X  |  [RO][07:07]""SID proc 7 requires access""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_8                                          |         0x%01X  |  [RO][08:08]""SID proc 8 requires access""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_9                                          |         0x%01X  |  [RO][09:09]""SID proc 9 requires access""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_10                                         |         0x%01X  |  [RO][10:10]""SID proc 10 requires access""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_11                                         |         0x%01X  |  [RO][11:11]""SID proc 11 requires access""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_12                                         |         0x%01X  |  [RO][12:12]""SID proc 12 requires access""\n", FIELD_VALUE(val, 12, 12));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_13                                         |         0x%01X  |  [RO][13:13]""SID proc 13 requires access""\n", FIELD_VALUE(val, 13, 13));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_14                                         |         0x%01X  |  [RO][14:14]""SID proc 14 requires access""\n", FIELD_VALUE(val, 14, 14));
	REG_DUMP_PRINT_1("   -arbiter_status.sid_proc_15                                         |         0x%01X  |  [RO][15:15]""SID proc 15 requires access""\n", FIELD_VALUE(val, 15, 15));
	REG_DUMP_PRINT_1("   -arbiter_status.power_management                                    |         0x%01X  |  [RO][16:16]""Power management block requires access""\n", FIELD_VALUE(val, 16, 16));
	REG_DUMP_PRINT_1("   -arbiter_status.frame_monitor                                       |         0x%01X  |  [RO][17:17]""Frame monitor block requires access""\n", FIELD_VALUE(val, 17, 17));
	REG_DUMP_PRINT_1("   -arbiter_status.GDA_dealloc                                         |         0x%01X  |  [RO][18:18]""GDA deallocation arbiter (collection of all SID procs) requires access""\n", FIELD_VALUE(val, 18, 18));
	val = REG_DUMP_READ_REGISTER(0x60004);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  ibuf_ctrl.iwake_addr                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_csi2_logic_ibuf_ctrl_iwake_addr_type */
	/* skip, unused field unused_iwake_addr (iwake_addr) */
	REG_DUMP_PRINT_1("   -iwake_addr.iwake_addr                                              |  0x%08X  |  [RW][29:00]""The address of where the Iwake and Idone have to be written to. Internally is made sure that all SID procs are done before sending an Idone""\n", FIELD_VALUE(val, 0, 29));
} /* end ibuf_ctrl */

/* Generated Debug Code: Device sp_control_tile_evq */
void ia_css_debug_dump_sp_control_tile_evq(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x195c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.trace_mmio_wp3_high    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_trace_mmio_wp3_high_type */
	REG_DUMP_PRINT_1("   -trace_mmio_wp3_high.trace_mmio_wp3_high  |  0x%08X  |  [RW][31:00]""Tracing mmio watchpoint 3 high register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x1958);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.trace_mmio_wp2_high    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_trace_mmio_wp2_high_type */
	REG_DUMP_PRINT_1("   -trace_mmio_wp2_high.trace_mmio_wp2_high  |  0x%08X  |  [RW][31:00]""Tracing mmio watchpoint 2 high register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x1954);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.trace_mmio_wp1_high    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_trace_mmio_wp1_high_type */
	REG_DUMP_PRINT_1("   -trace_mmio_wp1_high.trace_mmio_wp1_high  |  0x%08X  |  [RW][31:00]""Tracing mmio watchpoint 1 high register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x1950);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.trace_mmio_wp0_high    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_trace_mmio_wp0_high_type */
	REG_DUMP_PRINT_1("   -trace_mmio_wp0_high.trace_mmio_wp0_high  |  0x%08X  |  [RW][31:00]""Tracing mmio watchpoint 0 high register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x194c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.trace_mmio_wp3_low     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_trace_mmio_wp3_low_type */
	REG_DUMP_PRINT_1("   -trace_mmio_wp3_low.trace_mmio_wp3_low    |  0x%08X  |  [RW][31:00]""Tracing mmio watchpoint 3 low register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x1948);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.trace_mmio_wp2_low     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_trace_mmio_wp2_low_type */
	REG_DUMP_PRINT_1("   -trace_mmio_wp2_low.trace_mmio_wp2_low    |  0x%08X  |  [RW][31:00]""Tracing mmio watchpoint 2 low register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x1944);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.trace_mmio_wp1_low     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_trace_mmio_wp1_low_type */
	REG_DUMP_PRINT_1("   -trace_mmio_wp1_low.trace_mmio_wp1_low    |  0x%08X  |  [RW][31:00]""Tracing mmio watchpoint 1 low register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x1940);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.trace_mmio_wp0_low     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_trace_mmio_wp0_low_type */
	REG_DUMP_PRINT_1("   -trace_mmio_wp0_low.trace_mmio_wp0_low    |  0x%08X  |  [RW][31:00]""Tracing mmio watchpoint 0 low register""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x193c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.trace_mmio_sel         |  0x%08X  |  ""Tracing mmio select register""\n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_trace_mmio_sel_type */
	/* skip, unused field unused_trace_mmio_sel (trace_mmio_sel) */
	REG_DUMP_PRINT_1("   -trace_mmio_sel.mmio_sel                  |         0x%01X  |  [RW][03:00]""Select MMIO (LSU) input""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -trace_mmio_sel.wp0_rd                    |         0x%01X  |  [RW][04:04]""Watchpoint 0 hit on read""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -trace_mmio_sel.wp0_wr                    |         0x%01X  |  [RW][05:05]""Watchpoint 0 hit on write""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -trace_mmio_sel.wp1_rd                    |         0x%01X  |  [RW][06:06]""Watchpoint 1 hit on read""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -trace_mmio_sel.wp1_wr                    |         0x%01X  |  [RW][07:07]""Watchpoint 1 hit on write""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -trace_mmio_sel.wp2_rd                    |         0x%01X  |  [RW][08:08]""Watchpoint 2 hit on read""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -trace_mmio_sel.wp2_wr                    |         0x%01X  |  [RW][09:09]""Watchpoint 2 hit on write""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -trace_mmio_sel.wp3_rd                    |         0x%01X  |  [RW][10:10]""Watchpoint 3 hit on read""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -trace_mmio_sel.wp3_wr                    |         0x%01X  |  [RW][11:11]""Watchpoint 3 hit on write""\n", FIELD_VALUE(val, 11, 11));
	val = REG_DUMP_READ_REGISTER(0x1938);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.trace_lmrun_pc_high    |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_trace_lmrun_pc_high_type */
	/* skip, unused field unused_trace_lmrun_pc_high (trace_lmrun_pc_high) */
	REG_DUMP_PRINT_1("   -trace_lmrun_pc_high.trace_lmrun_pc_high  |      0x%04X  |  [RW][15:00]""Tracing lmrun PC high register""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x1934);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.trace_lmrun_pc_low     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_trace_lmrun_pc_low_type */
	/* skip, unused field unused_trace_lmrun_pc_low (trace_lmrun_pc_low) */
	REG_DUMP_PRINT_1("   -trace_lmrun_pc_low.trace_lmrun_pc_low    |      0x%04X  |  [RW][15:00]""Tracing lmrun PC low register""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x1930);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.trace_lmrun_mask       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_trace_lmrun_mask_type */
	/* skip, unused field unused_trace_lmrun_mask (trace_lmrun_mask) */
	REG_DUMP_PRINT_1("   -trace_lmrun_mask.trace_lmrun_mask        |        0x%02X  |  [RW][04:00]""Tracing lmrun mask register""\n", FIELD_VALUE(val, 0, 4));
	val = REG_DUMP_READ_REGISTER(0x1928);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.lost_packets           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_lost_packets_type */
	/* skip, unused field unused_lost_packets (lost_packets) */
	REG_DUMP_PRINT_1("   -lost_packets.lost_packets                |      0x%04X  |  [RO][15:00]""Tracks number of lost packets in acase of lossy tracing.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x1924);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.trace_cfg              |  0x%08X  |  ""Tracing configuration register""\n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_trace_cfg_type */
	/* skip, unused field unused_trace_cfg (trace_cfg) */
	REG_DUMP_PRINT_1("   -trace_cfg.trace_mode                     |         0x%01X  |  [RW][00:00]""When 0: lossy tracing, when 1: lossless tracing""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -trace_cfg.branch_prog_start              |         0x%01X  |  [RW][01:01]""when set, send branch packet at program start""\n", FIELD_VALUE(val, 1, 1));
	val = REG_DUMP_READ_REGISTER(0x1920);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.trace_header           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_trace_header_type */
	/* skip, unused field unused_trace_header (trace_header) */
	REG_DUMP_PRINT_1("   -trace_header.trace_header                |         0x%01X  |  [RW][03:00]""SVEN header""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x191c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.trace_per_branch       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_trace_per_branch_type */
	/* skip, unused field unused_trace_per_branch (trace_per_branch) */
	REG_DUMP_PRINT_1("   -trace_per_branch.trace_per_branch        |      0x%04X  |  [RW][15:00]""The periodic Branch trace timer will count upto this value. It will then reset and send a Branch trace packet.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x1918);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.trace_per_pc           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_trace_per_pc_type */
	/* skip, unused field unused_trace_per_pc (trace_per_pc) */
	REG_DUMP_PRINT_1("   -trace_per_pc.trace_per_pc                |      0x%04X  |  [RW][15:00]""The periodic PC trace timer will count upto this value. It will then reset and send a PC trace packet.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x1914);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.trace_enable_ddr       |  0x%08X  |  ""Individual trace enable for tracing to DDR.""\n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_trace_enable_ddr_type */
	/* skip, unused field unused_trace_enable_ddr (trace_enable_ddr) */
	REG_DUMP_PRINT_1("   -trace_enable_ddr.flush                   |         0x%01X  |  [RW][00:00]""Enable flush tracing""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -trace_enable_ddr.eq_entry                |         0x%01X  |  [RW][01:01]""Enable EQ entry tracing""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -trace_enable_ddr.eq_exit                 |         0x%01X  |  [RW][02:02]""Enable EQ exit tracing""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -trace_enable_ddr.eq_promotion            |         0x%01X  |  [RW][03:03]""Enable EQ promotion tracing""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -trace_enable_ddr.bq_entry                |         0x%01X  |  [RW][04:04]""Enable BQ entry tracing""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -trace_enable_ddr.bq_exit                 |         0x%01X  |  [RW][05:05]""Enable BQ exit tracing""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -trace_enable_ddr.bq_blocked_exit         |         0x%01X  |  [RW][06:06]""Enable BQ blocked exit tracing""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -trace_enable_ddr.pc                      |         0x%01X  |  [RW][07:07]""Enable PC tracing""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -trace_enable_ddr.branch                  |         0x%01X  |  [RW][08:08]""Enable Branch tracing""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -trace_enable_ddr.pstart                  |         0x%01X  |  [RW][09:09]""Enable Program Start tracing""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -trace_enable_ddr.isp                     |         0x%01X  |  [RW][10:10]""Enable (I)SP tracing""\n", FIELD_VALUE(val, 10, 10));
	val = REG_DUMP_READ_REGISTER(0x1910);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.trace_enable_npk       |  0x%08X  |  ""Individual trace enable for tracing to NPK.""\n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_trace_enable_npk_type */
	/* skip, unused field unused_trace_enable_npk (trace_enable_npk) */
	REG_DUMP_PRINT_1("   -trace_enable_npk.flush                   |         0x%01X  |  [RW][00:00]""Enable flush tracing""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -trace_enable_npk.eq_entry                |         0x%01X  |  [RW][01:01]""Enable EQ entry tracing""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -trace_enable_npk.eq_exit                 |         0x%01X  |  [RW][02:02]""Enable EQ exit tracing""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -trace_enable_npk.eq_promotion            |         0x%01X  |  [RW][03:03]""Enable EQ promotion tracing""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -trace_enable_npk.bq_entry                |         0x%01X  |  [RW][04:04]""Enable BQ entry tracing""\n", FIELD_VALUE(val, 4, 4));
	REG_DUMP_PRINT_1("   -trace_enable_npk.bq_exit                 |         0x%01X  |  [RW][05:05]""Enable BQ exit tracing""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -trace_enable_npk.bq_blocked_exit         |         0x%01X  |  [RW][06:06]""Enable BQ blocked exit tracing""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -trace_enable_npk.pc                      |         0x%01X  |  [RW][07:07]""Enable PC tracing""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -trace_enable_npk.branch                  |         0x%01X  |  [RW][08:08]""Enable Branch tracing""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -trace_enable_npk.pstart                  |         0x%01X  |  [RW][09:09]""Enable Program Start tracing""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -trace_enable_npk.isp                     |         0x%01X  |  [RW][10:10]""Enable (I)SP tracing""\n", FIELD_VALUE(val, 10, 10));
	val = REG_DUMP_READ_REGISTER(0x190c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.trace_addr_d           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_trace_addr_d_type */
	REG_DUMP_PRINT_1("   -trace_addr_d.trace_addr_d                |  0x%08X  |  [RW][31:00]""Address of all event queue and pc trace packets.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x1908);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.trace_addr_c           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_trace_addr_c_type */
	REG_DUMP_PRINT_1("   -trace_addr_c.trace_addr_c                |  0x%08X  |  [RW][31:00]""Address of the FW last trace packet.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x1904);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.trace_addr_b           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_trace_addr_b_type */
	REG_DUMP_PRINT_1("   -trace_addr_b.trace_addr_b                |  0x%08X  |  [RW][31:00]""Address of the FW middle trace packets.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x1900);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.trace_addr_a           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_trace_addr_a_type */
	REG_DUMP_PRINT_1("   -trace_addr_a.trace_addr_a                |  0x%08X  |  [RW][31:00]""Address of the FW first trace packet.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x1800);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.timer_inc              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_timer_inc_type */
	/* skip, unused field unused_timer_inc (timer_inc) */
	REG_DUMP_PRINT_1("   -timer_inc.timer_inc                      |        0x%02X  |  [RW][07:00]""Timer increment value, count this many clock cycles before the timer is incremented.""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0x1700);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.queue_reserve          |  0x%08X  |  ""Queue reservation register""\n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_queue_reserve_type */
	/* skip, unused field unused_queue_reserve (queue_reserve) */
	REG_DUMP_PRINT_1("   -queue_reserve.space_available            |         0x%01X  |  [RO][00:00]""When bit is clear, no space is available. When bit is set space is available, reserved one location for writing.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x1604);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.binqstat               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_binqstat_type */
	/* skip, unused field unused_binqstat (binqstat) */
	REG_DUMP_PRINT_1("   -binqstat.binqstat                        |        0x%02X  |  [RO][07:00]""Data present (not empty) flag foreach queue""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0x1600);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.totalqstat             |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_totalqstat_type */
	/* skip, unused field unused_totalqstat (totalqstat) */
	REG_DUMP_PRINT_1("   -totalqstat.totalqstat                    |        0x%02X  |  [RO][05:00]""Number of tokens for all queues""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x141c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.pidqstat7              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_pidqstat7_type */
	/* skip, unused field unused_pidqstat7 (pidqstat7) */
	REG_DUMP_PRINT_1("   -pidqstat7.pidqstat7                      |        0x%02X  |  [RO][05:00]""Number of tokens for queue 7""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x1418);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.pidqstat6              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_pidqstat6_type */
	/* skip, unused field unused_pidqstat6 (pidqstat6) */
	REG_DUMP_PRINT_1("   -pidqstat6.pidqstat6                      |        0x%02X  |  [RO][05:00]""Number of tokens for queue 6""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x1414);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.pidqstat5              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_pidqstat5_type */
	/* skip, unused field unused_pidqstat5 (pidqstat5) */
	REG_DUMP_PRINT_1("   -pidqstat5.pidqstat5                      |        0x%02X  |  [RO][05:00]""Number of tokens for queue 5""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x1410);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.pidqstat4              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_pidqstat4_type */
	/* skip, unused field unused_pidqstat4 (pidqstat4) */
	REG_DUMP_PRINT_1("   -pidqstat4.pidqstat4                      |        0x%02X  |  [RO][05:00]""Number of tokens for queue 4""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x140c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.pidqstat3              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_pidqstat3_type */
	/* skip, unused field unused_pidqstat3 (pidqstat3) */
	REG_DUMP_PRINT_1("   -pidqstat3.pidqstat3                      |        0x%02X  |  [RO][05:00]""Number of tokens for queue 3""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x1408);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.pidqstat2              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_pidqstat2_type */
	/* skip, unused field unused_pidqstat2 (pidqstat2) */
	REG_DUMP_PRINT_1("   -pidqstat2.pidqstat2                      |        0x%02X  |  [RO][05:00]""Number of tokens for queue 2""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x1404);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.pidqstat1              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_pidqstat1_type */
	/* skip, unused field unused_pidqstat1 (pidqstat1) */
	REG_DUMP_PRINT_1("   -pidqstat1.pidqstat1                      |        0x%02X  |  [RO][05:00]""Number of tokens for queue 1""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x1400);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.pidqstat0              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_pidqstat0_type */
	/* skip, unused field unused_pidqstat0 (pidqstat0) */
	REG_DUMP_PRINT_1("   -pidqstat0.pidqstat0                      |        0x%02X  |  [RO][05:00]""Number of tokens for queue 0""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x131c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.pidqcfg7               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_pidqcfg7_type */
	/* skip, unused field unused_pidqcfg7 (pidqcfg7) */
	REG_DUMP_PRINT_1("   -pidqcfg7.pidqcfg7                        |        0x%02X  |  [RW][05:00]""Configuration register for queue 7""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x1318);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.pidqcfg6               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_pidqcfg6_type */
	/* skip, unused field unused_pidqcfg6 (pidqcfg6) */
	REG_DUMP_PRINT_1("   -pidqcfg6.pidqcfg6                        |        0x%02X  |  [RW][05:00]""Configuration register for queue 6""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x1314);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.pidqcfg5               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_pidqcfg5_type */
	/* skip, unused field unused_pidqcfg5 (pidqcfg5) */
	REG_DUMP_PRINT_1("   -pidqcfg5.pidqcfg5                        |        0x%02X  |  [RW][05:00]""Configuration register for queue 5""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x1310);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.pidqcfg4               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_pidqcfg4_type */
	/* skip, unused field unused_pidqcfg4 (pidqcfg4) */
	REG_DUMP_PRINT_1("   -pidqcfg4.pidqcfg4                        |        0x%02X  |  [RW][05:00]""Configuration register for queue 4""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x130c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.pidqcfg3               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_pidqcfg3_type */
	/* skip, unused field unused_pidqcfg3 (pidqcfg3) */
	REG_DUMP_PRINT_1("   -pidqcfg3.pidqcfg3                        |        0x%02X  |  [RW][05:00]""Configuration register for queue 3""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x1308);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.pidqcfg2               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_pidqcfg2_type */
	/* skip, unused field unused_pidqcfg2 (pidqcfg2) */
	REG_DUMP_PRINT_1("   -pidqcfg2.pidqcfg2                        |        0x%02X  |  [RW][05:00]""Configuration register for queue 2""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x1304);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.pidqcfg1               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_pidqcfg1_type */
	/* skip, unused field unused_pidqcfg1 (pidqcfg1) */
	REG_DUMP_PRINT_1("   -pidqcfg1.pidqcfg1                        |        0x%02X  |  [RW][05:00]""Configuration register for queue 1""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x1300);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.pidqcfg0               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_pidqcfg0_type */
	/* skip, unused field unused_pidqcfg0 (pidqcfg0) */
	REG_DUMP_PRINT_1("   -pidqcfg0.pidqcfg0                        |        0x%02X  |  [RW][05:00]""Configuration register for queue 0""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x1218);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.pidmap6                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_pidmap6_type */
	/* skip, unused field unused_pidmap6 (pidmap6) */
	REG_DUMP_PRINT_1("   -pidmap6.pidmap6                          |        0x%02X  |  [RW][05:00]""PID End Value for queue 6""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x1214);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.pidmap5                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_pidmap5_type */
	/* skip, unused field unused_pidmap5 (pidmap5) */
	REG_DUMP_PRINT_1("   -pidmap5.pidmap5                          |        0x%02X  |  [RW][05:00]""PID End Value for queue 5""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x1210);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.pidmap4                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_pidmap4_type */
	/* skip, unused field unused_pidmap4 (pidmap4) */
	REG_DUMP_PRINT_1("   -pidmap4.pidmap4                          |        0x%02X  |  [RW][05:00]""PID End Value for queue 4""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x120c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.pidmap3                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_pidmap3_type */
	/* skip, unused field unused_pidmap3 (pidmap3) */
	REG_DUMP_PRINT_1("   -pidmap3.pidmap3                          |        0x%02X  |  [RW][05:00]""PID End Value for queue 3""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x1208);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.pidmap2                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_pidmap2_type */
	/* skip, unused field unused_pidmap2 (pidmap2) */
	REG_DUMP_PRINT_1("   -pidmap2.pidmap2                          |        0x%02X  |  [RW][05:00]""PID End Value for queue 2""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x1204);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.pidmap1                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_pidmap1_type */
	/* skip, unused field unused_pidmap1 (pidmap1) */
	REG_DUMP_PRINT_1("   -pidmap1.pidmap1                          |        0x%02X  |  [RW][05:00]""PID End Value for queue 1""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x1200);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.pidmap0                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_pidmap0_type */
	/* skip, unused field unused_pidmap0 (pidmap0) */
	REG_DUMP_PRINT_1("   -pidmap0.pidmap0                          |        0x%02X  |  [RW][05:00]""PID End Value for queue 0""\n", FIELD_VALUE(val, 0, 5));
	val = REG_DUMP_READ_REGISTER(0x110c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.sdp3                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_sdp3_type */
	/* skip, unused field unused_sdp3 (sdp3) */
	REG_DUMP_PRINT_1("   -sdp3.sdp3                                |      0x%04X  |  [RW][15:00]""Soft deadline for prio 3 (lowest)""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x1108);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.sdp2                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_sdp2_type */
	/* skip, unused field unused_sdp2 (sdp2) */
	REG_DUMP_PRINT_1("   -sdp2.sdp2                                |      0x%04X  |  [RW][15:00]""Soft deadline for prio 2""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x1104);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_evq.sdp1                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_evq_sdp1_type */
	/* skip, unused field unused_sdp1 (sdp1) */
	REG_DUMP_PRINT_1("   -sdp1.sdp1                                |      0x%04X  |  [RW][15:00]""Soft deadline for prio 1""\n", FIELD_VALUE(val, 0, 15));
} /* end sp_control_tile_evq */

/* Generated Debug Code: Device sp_control_tile_gpc */
void ia_css_debug_dump_sp_control_tile_gpc(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0x8bc);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_irq_enable_reg_3                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_irq_enable_reg_3_type */
	/* skip, unused field unused_gpc_irq_enable_reg_3 (gpc_irq_enable_reg_3) */
	REG_DUMP_PRINT_1("   -gpc_irq_enable_reg_3.gpc_irq_enable_reg_3                |         0x%01X  |  [RW][00:00]""Enable trigger 3 and sticky bits""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x8b8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_irq_enable_reg_2                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_irq_enable_reg_2_type */
	/* skip, unused field unused_gpc_irq_enable_reg_2 (gpc_irq_enable_reg_2) */
	REG_DUMP_PRINT_1("   -gpc_irq_enable_reg_2.gpc_irq_enable_reg_2                |         0x%01X  |  [RW][00:00]""Enable trigger 2 and sticky bits""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x8b4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_irq_enable_reg_1                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_irq_enable_reg_1_type */
	/* skip, unused field unused_gpc_irq_enable_reg_1 (gpc_irq_enable_reg_1) */
	REG_DUMP_PRINT_1("   -gpc_irq_enable_reg_1.gpc_irq_enable_reg_1                |         0x%01X  |  [RW][00:00]""Enable trigger 1 and sticky bits""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x8b0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_irq_enable_reg_0                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_irq_enable_reg_0_type */
	/* skip, unused field unused_gpc_irq_enable_reg_0 (gpc_irq_enable_reg_0) */
	REG_DUMP_PRINT_1("   -gpc_irq_enable_reg_0.gpc_irq_enable_reg_0                |         0x%01X  |  [RW][00:00]""Enable trigger 0 and sticky bits""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x8ac);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_irq_timer_sel_reg_3                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_irq_timer_sel_reg_3_type */
	/* skip, unused field unused_gpc_irq_timer_sel_reg_3 (gpc_irq_timer_sel_reg_3) */
	REG_DUMP_PRINT_1("   -gpc_irq_timer_sel_reg_3.gpc_irq_timer_sel_reg_3          |         0x%01X  |  [RW][01:00]""Selects which counter to be used for matching for trigger 3""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x8a8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_irq_timer_sel_reg_2                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_irq_timer_sel_reg_2_type */
	/* skip, unused field unused_gpc_irq_timer_sel_reg_2 (gpc_irq_timer_sel_reg_2) */
	REG_DUMP_PRINT_1("   -gpc_irq_timer_sel_reg_2.gpc_irq_timer_sel_reg_2          |         0x%01X  |  [RW][01:00]""Selects which counter to be used for matching for trigger 2""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x8a4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_irq_timer_sel_reg_1                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_irq_timer_sel_reg_1_type */
	/* skip, unused field unused_gpc_irq_timer_sel_reg_1 (gpc_irq_timer_sel_reg_1) */
	REG_DUMP_PRINT_1("   -gpc_irq_timer_sel_reg_1.gpc_irq_timer_sel_reg_1          |         0x%01X  |  [RW][01:00]""Selects which counter to be used for matching for trigger 1""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x8a0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_irq_timer_sel_reg_0                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_irq_timer_sel_reg_0_type */
	/* skip, unused field unused_gpc_irq_timer_sel_reg_0 (gpc_irq_timer_sel_reg_0) */
	REG_DUMP_PRINT_1("   -gpc_irq_timer_sel_reg_0.gpc_irq_timer_sel_reg_0          |         0x%01X  |  [RW][01:00]""Selects which counter to be used for matching for trigger 0""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x89c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_irq_trigger_value_reg_3            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_irq_trigger_value_reg_3_type */
	REG_DUMP_PRINT_1("   -gpc_irq_trigger_value_reg_3.gpc_irq_trigger_value_reg_3  |  0x%08X  |  [RW][31:00]""The reference value that is used for comparisson and trigger 3 generation""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x898);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_irq_trigger_value_reg_2            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_irq_trigger_value_reg_2_type */
	REG_DUMP_PRINT_1("   -gpc_irq_trigger_value_reg_2.gpc_irq_trigger_value_reg_2  |  0x%08X  |  [RW][31:00]""The reference value that is used for comparisson and trigger 2 generation""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x894);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_irq_trigger_value_reg_1            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_irq_trigger_value_reg_1_type */
	REG_DUMP_PRINT_1("   -gpc_irq_trigger_value_reg_1.gpc_irq_trigger_value_reg_1  |  0x%08X  |  [RW][31:00]""The reference value that is used for comparisson and trigger 1 generation""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x890);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_irq_trigger_value_reg_0            |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_irq_trigger_value_reg_0_type */
	REG_DUMP_PRINT_1("   -gpc_irq_trigger_value_reg_0.gpc_irq_trigger_value_reg_0  |  0x%08X  |  [RW][31:00]""The reference value that is used for comparisson and trigger 0 generation""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x88c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_trace_pload_sel_reg_3              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_trace_pload_sel_reg_3_type */
	/* skip, unused field unused_gpc_trace_pload_sel_reg_3 (gpc_trace_pload_sel_reg_3) */
	REG_DUMP_PRINT_1("   -gpc_trace_pload_sel_reg_3.gpc_trace_pload_sel_reg_3      |         0x%01X  |  [RW][01:00]""GPC payload selection for counter 3""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x888);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_trace_pload_sel_reg_2              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_trace_pload_sel_reg_2_type */
	/* skip, unused field unused_gpc_trace_pload_sel_reg_2 (gpc_trace_pload_sel_reg_2) */
	REG_DUMP_PRINT_1("   -gpc_trace_pload_sel_reg_2.gpc_trace_pload_sel_reg_2      |         0x%01X  |  [RW][01:00]""GPC payload selection for counter 2""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x884);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_trace_pload_sel_reg_1              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_trace_pload_sel_reg_1_type */
	/* skip, unused field unused_gpc_trace_pload_sel_reg_1 (gpc_trace_pload_sel_reg_1) */
	REG_DUMP_PRINT_1("   -gpc_trace_pload_sel_reg_1.gpc_trace_pload_sel_reg_1      |         0x%01X  |  [RW][01:00]""GPC payload selection for counter 1""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x880);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_trace_pload_sel_reg_0              |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_trace_pload_sel_reg_0_type */
	/* skip, unused field unused_gpc_trace_pload_sel_reg_0 (gpc_trace_pload_sel_reg_0) */
	REG_DUMP_PRINT_1("   -gpc_trace_pload_sel_reg_0.gpc_trace_pload_sel_reg_0      |         0x%01X  |  [RW][01:00]""GPC payload selection for counter 0""\n", FIELD_VALUE(val, 0, 1));
	val = REG_DUMP_READ_REGISTER(0x87c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_trace_msg_sel_reg_3                |  0x%08X  |  ""GPC message selection for counter 3""\n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_trace_msg_sel_reg_3_type */
	/* skip, unused field unused_gpc_trace_msg_sel_reg_3 (gpc_trace_msg_sel_reg_3) */
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_3.SrcSel                           |         0x%01X  |  [RW][03:00]""Select input / output""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_3.RoutSel                          |         0x%01X  |  [RW][05:04]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_3.SensSel                          |         0x%01X  |  [RW][07:06]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 6, 7));
	val = REG_DUMP_READ_REGISTER(0x878);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_trace_msg_sel_reg_2                |  0x%08X  |  ""GPC message selection for counter 2""\n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_trace_msg_sel_reg_2_type */
	/* skip, unused field unused_gpc_trace_msg_sel_reg_2 (gpc_trace_msg_sel_reg_2) */
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_2.SrcSel                           |         0x%01X  |  [RW][03:00]""Select input / output""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_2.RoutSel                          |         0x%01X  |  [RW][05:04]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_2.SensSel                          |         0x%01X  |  [RW][07:06]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 6, 7));
	val = REG_DUMP_READ_REGISTER(0x874);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_trace_msg_sel_reg_1                |  0x%08X  |  ""GPC message selection for counter 1""\n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_trace_msg_sel_reg_1_type */
	/* skip, unused field unused_gpc_trace_msg_sel_reg_1 (gpc_trace_msg_sel_reg_1) */
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_1.SrcSel                           |         0x%01X  |  [RW][03:00]""Select input / output""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_1.RoutSel                          |         0x%01X  |  [RW][05:04]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_1.SensSel                          |         0x%01X  |  [RW][07:06]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 6, 7));
	val = REG_DUMP_READ_REGISTER(0x870);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_trace_msg_sel_reg_0                |  0x%08X  |  ""GPC message selection for counter 0""\n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_trace_msg_sel_reg_0_type */
	/* skip, unused field unused_gpc_trace_msg_sel_reg_0 (gpc_trace_msg_sel_reg_0) */
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_0.SrcSel                           |         0x%01X  |  [RW][03:00]""Select input / output""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_0.RoutSel                          |         0x%01X  |  [RW][05:04]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -gpc_trace_msg_sel_reg_0.SensSel                          |         0x%01X  |  [RW][07:06]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 6, 7));
	val = REG_DUMP_READ_REGISTER(0x86c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_trace_stop_sel_reg_3               |  0x%08X  |  ""GPC stop selection for counter 3""\n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_trace_stop_sel_reg_3_type */
	/* skip, unused field unused_gpc_trace_stop_sel_reg_3 (gpc_trace_stop_sel_reg_3) */
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_3.SrcSel                          |         0x%01X  |  [RW][03:00]""Select input / output""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_3.RoutSel                         |         0x%01X  |  [RW][05:04]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_3.SensSel                         |         0x%01X  |  [RW][07:06]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 6, 7));
	val = REG_DUMP_READ_REGISTER(0x868);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_trace_stop_sel_reg_2               |  0x%08X  |  ""GPC stop selection for counter 2""\n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_trace_stop_sel_reg_2_type */
	/* skip, unused field unused_gpc_trace_stop_sel_reg_2 (gpc_trace_stop_sel_reg_2) */
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_2.SrcSel                          |         0x%01X  |  [RW][03:00]""Select input / output""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_2.RoutSel                         |         0x%01X  |  [RW][05:04]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_2.SensSel                         |         0x%01X  |  [RW][07:06]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 6, 7));
	val = REG_DUMP_READ_REGISTER(0x864);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_trace_stop_sel_reg_1               |  0x%08X  |  ""GPC stop selection for counter 1""\n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_trace_stop_sel_reg_1_type */
	/* skip, unused field unused_gpc_trace_stop_sel_reg_1 (gpc_trace_stop_sel_reg_1) */
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_1.SrcSel                          |         0x%01X  |  [RW][03:00]""Select input / output""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_1.RoutSel                         |         0x%01X  |  [RW][05:04]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_1.SensSel                         |         0x%01X  |  [RW][07:06]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 6, 7));
	val = REG_DUMP_READ_REGISTER(0x860);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_trace_stop_sel_reg_0               |  0x%08X  |  ""GPC stop selection for counter 0""\n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_trace_stop_sel_reg_0_type */
	/* skip, unused field unused_gpc_trace_stop_sel_reg_0 (gpc_trace_stop_sel_reg_0) */
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_0.SrcSel                          |         0x%01X  |  [RW][03:00]""Select input / output""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_0.RoutSel                         |         0x%01X  |  [RW][05:04]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -gpc_trace_stop_sel_reg_0.SensSel                         |         0x%01X  |  [RW][07:06]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 6, 7));
	val = REG_DUMP_READ_REGISTER(0x85c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_trace_start_sel_reg_3              |  0x%08X  |  ""GPC start selection for counter 3""\n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_trace_start_sel_reg_3_type */
	/* skip, unused field unused_gpc_trace_start_sel_reg_3 (gpc_trace_start_sel_reg_3) */
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_3.SrcSel                         |         0x%01X  |  [RW][03:00]""Select input / output""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_3.RoutSel                        |         0x%01X  |  [RW][05:04]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_3.SensSel                        |         0x%01X  |  [RW][07:06]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 6, 7));
	val = REG_DUMP_READ_REGISTER(0x858);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_trace_start_sel_reg_2              |  0x%08X  |  ""GPC start selection for counter 2""\n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_trace_start_sel_reg_2_type */
	/* skip, unused field unused_gpc_trace_start_sel_reg_2 (gpc_trace_start_sel_reg_2) */
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_2.SrcSel                         |         0x%01X  |  [RW][03:00]""Select input / output""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_2.RoutSel                        |         0x%01X  |  [RW][05:04]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_2.SensSel                        |         0x%01X  |  [RW][07:06]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 6, 7));
	val = REG_DUMP_READ_REGISTER(0x854);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_trace_start_sel_reg_1              |  0x%08X  |  ""GPC start selection for counter 1""\n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_trace_start_sel_reg_1_type */
	/* skip, unused field unused_gpc_trace_start_sel_reg_1 (gpc_trace_start_sel_reg_1) */
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_1.SrcSel                         |         0x%01X  |  [RW][03:00]""Select input / output""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_1.RoutSel                        |         0x%01X  |  [RW][05:04]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_1.SensSel                        |         0x%01X  |  [RW][07:06]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 6, 7));
	val = REG_DUMP_READ_REGISTER(0x850);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_trace_start_sel_reg_0              |  0x%08X  |  ""GPC start selection for counter 0""\n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_trace_start_sel_reg_0_type */
	/* skip, unused field unused_gpc_trace_start_sel_reg_0 (gpc_trace_start_sel_reg_0) */
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_0.SrcSel                         |         0x%01X  |  [RW][03:00]""Select input / output""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_0.RoutSel                        |         0x%01X  |  [RW][05:04]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -gpc_trace_start_sel_reg_0.SensSel                        |         0x%01X  |  [RW][07:06]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 6, 7));
	val = REG_DUMP_READ_REGISTER(0x84c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_trace_input_sel_reg_3              |  0x%08X  |  ""GPC input selection for counter 3""\n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_trace_input_sel_reg_3_type */
	/* skip, unused field unused_gpc_trace_input_sel_reg_3 (gpc_trace_input_sel_reg_3) */
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_3.SrcSel                         |         0x%01X  |  [RW][03:00]""Select input / output""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_3.RoutSel                        |         0x%01X  |  [RW][05:04]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_3.SensSel                        |         0x%01X  |  [RW][07:06]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 6, 7));
	val = REG_DUMP_READ_REGISTER(0x848);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_trace_input_sel_reg_2              |  0x%08X  |  ""GPC input selection for counter 2""\n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_trace_input_sel_reg_2_type */
	/* skip, unused field unused_gpc_trace_input_sel_reg_2 (gpc_trace_input_sel_reg_2) */
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_2.SrcSel                         |         0x%01X  |  [RW][03:00]""Select input / output""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_2.RoutSel                        |         0x%01X  |  [RW][05:04]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_2.SensSel                        |         0x%01X  |  [RW][07:06]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 6, 7));
	val = REG_DUMP_READ_REGISTER(0x844);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_trace_input_sel_reg_1              |  0x%08X  |  ""GPC input selection for counter 1""\n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_trace_input_sel_reg_1_type */
	/* skip, unused field unused_gpc_trace_input_sel_reg_1 (gpc_trace_input_sel_reg_1) */
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_1.SrcSel                         |         0x%01X  |  [RW][03:00]""Select input / output""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_1.RoutSel                        |         0x%01X  |  [RW][05:04]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_1.SensSel                        |         0x%01X  |  [RW][07:06]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 6, 7));
	val = REG_DUMP_READ_REGISTER(0x840);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_trace_input_sel_reg_0              |  0x%08X  |  ""GPC input selection for counter 0""\n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_trace_input_sel_reg_0_type */
	/* skip, unused field unused_gpc_trace_input_sel_reg_0 (gpc_trace_input_sel_reg_0) */
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_0.SrcSel                         |         0x%01X  |  [RW][03:00]""Select input / output""\n", FIELD_VALUE(val, 0, 3));
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_0.RoutSel                        |         0x%01X  |  [RW][05:04]""0: use an input as source; 1: use an output as source; 2: constant high; 3: constant low""\n", FIELD_VALUE(val, 4, 5));
	REG_DUMP_PRINT_1("   -gpc_trace_input_sel_reg_0.SensSel                        |         0x%01X  |  [RW][07:06]""Sensitivity; 0: high; 1: low; 2: rising-edge; 3: falling-edge""\n", FIELD_VALUE(val, 6, 7));
	val = REG_DUMP_READ_REGISTER(0x83c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_value_reg_3                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_value_reg_3_type */
	REG_DUMP_PRINT_1("   -gpc_value_reg_3.gpc_value_reg_3                          |  0x%08X  |  [RO][31:00]""GPC current value of counter 3""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x838);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_value_reg_2                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_value_reg_2_type */
	REG_DUMP_PRINT_1("   -gpc_value_reg_2.gpc_value_reg_2                          |  0x%08X  |  [RO][31:00]""GPC current value of counter 2""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x834);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_value_reg_1                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_value_reg_1_type */
	REG_DUMP_PRINT_1("   -gpc_value_reg_1.gpc_value_reg_1                          |  0x%08X  |  [RO][31:00]""GPC current value of counter 1""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x830);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_value_reg_0                        |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_value_reg_0_type */
	REG_DUMP_PRINT_1("   -gpc_value_reg_0.gpc_value_reg_0                          |  0x%08X  |  [RO][31:00]""GPC current value of counter 0""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x82c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_enable_reg_3                       |  0x%08X  |  ""GPC counter 3 enable""\n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_enable_reg_3_type */
	/* skip, unused field unused_gpc_enable_reg_3 (gpc_enable_reg_3) */
	REG_DUMP_PRINT_1("   -gpc_enable_reg_3.Enable                                  |         0x%01X  |  [RW][00:00]""When 0 counter is enabled, when 1 counter is enabled""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -gpc_enable_reg_3.Halt                                    |         0x%01X  |  [RW][01:01]""When 0 counter will wrap around, when 1 counter will halt""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -gpc_enable_reg_3.Reset_on_match                          |         0x%01X  |  [RW][02:02]""When 0 counter is not modified, when 1 counter reset on match""\n", FIELD_VALUE(val, 2, 2));
	val = REG_DUMP_READ_REGISTER(0x828);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_enable_reg_2                       |  0x%08X  |  ""GPC counter 2 enable""\n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_enable_reg_2_type */
	/* skip, unused field unused_gpc_enable_reg_2 (gpc_enable_reg_2) */
	REG_DUMP_PRINT_1("   -gpc_enable_reg_2.Enable                                  |         0x%01X  |  [RW][00:00]""When 0 counter is enabled, when 1 counter is enabled""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -gpc_enable_reg_2.Halt                                    |         0x%01X  |  [RW][01:01]""When 0 counter will wrap around, when 1 counter will halt""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -gpc_enable_reg_2.Reset_on_match                          |         0x%01X  |  [RW][02:02]""When 0 counter is not modified, when 1 counter reset on match""\n", FIELD_VALUE(val, 2, 2));
	val = REG_DUMP_READ_REGISTER(0x824);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_enable_reg_1                       |  0x%08X  |  ""GPC counter 1 enable""\n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_enable_reg_1_type */
	/* skip, unused field unused_gpc_enable_reg_1 (gpc_enable_reg_1) */
	REG_DUMP_PRINT_1("   -gpc_enable_reg_1.Enable                                  |         0x%01X  |  [RW][00:00]""When 0 counter is enabled, when 1 counter is enabled""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -gpc_enable_reg_1.Halt                                    |         0x%01X  |  [RW][01:01]""When 0 counter will wrap around, when 1 counter will halt""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -gpc_enable_reg_1.Reset_on_match                          |         0x%01X  |  [RW][02:02]""When 0 counter is not modified, when 1 counter reset on match""\n", FIELD_VALUE(val, 2, 2));
	val = REG_DUMP_READ_REGISTER(0x820);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_enable_reg_0                       |  0x%08X  |  ""GPC counter 0 enable""\n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_enable_reg_0_type */
	/* skip, unused field unused_gpc_enable_reg_0 (gpc_enable_reg_0) */
	REG_DUMP_PRINT_1("   -gpc_enable_reg_0.Enable                                  |         0x%01X  |  [RW][00:00]""When 0 counter is enabled, when 1 counter is enabled""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -gpc_enable_reg_0.Halt                                    |         0x%01X  |  [RW][01:01]""When 0 counter will wrap around, when 1 counter will halt""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -gpc_enable_reg_0.Reset_on_match                          |         0x%01X  |  [RW][02:02]""When 0 counter is not modified, when 1 counter reset on match""\n", FIELD_VALUE(val, 2, 2));
	val = REG_DUMP_READ_REGISTER(0x81c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_lost_packets_reg                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_lost_packets_reg_type */
	/* skip, unused field unused_gpc_lost_packets_reg (gpc_lost_packets_reg) */
	REG_DUMP_PRINT_1("   -gpc_lost_packets_reg.gpc_lost_packets_reg                |      0x%04X  |  [RO][15:00]""Tracks number of lost packets in acase of lossy tracing.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x814);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_trace_enable_ddr_reg               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_trace_enable_ddr_reg_type */
	/* skip, unused field unused_gpc_trace_enable_ddr_reg (gpc_trace_enable_ddr_reg) */
	REG_DUMP_PRINT_1("   -gpc_trace_enable_ddr_reg.gpc_trace_enable_ddr_reg        |         0x%01X  |  [RW][03:00]""Individual trace enable for tracing to DDR""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x810);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_trace_enable_npk_reg               |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_trace_enable_npk_reg_type */
	/* skip, unused field unused_gpc_trace_enable_npk_reg (gpc_trace_enable_npk_reg) */
	REG_DUMP_PRINT_1("   -gpc_trace_enable_npk_reg.gpc_trace_enable_npk_reg        |         0x%01X  |  [RW][03:00]""Individual trace enable for tracing to NPK.""\n", FIELD_VALUE(val, 0, 3));
	val = REG_DUMP_READ_REGISTER(0x80c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_trace_addr_reg                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_trace_addr_reg_type */
	REG_DUMP_PRINT_1("   -gpc_trace_addr_reg.gpc_trace_addr_reg                    |  0x%08X  |  [RW][31:00]""Address to which all trace packet are sent.""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x808);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_trace_header_reg                   |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_trace_header_reg_type */
	/* skip, unused field unused_gpc_trace_header_reg (gpc_trace_header_reg) */
	REG_DUMP_PRINT_1("   -gpc_trace_header_reg.gpc_trace_header_reg                |        0x%02X  |  [RW][07:00]""SVEN header""\n", FIELD_VALUE(val, 0, 7));
	val = REG_DUMP_READ_REGISTER(0x804);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_gpc.gpc_overall_enable_reg                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_gpc_gpc_overall_enable_reg_type */
	/* skip, unused field unused_gpc_overall_enable_reg (gpc_overall_enable_reg) */
	REG_DUMP_PRINT_1("   -gpc_overall_enable_reg.gpc_overall_enable_reg            |         0x%01X  |  [RW][00:00]""Overall enable all the counters""\n", FIELD_VALUE(val, 0, 0));
} /* end sp_control_tile_gpc */

/* Generated Debug Code: Device sp_control_tile_sp */
void ia_css_debug_dump_sp_control_tile_sp(void) {

	unsigned int val;

	val = REG_DUMP_READ_REGISTER(0xa8);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.pmem_slave_access                                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_pmem_slave_access_type */
	/* skip, unused field unused_pmem_slave_access (pmem_slave_access) */
	REG_DUMP_PRINT_1("   -pmem_slave_access.pmem_slave_access                                                                |         0x%01X  |  [RW][00:00]""PMEM slave access flag. By default, the local program memory of the core can only be accessed by a slave interface when the core is idling. While running a program, by default the core has exclusive read access to its local program. Whenever, the slave interface tries to access PMEM in this default mode, it will stall. When setting this flag to '1', this default behavior can be overuled by switching exclusive access to PMEM to the slave interface. Whenever the core tries to access PMEM in this 'PMEM slave access' mode, it will be stalled. The benefit of this feature is that it allows uploading new code to PMEM while the core is running a program, for instance from its instruction cache.""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0xa0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.config_icache_stat_control_reg_40                                                 |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_config_icache_stat_control_reg_40_type */
	/* skip, unused field unused_config_icache_stat_control_reg_40 (config_icache_stat_control_reg_40) */
	REG_DUMP_PRINT_1("   -config_icache_stat_control_reg_40.stall_stat_config_icache_loc_mt_am_inst_0_op0                    |         0x%01X  |  [RO][00:00]""Stalling flag for msink config_icache_loc_mt_am_inst_0_op0""\n", FIELD_VALUE(val, 0, 0));
	REG_DUMP_PRINT_1("   -config_icache_stat_control_reg_40.stall_stat_dmem_loc_mt_am_inst_1_op0                             |         0x%01X  |  [RO][01:01]""Stalling flag for msink dmem_loc_mt_am_inst_1_op0""\n", FIELD_VALUE(val, 1, 1));
	REG_DUMP_PRINT_1("   -config_icache_stat_control_reg_40.stall_stat_qmem_loc_mt_am_inst_2_op0                             |         0x%01X  |  [RO][02:02]""Stalling flag for msink qmem_loc_mt_am_inst_2_op0""\n", FIELD_VALUE(val, 2, 2));
	REG_DUMP_PRINT_1("   -config_icache_stat_control_reg_40.stall_stat_cmem_loc_mt_am_inst_3_op0                             |         0x%01X  |  [RO][03:03]""Stalling flag for msink cmem_loc_mt_am_inst_3_op0""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -config_icache_stat_control_reg_40.stall_stat_xmem_loc_mt_am_inst_4_op0                             |         0x%01X  |  [RO][04:04]""Stalling flag for msink xmem_loc_mt_am_inst_4_op0""\n", FIELD_VALUE(val, 4, 4));
	val = REG_DUMP_READ_REGISTER(0x9c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.debug_pc                                                                          |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_debug_pc_type */
	/* skip, unused field unused_debug_pc (debug_pc) */
	REG_DUMP_PRINT_1("   -debug_pc.debug_pc                                                                                  |      0x%04X  |  [RO][15:00]""Program counter. To observe the value of the program counter, for debug purpose.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0x84);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.base_info_override_seg_3_MI_xmem_master_int                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_base_info_override_seg_3_MI_xmem_master_int_type */
	/* skip, unused field unused_base_info_override_seg_3_MI_xmem_master_int (base_info_override_seg_3_MI_xmem_master_int) */
	REG_DUMP_PRINT_1("   -base_info_override_seg_3_MI_xmem_master_int.base_info_override_seg_3_MI_xmem_master_int            |         0x%01X  |  [RW][00:00]""Info override bit for segment 3 of master interface xmem_master_int""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x80);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.base_info_seg_3_MI_xmem_master_int                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_base_info_seg_3_MI_xmem_master_int_type */
	/* skip, unused field unused_base_info_seg_3_MI_xmem_master_int (base_info_seg_3_MI_xmem_master_int) */
	REG_DUMP_PRINT_1("   -base_info_seg_3_MI_xmem_master_int.base_info_seg_3_MI_xmem_master_int                              |       0x%03X  |  [RW][09:00]""Info for segment 3 of master interface xmem_master_int""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x7c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.base_addr_seg_3_MI_xmem_master_int                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_base_addr_seg_3_MI_xmem_master_int_type */
	REG_DUMP_PRINT_1("   -base_addr_seg_3_MI_xmem_master_int.base_addr_seg_3_MI_xmem_master_int                              |  0x%08X  |  [RW][31:00]""Base address for segment 3 of master interface xmem_master_int""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x78);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.base_info_override_seg_2_MI_xmem_master_int                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_base_info_override_seg_2_MI_xmem_master_int_type */
	/* skip, unused field unused_base_info_override_seg_2_MI_xmem_master_int (base_info_override_seg_2_MI_xmem_master_int) */
	REG_DUMP_PRINT_1("   -base_info_override_seg_2_MI_xmem_master_int.base_info_override_seg_2_MI_xmem_master_int            |         0x%01X  |  [RW][00:00]""Info override bit for segment 2 of master interface xmem_master_int""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x74);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.base_info_seg_2_MI_xmem_master_int                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_base_info_seg_2_MI_xmem_master_int_type */
	/* skip, unused field unused_base_info_seg_2_MI_xmem_master_int (base_info_seg_2_MI_xmem_master_int) */
	REG_DUMP_PRINT_1("   -base_info_seg_2_MI_xmem_master_int.base_info_seg_2_MI_xmem_master_int                              |       0x%03X  |  [RW][09:00]""Info for segment 2 of master interface xmem_master_int""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x70);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.base_addr_seg_2_MI_xmem_master_int                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_base_addr_seg_2_MI_xmem_master_int_type */
	REG_DUMP_PRINT_1("   -base_addr_seg_2_MI_xmem_master_int.base_addr_seg_2_MI_xmem_master_int                              |  0x%08X  |  [RW][31:00]""Base address for segment 2 of master interface xmem_master_int""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x6c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.base_info_override_seg_1_MI_xmem_master_int                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_base_info_override_seg_1_MI_xmem_master_int_type */
	/* skip, unused field unused_base_info_override_seg_1_MI_xmem_master_int (base_info_override_seg_1_MI_xmem_master_int) */
	REG_DUMP_PRINT_1("   -base_info_override_seg_1_MI_xmem_master_int.base_info_override_seg_1_MI_xmem_master_int            |         0x%01X  |  [RW][00:00]""Info override bit for segment 1 of master interface xmem_master_int""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x68);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.base_info_seg_1_MI_xmem_master_int                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_base_info_seg_1_MI_xmem_master_int_type */
	/* skip, unused field unused_base_info_seg_1_MI_xmem_master_int (base_info_seg_1_MI_xmem_master_int) */
	REG_DUMP_PRINT_1("   -base_info_seg_1_MI_xmem_master_int.base_info_seg_1_MI_xmem_master_int                              |       0x%03X  |  [RW][09:00]""Info for segment 1 of master interface xmem_master_int""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x64);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.base_addr_seg_1_MI_xmem_master_int                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_base_addr_seg_1_MI_xmem_master_int_type */
	REG_DUMP_PRINT_1("   -base_addr_seg_1_MI_xmem_master_int.base_addr_seg_1_MI_xmem_master_int                              |  0x%08X  |  [RW][31:00]""Base address for segment 1 of master interface xmem_master_int""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x60);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.base_info_override_seg_0_MI_xmem_master_int                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_base_info_override_seg_0_MI_xmem_master_int_type */
	/* skip, unused field unused_base_info_override_seg_0_MI_xmem_master_int (base_info_override_seg_0_MI_xmem_master_int) */
	REG_DUMP_PRINT_1("   -base_info_override_seg_0_MI_xmem_master_int.base_info_override_seg_0_MI_xmem_master_int            |         0x%01X  |  [RW][00:00]""Info override bit for segment 0 of master interface xmem_master_int""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x5c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.base_info_seg_0_MI_xmem_master_int                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_base_info_seg_0_MI_xmem_master_int_type */
	/* skip, unused field unused_base_info_seg_0_MI_xmem_master_int (base_info_seg_0_MI_xmem_master_int) */
	REG_DUMP_PRINT_1("   -base_info_seg_0_MI_xmem_master_int.base_info_seg_0_MI_xmem_master_int                              |       0x%03X  |  [RW][09:00]""Info for segment 0 of master interface xmem_master_int""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x58);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.base_addr_seg_0_MI_xmem_master_int                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_base_addr_seg_0_MI_xmem_master_int_type */
	REG_DUMP_PRINT_1("   -base_addr_seg_0_MI_xmem_master_int.base_addr_seg_0_MI_xmem_master_int                              |  0x%08X  |  [RW][31:00]""Base address for segment 0 of master interface xmem_master_int""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x54);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.base_info_override_seg_3_MI_cmem_master_int                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_base_info_override_seg_3_MI_cmem_master_int_type */
	/* skip, unused field unused_base_info_override_seg_3_MI_cmem_master_int (base_info_override_seg_3_MI_cmem_master_int) */
	REG_DUMP_PRINT_1("   -base_info_override_seg_3_MI_cmem_master_int.base_info_override_seg_3_MI_cmem_master_int            |         0x%01X  |  [RW][00:00]""Info override bit for segment 3 of master interface cmem_master_int""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x50);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.base_info_seg_3_MI_cmem_master_int                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_base_info_seg_3_MI_cmem_master_int_type */
	/* skip, unused field unused_base_info_seg_3_MI_cmem_master_int (base_info_seg_3_MI_cmem_master_int) */
	REG_DUMP_PRINT_1("   -base_info_seg_3_MI_cmem_master_int.base_info_seg_3_MI_cmem_master_int                              |       0x%03X  |  [RW][09:00]""Info for segment 3 of master interface cmem_master_int""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x4c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.base_addr_seg_3_MI_cmem_master_int                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_base_addr_seg_3_MI_cmem_master_int_type */
	REG_DUMP_PRINT_1("   -base_addr_seg_3_MI_cmem_master_int.base_addr_seg_3_MI_cmem_master_int                              |  0x%08X  |  [RW][31:00]""Base address for segment 3 of master interface cmem_master_int""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x48);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.base_info_override_seg_2_MI_cmem_master_int                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_base_info_override_seg_2_MI_cmem_master_int_type */
	/* skip, unused field unused_base_info_override_seg_2_MI_cmem_master_int (base_info_override_seg_2_MI_cmem_master_int) */
	REG_DUMP_PRINT_1("   -base_info_override_seg_2_MI_cmem_master_int.base_info_override_seg_2_MI_cmem_master_int            |         0x%01X  |  [RW][00:00]""Info override bit for segment 2 of master interface cmem_master_int""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x44);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.base_info_seg_2_MI_cmem_master_int                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_base_info_seg_2_MI_cmem_master_int_type */
	/* skip, unused field unused_base_info_seg_2_MI_cmem_master_int (base_info_seg_2_MI_cmem_master_int) */
	REG_DUMP_PRINT_1("   -base_info_seg_2_MI_cmem_master_int.base_info_seg_2_MI_cmem_master_int                              |       0x%03X  |  [RW][09:00]""Info for segment 2 of master interface cmem_master_int""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x40);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.base_addr_seg_2_MI_cmem_master_int                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_base_addr_seg_2_MI_cmem_master_int_type */
	REG_DUMP_PRINT_1("   -base_addr_seg_2_MI_cmem_master_int.base_addr_seg_2_MI_cmem_master_int                              |  0x%08X  |  [RW][31:00]""Base address for segment 2 of master interface cmem_master_int""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x3c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.base_info_override_seg_1_MI_cmem_master_int                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_base_info_override_seg_1_MI_cmem_master_int_type */
	/* skip, unused field unused_base_info_override_seg_1_MI_cmem_master_int (base_info_override_seg_1_MI_cmem_master_int) */
	REG_DUMP_PRINT_1("   -base_info_override_seg_1_MI_cmem_master_int.base_info_override_seg_1_MI_cmem_master_int            |         0x%01X  |  [RW][00:00]""Info override bit for segment 1 of master interface cmem_master_int""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x38);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.base_info_seg_1_MI_cmem_master_int                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_base_info_seg_1_MI_cmem_master_int_type */
	/* skip, unused field unused_base_info_seg_1_MI_cmem_master_int (base_info_seg_1_MI_cmem_master_int) */
	REG_DUMP_PRINT_1("   -base_info_seg_1_MI_cmem_master_int.base_info_seg_1_MI_cmem_master_int                              |       0x%03X  |  [RW][09:00]""Info for segment 1 of master interface cmem_master_int""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x34);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.base_addr_seg_1_MI_cmem_master_int                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_base_addr_seg_1_MI_cmem_master_int_type */
	REG_DUMP_PRINT_1("   -base_addr_seg_1_MI_cmem_master_int.base_addr_seg_1_MI_cmem_master_int                              |  0x%08X  |  [RW][31:00]""Base address for segment 1 of master interface cmem_master_int""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x30);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.base_info_override_seg_0_MI_cmem_master_int                                       |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_base_info_override_seg_0_MI_cmem_master_int_type */
	/* skip, unused field unused_base_info_override_seg_0_MI_cmem_master_int (base_info_override_seg_0_MI_cmem_master_int) */
	REG_DUMP_PRINT_1("   -base_info_override_seg_0_MI_cmem_master_int.base_info_override_seg_0_MI_cmem_master_int            |         0x%01X  |  [RW][00:00]""Info override bit for segment 0 of master interface cmem_master_int""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x2c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.base_info_seg_0_MI_cmem_master_int                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_base_info_seg_0_MI_cmem_master_int_type */
	/* skip, unused field unused_base_info_seg_0_MI_cmem_master_int (base_info_seg_0_MI_cmem_master_int) */
	REG_DUMP_PRINT_1("   -base_info_seg_0_MI_cmem_master_int.base_info_seg_0_MI_cmem_master_int                              |       0x%03X  |  [RW][09:00]""Info for segment 0 of master interface cmem_master_int""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x28);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.base_addr_seg_0_MI_cmem_master_int                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_base_addr_seg_0_MI_cmem_master_int_type */
	REG_DUMP_PRINT_1("   -base_addr_seg_0_MI_cmem_master_int.base_addr_seg_0_MI_cmem_master_int                              |  0x%08X  |  [RW][31:00]""Base address for segment 0 of master interface cmem_master_int""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x1c);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.base_addr_seg_0_MI_qmem_master_int                                                |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_base_addr_seg_0_MI_qmem_master_int_type */
	REG_DUMP_PRINT_1("   -base_addr_seg_0_MI_qmem_master_int.base_addr_seg_0_MI_qmem_master_int                              |  0x%08X  |  [RW][31:00]""Base address for segment 0 of master interface qmem_master_int""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x18);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.base_info_override_seg_0_MI_config_icache_master                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_base_info_override_seg_0_MI_config_icache_master_type */
	/* skip, unused field unused_base_info_override_seg_0_MI_config_icache_master (base_info_override_seg_0_MI_config_icache_master) */
	REG_DUMP_PRINT_1("   -base_info_override_seg_0_MI_config_icache_master.base_info_override_seg_0_MI_config_icache_master  |         0x%01X  |  [RW][00:00]""Info override bit for segment 0 of master interface config_icache_master""\n", FIELD_VALUE(val, 0, 0));
	val = REG_DUMP_READ_REGISTER(0x14);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.base_info_seg_0_MI_config_icache_master                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_base_info_seg_0_MI_config_icache_master_type */
	/* skip, unused field unused_base_info_seg_0_MI_config_icache_master (base_info_seg_0_MI_config_icache_master) */
	REG_DUMP_PRINT_1("   -base_info_seg_0_MI_config_icache_master.base_info_seg_0_MI_config_icache_master                    |       0x%03X  |  [RW][09:00]""Info for segment 0 of master interface config_icache_master""\n", FIELD_VALUE(val, 0, 9));
	val = REG_DUMP_READ_REGISTER(0x10);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.base_addr_seg_0_MI_config_icache_master                                           |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_base_addr_seg_0_MI_config_icache_master_type */
	REG_DUMP_PRINT_1("   -base_addr_seg_0_MI_config_icache_master.base_addr_seg_0_MI_config_icache_master                    |  0x%08X  |  [RW][31:00]""Base address for segment 0 of master interface config_icache_master""\n", FIELD_VALUE(val, 0, 31));
	val = REG_DUMP_READ_REGISTER(0x4);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.start_address                                                                     |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_start_address_type */
	/* skip, unused field unused_start_address (start_address) */
	REG_DUMP_PRINT_1("   -start_address.start_address                                                                        |      0x%04X  |  [RW][15:00]""Program start address. Specifies the address in the program memory from which the program execution starts when a start signal is issued to the core being in IDLE state.""\n", FIELD_VALUE(val, 0, 15));
	val = REG_DUMP_READ_REGISTER(0);
	REG_DUMP_PRINT_0("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	REG_DUMP_PRINT_1("  sp_control_tile_sp.config_icache_stat_control_reg_0                                                  |  0x%08X  |  \n", val);
/* reg_type: reg_input_system_unis_logic_sp_control_tile_sp_config_icache_stat_control_reg_0_type */
	/* skip, unused field unused_config_icache_stat_control_reg_0 (config_icache_stat_control_reg_0) */
	/* skip, WO field reset_flag */
	/* skip, WO field start_flag */
	REG_DUMP_PRINT_1("   -config_icache_stat_control_reg_0.run_flag                                                          |         0x%01X  |  [RW][03:03]""Run flag. Enables program execution (high) or stall the cell, disabling it from continuing program execution (low).""\n", FIELD_VALUE(val, 3, 3));
	REG_DUMP_PRINT_1("   -config_icache_stat_control_reg_0.ready_flag                                                        |         0x%01X  |  [RO][05:05]""Ready flag. Set to '1' when not executing a program. This state is entered after a (soft) reset or when the 'std_idle' operation has been issued. To (re)start execution from the start address (in the following register), the start control flag must be set to high.""\n", FIELD_VALUE(val, 5, 5));
	REG_DUMP_PRINT_1("   -config_icache_stat_control_reg_0.sleeping_flag                                                     |         0x%01X  |  [RO][06:06]""Sleeping flag. The cell is in sleep mode, i.e. when the 'std_sleep' operation has been issued. To resume execution, the start control flag must be set to high.""\n", FIELD_VALUE(val, 6, 6));
	REG_DUMP_PRINT_1("   -config_icache_stat_control_reg_0.stalling_flag                                                     |         0x%01X  |  [RO][07:07]""Stalling flag. Set to '1' when not executing an instruction. Happens when the run control signal has been set to low, or when an LSU or the CoreIO cannot access data (e.g. cache miss, arbitration conflict or FIFO full).""\n", FIELD_VALUE(val, 7, 7));
	REG_DUMP_PRINT_1("   -config_icache_stat_control_reg_0.irq_clear_flag                                                    |         0x%01X  |  [RW][08:08]""IRQ clear flag. Clears an interrupt request sent by the cell. The cell can generate a level-shaped IRQ when it gets to the BROKEN, IDLE or SLEEP state. Interrupt generation is controlled by mask.""\n", FIELD_VALUE(val, 8, 8));
	REG_DUMP_PRINT_1("   -config_icache_stat_control_reg_0.broken_irq_mask_flag                                              |         0x%01X  |  [RW][09:09]""Broken IRQ mask flag. Enables (high) or disables (low) IRQ generation when the cell enters the BROKEN state.""\n", FIELD_VALUE(val, 9, 9));
	REG_DUMP_PRINT_1("   -config_icache_stat_control_reg_0.ready_irq_mask_flag                                               |         0x%01X  |  [RW][10:10]""Ready IRQ mask flag. Enables (high) or disables (low) IRQ generation when the cell enters the IDLE state.""\n", FIELD_VALUE(val, 10, 10));
	REG_DUMP_PRINT_1("   -config_icache_stat_control_reg_0.sleeping_irq_mask_flag                                            |         0x%01X  |  [RW][11:11]""Sleeping IRQ mask flag. Enables (high) or disables (low) IRQ generation when the cell enters the SLEEP state.""\n", FIELD_VALUE(val, 11, 11));
	REG_DUMP_PRINT_1("   -config_icache_stat_control_reg_0.ivalidate_cache_flag                                              |         0x%01X  |  [RW][12:12]""Invalidate cache flag for config_icache_icache. The cell automatically resets the bit to '0' after one clock cycle.""\n", FIELD_VALUE(val, 12, 12));
	REG_DUMP_PRINT_1("   -config_icache_stat_control_reg_0.prefetch_enable_flag                                              |         0x%01X  |  [RW][13:13]""Prefetch enable flag for config_icache_icache. Enables (high) or disables (low) prefetching of instructions by the instruction cache.""\n", FIELD_VALUE(val, 13, 13));
	REG_DUMP_PRINT_1("   -config_icache_stat_control_reg_0.arb_period_dmem_Arb_mem_wp                                        |        0x%02X  |  [RW][18:14]""Arbiter period for dmem_Arb_mem_wp""\n", FIELD_VALUE(val, 14, 18));
	REG_DUMP_PRINT_1("   -config_icache_stat_control_reg_0.arb_cont_dmem_Arb_mem_wp_source0                                  |         0x%01X  |  [RW][22:19]""Arbiter contender group bandwidth for dmem_Arb_mem_wp_source0""\n", FIELD_VALUE(val, 19, 22));
	REG_DUMP_PRINT_1("   -config_icache_stat_control_reg_0.arb_cont_dmem_Arb_mem_wp_source1                                  |         0x%01X  |  [RW][26:23]""Arbiter contender group bandwidth for dmem_Arb_mem_wp_source1""\n", FIELD_VALUE(val, 23, 26));
} /* end sp_control_tile_sp */


