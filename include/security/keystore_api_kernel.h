/*
 *
 * Intel Keystore Linux driver
 * Copyright (c) 2013, Intel Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the GNU General Public License,
 * version 2, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 */

#ifndef _KEYSTORE_H_
#define _KEYSTORE_H_

#include <security/keystore_api_common.h>

/**
 * keystore_register() - Register a keystore client
 * @seed_type:           Which SEED to use to register the client.
 *                       This can be either a device or user-specific seed.
 * @client_ticket:       Output buffer for the client ticket
 *                       The caller must assure that at least
 *                       KEYSTORE_CLIENT_TICKET_SIZE bytes are available.
 *
 * Register a client with Keystore. The client is identified using the
 * path of the calling function for user-space applications.
 *
 * A client key is generated by combining the SEED type and client ID.
 *
 * A random ticket is generated and returned to the caller which can be used
 * for subsequent interactions with keystore.
 *
 * Return: 0 if OK or negative error code (see errno.h)
 */
int keystore_register(enum keystore_seed_type seed_type,
		      uint8_t *client_ticket);

/**
 * keystore_unregister() - Unregister a Keystore Client
 * @client_ticket: The client ticket (KEYSTORE_CLIENT_TICKET_SIZE bytes).
 *
 * Unregister a client with keystore. This will remove all state information
 * associated to the client.
 *
 * Return: 0 if OK or negative error code (see errno.h).
 */
int keystore_unregister(const uint8_t *client_ticket);

/**
 * keystore_wrapped_key_size() - Get the wrapped key size in bytes
 * @keyspec:     The key type
 * @size:        Output size
 *
 * To be called before generate/import key to allocate space for
 * a wrapped key buffer.
 */
int keystore_wrapped_key_size(enum keystore_key_spec keyspec,
			      unsigned int *size);

/**
 * keystore_generate_key() - Generate a random key and wrap it.
 *
 * @client_ticket: The client ticket (KEYSTORE_CLIENT_TICKET_SIZE bytes)
 * @keyspec:       The type of key to be generated.
 * @wrapped_key:   Output buffer for the wrapped key
 *                 Caller must ensure that the buffer has sufficient
 *                 space by calling keystore_wrapped_key_size beforehand.
 *
 * Generates a random cryptographic key and wraps it using the client key
 * corresponding to the client ticket provided.
 *
 * Return: 0 if OK or negative error code (see errno.h).
 */
int keystore_generate_key(const uint8_t *client_ticket,
			  enum keystore_key_spec keyspec, uint8_t *wrapped_key);

/**
 * keystore_wrap_key() - Wrap the application key.
 *
 * @client_ticket: The client ticket (KEYSTORE_CLIENT_TICKET_SIZE bytes).
 * @app_key:       The application key to be wrapped.
 * @app_key_size:  The application key size in bytes.
 * @keyspec:       The key specification.
 * @wrapped_key:   Output buffer for the wrapped key.
 *                 (app_key_size + KEYSTORE_WRAPPED_KEY_EXTRA bytes).
 *
 * Wrap (import) a bare (unencrypted) application key which has the given
 * keyspec. The wrapped key is returned to the client for use with keystore
 * for encryption/decryption operations.
 *
 * Return: 0 if OK or negative error code (see errno.h).
 */
int keystore_wrap_key(const uint8_t *client_ticket, const uint8_t *app_key,
		      unsigned int app_key_size,
		      enum keystore_key_spec keyspec, uint8_t *wrapped_key);

/**
 * keystore_load_key() - Unwrap the application key and store in a slot.
 *
 * @client_ticket:     The client ticket (KEYSTORE_CLIENT_TICKET_SIZE bytes).
 * @wrapped_key:       The wrapped key to be imported.
 * @wrapped_key_size:  The wrapped key size in bytes.
 * @slot_id:           Slot ID where the key is stored.
 *
 * Keystore will take the wrapped key, unwrap it and store it in a slot
 * associated with the client_ticket.
 *
 * Return: 0 if OK or negative error code (see errno.h).
 */
int keystore_load_key(const uint8_t *client_ticket, const uint8_t *wrapped_key,
		      unsigned int wrapped_key_size, unsigned int *slot_id);

/**
 * keystore_unload_key() - Remove a key from a slot
 *
 * @client_ticket: The client ticket (KEYSTORE_CLIENT_TICKET_SIZE bytes).
 * @slot_id:       The slot ID where the key is stored.
 *
 * If there is a key in the given slot, remove it and free the slot.
 *
 * Return: 0 if OK or negative error code (see errno.h).
 */
int keystore_unload_key(const uint8_t *client_ticket, unsigned int slot_id);

/**
 * keystore_encrypt_size() - Get the required size of an encrypted buffer.
 * @algo_spec:      The encryption algorithm specification.
 * @input_size:     The size of the plaintext buffer.
 * @output_size:    The size of the output buffer.
 *
 * Return: 0 if OK or negative error code (see errno.h).
 */
int keystore_encrypt_size(enum keystore_algo_spec algo_spec,
			  unsigned int input_size, unsigned int *output_size);

/**
 * keystore_encrypt() - Encrypt plaintext using AppKey/IV according to AlgoSpec.
 *
 * @client_ticket:   The client ticket (KEYSTORE_CLIENT_TICKET_SIZE bytes).
 * @slot_id:         The slot ID.
 * @algo_spec:       The algorithm specification.
 * @iv:              Encryption initialization vector.
 * @iv_size:         Initialization vector size in bytes.
 * @input:           Input block of data to encrypt.
 * @input_size:      Input block size in bytes.
 * @output:          Pointer to the block for encrypted data. The caller
 *                   is responsible for providing a buffer of sufficent size
 *                   by first calling keystore_encrypt_size.
 *
 * Use the key stored in the given slot to encrypt a block of data.
 * The output contains the algo_spec and IV which is extracted by
 * the decrypt command.
 *
 * Return: Encrypted data size in bytes if OK or negative error code
 *         (see errno.h).
 */
int keystore_encrypt(const uint8_t *client_ticket, int slot_id,
		     enum keystore_algo_spec algo_spec,
		     const uint8_t *iv, unsigned int iv_size,
		     const uint8_t *input, unsigned int input_size,
		     uint8_t *output);

/**
 * keystore_decrypt_size() - Get the required size of an encrypted buffer.
 * @algo_spec:      The encryption algorithm specification.
 * @input_size:     The size of the encrypted buffer.
 * @output_size:    The size of the output buffer.
 *
 * Return: 0 if OK or negative error code (see errno.h).
 */
int keystore_decrypt_size(enum keystore_algo_spec algo_spec,
			  unsigned int input_size, unsigned int *output_size);

/**
 * kesytore_decrypt() - Decrypt cipher using AppKey and AlgoSpec/IV.
 *
 * @client_ticket:  The client ticket (KEYSTORE_CLIENT_TICKET_SIZE bytes).
 * @slot_id:        The slot ID.
 * @algo_spec:       The algorithm specification.
 * @iv:              Encryption initialization vector.
 * @iv_size:         Initialization vector size in bytes.
 * @input:          Input block of data to decrypt.
 * @input_size:     Input block size in bytes.
 * @output:         Pointer to the block for decrypted data. The caller
 *                  must ensure sufficient space is available for the
 *                  decrypted data by calling keystore_decrypt_size
 *                  first.
 *
 * Use the key stored in the given slot to decrypt a block of data.
 *
 * Return: 0 if OK or negative error code (see errno.h).
 */
int keystore_decrypt(const uint8_t *client_ticket, int slot_id,
		     enum keystore_algo_spec algo_spec,
		     const uint8_t *iv, unsigned int iv_size,
		     const uint8_t *input, unsigned int input_size,
		     uint8_t *output);

/**
 * keystore_backup() - Create an encrypted backup of the Client Key.
 *
 * @client_ticket:         The client ticket
 *                         (KEYSTORE_CLIENT_TICKET_SIZE bytes).
 * @oem_pub:               OEM public ECC key.
 * @oem_pub_sig:           ECC key signed by OEM RSA key, must be
 *                         RSA_SIGNATURE_SIZE bytes in size.
 * @output:                Pointer to the block for encrypted data.
 *                         (at least KEYSTORE_BACKUP_SIZE bytes).
 * @output_signature:      ECC signature of output buffer, must
 *                         be ECC_SIGNATURE_SIZE in size.
 *
 * Validate OEM public ECC key and encrypt data for backup with it.
 * The backup data contains the Client ID and Client key.
 * The encryped output is signed by the keystore public ECC key.
 * The signed and encrypted output can be used to migrate keystore client
 * keys between targets.
 *
 * Return: 0 if OK or negative error code (see errno.h).
 */
int keystore_backup(const uint8_t *client_ticket,
		    const struct keystore_ecc_public_key *oem_pub,
		    const uint8_t *signature,
		    uint8_t *output,
		    struct keystore_ecc_signature *output_signature);

/**
 * keystore_get_ksm_key() - Retrieve the Keystore public ECC key.
 *
 * @public_key: The Keystore public ECC key
 *
 * Return: 0 OK or negative error code (see errno.h),
 * (ENODATA if SEED cannot be used to generate private key
 * or EKEYREJECTED if public key cannot pass verification.
 */
int keystore_get_ksm_key(struct keystore_ecc_public_key *public_key);

/**
 * keystore_generate_mkey() - Generate migration key.
 *
 * @oem_pub:          OEM public ECC key.
 * @oem_pub_sig:      ECC key signed by OEM RSA key, RSA_SIGNATURE_SIZE
 *                    bytes in size.
 * @emkey:            Encrypted migration key, caller must reserve
 *                    KEYSTORE_MKEY_SIZE bytes.
 * @mkey_sig:         Signature of encrypted migration key.
 * @mkey_nonce:       Nonce used to create the migration key, caller must
 *                    ensure KEYSTORE_MKEY_NONCE_SIZE bytes are available.
 *
 * Keystore will check the signature of the ECC public key against the
 * OEM RSA public key. This ECC key will be used to encrypt a randomly
 * generated migration key (mkey) and return it together with the nonce
 * used to generate the key.
 *
 * Return: 0 if OK or negative error code (see errno.h).
 */
int keystore_generate_mkey(const struct keystore_ecc_public_key *oem_pub,
			   const uint8_t *oem_pub_sig,
			   uint8_t *emkey,
			   struct keystore_ecc_signature *mkey_sig,
			   uint8_t *mkey_nonce);

/**
 * keystore_rewrap_key() - Import key backup from another keystore
 *
 * @client_ticket:      The client ticket (KEYSTORE_CLIENT_TICKET_SIZE bytes).
 * @backup_emkey:       Backup data encrypted using migration key(AES-CCM),
 *                      mkey - {ClientKey1, ClientIDMK}. Expected size is
 *                      REENCRYPTED_BACKUP_SIZE bytes.
 * @mkey_nonce:         Nonce for creating migration key,
 *                      KEYSTORE_MKEY_NONCE_SIZE bytes in size.
 * @wrapped_key:        Wrapped key which needs to be rewrapped.
 * @wrapped_key_size:   Size of the wrapped key.
 * @rewrapped_key:      Rewrapped key with new KSM client key. The caller must
 *                      ensure wrapped_key_size bytes are available.
 *
 * Takes a wrapped key and re-encrypted migration data from a different
 * keystore and re-wraps the key using the Client key associated with
 * the current client.
 *
 * Return: 0 if OK or negative error code (see errno.h).
 */
int keystore_rewrap_key(const uint8_t *client_ticket,
			const uint8_t *backup_emkey,
			const uint8_t *mkey_nonce,
			const uint8_t *wrapped_key,
			unsigned int wrapped_key_size,
			uint8_t *rewrapped_key);

#if defined(CONFIG_KEYSTORE_TEST_MIGRATION)
/**
 * keystore_gen_ecc_keys() - Generate a random ECC private and public key pair.
 *
 * @key_pair: ECC public/private key pair
 *
 * Return: 0 OK or negative error code (see errno.h).
 * ENODATA if SEED cannot be used to generate private key
 * or EKEYREJECTED if public key cannot pass verification.
 */
int keystore_gen_ecc_keys(struct ias_keystore_ecc_keypair *key_pair);

/**
 * keystore_test_verify_ecc_signature() - Verify ECC signature using public key
 *
 * @public_key:      Public ECC key.
 * @data:            Data to verify the signature of.
 * @data_size:       Size of data.
 * @sig:             Signature data, must be ECC_SIGNATURE_SIZE bytes in size
 *
 * Return: 0 if OK or negative error code (see errno.h).
 */
int keystore_test_verify_ecc_signature(const struct keystore_ecc_public_key
				       *public_key,
				       const uint8_t *data,
				       unsigned int data_size,
				       const struct keystore_ecc_signature
				       *output_sig);

/**
 * keystore_migrate() - Re-encrypt using a migration key,
 *
 * @private_key:       Private ECC key whose public key was used to encrypt
 *                     the backup data.
 * @backup:            Backup data from the keystore_backup function.
 * @private_key2:      Private ECC key whose public key was used to encrypt the
 *                     migration key.
 * @mig_key:           Encrypted migration key.
 * @output:            Backup data re-encrypted using the migration key.
 *
 * Decrypt backup and migration key and then encrypt backup data with migration
 * key. Intended to test the migration operation.
 *
 * Return: 0 OK or negative error code (see errno.h).
 */
int keystore_migrate(const uint32_t *private_key,
		     const uint8_t *backup,
		     const uint32_t *private_key2,
		     const uint8_t *mig_key,
		     uint8_t *output);

#endif /* KEYSTORE_TEST_MIGRATION */

#endif /* _KEYSTORE_H_ */
