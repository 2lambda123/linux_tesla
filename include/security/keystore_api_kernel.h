/*
 *
 * Intel Keystore Linux driver
 * Copyright (c) 2013, Intel Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the GNU General Public License,
 * version 2, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 */

#ifndef _KEYSTORE_H_
#define _KEYSTORE_H_

#include <security/keystore_api_common.h>

/**
 * DOC: Introduction
 *
 * Keystore can be accessed from kernel clients via this interface.
 * The user-space ioctl calls also call into this interface.
 */

/**
 * keystore_register() - Register a keystore client
 * @seed_type:           Which SEED to use to register the client.
 *                       This can be either a device or user-specific seed.
 * @client_ticket:       Output buffer for the client ticket
 *                       The caller must assure that at least
 *                       KEYSTORE_CLIENT_TICKET_SIZE bytes are available.
 *
 * Register a client with Keystore. The client is identified using the
 * path of the calling function for user-space applications.
 *
 * A client key is generated by combining the SEED type and client ID.
 *
 * A random ticket is generated and returned to the caller which can be used
 * for subsequent interactions with keystore.
 *
 * Return: 0 if OK or negative error code (see errno.h)
 */
int keystore_register(enum keystore_seed_type seed_type,
		      uint8_t *client_ticket);

/**
 * keystore_unregister() - Unregister a Keystore Client
 * @client_ticket: The client ticket (KEYSTORE_CLIENT_TICKET_SIZE bytes).
 *
 * Unregister a client with keystore. This will remove all state information
 * associated to the client.
 *
 * Return: 0 if OK or negative error code (see errno.h).
 */
int keystore_unregister(const uint8_t *client_ticket);

/**
 * keystore_wrapped_key_size() - Get the wrapped key size in bytes
 * @keyspec:     The key type
 * @size:        Output size
 * @unwrapped_size: Unwrapped key size (can be left null).
 *
 * To be called before generate/import key to allocate space for
 * a wrapped key buffer.
 */
int keystore_wrapped_key_size(enum keystore_key_spec keyspec,
			      unsigned int *size,
			      unsigned int *unwrapped_size);

/**
 * keystore_generate_key() - Generate a random key and wrap it.
 *
 * @client_ticket: The client ticket (KEYSTORE_CLIENT_TICKET_SIZE bytes)
 * @keyspec:       The type of key to be generated.
 * @wrapped_key:   Output buffer for the wrapped key
 *                 Caller must ensure that the buffer has sufficient
 *                 space by calling keystore_wrapped_key_size beforehand.
 *
 * Generates a random cryptographic key and wraps it using the client key
 * corresponding to the client ticket provided.
 *
 * Return: 0 if OK or negative error code (see errno.h).
 */
int keystore_generate_key(const uint8_t *client_ticket,
			  enum keystore_key_spec keyspec, uint8_t *wrapped_key);

/**
 * keystore_wrap_key() - Wrap the application key.
 *
 * @client_ticket: The client ticket (KEYSTORE_CLIENT_TICKET_SIZE bytes).
 * @app_key:       The application key to be wrapped.
 * @app_key_size:  The application key size in bytes.
 * @keyspec:       The key specification.
 * @wrapped_key:   Output buffer for the wrapped key.
 *
 * Wrap (import) a bare (unencrypted) application key which has the given
 * keyspec. The wrapped key is returned to the client for use with keystore
 * for encryption/decryption operations.
 *
 * Return: 0 if OK or negative error code (see errno.h).
 */
int keystore_wrap_key(const uint8_t *client_ticket, const uint8_t *app_key,
		      unsigned int app_key_size,
		      enum keystore_key_spec keyspec, uint8_t *wrapped_key);

/**
 * keystore_load_key() - Unwrap the application key and store in a slot.
 *
 * @client_ticket:     The client ticket (KEYSTORE_CLIENT_TICKET_SIZE bytes).
 * @wrapped_key:       The wrapped key to be imported.
 * @wrapped_key_size:  The wrapped key size in bytes.
 * @slot_id:           Slot ID where the key is stored.
 *
 * Keystore will take the wrapped key, unwrap it and store it in a slot
 * associated with the client_ticket.
 *
 * If the function returns -EAGAIN, unwrapping was only possible with a legacy
 * SEED (with outdated SVN). The key has not been loaded, but the @wrapped_key
 * array has been replaced with a key wrapped with the latest client key (with
 * largest SVN). In this case the client must save the wrapped_key and call
 * keystore_load_key() again with the newly wrapped key.
 *
 * Return: 0 if OK or negative error code (see errno.h).
 */
int keystore_load_key(const uint8_t *client_ticket, uint8_t *wrapped_key,
		      unsigned int wrapped_key_size, unsigned int *slot_id);

/**
 * keystore_unload_key() - Remove a key from a slot
 *
 * @client_ticket: The client ticket (KEYSTORE_CLIENT_TICKET_SIZE bytes).
 * @slot_id:       The slot ID where the key is stored.
 *
 * If there is a key in the given slot, remove it and free the slot.
 *
 * Return: 0 if OK or negative error code (see errno.h).
 */
int keystore_unload_key(const uint8_t *client_ticket, unsigned int slot_id);

/**
 * keystore_encrypt_size() - Get the required size of an encrypted buffer.
 * @algo_spec:      The encryption algorithm specification.
 * @input_size:     The size of the plaintext buffer.
 * @output_size:    The size of the output buffer.
 *
 * Return: 0 if OK or negative error code (see errno.h).
 */
int keystore_encrypt_size(enum keystore_algo_spec algo_spec,
			  unsigned int input_size, unsigned int *output_size);

/**
 * keystore_encrypt() - Encrypt plaintext using AppKey/IV according to AlgoSpec.
 *
 * @client_ticket:   The client ticket (KEYSTORE_CLIENT_TICKET_SIZE bytes).
 * @slot_id:         The slot ID.
 * @algo_spec:       The algorithm specification.
 * @iv:              Encryption initialization vector (must be NULL for ECIES).
 * @iv_size:         Initialization vector size in bytes (must be 0 for ECIES).
 * @input:           Input block of data to encrypt.
 * @input_size:      Input block size in bytes.
 * @output:          Pointer to the block for encrypted data. The caller
 *                   is responsible for providing a buffer of sufficent size
 *                   by first calling keystore_encrypt_size.
 *
 * Use the key stored in the given slot to encrypt a block of data.
 *
 * Return: Encrypted data size in bytes if OK or negative error code
 *         (see errno.h).
 */
int keystore_encrypt(const uint8_t *client_ticket, int slot_id,
		     enum keystore_algo_spec algo_spec,
		     const uint8_t *iv, unsigned int iv_size,
		     const uint8_t *input, unsigned int input_size,
		     uint8_t *output);

/**
 * keystore_decrypt_size() - Get the required size of an encrypted buffer.
 * @algo_spec:      The encryption algorithm specification.
 * @input_size:     The size of the encrypted buffer.
 * @output_size:    The size of the output buffer.
 *
 * Return: 0 if OK or negative error code (see errno.h).
 */
int keystore_decrypt_size(enum keystore_algo_spec algo_spec,
			  unsigned int input_size, unsigned int *output_size);

/**
 * kesytore_decrypt() - Decrypt cipher using AppKey and AlgoSpec/IV.
 *
 * @client_ticket:  The client ticket (KEYSTORE_CLIENT_TICKET_SIZE bytes).
 * @slot_id:        The slot ID.
 * @algo_spec:      The algorithm specification.
 * @iv:             Encryption initialization vector.
 * @iv_size:        Initialization vector size in bytes.
 * @input:          Input block of data to decrypt.
 * @input_size:     Input block size in bytes.
 * @output:         Pointer to the block for decrypted data. The caller
 *                  must ensure sufficient space is available for the
 *                  decrypted data by calling keystore_decrypt_size
 *                  first.
 *
 * Use the key stored in the given slot to decrypt a block of data.
 *
 * Return: 0 if OK or negative error code (see errno.h).
 */
int keystore_decrypt(const uint8_t *client_ticket, int slot_id,
		     enum keystore_algo_spec algo_spec,
		     const uint8_t *iv, unsigned int iv_size,
		     const uint8_t *input, unsigned int input_size,
		     uint8_t *output);

/**
 * keystore_sign_verify_size() - Get the required size of a signature buffer.
 * @algo_spec:      The encryption algorithm specification.
 * @signature_size: The size of the signature buffer.
 *
 * Return: 0 if OK or negative error code (see errno.h).
 */
int keystore_sign_verify_size(enum keystore_algo_spec algo_spec,
			  unsigned int *signature_size);

/**
 * keystore_sign() - Sign plaintext using AppKey according to AlgoSpec.
 *
 * @client_ticket:   The client ticket (KEYSTORE_CLIENT_TICKET_SIZE bytes).
 * @slot_id:         The slot ID.
 * @algo_spec:       The algorithm specification.
 * @input:           Input block of data to sign.
 * @input_size:      Input block size in bytes.
 * @signature:       Pointer to the block for signature data. The caller
 *                   is responsible for providing a buffer of sufficent size
 *                   by first calling keystore_sign_verify_size.
 *
 * Use the key stored in the given slot to sign a block of data.
 *
 * Return: Signature data size in bytes if OK or negative error code
 *         (see errno.h).
 */
int keystore_sign(const uint8_t *client_ticket, int slot_id,
		     enum keystore_algo_spec algo_spec,
		     const uint8_t *input, unsigned int input_size,
		     uint8_t *signature);

/**
 * keystore_verify() - verify plaintext using AppKey and Signature according
 *                     to AlgoSpec.
 *
 * @client_ticket:   The client ticket (KEYSTORE_CLIENT_TICKET_SIZE bytes).
 * @slot_id:         The slot ID.
 * @algo_spec:       The algorithm specification.
 * @input:           Input block of data to sign.
 * @input_size:      Input block size in bytes.
 * @signature:       Pointer to the signature data. The signature size must
 *                   match the value returned by keystore_sign_verify_size
 *                   for the given algo_spec.
 *
 * Use the key stored in the given slot and the signature to verify
 * a block of data.
 *
 * Return: Zero if OK or negative error code
 *         (see errno.h).
 */
int keystore_verify(const uint8_t *client_ticket, int slot_id,
		     enum keystore_algo_spec algo_spec,
		     const uint8_t *input, unsigned int input_size,
		     uint8_t *signature);

/**
 * keystore_get_public_key() - Retrieve the public key from a loaded key.
 * @client_ticket:   The client ticket (KEYSTORE_CLIENT_TICKET_SIZE bytes).
 * @slot_id:         The slot ID.
 * @key_spec:        Output key spec of the key in @slot_id.
 * @unwrapped_key:   Output buffer for the unwrapped key.
 *
 * Retrieves the app key in the slot denoted by @slot. Make a copy of
 * the key pair represented by the app key, but only copies the public
 * key. The private key is filled with dummy values.
 *
 * If the @unwrapped_key is provided as null, the function will succeed
 * and return the @key_spec of the key stored in @slot_id. To get the required
 * size, keystore_wrapped_key_size() should be called providing a input
 * for the @unwrapped_key argument.
 *
 * Returns: 0 OK or negative error code (see errno.h)
 */
int keystore_get_public_key(const uint8_t *client_ticket, int slot_id,
			    enum keystore_key_spec *key_spec,
			    uint8_t *unwrapped_key);

/**
 * keystore_get_ksm_key() - Retrieve the Keystore public ECC key.
 *
 * @public_key: The Keystore public ECC key
 *
 * Return: 0 OK or negative error code (see errno.h),
 * (ENODATA if SEED cannot be used to generate private key
 * or EKEYREJECTED if public key cannot pass verification.
 */
int keystore_get_ksm_key(struct keystore_ecc_public_key *public_key);

/**
 * keystore_backup() - Create an encrypted backup of the Client Key.
 *
 * @client_ticket:      The client ticket (%KEYSTORE_CLIENT_TICKET_SIZE bytes).
 * @key_enc_backup:     Public key to encrypt the backup.
 * @key_enc_backup_sig: RSA signature of @key_enc_backup, the caller must
 *                      provide a buffer of %RSA_SIGNATURE_BYTE_SIZE bytes.
 * @backup_enc:         The client_id and client_key encrypted with
 *                      the backup key, @key_enc_backup.
 * @backup_enc_sig:     ECDSA signature of @backup_enc, signed with the keystore
 *                      ECC key.
 *
 * Validate OEM public ECC key and encrypt data for backup with it.
 * The backup data contains the Client ID and Client key.
 * The encryped output is signed by the keystore public ECC key.
 * The signed and encrypted output can be used to migrate keystore client
 * keys between targets.
 *
 * Return: 0 if OK or negative error code (see errno.h).
 */
int keystore_backup(const uint8_t *client_ticket,
		    const struct keystore_ecc_public_key *key_enc_backup,
		    const uint8_t *key_enc_backup_sig,
		    uint8_t *backup_enc,
		    struct keystore_ecc_signature *backup_enc_sig);

/**
 * keystore_generate_mkey() - Generate migration key.
 *
 * @key_enc_mkey:        Public ECC key which should be used to encrypt the
 *                       migration key.
 * @key_enc_mkey_sig:    RSA signature of the backup key, %RSA_SIGNATURE_SIZE
 *                       bytes in size.
 * @mkey_enc:            The migration key encrypted with the @key_enc_mkey. The
 *                       caller must reserve %KEYSTORE_MKEY_SIZE bytes.
 * @mkey_sig:            Encrypted migration key signed using keystore ECC key.
 * @nonce:               The nonce used to generate the migration key. Caller
 *                       must ensure that %KEYSTORE_MKEY_NONCE_SIZE bytes are
 *                       available.
 *
 * Keystore will check the signature of the ECC public key against the
 * OEM RSA public key. This ECC key will be used to encrypt a randomly
 * generated migration key (mkey) and return it together with the nonce
 * used to generate the key.
 *
 * Return: 0 if OK or negative error code (see errno.h).
 */
int keystore_generate_mkey(const struct keystore_ecc_public_key *key_enc_mkey,
			   const uint8_t *key_enc_mkey_sig,
			   uint8_t *mkey_enc,
			   struct keystore_ecc_signature *mkey_sig,
			   uint8_t *nonce);

/**
 * keystore_rewrap_key() - Import key backup from another keystore
 *
 * @client_ticket:      Ticket used to identify this client session
 *                      (%KEYSTORE_CLIENT_TICKET_SIZE bytes).
 * @backup_mk_enc:      The backup encrypted using the migration key
 *                      (%REENCRYPTED_BACKUP_SIZE bytes).
 * @nonce:              The nonce used to create the migration key
 *                      (%KEYSTORE_MKEY_NONCE_SIZE).
 * @wrapped_key:        The wrapped key from the other system which is
 *                      being migrated from.
 * @wrapped_key_size:   Size of the wrapped key.
 * @rewrapped_key:      The key wrapped for this system (which is being migrated
 *                      to). The caller must ensure that @wrapped_key_size
 *                      bytes are available.
 *
 * Takes a wrapped key and encrypted client data from the system which
 * is the source of the backup. Regenerates the migration key from the
 * nonce and uses it to decrypt the backup. The backup contains the
 * client key which is used to unwrap the wrapped key. The bare key is
 * rewrapped using the client key corresponding to the client_ticket.
 *
 * Return: 0 if OK or negative error code (see errno.h).
 */
int keystore_rewrap_key(const uint8_t *client_ticket,
			const uint8_t *backup_mk_enc,
			const uint8_t *nonce,
			const uint8_t *wrapped_key,
			unsigned int wrapped_key_size,
			uint8_t *rewrapped_key);

#if defined(CONFIG_KEYSTORE_TEST_MIGRATION)
/**
 * keystore_gen_ecc_keys() - Generate a random ECC private and public key pair.
 *
 * @key_pair: ECC public/private key pair
 *
 * Return: 0 OK or negative error code (see errno.h).
 * ENODATA if SEED cannot be used to generate private key
 * or EKEYREJECTED if public key cannot pass verification.
 */
int keystore_gen_ecc_keys(struct ias_keystore_ecc_keypair *key_pair);

/**
 * keystore_test_verify_ecc_signature() - Verify ECC signature using public key
 *
 * @public_key:      Public ECC key.
 * @data:            Data to verify the signature of.
 * @data_size:       Size of data.
 * @output_sig:      ECDSA signature.
 *
 * Return: 0 if OK or negative error code (see errno.h).
 */
int keystore_test_verify_ecc_signature(const struct keystore_ecc_public_key
				       *public_key,
				       const uint8_t *data,
				       unsigned int data_size,
				       const struct keystore_ecc_signature
				       *output_sig);

/**
 * keystore_unwrapped_key_size() - Get the size of an unwrapped key
 * @unwrapped_size: Unwrapped key size.
 * @wrapped_size: Wrapped key size output.
 *
 * This function should be called before calling keystore_unwrap_with_backup()
 * function in order to find the length of an unwrapped key buffer.
 *
 * Returns: 0 on success or negative errno.
 */
int keystore_unwrapped_key_size(unsigned int wrapped_size,
				unsigned int *unwrapped_size);

/**
 * keystore_unwrap_with_backup() - Unwrap a wrapped key using encrypted backup.
 * @key_enc_backup:   The ECC private key whose public key was used to encrypt
 *                    the backup data.
 * @backup_enc:       Encrypted backup data from the keystore_backup() function.
 * @wrapped_key:      The wrapped user application key.
 * @wrapped_key_size: Size of the wrapped key
 * @keyspec:          Returns the keyspec used to wrap the key.
 * @unwrapped_key:    The output wrapped key. The caller must ensure
 *                    that a correctly sized buffer is available by
 *                    first calling keystore_unwrapped_key_size().
 *
 * Will unwrap a wrapped key using an encrypted backup blob obtained from
 * the keystore_backup() function. The unwrapped key could be re-wrapped on
 * a second keystore device assuming the environment is secure. If the
 * backup and migration environment is insecure the keystore_generate_mkey()
 * and keystore_rewrap_key() functions should be used.
 *
 * Returns: 0 on success or negative errno.
 */
int keystore_unwrap_with_backup(const uint32_t *key_enc_backup,
				const uint8_t *backup_enc,
				const uint8_t *wrapped_key,
				unsigned int wrapped_key_size,
				enum keystore_key_spec *keyspec,
				uint8_t *unwrapped_key);

/**
 * keystore_migrate() - Re-encrypt using a migration key,
 *
 * @key_enc_backup:    Private ECC key whose public key was used to encrypt
 *                     the backup data.
 * @backup_enc:        Backup data from the keystore_backup function.
 * @key_enc_mkey:      Private ECC key whose public key was used to encrypt the
 *                     migration key.
 * @mkey_enc:          Encrypted migration key.
 * @backup_mk_enc:     Backup data re-encrypted using the migration key.
 *
 * Decrypt backup and migration key and then encrypt backup data with migration
 * key. Intended to test the migration operation.
 *
 * Return: 0 OK or negative error code (see errno.h).
 */
int keystore_migrate(const uint32_t *key_enc_backup,
		     const uint8_t *backup_enc,
		     const uint32_t *key_enc_mkey,
		     const uint8_t *mkey_enc,
		     uint8_t *backup_mk_enc);

#endif /* KEYSTORE_TEST_MIGRATION */

#endif /* _KEYSTORE_H_ */
